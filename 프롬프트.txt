===SYSTEM===
# System Instruction Prompt

## 1. Role Assignment

You are a '**Code Patching Only** LLM'.
Your primary mission is:

1. Analyze existing Python code to identify the **bug location** down to the token level,
2. Write a **minimally invasive** patch, add and pass regression tests, and
3. Return the results as a **single XML document** (`<code_patch>`).

## 2. Execution Steps

### 2-1. Bug Diagnosis

- Analyze stack traces, logs, and failed tests to identify the **root cause** and scope of impact.
- Keep the identified cause in internal memory only (do not output).

### 2-2. Develop Correction Strategy

- Adhere to all clauses of the "Integrated Development Guide".
- Follow the **TDD procedure** (Test-First): Write a new failing test case âœ Implement code to make it pass.
- Target **zero** warnings from **static analysis** (ruff/flake8).
- Feature improvement is _secondary_; the primary goal is bug fixing.

### 2-3. Implement Patch

- Use **functional programming** (+ classes when necessary), type hints, and Pydantic models.
- Split files exceeding 15,000 tokens by functionality.
- When handling exceptions, log the full stack trace using `logger.exception()`.
- Always use `encoding="utf-8"` for encoding.

### 2-5. XML Output Rules (!!!)

```xml
<code_patch> <!-- Single Root Element -->
<code_changes>
<changed_files>
<file>
<file_summary>...</file_summary>
<file_operation>CREATE|UPDATE|DELETE</file_operation>
<file_path>...</file_path>
<file_code><![CDATA[

# Full source code (Omit if DELETE)

        ]]></file_code>
      </file>
      <!-- Repeat for each modified file -->
    </changed_files>

</code_changes>

  <summary>
    <!-- â‘  Overall change summary â‰¤150 chars
         â‘¡ Reason for change/deletion per file (1 sentence each)
         â‘¢ Git commit message (Korean, feat/fix/docsâ€¦) -->
  </summary>
</code_patch>
```

- Inside `<code_patch>`, the order **must be** `<code_changes>` â†’ `<summary>`.
- Do not include unmodified files in the XML.
- Escape reserved characters (`&amp; &lt; &gt; &apos; &quot;`) or wrap them in CDATA. CDATA sections cannot contain `]]>`.

### 2-6. Summary Writing Guidelines

- Korean, maximum **1000 tokens**.
- Separate the three blocks (Overview / Per-File / Commit) with blank lines.

## 3. Output Example (For format reference only)

```xml
<code_patch>
<code_changes>
<changed_files>
<file>
<file_summary>Root main.py: Integrated common logging/config loader, improved FastAPIApp execution logic</file_summary>
<file_operation>UPDATE</file_operation>
<file_path>main.py</file_path>
<file_code><![CDATA[

# Modified full code â€¦

        ]]></file_code>
      </file>
      <!-- â€¦other filesâ€¦ -->
    </changed_files>

</code_changes>

  <summary>
Overall change: Introduced logging/config utils and fixed bugs, achieving 100% test pass rate.

- main.py: Integrated logging/config and exception handling (UPDATE)
- src/utils/log_manager.py: Created common logging module (CREATE)
- tests/stage_01_core/test_root.py: Added new regression test (CREATE)

fix: ê³µí†µ ë¡œê¹…Â·ì„¤ì • ì ìš© ë° xxx ë²„ê·¸ í•´ê²° (Applied common logging/config and resolved xxx bug)

  </summary>
</code_patch>
```

---


===USER===

ì´ í”„ë¡œê·¸ë¨ì˜ ì‘ë™ ë°©ì‹ì´ ì•„ë˜ì˜ ë¬¸ì œê°€ ìˆì–´ì„œ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œë¡œ ì—°ê²°ëœ í´ë”ë¥¼ í”„ë¡œì íŠ¸ í´ë”ë¡œ ì§€ì •í•˜ë©´ ë¡œë”©ì´ ëŠ¦ê²Œ ë˜ê±°ë‚˜ ë ‰ì´ ê±¸ë¦¬ëŠ” ë¬¸ì œê°€ ë°œìƒí•¨.
ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ "docs\ë¦¬íŒ©í† ë§\ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ ê°œì„ \_ìºì‹± ë° watchdog ì‚¬ìš©.md" ì—ì„œ ì œì•ˆëœ ë°©ì‹ìœ¼ë¡œ ë¦¬íŒ©í† ë§ì„ ì§„í–‰í•´ì¤˜.


===FILES CONTENTS===

======== main.py ========
import sys
import os

# src ë””ë ‰í† ë¦¬ë¥¼ sys.pathì— ì¶”ê°€
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.join(current_dir, "src")
if src_dir not in sys.path:
    sys.path.insert(0, src_dir)

# src/app.pyì˜ ë©”ì¸ í•¨ìˆ˜ ì‹¤í–‰
if __name__ == '__main__':
    # app ëª¨ë“ˆì„ ì—¬ê¸°ì„œ ì„í¬íŠ¸í•˜ì—¬ ìˆœí™˜ ì°¸ì¡° ë°©ì§€ ê°€ëŠ¥ì„± ê³ ë ¤
    from app import main
    main()



======== pyproject.toml ========

[project]
name = "duck-prompt"
version = "0.2.0"
description = "DuckPrompt: Code Enhancer & Meta Prompt Builder"
requires-python = ">=3.12"
dependencies = [
    "PyQt6>=6.7.0",
    "PyQt6-Qt6>=6.7.0",
    "google-generativeai>=0.5.4", # Gemini API
    "langgraph>=0.0.69", # LangGraph for workflow
    "tiktoken>=0.7.0", # Token calculation (GPT/fallback)
    "anthropic>=0.28.0", # Anthropic API (Claude)
    "psycopg2-binary>=2.9.9", # PostgreSQL driver
    "PyYAML>=6.0.1", # YAML parsing (config)
    "pydantic>=2.7.1", # Data validation and settings
    "pillow>=10.3.0", # Image handling
    "winotify>=1.1.0", # Windows notifications
    "pyinstaller>=6.13.0",
    "asyncssh>=2.21.0",
    "python-dotenv>=1.1.0",
]

[tool.black]
line-length = 88

[tool.isort]
profile = "black"

[tool.uv.sources]
# Optional: Specify custom package sources if needed

# Optional: Define project scripts or entry points
# [project.scripts]
# duckprompt = "src.app:main"

# Optional: Project URLs
# [project.urls]
# homepage = "https://example.com"
# documentation = "https://readthedocs.org"
# repository = "https://github.com/user/duck-prompt.git"
# changelog = "https://github.com/user/duck-prompt/blob/main/CHANGELOG.md"

# Optional: Author and maintainer information
# authors = [
#   { name="Your Name", email="your.email@example.com" },
# ]
# maintainers = [
#   { name="Your Name", email="your.email@example.com" },
# ]

# Optional: License information
# license = { text = "MIT License" }

# Optional: Keywords for PyPI
# keywords = ["llm", "prompt", "gui", "pyqt"]

# Optional: Classifiers for PyPI
# classifiers = [
#     "Development Status :: 3 - Alpha",
#     "Intended Audience :: Developers",
#     "License :: OSI Approved :: MIT License",
#     "Programming Language :: Python :: 3",
#     "Programming Language :: Python :: 3.12",
#     "Operating System :: OS Independent",
#     "Topic :: Software Development :: User Interfaces",
# ]




======== qt.conf ========
[Platforms]
WindowsArguments = dpiawareness=3 


======== docs\ë¦¬íŒ©í† ë§\ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ ê°œì„ _ìºì‹± ë° watchdog ì‚¬ìš©.md ========
**ì†ë„ í–¥ìƒ ë°©ë²•**

ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ ì¡°íšŒê°€ ëŠë ¤ì§€ëŠ” ì´ìœ ëŠ” ë‹¤ì–‘í•  ìˆ˜ ìˆì–´ìš”! ìš°ì„ , PyQt6ì—ì„œ íŒŒì¼ ì‹œìŠ¤í…œì„ íƒìƒ‰í•  ë•Œ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸ŒëŠ” ë¡œì»¬ ë“œë¼ì´ë¸Œë³´ë‹¤ ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦´ ìˆ˜ ìˆë‹µë‹ˆë‹¤ ğŸ˜•. ì†ë„ë¥¼ ë†’ì´ê¸° ìœ„í•´ ëª‡ ê°€ì§€ ë°©ë²•ì„ ì‹œë„í•´ë³¼ ìˆ˜ ìˆì–´ìš”:

1. **ë¹„ë™ê¸° ì²˜ë¦¬**: UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ê²€ìƒ‰ ì‘ì—…ì„ ë¹„ë™ê¸°ì‹ìœ¼ë¡œ ì‹¤í–‰í•˜ë©´ ì†ë„ë¥¼ ë†’ì¼ ìˆ˜ ìˆì–´ìš”! ğŸ¤—
2. **ìºì‹œ ì‚¬ìš©**: ë””ë ‰í„°ë¦¬ì˜ ë°ì´í„°ë¥¼ ìºì‹±í•˜ì—¬ ë‹¤ì‹œ ë¡œë”©í•  ë•Œ ì‹œê°„ì„ ì ˆì•½í•  ìˆ˜ ìˆì–´ìš”âœ¨
3. **ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ ìµœì í™”**: ë„¤íŠ¸ì›Œí¬ ì†ë„ë‚˜ ê³µìœ  í´ë” ì„¤ì •ì„ ì ê²€í•´ë³´ì„¸ìš”!

ì´ë ‡ê²Œ í•´ë³´ë©´ ì†ë„ ê°œì„ ì´ ë  ê±°ì˜ˆìš”! <3

**ì†ë„ ì¦ê°€ ë°©ë²•**

ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œì—ì„œ ë””ë ‰í„°ë¦¬ ë¡œë”©ì„ ë¹ ë¥´ê²Œ í•˜ë ¤ë©´ ì—¬ëŸ¬ ê°€ì§€ ë°©ë²•ì„ ì‹œë„í•  ìˆ˜ ìˆì–´ìš”! ğŸ˜„

1. **Lazy Loading & ë¹„ë™ê¸° ìŠ¤ìºë‹**: `fetchMore`ì™€ `QModel`ì„ ì‚¬ìš©í•´ ë°ì´í„°ë¥¼ ì¡°ê¸ˆì”© ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ë²•ì´ì—ìš”! ğŸ¢
2. **ë©€í‹°ì“°ë ˆë“œ**: `concurrent.futures`ë‚˜ `asyncio`ë¡œ ìŠ¤ìº”ì„ ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ìˆì–´ìš”! ğŸš€
3. **ìºì‹œ & ì¸ë±ì‹±**: ë³€ë™ì´ ìˆëŠ” ë””ë ‰í„°ë¦¬ë§Œ ì—…ë°ì´íŠ¸í•˜ìêµ¬ìš”! (Watchdog ì‚¬ìš©) ğŸ“‚
4. **íŒŒì¼ ì •ë³´ ìµœì†Œí™”**: `os.scandir`ì™€ `follow links`ë¥¼ `False`ë¡œ ì„¤ì •í•˜ì„¸ìš”! ğŸ”

ì´ ë°©ë²•ë“¤ì´ ì„±ëŠ¥ì„ ë†’ì´ëŠ” ë° ë„ì›€ì´ ë  ê±°ì˜ˆìš”!ğŸ’¡

27ì´ˆ ë™ì•ˆ ìƒê°í•¨

ê·€ì—¬ìš´ ì•„ë¦¬ ë“±ì¥ğŸ’•
ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ íŠ¸ë¦¬ í¼ì¹  ë•Œ â€œì™œ ì´ë ‡ê²Œ êµ¼ë±…ì´ ê°™ì§€â€¦?!â€ í•˜ê³  ì† í„°ì¡Œì§€? ğŸ˜–
ì •ë¦¬í•´ ë³´ë‹ˆ â‘  Qt-ëª¨ë¸ ìì²´ì˜ ì¶”ê°€ I/O, â‘¡ SMB ë„¤íŠ¸ì›Œí¬ ì§€ì—°, â‘¢ ì•„ì´ì½˜Â·stat ì¡°íšŒ ê³¼ë‹¤ â€” ì„¸ ìš”ì†Œê°€ ë³‘ëª©ì´ì—ˆì–´.
ì•„ë˜ ë°©ë²•ë“¤ì„ ì¡°í•©í•˜ë©´ **2-10ë°° ì •ë„** ì²´ê° ì†ë„ê°€ í™• ì˜¬ë¼ê°„ë‹¤ëŠ” ì‹¤ì „ í›„ê¸°ê°€ ë§ì•„! ğŸ˜‰

---

## 1. QFileSystemModel íŠœë‹

| íŒ                          | ì„¤ëª…                                                                                                                          |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **ì»¤ìŠ¤í…€ ì•„ì´ì½˜ ë„ê¸°**      | ëª¨ë¸ ì˜µì…˜ `DontUseCustomDirectoryIcons` ë¡œ ë„¤íŠ¸ì›Œí¬ ì•„ì´ì½˜ ê²€ìƒ‰ ì°¨ë‹¨ â†’ ìˆ˜â€‰ms â†’ ìˆ˜ Î¼së¡œ ë‹¨ì¶• ([Qt ë¬¸ì„œ][1])                    |
| **IconProvider ì œê±°**       | `setIconProvider(nullptr)` ë¡œ ì™„ì „ ë¹„í™œì„±í™” (ì•„ì´ì½˜ ì•ˆ ì“°ë©´ ìµœê°•) ([Stack Overflow][2])                                       |
| **NameFiltersÂ·stat ìµœì†Œí™”** | `setNameFilters()` ëŒ€ì‹  í•„í„°ë§ì€ ë‚˜ì¤‘ì—, `QDirIterator::NoSymLinks` ë“±ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ `stat` ê°ì†Œ ([Qt Forum][3])               |
| **Lazy Fetch êµ¬í˜„**         | `canFetchMore/fetchMore` ì˜¤ë²„ë¼ì´ë“œë¡œ ìì‹ ë…¸ë“œ ìš”êµ¬ ì‹œì ì—ë§Œ ì±„ì›€ (â€œlazy loadingâ€ íŒ¨í„´) ([Stack Overflow][4], [Qt Forum][5]) |

### ì˜ˆì‹œ ì½”ë“œ ìŠ¤ì¼€ì¹˜

```python
class FastFSModel(QtCore.QFileSystemModel):
    def __init__(self, *a, **kw):
        super().__init__(*a, **kw)
        self.setIconProvider(None)                     # ì•„ì´ì½˜ OFF
        self.setOption(QtWidgets.QFileSystemModel.DontUseCustomDirectoryIcons, True)

    def canFetchMore(self, index):
        # ë„¤íŠ¸ì›Œí¬ ê²½ë¡œëŠ” children ì¹´ìš´íŠ¸ ë¯¸ë¦¬ ìºì‹œ
        return not self.isDir(index) and super().canFetchMore(index)

    def fetchMore(self, index):
        QtCore.QTimer.singleShot(0, lambda: super().fetchMore(index))  # UI ë¸”ë¡ ìµœì†Œí™”
```

---

## 2. ë¹„ë™ê¸°Â·ë©€í‹°ì“°ë ˆë“œ ìŠ¤ìºë‹

1. **Worker ìŠ¤ë ˆë“œ** â€• `os.scandir()`ë¥¼ ë³„ë„ `QThread`ì—ì„œ ëŒë¦¬ê³ , ê²°ê³¼ë§Œ `pyqtSignal`ë¡œ UIì— ë¨¸ì§€

   - `scandir`ëŠ” í•œ ë²ˆì˜ sys callë¡œ ì´ë¦„Â·ì†ì„± ë™ì‹œ ì·¨ë“ì´ë¼ `listdir+stat`ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„ ([Stack Overflow][6], [Python Enhancement Proposals (PEPs)][7])

2. **QtConcurrent** â€• C++ ìŠ¤ë ˆë”©ì„ ë˜í•‘í•˜ë¯€ë¡œ GIL ì œì•½ì´ ëœí•˜ê³  ì‘ë‹µì„±ì´ ë†’ì•„ì ¸.

> **íŒ** : ìŠ¤ìºë‹ ê²°ê³¼ë¥¼ `QStandardItemModel`ì— ìŒ“ì€ ë’¤ ìµœì¢… ìŠ¤ì™‘í•˜ë©´, íŠ¸ë¦¬ë·° ì¬ê·¸ë¦¬ê¸° 1íšŒë¡œ ëë‚˜ì„œ ê¹œë¹¡ì„ì´ ì—†ë‹¤ğŸ˜Š

---

## 3. ìºì‹± & ë³€ê²½ ê°ì‹œ

- **ì²« ìŠ¤ìº” ìºì‹œ** â†’ `pickle`ì´ë‚˜ local SQLiteì— ë””ë ‰í„°ë¦¬ ìŠ¤ëƒ…ìƒ· ì €ì¥ í›„, ë‹¤ìŒ ì‹¤í–‰ ë•Œ ë°”ë¡œ ë¡œë“œ
- **watchdog** ê°™ì€ FS ëª¨ë‹ˆí„°ë¡œ ë³€ê²½ë¶„ë§Œ íŒ¨ì¹˜í•˜ë©´ ë“œë¼ì´ë¸Œ ì „ì²´ ì¬íƒìƒ‰ì„ í”¼í•  ìˆ˜ ìˆì–´ìš”.
  (ë„¤íŠ¸ì›Œí¬ shareë„ SMB ë³€ê²½ ì•Œë¦¼ ì§€ì›)

---

## 4. Windows SMB ìì²´ ìµœì í™”

| ì„¤ì •                              | íš¨ê³¼                                                                                          |
| --------------------------------- | --------------------------------------------------------------------------------------------- |
| **8.3 íŒŒì¼ëª… ìƒì„± ë„ê¸°**          | DIR ì—´ëŒì‹œ ì§§ì€ DOS ì´ë¦„ ê³„ì‚° ì•ˆ í•¨ â†’ ëª©ë¡ ì†ë„ â†‘ ([Super User][8])                           |
| **Directory Cache Time-out ì¡°ì •** | ë ˆì§€ìŠ¤íŠ¸ë¦¬ `DirectoryCacheLifetime` ëŠ˜ë ¤ ì¤‘ë³µ I/O ê°ì†Œ ([TrueNAS Open Enterprise Storage][9]) |
| **ì•ˆí‹°ë°”ì´ëŸ¬ìŠ¤ ì œì™¸**             | ì‹¤ì‹œê°„ ê²€ì‚¬ê°€ dir statë¥¼ ê°€ë¡œì±„ë©´ ì§€ì—°ì´ ì»¤ì ¸ìš”(íŠ¹íˆ ê³µìœ  í´ë”).                              |

---

## 5. íŒŒì´ì¬ ë ˆë²¨ ì„±ëŠ¥ ë¶€ìŠ¤íŠ¸

- **I/O ë°”ìš´ë“œì—ëŠ” ë¹„ë™ê¸°** : `asyncio + aiofiles`ë¡œ ì—¬ëŸ¬ í•˜ìœ„ í´ë”ë¥¼ ë™ì‹œ ì—´ëŒ ê°€ëŠ¥ (SMB ë¼ìš´ë“œíŠ¸ë¦½ ì€ë‹‰).



======== src\core\pydantic_models\__init__.py ========
# This file makes Python treat the directory pydantic_models as a package.



======== src\core\pydantic_models\app_state.py ========

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any # Dict, Any ì¶”ê°€

class AppState(BaseModel):
    """
    Represents the application state.
    ì €ì¥/ë¡œë“œ ì‹œ íŠ¹ì • í•„ë“œë§Œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ (ì˜ˆ: ì´ì „ ì‘ì—… ë¶ˆëŸ¬ì˜¤ê¸°).
    """
    # --- ì´ì „ ì‘ì—… ì €ì¥/ë¡œë“œ ëŒ€ìƒ í•„ë“œ ---
    project_folder: Optional[str] = None # í”„ë¡œì íŠ¸ í´ë” ê²½ë¡œ
    checked_files: List[str] = Field(default_factory=list) # ì²´í¬ëœ íŒŒì¼/í´ë” ê²½ë¡œ ëª©ë¡
    user_prompt: str = "" # ì‚¬ìš©ì íƒ­ ë‚´ìš©
    attached_items: List[Dict[str, Any]] = Field(default_factory=list) # ì²¨ë¶€ íŒŒì¼/ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ëª©ë¡

    # --- ê¸°íƒ€ ìƒíƒœ í•„ë“œ (ì „ì²´ ìƒíƒœ ì €ì¥/ë¡œë“œ ì‹œ ì‚¬ìš©) ---
    mode: str = "Code Enhancer Prompt Builder"
    system_prompt: str = "" # ì‹œìŠ¤í…œ íƒ­ ë‚´ìš© (ê¸°ë³¸ê°’ ë¡œë“œ ë¡œì§ ìˆìŒ)
    selected_llm: str = "Gemini" # ì„ íƒëœ LLM
    selected_model_name: str = "" # ì„ íƒëœ ëª¨ë¸ëª…

    # Gemini íŒŒë¼ë¯¸í„°ëŠ” config.ymlì—ì„œ ê´€ë¦¬í•˜ë¯€ë¡œ AppStateì—ì„œ ì œê±°
    # gemini_temperature: float = 0.0
    # gemini_enable_thinking: bool = True
    # gemini_thinking_budget: int = 24576
    # gemini_enable_search: bool = True

    class Config:
        validate_assignment = True




======== src\core\pydantic_models\config_settings.py ========

from pydantic import BaseModel, Field, field_validator, FieldValidationInfo
from typing import List, Set, Any, Optional, Dict

class ConfigSettings(BaseModel):
    """
    Represents the application configuration settings loaded from the database.
    """
    # --- Fields loaded from application_config table ---
    profile_name: str = 'default' # Included for completeness, usually 'default'
    default_system_prompt: Optional[str] = None
    allowed_extensions: Set[str] = Field(default_factory=set)
    excluded_dirs: Set[str] = Field(default_factory=set)
    default_ignore_list: List[str] = Field(default_factory=list)
    gemini_default_model: str = "gemini-1.5-pro-latest" # Default if DB is missing
    claude_default_model: str = "claude-3-sonnet-20240229"
    gpt_default_model: str = "gpt-4o"
    gemini_available_models: List[str] = Field(default_factory=list)
    claude_available_models: List[str] = Field(default_factory=list)
    gpt_available_models: List[str] = Field(default_factory=list)
    gemini_temperature: float = Field(0.0, ge=0.0, le=2.0)
    gemini_enable_thinking: bool = Field(True)
    gemini_thinking_budget: int = Field(24576, ge=0)
    gemini_enable_search: bool = Field(True)
    # created_at, updated_at are in DB but not needed in the model for app logic

    # --- Fields loaded separately from api_keys table ---
    gemini_api_key: Optional[str] = None
    anthropic_api_key: Optional[str] = None
    # openai_api_key: Optional[str] = None # If needed

    @field_validator('allowed_extensions', 'excluded_dirs', mode='before')
    @classmethod
    def ensure_set_from_list_or_none(cls, v: Any, info: FieldValidationInfo):
        """Converts list (from DB array) or None to a set of strings."""
        if v is None:
            return set()
        if isinstance(v, (list, tuple, set)):
            # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return set(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        # Allow comma or space separated string as fallback (though DB should provide list)
        if isinstance(v, str):
             items = {item.strip() for item in v.replace(',', ' ').split() if item.strip()}
             return items
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    @field_validator('default_ignore_list', 'gemini_available_models', 'claude_available_models', 'gpt_available_models', mode='before')
    @classmethod
    def ensure_list_from_list_or_none(cls, v: Any, info: FieldValidationInfo):
        """Ensures the value is a list of strings, accepting None."""
        if v is None:
            return []
        if isinstance(v, (list, tuple, set)):
             # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return list(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    class Config:
        validate_assignment = True
        # If loading directly from DB dict, extra fields might exist (id, created_at etc.)
        extra = 'ignore' # Ignore extra fields from DB query result




======== src\core\services\__init__.py ========

# This file makes Python treat the directory services as a package.
# It can also be used to expose specific classes or functions.

from .config_service import ConfigService
from .db_service import DbService # Added
from .filesystem_service import FilesystemService
from .prompt_service import PromptService
from .state_service import StateService
from .template_service import TemplateService
from .token_service import TokenCalculationService
from .xml_service import XmlService
# from .gemini_service import build_gemini_graph # í•¨ìˆ˜ ì§ì ‘ ì„í¬íŠ¸ ëŒ€ì‹  ëª¨ë“ˆ ì‚¬ìš©

__all__ = [
    "ConfigService",
    "DbService", # Added
    "FilesystemService",
    "PromptService",
    "StateService",
    "TemplateService",
    "TokenCalculationService",
    "XmlService",
    # "build_gemini_graph", # í•¨ìˆ˜ ì§ì ‘ ë…¸ì¶œ ëŒ€ì‹  ì„œë¹„ìŠ¤ ëª¨ë“ˆ ì‚¬ìš©
]



======== src\core\services\config_service.py ========
import os
import logging
import random # ëœë¤ ì„ íƒì„ ìœ„í•´ ì¶”ê°€
from pydantic import ValidationError
from typing import Optional, List, Set, Dict, Any # Set, Dict, Any ì¶”ê°€

from core.pydantic_models.config_settings import ConfigSettings
from .db_service import DbService # DbService import

logger = logging.getLogger(__name__)

class ConfigService:
    def __init__(self, db_service: DbService, profile_name: str = 'default'):
        """
        Initializes ConfigService using a DbService instance.

        Args:
            db_service: An instance of DbService to interact with the database.
            profile_name: The configuration profile to load (default: 'default').
        """
        self.db_service = db_service
        self.profile_name = profile_name
        self._settings: ConfigSettings = self._load_config()
        self._user_selected_gemini_key_id: Optional[int] = None # ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ ì„ íƒí•œ í‚¤ ID (ë©”ëª¨ë¦¬ ê´€ë¦¬)
        self._last_used_gemini_key: Optional[str] = None # ë§ˆì§€ë§‰ìœ¼ë¡œ ì„±ê³µì ìœ¼ë¡œ ì‚¬ìš©ëœ í‚¤ ë¬¸ìì—´ (ë©”ëª¨ë¦¬ ê´€ë¦¬)

    def _load_config(self) -> ConfigSettings:
        """
        Loads configuration from the database.
        Initial active Gemini key is NOT selected here. Selection happens in gemini_service.
        """
        logger.info(f"Loading configuration from database for profile '{self.profile_name}'...")
        try:
            # 1. Fetch application config from DB
            config_data = self.db_service.get_application_config(self.profile_name)

            if not config_data:
                logger.critical(f"Failed to load configuration from database for profile '{self.profile_name}'. Application cannot proceed.")
                raise ValueError(f"Configuration profile '{self.profile_name}' not found in database.")

            # --- ë¡œê¹… ì¶”ê°€: DBì—ì„œ ë¡œë“œëœ ì„¤ì • ë°ì´í„° í™•ì¸ ---
            logger.info(f"Raw config data loaded from DB for profile '{self.profile_name}':")
            # ì¤‘ìš” ì„¤ì •ê°’ë§Œ ë¡œê¹… (API í‚¤ ì œì™¸)
            logged_data = {k: v for k, v in config_data.items() if 'api_key' not in k}
            logger.info(f"{logged_data}")
            # ---------------------------------------------

            # 2. Fetch *active* API keys from DB (just to check availability, not select)
            # This check is mainly for logging warnings if no keys are available initially.
            active_gemini_keys = self.db_service.get_active_api_keys('google')
            active_anthropic_keys = self.db_service.get_active_api_keys('anthropic')

            # --- Initial Gemini Key Selection REMOVED ---
            if not active_gemini_keys:
                logger.warning("No active Gemini API key found in DB. API calls will likely fail until a key is added/activated.")
            else:
                logger.info(f"Found {len(active_gemini_keys)} active Gemini keys. Key selection will occur during API call.")

            # Use the first active Anthropic key if available
            anthropic_key = active_anthropic_keys[0]['api_key'] if active_anthropic_keys else None
            if not anthropic_key: logger.warning("No active Anthropic API key found in DB.")

            # 3. Add the API keys (set to None initially) to the config data dictionary
            config_data['gemini_api_key'] = None # Placeholder, always None initially
            config_data['anthropic_api_key'] = anthropic_key

            # 4. Validate and create ConfigSettings model
            settings = ConfigSettings(**config_data)
            logger.info(f"Configuration loaded successfully from database for profile '{self.profile_name}'.")
            # --- ë¡œê¹… ì¶”ê°€: Pydantic ëª¨ë¸ ìƒì„± í›„ ì„¤ì • ê°’ í™•ì¸ ---
            logger.info("Validated ConfigSettings object created:")
            logger.info(f"  gemini_temperature: {settings.gemini_temperature}")
            # ... other relevant settings ...
            logger.info(f"  Initial gemini_api_key in settings object: {settings.gemini_api_key}") # Should log None
            # -------------------------------------------------
            return settings

        except ValidationError as e:
            logger.critical(f"Database configuration validation error: {e}. Using default settings (or failing).", exc_info=True)
            raise ValueError(f"Configuration validation failed: {e}")
        except Exception as e:
            logger.critical(f"Unexpected error loading config from database: {e}", exc_info=True)
            raise ValueError(f"Failed to load configuration from database: {e}")

    def update_settings(self, updated_settings: ConfigSettings) -> bool:
        """
        Updates the application configuration in the database and in memory.
        API keys are NOT saved via this method. User-selected key preference is not saved to DB.

        Args:
            updated_settings: A ConfigSettings object with the updated values.

        Returns:
            True if the update was successful, False otherwise.
        """
        logger.info(f"Attempting to update configuration in database for profile '{self.profile_name}'...")
        try:
            # Convert Pydantic model to dictionary for DB service
            # Exclude API keys as they are managed separately
            config_dict_to_save = updated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})

            # --- ë¡œê¹… ì¶”ê°€: DBì— ì €ì¥ë  ì„¤ì • ë°ì´í„° í™•ì¸ ---
            logger.info(f"Data being saved to DB for profile '{self.profile_name}':")
            logger.info(f"{config_dict_to_save}")
            # ---------------------------------------------

            # Call DbService to save the configuration (excluding API keys)
            success = self.db_service.save_application_config(self.profile_name, config_dict_to_save)

            if success:
                # Update in-memory settings only if DB save was successful
                # Keep the currently loaded API keys AND the user selection in the in-memory object
                current_anthropic_key = self._settings.anthropic_api_key # Keep potentially updated Anthropic key
                # Create a fresh copy from the validated input, then restore keys/selection
                self._settings = updated_settings.model_copy(deep=True)
                self._settings.gemini_api_key = self._last_used_gemini_key # Restore last used key string
                self._settings.anthropic_api_key = current_anthropic_key
                # User selection (_user_selected_gemini_key_id) remains as it is in memory.
                logger.info(f"Configuration updated successfully in database and memory for profile '{self.profile_name}'.")
                return True
            else:
                logger.error(f"Failed to save configuration update to database for profile '{self.profile_name}'.")
                return False

        except ValidationError as e:
            logger.error(f"Configuration update validation error: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Unexpected error updating configuration: {e}", exc_info=True)
            return False

    def get_settings(self) -> ConfigSettings:
        """Returns the current configuration settings."""
        if not self._settings:
             logger.error("Configuration settings are not loaded.")
             self._settings = self._load_config() # Attempt to reload
        return self._settings

    def get_default_model_name(self, llm_type: str) -> str:
        """Gets the default model name for a given LLM type from settings."""
        settings = self.get_settings()
        if llm_type == "Gemini": return settings.gemini_default_model
        elif llm_type == "Claude": return settings.claude_default_model
        elif llm_type == "GPT": return settings.gpt_default_model
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for default model."); return ""

    def get_available_models(self, llm_type: str) -> List[str]:
        """Gets the list of available model names for a given LLM type from settings."""
        settings = self.get_settings()
        models = []
        if llm_type == "Gemini": models = settings.gemini_available_models
        elif llm_type == "Claude": models = settings.claude_available_models
        elif llm_type == "GPT": models = settings.gpt_available_models
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for available models.")
        return models if models is not None else []

    # --- User Selected Key Management ---
    def set_user_selected_gemini_key(self, key_id: Optional[int]):
        """Sets the user's preferred Gemini API key ID (managed in memory)."""
        if self._user_selected_gemini_key_id != key_id:
            logger.info(f"Setting user-selected Gemini Key ID to: {key_id}")
            self._user_selected_gemini_key_id = key_id
            # Optionally clear the last used key if a new preference is set? No, keep last used.
        else:
             logger.debug(f"User selected Gemini key ID is already {key_id}.")

    def get_user_selected_gemini_key_id(self) -> Optional[int]:
        """Gets the user's preferred Gemini API key ID."""
        return self._user_selected_gemini_key_id

    # --- Last Used Key Management ---
    def update_last_used_gemini_key(self, key_string: str):
        """
        Updates the last successfully used Gemini API key string in memory
        and updates the placeholder in the settings object.
        Called by gemini_service after a successful API call.
        """
        if self._last_used_gemini_key != key_string:
            logger.info(f"Updating last successfully used Gemini API key string.")
            self._last_used_gemini_key = key_string
            if self._settings:
                # Update the placeholder in the settings object for consistency/display if needed
                self._settings.gemini_api_key = key_string
        else:
            logger.debug("Attempted to update last used Gemini key, but it's the same.")

    def get_last_used_gemini_key_id(self) -> Optional[int]:
        """Gets the database ID of the last successfully used Gemini API key."""
        if self._last_used_gemini_key:
            try:
                # Fetch the ID from the database using the key string
                key_id = self.db_service.get_api_key_id(self._last_used_gemini_key)
                logger.debug(f"Retrieved ID for last used Gemini key: {key_id}")
                return key_id
            except Exception as e:
                logger.error(f"Error getting ID for last used Gemini key '{self._last_used_gemini_key[:4]}...': {e}")
                return None
        else:
            # Log if no key has been successfully used yet
            logger.debug("Cannot get last used Gemini key ID: No key has been successfully used yet.")
            return None

    # Renamed for clarity (was get_current_gemini_key_id)
    # def get_current_gemini_key_id(self) -> Optional[int]:
    #     """Gets the database ID of the currently configured Gemini API key."""
    #     # ... (old logic based on settings.gemini_api_key) ...
    #     # Now replaced by get_last_used_gemini_key_id and get_user_selected_gemini_key_id

    # Renamed for clarity (was update_current_gemini_key)
    # def update_current_gemini_key(self, new_key: str):
    #      # Now replaced by update_last_used_gemini_key



======== src\core\services\db_service.py ========

import psycopg2
import logging
from typing import Optional, Dict, Any, List, Tuple
import json
import datetime
from decimal import Decimal

logger = logging.getLogger(__name__)

# ë°ì´í„°ë² ì´ìŠ¤ ì ‘ì† ì •ë³´ (ìš”ì²­ì— ë”°ë¼ í•˜ë“œì½”ë”©)
DB_CONFIG = {
    "host": "postgresdb.lab.miraker.me",
    "user": "shacea",
    "password": "alfkzj9389",
    "port": 5333,
    "database": "duck_agent"
}

class DbService:
    """Handles database connection and queries for application configuration and logging."""

    def __init__(self, db_config: Dict[str, Any] = DB_CONFIG):
        self.db_config = db_config
        self.connection = None
        self.connect()

    def connect(self):
        """Establishes a connection to the PostgreSQL database."""
        if self.connection and not self.connection.closed:
            return # Already connected

        try:
            logger.info(f"Connecting to database '{self.db_config['database']}' on {self.db_config['host']}...")
            self.connection = psycopg2.connect(**self.db_config)
            logger.info("Database connection successful.")
        except psycopg2.Error as e:
            logger.critical(f"Database connection failed: {e}", exc_info=True)
            self.connection = None
            raise ConnectionError(f"Failed to connect to the database: {e}")

    def disconnect(self):
        """Closes the database connection."""
        if self.connection and not self.connection.closed:
            self.connection.close()
            logger.info("Database connection closed.")
        self.connection = None

    def _execute_query(self, query: str, params: Optional[tuple] = None, fetch_one: bool = False, fetch_all: bool = False, return_id: bool = False) -> Optional[Any]:
        """Executes a SQL query and returns the result."""
        if not self.connection or self.connection.closed:
            logger.error("Cannot execute query: Database connection is not active.")
            logger.info("Attempting to reconnect to the database...")
            self.connect()
            if not self.connection or self.connection.closed:
                 raise ConnectionError("Database connection lost and could not be re-established.")

        cursor = None
        try:
            cursor = self.connection.cursor()
            logger.debug(f"Executing query: {query} with params: {params}")
            cursor.execute(query, params)

            if return_id:
                result = cursor.fetchone()
                self.connection.commit()
                logger.debug(f"Query returned ID: {result[0] if result else None}")
                return result[0] if result else None
            elif fetch_one:
                result = cursor.fetchone()
                if result and cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    row_dict = dict(zip(colnames, result))
                    logger.debug(f"Query fetched one row: {row_dict}")
                    return row_dict
                elif result:
                    logger.debug(f"Query fetched one value: {result[0]}")
                    return result[0]
                else:
                    logger.debug("Query fetched no results (fetch_one).")
                    return None
            elif fetch_all:
                if cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    rows = cursor.fetchall()
                    results_list = [dict(zip(colnames, row)) for row in rows]
                    logger.debug(f"Query fetched {len(results_list)} rows.")
                    return results_list
                else:
                    logger.debug("Query fetched no results (fetch_all).")
                    return []
            else:
                affected_rows = cursor.rowcount
                self.connection.commit()
                logger.debug(f"Query executed successfully. Rows affected: {affected_rows}")
                return affected_rows
        except psycopg2.Error as e:
            logger.error(f"Database query failed: {e}\nQuery: {query}\nParams: {params}", exc_info=True)
            if self.connection:
                self.connection.rollback()
            raise e
        finally:
            if cursor:
                cursor.close()

    def get_application_config(self, profile_name: str = 'default') -> Optional[Dict[str, Any]]:
        """Fetches application configuration for a given profile."""
        query = """
            SELECT * FROM application_config WHERE profile_name = %s;
        """
        try:
            result = self._execute_query(query, (profile_name,), fetch_one=True)
            if result and isinstance(result, dict):
                logger.info(f"Application config loaded for profile '{profile_name}'.")
                config_data = result
                if 'gemini_temperature' in config_data and isinstance(config_data['gemini_temperature'], Decimal):
                    config_data['gemini_temperature'] = float(config_data['gemini_temperature'])
                return config_data
            else:
                logger.error(f"Application config not found for profile '{profile_name}'.")
                return None
        except psycopg2.Error as e:
             logger.error(f"Failed to get application config for profile '{profile_name}': {e}")
             return None

    def save_application_config(self, profile_name: str, config_data: Dict[str, Any]) -> bool:
        """
        Inserts or updates the application configuration for a given profile.
        Handles data type conversions for DB compatibility. Excludes API keys.
        """
        logger.info(f"Attempting to save application configuration for profile '{profile_name}'...")

        allowed_extensions = list(config_data.get('allowed_extensions', []))
        excluded_dirs = list(config_data.get('excluded_dirs', []))
        default_ignore_list = list(config_data.get('default_ignore_list', []))
        gemini_available_models = list(config_data.get('gemini_available_models', []))
        claude_available_models = list(config_data.get('claude_available_models', []))
        gpt_available_models = list(config_data.get('gpt_available_models', []))

        gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
        gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

        try: gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
        except (ValueError, TypeError): gemini_temperature = 0.0
        try: gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
        except (ValueError, TypeError): gemini_thinking_budget = 24576

        sql = """
            INSERT INTO application_config (
                profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
                default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
                gemini_available_models, claude_available_models, gpt_available_models,
                gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (profile_name) DO UPDATE SET
                default_system_prompt = EXCLUDED.default_system_prompt,
                allowed_extensions = EXCLUDED.allowed_extensions,
                excluded_dirs = EXCLUDED.excluded_dirs,
                default_ignore_list = EXCLUDED.default_ignore_list,
                gemini_default_model = EXCLUDED.gemini_default_model,
                claude_default_model = EXCLUDED.claude_default_model,
                gpt_default_model = EXCLUDED.gpt_default_model,
                gemini_available_models = EXCLUDED.gemini_available_models,
                claude_available_models = EXCLUDED.claude_available_models,
                gpt_available_models = EXCLUDED.gpt_available_models,
                gemini_temperature = EXCLUDED.gemini_temperature,
                gemini_enable_thinking = EXCLUDED.gemini_enable_thinking,
                gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
                gemini_enable_search = EXCLUDED.gemini_enable_search,
                updated_at = NOW();
        """
        params = (
            profile_name, config_data.get('default_system_prompt'), allowed_extensions, excluded_dirs,
            default_ignore_list, config_data.get('gemini_default_model'), config_data.get('claude_default_model'),
            config_data.get('gpt_default_model'), gemini_available_models, claude_available_models,
            gpt_available_models, gemini_temperature, gemini_enable_thinking, gemini_thinking_budget,
            gemini_enable_search
        )

        try:
            affected_rows = self._execute_query(sql, params)
            logger.info(f"Application configuration for profile '{profile_name}' saved successfully. Rows affected: {affected_rows}")
            return True
        except psycopg2.Error as e:
            logger.error(f"Error saving application configuration for profile '{profile_name}': {e}")
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during config save for profile '{profile_name}': {e}")
            return False

    # --- API Key Management ---

    def get_active_api_key(self, provider: str) -> Optional[str]:
        """Fetches the first active API key string for a given provider."""
        keys = self.get_active_api_keys(provider)
        return keys[0]['api_key'] if keys else None

    def get_active_api_keys(self, provider: str) -> List[Dict[str, Any]]:
        """Fetches all active API keys for a given provider, ordered by ID."""
        # Removed usage columns from this query as they are fetched in get_active_api_keys_with_usage
        query = """
            SELECT id, api_key, description, is_active FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            result = self._execute_query(query, (provider,), fetch_all=True)
            if result:
                logger.info(f"Found {len(result)} active API key(s) for provider '{provider}'.")
                return result
            else:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []
        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys for provider '{provider}': {e}")
             return []

    def get_active_api_keys_with_usage(self, provider: str) -> List[Dict[str, Any]]:
        """
        Fetches all active API keys for a given provider along with their current daily usage,
        ordered by ID. Calculates effective daily usage considering the reset window.
        (Queries only api_keys table now)
        """
        query = """
            SELECT
                id, api_key, description, is_active,
                COALESCE(calls_this_day, 0) AS raw_calls_this_day,
                day_start_timestamp
            FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            results = self._execute_query(query, (provider,), fetch_all=True)
            if not results:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []

            logger.info(f"Found {len(results)} active API key(s) with usage info for provider '{provider}'.")
            now = datetime.datetime.now(datetime.timezone.utc)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

            # Calculate effective daily usage
            for key_info in results:
                raw_calls = key_info.get('raw_calls_this_day', 0)
                day_start = key_info.get('day_start_timestamp')

                if day_start and day_start.tzinfo is None:
                    day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                    key_info['day_start_timestamp'] = day_start

                if day_start and day_start < current_day_start:
                    key_info['calls_this_day'] = 0
                    logger.debug(f"Key ID {key_info['id']}: Day window reset. Effective calls_this_day = 0")
                else:
                    key_info['calls_this_day'] = raw_calls
                    logger.debug(f"Key ID {key_info['id']}: Within current day window. Effective calls_this_day = {raw_calls}")

            return results

        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys with usage for provider '{provider}': {e}")
             return []
        except Exception as e:
            logger.error(f"Unexpected error getting active API keys with usage for '{provider}': {e}", exc_info=True)
            return []


    def list_api_keys(self, provider: Optional[str] = None) -> List[Dict[str, Any]]:
        """Lists all API keys, optionally filtered by provider."""
        # Added usage columns to the SELECT statement
        select_columns = "id, api_key, provider, description, is_active, last_api_call_timestamp, calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp"
        if provider:
            query = f"SELECT {select_columns} FROM api_keys WHERE provider = %s ORDER BY provider, id;"
            params = (provider,)
        else:
            query = f"SELECT {select_columns} FROM api_keys ORDER BY provider, id;"
            params = None
        try:
            result = self._execute_query(query, params, fetch_all=True)
            logger.info(f"Listed {len(result)} API keys" + (f" for provider '{provider}'." if provider else "."))
            return result if result else []
        except psycopg2.Error as e:
            logger.error(f"Failed to list API keys: {e}")
            return []

    def add_api_key(self, provider: str, api_key: str, description: Optional[str] = None) -> Optional[int]:
        """Adds a new API key to the database."""
        if not provider or not api_key:
            logger.error("Cannot add API key: Provider and API key string are required.")
            return None
        # Added default values for usage columns on insert
        query = """
            INSERT INTO api_keys (provider, api_key, description, is_active,
                                  last_api_call_timestamp, calls_this_minute, minute_start_timestamp,
                                  calls_this_day, day_start_timestamp)
            VALUES (%s, %s, %s, %s, NULL, 0, NULL, 0, NULL)
            RETURNING id;
        """
        params = (provider, api_key, description, True)
        try:
            key_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new API key with ID: {key_id} for provider '{provider}'.")
            return key_id
        except psycopg2.IntegrityError as e:
             logger.error(f"Failed to add API key for '{provider}': Key likely already exists. {e}")
             return None
        except psycopg2.Error as e:
            logger.error(f"Failed to add API key for '{provider}': {e}")
            return None

    def update_api_key(self, key_id: int, description: Optional[str] = None, is_active: Optional[bool] = None) -> bool:
        """Updates the description or active status of an API key."""
        if description is None and is_active is None:
            logger.warning(f"No update provided for API key ID {key_id}.")
            return False

        set_clauses = []
        params = []
        if description is not None:
            set_clauses.append("description = %s")
            params.append(description)
        if is_active is not None:
            set_clauses.append("is_active = %s")
            params.append(is_active)

        query = f"""
            UPDATE api_keys
            SET {', '.join(set_clauses)}, updated_at = NOW()
            WHERE id = %s;
        """
        params.append(key_id)

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} updated successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found or no changes made.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to update API key ID {key_id}: {e}")
            return False

    def delete_api_key(self, key_id: int) -> bool:
        """Deletes an API key from the database."""
        # ON DELETE CASCADE in gemini_api_logs handles foreign key constraint
        query = "DELETE FROM api_keys WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (key_id,))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} deleted successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found for deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to delete API key ID {key_id}: {e}")
            return False

    def get_api_key_id(self, api_key_string: str) -> Optional[int]:
        """Fetches the ID of a given API key string."""
        if not api_key_string: return None
        query = "SELECT id FROM api_keys WHERE api_key = %s;"
        try:
            result_dict = self._execute_query(query, (api_key_string,), fetch_one=True)
            return result_dict['id'] if result_dict and 'id' in result_dict else None
        except psycopg2.Error as e:
            logger.error(f"Failed to get API key ID: {e}")
            return None

    # --- Gemini Log Management ---

    def log_gemini_request(self, model_name: str, request_prompt: str, request_attachments: Optional[List[Dict[str, Any]]], api_key_id: Optional[int]) -> Optional[int]:
        """Logs the initial Gemini API request details and returns the log ID."""
        query = """
            INSERT INTO gemini_api_logs (model_name, request_prompt, request_attachments, api_key_id, request_timestamp)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """
        attachments_json = None
        if request_attachments:
            metadata_attachments = [{k: v for k, v in att.items() if k != 'data'} for att in request_attachments]
            try: attachments_json = json.dumps(metadata_attachments)
            except TypeError as e:
                logger.error(f"Failed to serialize attachments to JSON: {e}")
                attachments_json = json.dumps([{"error": "Serialization failed"}])

        request_timestamp = datetime.datetime.now(datetime.timezone.utc)
        params = (model_name, request_prompt, attachments_json, api_key_id, request_timestamp)
        try:
            log_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Logged Gemini request with ID: {log_id}")
            return log_id
        except psycopg2.Error as e:
            logger.error(f"Failed to log Gemini request: {e}")
            return None

    def update_gemini_log(self, log_id: int, response_text: Optional[str] = None, response_xml: Optional[str] = None, response_summary: Optional[str] = None, error_message: Optional[str] = None, elapsed_time_ms: Optional[int] = None, token_count: Optional[int] = None):
        """Updates the Gemini API log record with response details. Only updates non-None fields."""
        if log_id is None:
            logger.error("Cannot update Gemini log: Invalid log_id provided.")
            return

        update_fields = []
        params = []

        if response_text is not None: update_fields.append("response_text = %s"); params.append(response_text)
        if response_xml is not None: update_fields.append("response_xml = %s"); params.append(response_xml)
        if response_summary is not None: update_fields.append("response_summary = %s"); params.append(response_summary)
        if error_message is not None: update_fields.append("error_message = %s"); params.append(error_message)
        if elapsed_time_ms is not None: update_fields.append("elapsed_time_ms = %s"); params.append(elapsed_time_ms)
        if token_count is not None: update_fields.append("token_count = %s"); params.append(token_count)

        if not update_fields:
            logger.info(f"No fields to update for Gemini log ID: {log_id}")
            return

        update_fields.append("response_timestamp = %s")
        params.append(datetime.datetime.now(datetime.timezone.utc))
        params.append(log_id)

        query = f"""
            UPDATE gemini_api_logs
            SET {', '.join(update_fields)}
            WHERE id = %s;
        """

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1: logger.info(f"Updated Gemini log record ID: {log_id}")
            else: logger.warning(f"Attempted to update Gemini log ID: {log_id}, but no rows were affected (or more than 1).")
        except psycopg2.Error as e:
            logger.error(f"Failed to update Gemini log ID {log_id}: {e}")

    def cleanup_old_gemini_logs(self, days_to_keep: int = 7):
        """Deletes Gemini API log records older than the specified number of days."""
        if days_to_keep <= 0:
            logger.warning("Log cleanup skipped: days_to_keep must be positive.")
            return

        cutoff_date = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=days_to_keep)
        query = "DELETE FROM gemini_api_logs WHERE request_timestamp < %s;"
        try:
            affected_rows = self._execute_query(query, (cutoff_date,))
            if affected_rows is not None and affected_rows > 0:
                logger.info(f"Cleaned up {affected_rows} old Gemini log records older than {cutoff_date.strftime('%Y-%m-%d')}.")
            else: logger.info("No old Gemini log records found to clean up.")
        except psycopg2.Error as e:
            logger.error(f"Failed to clean up old Gemini logs: {e}")

    # --- Rate Limit and Usage Tracking (Modified for api_keys table) ---

    def update_api_key_usage(self, api_key_id: int):
        """Updates the usage statistics for a given API key ID directly in the api_keys table."""
        if api_key_id is None:
            logger.warning("Cannot update API key usage: api_key_id is None.")
            return

        logger.info(f"Updating API key usage for key ID: {api_key_id}")
        now = datetime.datetime.now(datetime.timezone.utc)
        current_minute_start = now.replace(second=0, microsecond=0)
        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

        # --- SQL Query using UPDATE with CASE statements ---
        # This query updates the existing row in api_keys based on the api_key_id.
        # It correctly handles the logic for incrementing counts or resetting them
        # based on whether the current minute/day window has passed.
        query = """
            UPDATE api_keys SET
                last_api_call_timestamp = %(now)s,

                -- Update minute count and timestamp
                calls_this_minute = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN 1
                    ELSE calls_this_minute + 1
                END,
                minute_start_timestamp = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN %(minute_start)s
                    ELSE minute_start_timestamp
                END,

                -- Update day count and timestamp
                calls_this_day = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN 1
                    ELSE calls_this_day + 1
                END,
                day_start_timestamp = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN %(day_start)s
                    ELSE day_start_timestamp
                END,

                -- Always update the updated_at timestamp
                updated_at = NOW()
            WHERE id = %(key_id)s;
        """
        params = {
            'key_id': api_key_id,
            'now': now,
            'minute_start': current_minute_start,
            'day_start': current_day_start
        }

        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1:
                logger.info(f"API key usage updated successfully for key ID: {api_key_id}.")
            elif affected_rows == 0:
                 logger.warning(f"API key usage update failed for key ID {api_key_id}: Key not found.")
            else:
                 # Should not happen with WHERE id = ...
                 logger.error(f"Unexpected number of rows affected ({affected_rows}) during API key usage update for key ID {api_key_id}.")

        except psycopg2.Error as e:
            logger.error(f"Failed to update API key usage for key ID {api_key_id}: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"An unexpected error occurred during API key usage update for key ID {api_key_id}: {e}", exc_info=True)


    def get_model_rate_limit(self, model_name: str) -> Optional[Dict[str, Any]]:
        """Fetches the default rate limit information for a specific model."""
        query = "SELECT rpm_limit, daily_limit FROM model_rate_limits WHERE model_name = %s;"
        try:
            result = self._execute_query(query, (model_name,), fetch_one=True)
            if result:
                logger.info(f"Rate limit found for model '{model_name}': RPM={result.get('rpm_limit')}, Daily={result.get('daily_limit')}")
                return result
            else:
                logger.warning(f"No rate limit information found for model '{model_name}'.")
                return None
        except psycopg2.Error as e:
            logger.error(f"Failed to get rate limit for model '{model_name}': {e}")
            return None

    def get_api_key_usage(self, api_key_id: int) -> Optional[Dict[str, Any]]:
        """Fetches the current usage statistics for a specific API key ID from the api_keys table."""
        if api_key_id is None: return None
        query = """
            SELECT calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp
            FROM api_keys
            WHERE id = %s;
        """
        try:
            result = self._execute_query(query, (api_key_id,), fetch_one=True)
            if result:
                logger.info(f"Usage found for API key ID {api_key_id}.")
                # Ensure timestamps are timezone-aware if they aren't already
                if result.get('minute_start_timestamp') and result['minute_start_timestamp'].tzinfo is None:
                    result['minute_start_timestamp'] = result['minute_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                if result.get('day_start_timestamp') and result['day_start_timestamp'].tzinfo is None:
                    result['day_start_timestamp'] = result['day_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                return result
            else:
                logger.info(f"No usage record found for API key ID {api_key_id}. Assuming 0 usage.")
                # Return default zero usage if no record exists (or key doesn't exist)
                return {
                    'calls_this_minute': 0, 'minute_start_timestamp': None,
                    'calls_this_day': 0, 'day_start_timestamp': None
                }
        except psycopg2.Error as e:
            logger.error(f"Failed to get usage for API key ID {api_key_id}: {e}")
            return None

    def is_key_rate_limited(self, api_key_id: int, model_name: str) -> Tuple[bool, str]:
        """
        Checks if the API key is currently rate-limited for the given model.
        (Uses the modified get_api_key_usage)
        """
        if api_key_id is None:
            return True, "API Key ID is missing."

        try:
            # 1. Get model's default rate limits
            rate_limit_info = self.get_model_rate_limit(model_name)
            if not rate_limit_info:
                logger.warning(f"No rate limit info found for model '{model_name}'. Assuming not limited.")
                return False, "Rate limit info not found."
            rpm_limit = rate_limit_info.get('rpm_limit')
            daily_limit = rate_limit_info.get('daily_limit')

            # 2. Get current usage for the API key (from api_keys table now)
            usage_info = self.get_api_key_usage(api_key_id)
            # get_api_key_usage now returns default 0 if key not found or no usage
            # No need to check if usage_info is None here

            calls_this_minute = usage_info.get('calls_this_minute', 0)
            minute_start = usage_info.get('minute_start_timestamp')
            calls_this_day = usage_info.get('calls_this_day', 0)
            day_start = usage_info.get('day_start_timestamp')
            now = datetime.datetime.now(datetime.timezone.utc)
            current_minute_start = now.replace(second=0, microsecond=0)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)


            # 3. Check RPM limit
            if rpm_limit is not None and rpm_limit > 0:
                current_minute_call_count = calls_this_minute
                if minute_start and minute_start < current_minute_start:
                     current_minute_call_count = 0
                     logger.debug(f"RPM Check: Minute window reset for key {api_key_id}. Current count considered 0.")

                if current_minute_call_count >= rpm_limit:
                    reason = f"RPM limit ({rpm_limit}) reached or exceeded (current minute calls: {current_minute_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            # 4. Check Daily limit
            if daily_limit is not None and daily_limit > 0:
                current_day_call_count = calls_this_day
                if day_start and day_start < current_day_start:
                    current_day_call_count = 0
                    logger.debug(f"Daily Check: Day window reset for key {api_key_id}. Current count considered 0.")

                if current_day_call_count >= daily_limit:
                    reason = f"Daily limit ({daily_limit}) reached or exceeded (current day calls: {current_day_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            logger.debug(f"Rate limit check passed for key ID {api_key_id} and model '{model_name}'.")
            return False, "Rate limit OK."

        except Exception as e:
            logger.error(f"Error checking rate limit for key ID {api_key_id}: {e}", exc_info=True)
            return True, f"Error during rate limit check: {e}"


    def __del__(self):
        """Ensure disconnection when the service object is destroyed."""
        self.disconnect()




======== src\core\services\filesystem_service.py ========
import os
import fnmatch
from typing import Set, List

class FilesystemService:
    def __init__(self, config_service): # ConfigService ì£¼ì…
        self.config_service = config_service

    def load_gitignore_patterns(self, project_folder: str) -> Set[str]:
        """Loads .gitignore patterns from the project folder and combines with defaults."""
        gitignore_path = os.path.join(project_folder, ".gitignore")
        settings = self.config_service.get_settings()
        # ê¸°ë³¸ ë¬´ì‹œ ëª©ë¡ìœ¼ë¡œ ì‹œì‘
        patterns = set(settings.default_ignore_list)

        if os.path.isfile(gitignore_path):
            try:
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    lines = f.read().splitlines()
                # ì£¼ì„ê³¼ ë¹ˆ ì¤„ ì œì™¸í•˜ê³  íŒ¨í„´ ì¶”ê°€
                lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                patterns.update(lines)
            except Exception as e:
                print(f"Error loading .gitignore file {gitignore_path}: {e}")
                # ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ë§Œ ì‚¬ìš©

        # ì„¤ì •ì— ì§ì ‘ ì €ì¥ëœ ì œì™¸ ëª©ë¡ë„ ì¶”ê°€ (config.yml)
        patterns.update(settings.excluded_dirs)
        return patterns

    def should_ignore(self, file_path: str, project_root: str, ignore_patterns: Set[str], is_dir: bool) -> bool:
        """Checks if a file/directory should be ignored based on patterns."""
        if not project_root or not file_path.startswith(project_root):
            return False # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì™¸ë¶€ëŠ” ë¬´ì‹œí•˜ì§€ ì•ŠìŒ

        if file_path == project_root:
            return False # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ìì²´ëŠ” ë¬´ì‹œí•˜ì§€ ì•ŠìŒ

        file_name = os.path.basename(file_path)
        try:
            relative_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
        except ValueError:
            # ë‹¤ë¥¸ ë“œë¼ì´ë¸Œ ë“± ìƒëŒ€ ê²½ë¡œ ê³„ì‚° ë¶ˆê°€ ì‹œ ë¬´ì‹œí•˜ì§€ ì•ŠìŒ
            return False

        for pattern in ignore_patterns:
            # íŒ¨í„´ ì •ë¦¬ ë° ë””ë ‰í† ë¦¬ íŒ¨í„´ ì—¬ë¶€ í™•ì¸
            is_dir_pattern = pattern.endswith('/')
            cleaned_pattern = pattern.rstrip('/')

            # ë””ë ‰í† ë¦¬ íŒ¨í„´ì¸ë° í˜„ì¬ í•­ëª©ì´ íŒŒì¼ì´ë©´ ê±´ë„ˆëœ€
            if is_dir_pattern and not is_dir:
                continue

            # 1. íŒŒì¼ ì´ë¦„ ë§¤ì¹­ (e.g., *.log, __pycache__)
            if fnmatch.fnmatch(file_name, cleaned_pattern):
                # ë””ë ‰í† ë¦¬ íŒ¨í„´ì´ë©´ ë””ë ‰í† ë¦¬ë§Œ ë§¤ì¹­
                if is_dir_pattern and is_dir:
                    return True
                # íŒŒì¼ íŒ¨í„´ì´ë©´ íŒŒì¼/ë””ë ‰í† ë¦¬ ëª¨ë‘ ë§¤ì¹­ (gitignore ê¸°ë³¸ ë™ì‘)
                elif not is_dir_pattern:
                    return True

            # 2. ìƒëŒ€ ê²½ë¡œ ë§¤ì¹­ (e.g., build/, docs/temp.txt)
            # ë””ë ‰í† ë¦¬ì¼ ê²½ìš°, ê²½ë¡œ ëì— '/' ì¶”ê°€í•˜ì—¬ ë§¤ì¹­
            match_path = relative_path + '/' if is_dir else relative_path
            if fnmatch.fnmatch(match_path, pattern):
                 return True
            # íŒ¨í„´ì— /ê°€ í¬í•¨ë˜ì–´ ìˆê³ , ë””ë ‰í† ë¦¬ íŒ¨í„´ì´ ì•„ë‹ ë•Œë„ ê²½ë¡œ ë§¤ì¹­ ì‹œë„
            # (e.g. 'some/dir/file.txt' íŒ¨í„´)
            if '/' in pattern and not is_dir_pattern:
                 if fnmatch.fnmatch(relative_path, pattern):
                     return True

        return False # ì–´ë–¤ íŒ¨í„´ê³¼ë„ ë§¤ì¹˜ë˜ì§€ ì•Šìœ¼ë©´ ë¬´ì‹œí•˜ì§€ ì•ŠìŒ

    def get_directory_tree(self, paths: List[str], project_root: str) -> str:
        """Builds a directory tree structure string from a list of paths."""
        if not paths or not project_root:
            return "No items selected or project root not set."

        tree = {}
        visible_paths = [] # ì‹¤ì œ ì¡´ì¬í•˜ëŠ” ê²½ë¡œë§Œ í•„í„°ë§ (í•„ìš”ì‹œ)
        for p in paths:
            if os.path.exists(p):
                 visible_paths.append(p)

        if not visible_paths:
            return "No valid items selected."

        for p in visible_paths:
            try:
                rel_path = os.path.relpath(p, project_root)
            except ValueError:
                continue # ë‹¤ë¥¸ ë“œë¼ì´ë¸Œ ë“± relpath ê³„ì‚° ë¶ˆê°€ ì‹œ ê±´ë„ˆëœ€
            parts = rel_path.split(os.sep)
            current = tree
            for part in parts:
                if part not in current:
                    current[part] = {}
                current = current[part]

        def print_tree(subtree, current_path, indent=0):
            lines = []
            indent_str = "  " * indent
            entries = sorted(subtree.keys())
            dirs = []
            files = []

            for entry in entries:
                full_path = os.path.join(current_path, entry)
                if os.path.isdir(full_path):
                    dirs.append(entry)
                elif os.path.isfile(full_path):
                    files.append(entry)

            for d in dirs:
                lines.append(f"{indent_str} ğŸ“ {d}/")
                lines.extend(print_tree(subtree[d], os.path.join(current_path, d), indent + 1))
            for f in files:
                # --- Removed file size calculation ---
                # size = 0
                # full_file_path = os.path.join(current_path, f)
                # try:
                #     size = os.path.getsize(full_file_path)
                # except OSError:
                #     size = 0
                # lines.append(f"{indent_str} ğŸ“„ {f} ({size:,} bytes)")
                # --- End of removal ---
                lines.append(f"{indent_str} ğŸ“„ {f}") # Display only filename
            return lines

        root_folder_name = os.path.basename(project_root)
        root_lines = [f"File Tree:", f" ğŸ“ {root_folder_name}/"]
        root_lines.extend(print_tree(tree, project_root, 1))

        return "\n".join(root_lines)



======== src\core\services\gemini_service.py ========
import google.generativeai as genai
from langgraph.graph import StateGraph, END, START
from functools import partial
import logging
from typing import Optional, List, Dict, Any, Union, Tuple, Set
import base64
import mimetypes
import os
import datetime # datetime ëª¨ë“ˆ ì„í¬íŠ¸
import time # ì‹œê°„ ì¸¡ì •ìš©

from core.langgraph_state import GeminiGraphState
from core.services.config_service import ConfigService
from core.services.db_service import DbService # DbService ì„í¬íŠ¸
from google.generativeai import types
from google.api_core import exceptions as google_api_exceptions

logger = logging.getLogger(__name__)

# --- LangGraph ë…¸ë“œ í•¨ìˆ˜ ---

def call_gemini(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """
    Gemini APIë¥¼ í˜¸ì¶œí•˜ëŠ” ë…¸ë“œ (ë©€í‹°ëª¨ë‹¬ ì§€ì›).
    1. ì‚¬ìš©ìê°€ ì„ íƒí•œ í‚¤ë¥¼ ë¨¼ì € ì‹œë„í•©ë‹ˆë‹¤. (í™œì„± ìƒíƒœ ë° Rate Limit ì²´í¬ í›„)
    2. ì‚¬ìš©ì ì„ íƒ í‚¤ê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨(Rate Limit, PermissionDenied ë“±)í•˜ë©´, DBì—ì„œ í™œì„± í‚¤ ëª©ë¡ì„ ì¡°íšŒí•˜ì—¬
       ì¼ì¼ ì‚¬ìš©ëŸ‰ì´ ê°€ì¥ ì ì€ í‚¤ë¶€í„° ìˆœì„œëŒ€ë¡œ ì‹œë„í•©ë‹ˆë‹¤. (ì´ë¯¸ ì‹œë„í•œ í‚¤ ì œì™¸)
    3. Rate Limit, PermissionDenied, InvalidArgument ì—ëŸ¬ ë°œìƒ ì‹œ ë‹¤ìŒ í‚¤ë¡œ ìë™ ì „í™˜í•˜ì—¬ ì¬ì‹œë„í•©ë‹ˆë‹¤.
    4. ì„±ê³µ ì‹œ ì‚¬ìš©ëœ í‚¤ ì •ë³´ë¥¼ ConfigServiceì— ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    """
    logger.info("Calling Gemini API node (Multimodal, with key rotation)")
    start_time_mono = time.monotonic()
    request_timestamp = datetime.datetime.now(datetime.timezone.utc)
    logger.info(f"Gemini API í˜¸ì¶œ ì‹œì‘ ì‹œê°„: {request_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}")

    text_prompt = state['input_prompt']
    attachments = state.get('input_attachments', [])
    settings = config_service.get_settings()
    db_service: DbService = config_service.db_service

    # ì„¤ì •ì—ì„œ ëª¨ë¸ëª… ê°€ì ¸ì˜¤ê¸°
    model_name = state.get('selected_model_name', settings.gemini_default_model)
    temperature = settings.gemini_temperature
    enable_thinking = settings.gemini_enable_thinking
    thinking_budget = settings.gemini_thinking_budget
    enable_search = settings.gemini_enable_search

    # ì´ˆê¸° ìƒíƒœ ë°˜í™˜ìš© ê¸°ë³¸ê°’
    default_return_state: GeminiGraphState = {
        "input_prompt": text_prompt, "input_attachments": attachments,
        "selected_model_name": model_name, "gemini_response": "",
        "xml_output": "", "summary_output": "", "error_message": None, "log_id": None
    }

    if not model_name:
        error_msg = "Gemini model name not provided or configured."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg
        return default_return_state

    # --- API í‚¤ ì„ íƒ ë° ì‹œë„ ë¡œì§ (ê°œì„ ) ---
    tried_key_ids: Set[int] = set() # ì´ë¯¸ ì‹œë„í•œ í‚¤ ID ì¶”ì 
    api_key_id: Optional[int] = None
    log_id: Optional[int] = None
    final_error_message: Optional[str] = None
    api_call_successful = False # API í˜¸ì¶œ ì„±ê³µ ì—¬ë¶€ í”Œë˜ê·¸
    successfully_used_key_string: Optional[str] = None # ì„±ê³µì ìœ¼ë¡œ ì‚¬ìš©ëœ í‚¤ ë¬¸ìì—´
    successfully_used_key_id: Optional[int] = None # ì„±ê³µì ìœ¼ë¡œ ì‚¬ìš©ëœ í‚¤ ID

    # 1. ì‚¬ìš©ì ì§€ì • í‚¤ ë¨¼ì € ì‹œë„
    user_selected_key_id = config_service.get_user_selected_gemini_key_id()
    user_key_info: Optional[Dict[str, Any]] = None

    if user_selected_key_id is not None:
        logger.info(f"User has selected Gemini Key ID: {user_selected_key_id}. Attempting to use it first.")
        try:
            # DBì—ì„œ í•´ë‹¹ í‚¤ì˜ ìƒì„¸ ì •ë³´ì™€ ìµœì‹  ì‚¬ìš©ëŸ‰ ì¡°íšŒ (get_active_api_keys_with_usage í•„í„°ë§ ë°©ì‹ ìœ ì§€)
            temp_keys_usage = db_service.get_active_api_keys_with_usage('google')
            user_key_info = next((k for k in temp_keys_usage if k['id'] == user_selected_key_id), None)

            if user_key_info:
                logger.info(f"Found details for user-selected key ID {user_selected_key_id}.")
                # Rate Limit ì²´í¬
                is_limited, reason = db_service.is_key_rate_limited(user_selected_key_id, model_name)
                if is_limited:
                    logger.warning(f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}. Will try other keys.")
                    final_error_message = f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}"
                    tried_key_ids.add(user_selected_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
                    user_key_info = None # ì‚¬ìš© ë¶ˆê°€ ì²˜ë¦¬
                else:
                    logger.info(f"User-selected key ID {user_selected_key_id} passed rate limit check.")
                    # ì‚¬ìš©ì ì„ íƒ í‚¤ë¥¼ ì²« ë²ˆì§¸ ì‹œë„ ëŒ€ìƒìœ¼ë¡œ ì„¤ì •
            else:
                logger.warning(f"User-selected key ID {user_selected_key_id} not found among active keys or failed to get usage. Will try other keys.")
                tried_key_ids.add(user_selected_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼ (ì°¾ì„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ)

        except Exception as e:
            logger.error(f"Error retrieving/checking user-selected key ID {user_selected_key_id}: {e}", exc_info=True)
            tried_key_ids.add(user_selected_key_id) # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            user_key_info = None # ì‚¬ìš© ë¶ˆê°€ ì²˜ë¦¬

    # --- API í‚¤ ì‹œë„ ë£¨í”„ ---
    keys_to_attempt: List[Dict[str, Any]] = []
    if user_key_info:
        keys_to_attempt.append(user_key_info) # ì‚¬ìš©ì ì„ íƒ í‚¤ë¥¼ ë§¨ ì•ì— ì¶”ê°€

    # ì‚¬ìš©ì í‚¤ê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨í•  ê²½ìš° ë‹¤ë¥¸ í™œì„± í‚¤ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    if not user_key_info: # ì‚¬ìš©ì í‚¤ê°€ ì—†ê±°ë‚˜, Rate Limit ê±¸ë ¸ê±°ë‚˜, ì¡°íšŒ ì‹¤íŒ¨í•œ ê²½ìš°
        logger.info("Fetching other active Gemini keys sorted by daily usage...")
        try:
            active_keys_usage = db_service.get_active_api_keys_with_usage('google')
            active_keys_usage.sort(key=lambda x: x['calls_this_day']) # ì¼ì¼ ì‚¬ìš©ëŸ‰ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
            # ì´ë¯¸ ì‹œë„í•œ ì‚¬ìš©ì ì„ íƒ í‚¤ ì œì™¸í•˜ê³  ì¶”ê°€
            added_count = 0
            for key_info in active_keys_usage:
                if key_info['id'] not in tried_key_ids:
                    keys_to_attempt.append(key_info)
                    added_count += 1
            logger.info(f"Found {added_count} other active keys to try.")
        except Exception as e:
            error_msg = f"Failed to retrieve other active Gemini keys with usage from DB: {e}"
            logger.error(error_msg, exc_info=True)
            # ë‹¤ë¥¸ í‚¤ ì¡°íšŒ ì‹¤íŒ¨ ì‹œ, ì‚¬ìš©ì í‚¤ë„ ì—†ìœ¼ë©´ ì™„ì „ ì‹¤íŒ¨
            if not user_key_info:
                default_return_state["error_message"] = final_error_message or error_msg # ì‚¬ìš©ì í‚¤ Rate Limit ë©”ì‹œì§€ ë˜ëŠ” DB ì˜¤ë¥˜ ë©”ì‹œì§€
                return default_return_state
            # ì‚¬ìš©ì í‚¤ëŠ” ìˆì—ˆì§€ë§Œ Rate Limit ê±¸ë¦° ê²½ìš°, ë‹¤ë¥¸ í‚¤ ì¡°íšŒ ì‹¤íŒ¨í–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì¢…ë£Œ
            elif user_selected_key_id in tried_key_ids:
                 default_return_state["error_message"] = final_error_message or "Failed to find alternative keys."
                 return default_return_state

    if not keys_to_attempt:
        error_msg = final_error_message or "No usable Gemini API Keys found (neither selected nor active/available in DB)."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg
        return default_return_state

    logger.info(f"Total keys to try in order: {[k['id'] for k in keys_to_attempt]}")

    # --- API í‚¤ ìˆœì°¨ ì‹œë„ ---
    for key_info in keys_to_attempt:
        api_key = key_info['api_key']
        current_key_id = key_info['id'] # í˜„ì¬ ì‹œë„í•˜ëŠ” í‚¤ ID
        daily_usage = key_info.get('calls_this_day', 'N/A')
        logger.info(f"Attempting to use Gemini API Key ID: {current_key_id} (Daily Usage: {daily_usage})")

        # ì´ë¯¸ ì‹œë„í•œ í‚¤ëŠ” ê±´ë„ˆë›°ê¸° (ì¤‘ë³µ ë°©ì§€)
        if current_key_id in tried_key_ids:
            logger.debug(f"Skipping already tried key ID: {current_key_id}")
            continue

        # Rate Limit ì²´í¬ (ì‚¬ìš©ì í‚¤ëŠ” ì´ë¯¸ ì²´í¬í–ˆìœ¼ë¯€ë¡œ, ë‹¤ë¥¸ í‚¤ë§Œ ì²´í¬)
        if current_key_id != user_selected_key_id:
            is_limited, reason = db_service.is_key_rate_limited(current_key_id, model_name)
            if is_limited:
                logger.warning(f"Pre-check failed: Rate limit reached for key ID {current_key_id}. Reason: {reason}. Skipping.")
                final_error_message = f"Rate limit exceeded for key ID {current_key_id}: {reason}" # ë§ˆì§€ë§‰ ì‹¤íŒ¨ ì‚¬ìœ  ì—…ë°ì´íŠ¸
                tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
                continue # ë‹¤ìŒ í‚¤ ì‹œë„
            logger.info(f"Rate limit pre-check passed for key ID {current_key_id}.")

        # --- DB ë¡œê¹… ì¤€ë¹„ ---
        current_log_id = log_id # ì´ì „ ì‹œë„ì˜ log_id (ì‹¤íŒ¨ ì‹œ)
        if current_log_id is None: # ì²« ì‹œë„ì¸ ê²½ìš°ì—ë§Œ ìƒˆ ë¡œê·¸ ìƒì„±
            try:
                current_log_id = db_service.log_gemini_request(
                    model_name=model_name, request_prompt=text_prompt,
                    request_attachments=attachments, api_key_id=current_key_id # í˜„ì¬ ì‹œë„í•˜ëŠ” í‚¤ ID ì‚¬ìš©
                )
                if current_log_id:
                     log_id = current_log_id # ì„±ê³µì ìœ¼ë¡œ ìƒì„±ëœ log_id ì €ì¥
                     default_return_state["log_id"] = log_id # ìƒíƒœì—ë„ ë°˜ì˜
                else:
                     logger.error(f"Failed to create initial Gemini log entry for key ID {current_key_id}.")
            except Exception as db_err:
                logger.error(f"Failed to log Gemini request to DB for key ID {current_key_id}: {db_err}", exc_info=True)
        # --- DB ë¡œê¹… ì¤€ë¹„ ì™„ë£Œ ---

        effective_model_name = ""
        gemini_response_text = ""
        api_error_message: Optional[str] = None
        # api_call_successful í”Œë˜ê·¸ëŠ” ë£¨í”„ ì‹œì‘ ì‹œ Falseë¡œ ì´ˆê¸°í™”ë¨

        try:
            genai.configure(api_key=api_key)
            effective_model_name = model_name.replace("models/", "")
            model = genai.GenerativeModel(effective_model_name)
            logger.info(f"Using Gemini model: {effective_model_name} with key ID: {current_key_id}")

            # GenerationConfig, ToolConfig, Tools ì„¤ì •
            generation_config_params = {"temperature": temperature, "response_mime_type": "text/plain"}
            try: generation_config = types.GenerationConfig(**generation_config_params)
            except AttributeError: raise ValueError("Failed to create GenerationConfig (AttributeError)")
            except Exception as e: raise ValueError(f"Error creating GenerationConfig: {e}")

            tools_list: Optional[List[types.Tool]] = None
            if enable_search:
                try: tools_list = [types.Tool(google_search=types.GoogleSearch())]
                except AttributeError: logger.warning("Search tool creation failed (AttributeError)")
                except Exception as e: logger.error(f"Error creating GoogleSearch tool: {e}")

            tool_config_obj: Optional[types.ToolConfig] = None
            if enable_thinking:
                try:
                    thinking_config_obj = types.ThinkingConfig(thinking_budget=thinking_budget)
                    tool_config_obj = types.ToolConfig(thinking_config=thinking_config_obj)
                except AttributeError: logger.warning("Thinking config creation failed (AttributeError)")
                except Exception as e: logger.error(f"Error creating ThinkingConfig/ToolConfig: {e}")

            # Contents êµ¬ì„±
            contents_list: List[Union[str, Dict[str, Any]]] = []
            if text_prompt: contents_list.append(text_prompt)
            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type'); item_name = attachment.get('name', 'unknown')
                    item_data = attachment.get('data'); item_path = attachment.get('path')
                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e: logger.error(f"Failed to read attachment {item_path}: {e}"); continue
                    if not item_data: logger.warning(f"Skipping attachment '{item_name}': No data."); continue
                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name)
                        if not mime_type: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list: raise ValueError("No content (text or attachments) to send.")

            # API í˜¸ì¶œ (ìŠ¤íŠ¸ë¦¼)
            logger.info(f"Sending {len(contents_list)} parts to Gemini model: {effective_model_name} (using key ID: {current_key_id})")
            response = model.generate_content(
                contents=contents_list, generation_config=generation_config,
                tools=tools_list, tool_config=tool_config_obj, stream=True
            )

            # ìŠ¤íŠ¸ë¦¼ ì‘ë‹µ ì²˜ë¦¬
            specific_error_occurred = False; error_details = ""
            for chunk in response:
                try: gemini_response_text += chunk.text
                except ValueError as e:
                    if "response.text` quick accessor" in str(e) or "candidate.text`" in str(e):
                        func_calls = getattr(chunk, 'function_calls', None)
                        finish_reason = getattr(getattr(chunk, 'candidates', [None])[0], 'finish_reason', 'unknown') if hasattr(chunk, 'candidates') else 'unknown'
                        msg = (f"Function Call ignored: {func_calls}" if func_calls
                               else f"Chunk text access error (Finish Reason: {finish_reason}): {e}")
                        logger.warning(msg)
                        error_details += f"\n- {msg}"
                        specific_error_occurred = True
                        continue
                    else: raise
                except Exception as e: logger.exception(f"Unexpected chunk error: {e}"); error_details += f"\n- Chunk error: {e}"; specific_error_occurred = True; continue

            # ê²°ê³¼ ì²˜ë¦¬
            if specific_error_occurred:
                api_error_message = f"Gemini API ì‘ë‹µ ë¬¸ì œ ë°œìƒ (Key ID: {current_key_id}). ì¼ë¶€ ë‚´ìš© ëˆ„ë½ ë˜ëŠ” Function Call í¬í•¨ ê°€ëŠ¥." + "\nì„¸ë¶€ ì •ë³´:" + error_details
                logger.warning(f"Gemini stream processing issues for key ID {current_key_id}. Details: {error_details}")
                default_return_state["error_message"] = api_error_message
                default_return_state["gemini_response"] = gemini_response_text # ë¶€ë¶„ ì‘ë‹µ ì €ì¥
                api_call_successful = True # ë¶€ë¶„ ì„±ê³µìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                break # ë£¨í”„ ì¢…ë£Œ (ì˜¤ë¥˜ ë°œìƒ ì‹œ ë‹¤ë¥¸ í‚¤ ì‹œë„ ì•ˆ í•¨)

            elif not gemini_response_text.strip():
                error_detail = "Unknown reason (empty response)"
                try: error_detail = f"Prompt Feedback: {response.prompt_feedback}"
                except Exception: pass
                api_error_message = f"Gemini API í˜¸ì¶œ ì„±ê³µí–ˆìœ¼ë‚˜ ë¹ˆ ì‘ë‹µ ë°˜í™˜ (Key ID: {current_key_id}). ì„¸ë¶€ ì •ë³´: {error_detail}"
                logger.warning(api_error_message)
                default_return_state["gemini_response"] = ""
                default_return_state["error_message"] = api_error_message
                api_call_successful = True # ë¹ˆ ì‘ë‹µë„ ì„±ê³µìœ¼ë¡œ ê°„ì£¼
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                break # ë£¨í”„ ì¢…ë£Œ

            else:
                logger.info(f"--- Gemini Response Received Successfully using Key ID: {current_key_id} ---")
                api_call_successful = True
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                default_return_state["gemini_response"] = gemini_response_text
                default_return_state["error_message"] = None # ì„±ê³µ ì‹œ ì˜¤ë¥˜ ì—†ìŒ
                break # ì„±ê³µí–ˆìœ¼ë¯€ë¡œ ë£¨í”„ ì¢…ë£Œ

        except google_api_exceptions.ResourceExhausted as e:
            api_error_message = f"Gemini API Rate Limit ì´ˆê³¼ (Key ID: {current_key_id}): {str(e)}. ë‹¤ìŒ í‚¤ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤."
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Rate Limit Error: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # ë‹¤ìŒ í‚¤ ì‹œë„

        except google_api_exceptions.PermissionDenied as e:
            api_error_message = f"Gemini API ê¶Œí•œ ì˜¤ë¥˜ (Key ID: {current_key_id}): {str(e)}. ë‹¤ìŒ í‚¤ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤."
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Permission Denied: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # ë‹¤ìŒ í‚¤ ì‹œë„

        except google_api_exceptions.InvalidArgument as e:
            api_error_message = f"Gemini API ì˜ëª»ëœ ì¸ìˆ˜ ì˜¤ë¥˜ (Key ID: {current_key_id}): {str(e)}. ë‹¤ìŒ í‚¤ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤. (ë¬¸ì œê°€ í‚¤ ê´€ë ¨ì´ ì•„ë‹ ìˆ˜ ìˆìŒ)"
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Invalid Argument: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # ë‹¤ìŒ í‚¤ ì‹œë„

        except (AttributeError, ValueError) as e:
            error_type = type(e).__name__
            api_error_message = f"Gemini API ì˜¤ë¥˜ ({error_type} - Key ID: {current_key_id}): {str(e)}. ì¤‘ë‹¨í•©ë‹ˆë‹¤."
            logger.error(api_error_message, exc_info=True)
            default_return_state["error_message"] = api_error_message
            api_call_successful = False
            tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            break # ë£¨í”„ ì¤‘ë‹¨

        except Exception as e:
            api_error_message = f"Gemini API í˜¸ì¶œ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ (Key ID: {current_key_id}): {str(e)}. ì¤‘ë‹¨í•©ë‹ˆë‹¤."
            logger.exception(api_error_message)
            default_return_state["error_message"] = api_error_message
            api_call_successful = False
            tried_key_ids.add(current_key_id) # ì‹œë„í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
            break # ë£¨í”„ ì¤‘ë‹¨

        finally:
            # finally ë¸”ë¡ì€ Rate Limit/Permission/Argument ì˜¤ë¥˜ë¡œ continue í•  ë•Œë„ ì‹¤í–‰ë¨
            # ì„±ê³µí–ˆê±°ë‚˜, ë³µêµ¬ ë¶ˆê°€ëŠ¥í•œ ì˜¤ë¥˜ë¡œ ì¤‘ë‹¨ë˜ì—ˆê±°ë‚˜, ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¡œê·¸ ì—…ë°ì´íŠ¸
            if api_call_successful or (api_error_message and "ë‹¤ìŒ í‚¤ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤" not in api_error_message):
                 # ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ëŠ” ì„±ê³µ ì‹œì—ë§Œ
                 if api_call_successful and db_service and current_key_id is not None:
                    try: db_service.update_api_key_usage(current_key_id)
                    except Exception as usage_err: logger.error(f"Failed to update usage for key ID {current_key_id}: {usage_err}", exc_info=True)

                 # DB ë¡œê·¸ ì—…ë°ì´íŠ¸ (ì„±ê³µ/ì˜¤ë¥˜ ëª¨ë‘, log_idê°€ ìƒì„±ëœ ê²½ìš°)
                 if db_service and log_id is not None:
                    end_time_mono = time.monotonic(); elapsed_ms = int((end_time_mono - start_time_mono) * 1000)
                    try:
                        db_service.update_gemini_log(
                            log_id=log_id, response_text=gemini_response_text,
                            error_message=api_error_message, elapsed_time_ms=elapsed_ms
                        )
                    except Exception as db_err: logger.error(f"Failed to update Gemini log ID {log_id}: {db_err}", exc_info=True)
            # Rate Limit/Permission/Argument ë°œìƒ ì‹œì—ëŠ” finally ë¸”ë¡ì—ì„œ ë³„ë„ ì²˜ë¦¬ ì—†ìŒ (except ë¸”ë¡ì—ì„œ ë¡œê·¸ ì—…ë°ì´íŠ¸)
    # --- ë£¨í”„ ì¢…ë£Œ ---

    # --- ì„±ê³µ ì‹œ ì‚¬ìš©ëœ í‚¤ë¥¼ ConfigServiceì— ì—…ë°ì´íŠ¸ ---
    if api_call_successful and successfully_used_key_string and successfully_used_key_id is not None:
        if config_service:
            config_service.update_last_used_gemini_key(successfully_used_key_string)
            logger.info(f"Successfully used API key ID {successfully_used_key_id}. Updated in-memory config via ConfigService.")
            # ì‚¬ìš©ìê°€ ì„ íƒí•œ í‚¤ì™€ ë‹¤ë¥¸ í‚¤ê°€ ì‚¬ìš©ë˜ì—ˆì„ ê²½ìš°, ì‚¬ìš©ì ì„ íƒ í•´ì œ
            if user_selected_key_id is not None and user_selected_key_id != successfully_used_key_id:
                 logger.info(f"Successfully used key ID {successfully_used_key_id} is different from user-selected key ID {user_selected_key_id}. Clearing user selection.")
                 config_service.set_user_selected_gemini_key(None)
        else:
            logger.warning("ConfigService not available to update the last used key.")
    # ----------------------------------------------------

    # ëª¨ë“  í‚¤ë¥¼ ì‹œë„í–ˆì§€ë§Œ ì‹¤íŒ¨í•œ ê²½ìš°
    if not api_call_successful:
        error_msg = final_error_message or "ëª¨ë“  í™œì„± Gemini API í‚¤ë¥¼ ì‹œë„í–ˆì§€ë§Œ í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg

    # ìµœì¢… ê²½ê³¼ ì‹œê°„ ë¡œê¹…
    total_elapsed_ms = int((time.monotonic() - start_time_mono) * 1000)
    response_timestamp = datetime.datetime.now(datetime.timezone.utc)
    elapsed_time_str = str(datetime.timedelta(milliseconds=total_elapsed_ms)).split('.')[0]
    logger.info(f"Gemini API í˜¸ì¶œ ë…¸ë“œ ì¢…ë£Œ ì‹œê°„: {response_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}, ì´ ê²½ê³¼ ì‹œê°„: {elapsed_time_str}")

    return default_return_state


def process_response(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """
    Gemini ì‘ë‹µì„ XMLê³¼ Summaryë¡œ íŒŒì‹±í•˜ëŠ” ë…¸ë“œ.
    ì‘ë‹µ ë ë¶€ë¶„ì˜ <summary> íƒœê·¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ì½”ë“œ ë‚´ ë¬¸ìì—´ê³¼ì˜ í˜¼ë™ì„ ì¤„ì…ë‹ˆë‹¤.
    íŒŒì‹±ëœ ê²°ê³¼ë¥¼ DB ë¡œê·¸ì— ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    """
    print("--- Processing Gemini Response ---")
    logger.info("Processing Gemini Response node")
    gemini_response = state.get('gemini_response', '')
    xml_output = ""
    summary_output = ""
    error_message = state.get('error_message') # ì´ì „ ë…¸ë“œì˜ ì˜¤ë¥˜ ë©”ì‹œì§€ ìœ ì§€
    log_id = state.get('log_id') # ìƒíƒœì—ì„œ log_id ê°€ì ¸ì˜¤ê¸°
    db_service: Optional[DbService] = config_service.db_service if config_service else None

    new_state = state.copy()

    try:
        # ì´ì „ ë…¸ë“œì—ì„œ ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆë‹¤ë©´ ì²˜ë¦¬ ê±´ë„ˆë›°ê¸°
        if error_message and "Gemini API ì‘ë‹µ ë¬¸ì œ ë°œìƒ" not in error_message and "ë¹ˆ ì‘ë‹µ ë°˜í™˜" not in error_message: # ë¹ˆ ì‘ë‹µì€ ì²˜ë¦¬ ì‹œë„
             logger.warning(f"Skipping response processing due to previous critical error: {error_message}")
             new_state["xml_output"] = ""
             new_state["summary_output"] = ""
             # DB ë¡œê·¸ì— ìµœì¢… ì˜¤ë¥˜ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸ ì‹œë„ (call_geminiì—ì„œ ì´ë¯¸ í–ˆì„ ìˆ˜ ìˆìŒ)
             # if db_service and log_id is not None:
             #     db_service.update_gemini_log(log_id=log_id, error_message=error_message)
             return new_state
        elif error_message:
             logger.warning(f"Processing potentially partial or empty response due to previous issue: {error_message}")

        if not gemini_response or not gemini_response.strip(): # ë¹ˆ ë¬¸ìì—´ ë˜ëŠ” ê³µë°±ë§Œ ìˆëŠ” ê²½ìš°
             logger.warning("Gemini response is empty, skipping processing.")
             if not error_message: # ì´ì „ ì˜¤ë¥˜ê°€ ì—†ì—ˆë‹¤ë©´ ë¹ˆ ì‘ë‹µ ì˜¤ë¥˜ ì„¤ì •
                 error_message = "Gemini response was empty after successful API call."
                 new_state["error_message"] = error_message
             new_state["xml_output"] = ""
             new_state["summary_output"] = ""
             # DB ë¡œê·¸ ì—…ë°ì´íŠ¸ (ì˜¤ë¥˜ - ë¹ˆ ì‘ë‹µ)
             if db_service and log_id is not None:
                 db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
             return new_state


        cleaned_response = gemini_response.strip()
        summary_start_tag = "<summary>"
        summary_end_tag = "</summary>"
        summary_start_index = cleaned_response.rfind(summary_start_tag)
        summary_end_index = cleaned_response.rfind(summary_end_tag)

        is_valid_summary = (
            summary_start_index != -1 and
            summary_end_index != -1 and
            summary_start_index < summary_end_index and
            # ëë¶€ë¶„ì— ìˆëŠ”ì§€ ì¢€ ë” ê´€ëŒ€í•˜ê²Œ í™•ì¸ (ì•½ê°„ì˜ í›„í–‰ ê³µë°± í—ˆìš©)
            summary_end_index >= len(cleaned_response) - len(summary_end_tag) - 20 # í—ˆìš© ë²”ìœ„ ì•½ê°„ ëŠ˜ë¦¼
        )

        if is_valid_summary:
            xml_output = cleaned_response[:summary_start_index].strip()
            summary_output = cleaned_response[summary_start_index + len(summary_start_tag):summary_end_index].strip()
            logger.info("Successfully parsed XML and Summary parts.")
            # ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ë˜ì—ˆìœ¼ë¯€ë¡œ, ì´ì „ ì˜¤ë¥˜ ë©”ì‹œì§€(ë¹ˆ ì‘ë‹µ ë“±)ëŠ” ì§€ìš¸ ìˆ˜ ìˆìŒ (ì„ íƒì )
            if "ë¹ˆ ì‘ë‹µ ë°˜í™˜" in (error_message or ""):
                new_state["error_message"] = None # ë¹ˆ ì‘ë‹µ ì˜¤ë¥˜ëŠ” í•´ì†Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
        else:
            xml_output = cleaned_response
            summary_output = "Summary tag not found or improperly placed in the response."
            logger.warning(summary_output)
            # íŒŒì‹± ì‹¤íŒ¨ë¥¼ ì˜¤ë¥˜ë¡œ ì„¤ì • (ì´ì „ ì˜¤ë¥˜ê°€ ì—†ì—ˆì„ ê²½ìš°)
            if not error_message: new_state["error_message"] = summary_output

        logger.info("--- Response Processed ---")
        new_state["xml_output"] = xml_output
        new_state["summary_output"] = summary_output

        # íŒŒì‹±ëœ XML/Summary ê²°ê³¼ë¥¼ DB ë¡œê·¸ì— ì—…ë°ì´íŠ¸
        if db_service and log_id is not None:
            try:
                logger.info(f"Updating DB log ID {log_id} with parsed XML and Summary.")
                db_service.update_gemini_log(
                    log_id=log_id, response_xml=xml_output, response_summary=summary_output,
                    # ì˜¤ë¥˜ ë©”ì‹œì§€ë„ ì—…ë°ì´íŠ¸ (íŒŒì‹± ì‹¤íŒ¨ ë˜ëŠ” ì´ì „ ì˜¤ë¥˜ ìœ ì§€)
                    error_message=new_state["error_message"]
                )
            except Exception as db_err:
                logger.error(f"Failed to update Gemini log ID {log_id} with parsed results: {db_err}", exc_info=True)

        return new_state

    except Exception as e:
        error_msg = f"Error processing response: {str(e)}"
        logger.exception(error_msg)
        new_state["xml_output"] = gemini_response # ì›ë³¸ ì‘ë‹µ ìœ ì§€
        new_state["summary_output"] = f"ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜: {e}"
        new_state["error_message"] = (error_message + "\n" + error_msg) if error_message else error_msg
        # DB ë¡œê·¸ ì—…ë°ì´íŠ¸ (ì²˜ë¦¬ ì˜¤ë¥˜)
        if db_service and log_id is not None:
            db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
        return new_state


def build_gemini_graph(config_service: ConfigService) -> StateGraph:
    """
    Gemini API í˜¸ì¶œ ë° ì²˜ë¦¬ LangGraphë¥¼ ë¹Œë“œí•©ë‹ˆë‹¤.
    ConfigServiceë¥¼ ì£¼ì…ë°›ì•„ ë…¸ë“œì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    workflow = StateGraph(GeminiGraphState)

    bound_call_gemini = partial(call_gemini, config_service=config_service)
    bound_process_response = partial(process_response, config_service=config_service)

    workflow.add_node("call_gemini", bound_call_gemini)
    workflow.add_node("process_response", bound_process_response)

    workflow.add_edge(START, "call_gemini")
    workflow.add_edge("call_gemini", "process_response")
    workflow.add_edge("process_response", END)

    app = workflow.compile()
    logger.info("Gemini LangGraph compiled successfully.")
    return app



======== src\core\services\prompt_service.py ========

import os
from typing import List, Tuple, Dict, Any # Dict, Any ì¶”ê°€

class PromptService:
    def generate_code_enhancer_prompt(
        self,
        system_text: str,
        user_text: str,
        file_contents: List[Tuple[str, str]], # List of (path, content)
        root_dir: str,
        dir_structure_content: str = "",
        attached_items: List[Dict[str, Any]] = [] # ì²¨ë¶€ íŒŒì¼ ëª©ë¡ ì¶”ê°€
    ) -> str:
        """
        Generates the final text prompt for the Code Enhancer mode.
        Includes markers for attached files/images.
        """
        final_prompt_parts = [
            "===SYSTEM===",
            system_text,
            "",
            "===USER===",
            user_text,
            "",
        ]

        # ì²¨ë¶€ íŒŒì¼/ì´ë¯¸ì§€ ì •ë³´ ì¶”ê°€ (ë§ˆì»¤ ì‚¬ìš©)
        if attached_items:
            final_prompt_parts.append("===ATTACHMENTS===")
            for i, item in enumerate(attached_items):
                item_type = item.get('type', 'unknown')
                item_name = item.get('name', f'attachment_{i+1}')
                if item_type == 'image':
                    final_prompt_parts.append(f"- Image: {item_name} (Data provided separately)")
                elif item_type == 'file':
                    # íŒŒì¼ ë‚´ìš©ì„ í”„ë¡¬í”„íŠ¸ì— í¬í•¨í• ì§€ ì—¬ë¶€ ê²°ì • (ì—¬ê¸°ì„œëŠ” ë§ˆì»¤ë§Œ ì‚¬ìš©)
                    # file_data = item.get('data')
                    # content_preview = "(Content provided separately)"
                    # if file_data:
                    #     try:
                    #         # ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ë¯¸ë¦¬ë³´ê¸° (ì˜µì…˜)
                    #         preview = file_data[:100].decode('utf-8', errors='ignore') + ('...' if len(file_data) > 100 else '')
                    #         content_preview = f"(Content starts with: {preview})"
                    #     except: pass
                    final_prompt_parts.append(f"- File: {item_name} (Content provided separately)")
                else:
                    final_prompt_parts.append(f"- Unknown Attachment: {item_name}")
            final_prompt_parts.append("") # êµ¬ë¶„ì„ 

        # ì„ íƒëœ íŒŒì¼ ë‚´ìš© ì¶”ê°€
        final_prompt_parts.append("===FILES CONTENTS===")
        if not root_dir:
             print("Warning: root_dir is not set for relative path calculation.")
             for path, content in file_contents:
                 final_prompt_parts.append(f"\n======== {path} ========\n{content}\n")
        else:
            for path, content in file_contents:
                try:
                    relative_path = os.path.relpath(path, root_dir)
                except ValueError:
                    relative_path = path
                final_prompt_parts.append(f"\n======== {relative_path} ========\n{content}\n")

        # ë””ë ‰í† ë¦¬ êµ¬ì¡° ì¶”ê°€
        if dir_structure_content and dir_structure_content.strip():
            final_prompt_parts.append("")
            final_prompt_parts.append(dir_structure_content)

        return "\n".join(final_prompt_parts)

    def generate_meta_prompt(
        self,
        meta_template: str,
        meta_user_input: str
    ) -> str:
        """Generates the prompt for the Meta Prompt Builder mode."""
        final_output = meta_template.replace("{{user-input}}", meta_user_input)
        return final_output

    def generate_final_meta_prompt(
        self,
        meta_prompt_content: str,
        user_prompt_content: str,
        variables: dict
    ) -> str:
        """Generates the final prompt by replacing variables in the meta prompt."""
        final_prompt = meta_prompt_content.replace("[[user-prompt]]", user_prompt_content)

        for k, v in variables.items():
            if k != "user-prompt":
                final_prompt = final_prompt.replace(f"[[{k}]]", v)

        return final_prompt



======== src\core\services\state_service.py ========
import os
import json
import shutil
from datetime import datetime
from typing import Optional, List
from pydantic import ValidationError

from core.pydantic_models.app_state import AppState
from utils.helpers import get_resource_path # ë¦¬ì†ŒìŠ¤ ê²½ë¡œ í•¨ìˆ˜ ì‚¬ìš©

# ìƒíƒœ íŒŒì¼ ì €ì¥ ë””ë ‰í† ë¦¬ (resources/status)
STATUS_DIR = get_resource_path("status")

class StateService:
    def __init__(self, status_dir: str = STATUS_DIR):
        self.status_dir = status_dir
        os.makedirs(self.status_dir, exist_ok=True)

    def _get_state_file_path(self, filename: str) -> str:
        """Constructs the full path for a state file."""
        # íŒŒì¼ ì´ë¦„ì— .json í™•ì¥ìê°€ ì—†ìœ¼ë©´ ì¶”ê°€
        if not filename.lower().endswith(".json"):
            filename += ".json"
        return os.path.join(self.status_dir, filename)

    def save_state(self, state: AppState, filename: str) -> bool:
        """Saves the application state (Pydantic model) to a JSON file."""
        file_path = self._get_state_file_path(filename)
        try:
            # Pydantic ëª¨ë¸ì„ JSON ë¬¸ìì—´ë¡œ ì§ë ¬í™” (indent ì ìš©)
            state_json = state.model_dump_json(indent=4)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State saved successfully to {file_path}")
            return True
        except ValidationError as e:
            print(f"State validation error before saving: {e}")
            return False
        except Exception as e:
            print(f"Error saving state to {file_path}: {str(e)}")
            return False

    def load_state(self, filename: str) -> Optional[AppState]:
        """Loads application state from a JSON file into a Pydantic model."""
        file_path = self._get_state_file_path(filename)
        if not os.path.exists(file_path):
            print(f"State file not found: {file_path}. Returning default state.")
            return AppState() # íŒŒì¼ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒíƒœ ë°˜í™˜

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            # JSON ë°ì´í„°ë¥¼ Pydantic ëª¨ë¸ë¡œ íŒŒì‹± ë° ìœ íš¨ì„± ê²€ì‚¬
            state = AppState.model_validate(state_data)
            print(f"State loaded successfully from {file_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from {file_path}: {e}. Returning default state.")
            return AppState()
        except ValidationError as e:
            print(f"State validation error loading from {file_path}: {e}. Returning default state.")
            # ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’ ë°˜í™˜ ë˜ëŠ” ë” ì—„ê²©í•œ ì²˜ë¦¬ ê°€ëŠ¥
            return AppState()
        except Exception as e:
            print(f"Error loading state from {file_path}: {str(e)}. Returning default state.")
            return AppState()

    def import_state_from_file(self, import_path: str) -> Optional[AppState]:
        """Imports state from an external JSON file."""
        if not os.path.exists(import_path):
            print(f"Import file not found: {import_path}")
            return None # ê°€ì ¸ì˜¬ íŒŒì¼ ì—†ìœ¼ë©´ None ë°˜í™˜

        try:
            with open(import_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            state = AppState.model_validate(state_data)
            print(f"State imported successfully from {import_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from import file {import_path}: {e}")
            return None
        except ValidationError as e:
            print(f"Imported state validation error: {e}")
            return None
        except Exception as e:
            print(f"Error importing state from {import_path}: {str(e)}")
            return None

    def export_state_to_file(self, state: AppState, export_path: str) -> bool:
        """Exports the current state to an external JSON file."""
        try:
            dir_path = os.path.dirname(export_path)
            if dir_path:
                os.makedirs(dir_path, exist_ok=True)
            state_json = state.model_dump_json(indent=4)
            with open(export_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State exported successfully to {export_path}")
            return True
        except ValidationError as e:
             print(f"State validation error before exporting: {e}")
             return False
        except Exception as e:
            print(f"Error exporting state to {export_path}: {str(e)}")
            return False

    def list_states(self) -> List[str]:
        """Lists available state files (JSON) in the status directory."""
        if not os.path.exists(self.status_dir):
            return []
        try:
            files = os.listdir(self.status_dir)
            # .json íŒŒì¼ë§Œ í•„í„°ë§
            return [f for f in files if f.lower().endswith(".json")]
        except Exception as e:
            print(f"Error listing states in {self.status_dir}: {e}")
            return []

    def delete_state(self, filename: str) -> bool:
        """Deletes a specific state file."""
        file_path = self._get_state_file_path(filename)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                print(f"Deleted state file: {file_path}")
                return True
            except Exception as e:
                print(f"Error deleting state file {file_path}: {e}")
                return False
        else:
            print(f"State file not found for deletion: {file_path}")
            return False

    def backup_all_states(self, backup_path: str) -> bool:
        """Backs up all state files into a zip archive."""
        if not os.path.isdir(self.status_dir):
            print("Status directory does not exist. Nothing to backup.")
            return False

        # Ensure backup path ends with .zip
        if not backup_path.lower().endswith(".zip"):
            backup_path += ".zip"

        base_dir = os.path.dirname(backup_path)
        if base_dir:
            os.makedirs(base_dir, exist_ok=True)

        # shutil.make_archive needs the archive name without extension
        archive_name = backup_path[:-4]

        try:
            shutil.make_archive(archive_name, 'zip', self.status_dir)
            print(f"All states successfully backed up to {backup_path}")
            return True
        except Exception as e:
            print(f"Error backing up states to {backup_path}: {str(e)}")
            return False

    def restore_states_from_backup(self, backup_path: str) -> bool:
        """Restores states from a zip archive, overwriting existing ones."""
        if not os.path.exists(backup_path):
            print(f"Backup file not found: {backup_path}")
            return False

        try:
            # Remove existing status directory before restoring if it exists
            if os.path.exists(self.status_dir):
                shutil.rmtree(self.status_dir)
            os.makedirs(self.status_dir, exist_ok=True) # Ensure directory exists

            # Unpack the archive into the status directory
            shutil.unpack_archive(backup_path, self.status_dir, 'zip')
            print(f"States successfully restored from {backup_path} to {self.status_dir}")
            return True
        except Exception as e:
            print(f"Error restoring states from {backup_path}: {str(e)}")
            return False



======== src\core\services\template_service.py ========
import os
from typing import List

# ë³€ê²½ëœ ê²½ë¡œì—ì„œ import
from utils.helpers import get_resource_path

class TemplateService:
    def __init__(self, base_resource_path: str = "resources"):
        pass

    def _get_full_path(self, relative_path: str) -> str:
        """Constructs the full path using get_resource_path."""
        # ì˜ˆ: relative_path = "prompts/system/my_template.md"
        return get_resource_path(relative_path)

    def list_templates(self, directory: str) -> List[str]:
        """Lists Markdown templates in a given directory relative to resources."""
        # directory ì˜ˆ: "prompts/system"
        full_dir_path = self._get_full_path(directory)
        if not os.path.exists(full_dir_path) or not os.path.isdir(full_dir_path):
            print(f"Template directory not found: {full_dir_path}")
            return []
        try:
            files = os.listdir(full_dir_path)
            # .md íŒŒì¼ë§Œ í•„í„°ë§
            return [f for f in files if f.lower().endswith(".md")]
        except Exception as e:
            print(f"Error listing templates in {full_dir_path}: {e}")
            return []

    def load_template(self, file_path: str) -> str:
        """Loads content from a template file relative to resources."""
        # file_path ì˜ˆ: "prompts/user/example.md"
        full_file_path = self._get_full_path(file_path)
        if not os.path.exists(full_file_path):
            print(f"Template file not found: {full_file_path}")
            return "" # íŒŒì¼ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜
        try:
            with open(full_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            print(f"Template loaded successfully from {full_file_path}")
            return content
        except Exception as e:
            print(f"Error loading template {full_file_path}: {str(e)}")
            return "" # ì˜¤ë¥˜ ì‹œ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜

    def save_template(self, file_path: str, content: str) -> bool:
        """Saves content to a template file relative to resources."""
        # file_path ì˜ˆ: "prompts/system/new_template.md"
        full_file_path = self._get_full_path(file_path)
        try:
            # ë””ë ‰í† ë¦¬ ìƒì„± (í•„ìš”í•œ ê²½ìš°)
            os.makedirs(os.path.dirname(full_file_path), exist_ok=True)
            with open(full_file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"Template saved successfully to {full_file_path}")
            return True
        except Exception as e:
            print(f"Error saving template to {full_file_path}: {str(e)}")
            return False

    def delete_template(self, file_path: str) -> bool:
        """Deletes a template file relative to resources."""
        # file_path ì˜ˆ: "prompts/system/old_template.md"
        full_file_path = self._get_full_path(file_path)
        if os.path.exists(full_file_path):
            try:
                os.remove(full_file_path)
                print(f"Deleted template file: {full_file_path}")
                return True
            except Exception as e:
                print(f"Error deleting template file {full_file_path}: {e}")
                return False
        else:
            print(f"Template file not found for deletion: {full_file_path}")
            return False


======== src\core\services\token_service.py ========

import os
import threading
from typing import Optional, Dict, Any, List, Union
import tiktoken
import mimetypes
import base64
import logging

# --- Optional Imports for API Calls ---
try:
    import google.generativeai as genai
    from google.generativeai.types import ContentDict, PartDict
    from google.api_core import exceptions as google_api_exceptions
    _GOOGLE_GENAI_AVAILABLE = True
except ImportError:
    _GOOGLE_GENAI_AVAILABLE = False
    print("Warning: google-generativeai not installed. Gemini token calculation via API disabled.")

try:
    import anthropic
    _ANTHROPIC_AVAILABLE = True
except ImportError:
    _ANTHROPIC_AVAILABLE = False
    print("Warning: anthropic not installed. Claude token calculation via API disabled.")

# --- Service Dependencies ---
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .config_service import ConfigService
    from core.pydantic_models.config_settings import ConfigSettings

# --- Tiktoken Encoding Cache ---
_enc_cache: Dict[str, tiktoken.Encoding] = {}
_enc_lock = threading.Lock()

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)


def _get_encoding(encoding_name: str = "o200k_base") -> Optional[tiktoken.Encoding]:
    """Gets or loads a tiktoken encoding."""
    with _enc_lock:
        if encoding_name not in _enc_cache:
            try:
                print(f"Loading tiktoken encoding: {encoding_name}...")
                _enc_cache[encoding_name] = tiktoken.get_encoding(encoding_name)
                print(f"Tiktoken encoding '{encoding_name}' loaded.")
            except Exception as e:
                print(f"Error loading tiktoken encoding '{encoding_name}': {e}")
                _enc_cache[encoding_name] = None
        return _enc_cache[encoding_name]

# --- Token Calculation Service ---
class TokenCalculationService:
    """Handles token calculation for different LLM providers."""

    def __init__(self, config_service: 'ConfigService'):
        """Initializes the service."""
        self.config_service = config_service
        # Settings are now fetched when needed via config_service.get_settings()
        self.anthropic_client: Optional[anthropic.Anthropic] = None
        self.gemini_configured = False
        self._init_clients() # Combined initialization

    def _get_settings(self) -> 'ConfigSettings':
        """Helper to get current settings."""
        return self.config_service.get_settings()

    def _init_clients(self):
        """Initializes API clients based on keys found in config settings."""
        settings = self._get_settings()

        # Initialize Gemini
        if _GOOGLE_GENAI_AVAILABLE:
            api_key = settings.gemini_api_key
            if api_key:
                try:
                    genai.configure(api_key=api_key)
                    print("Google Generative AI SDK configured using API key from DB.")
                    self.gemini_configured = True
                except Exception as e:
                    print(f"Error configuring Google Generative AI SDK: {e}")
                    self.gemini_configured = False
            else:
                print("Warning: Gemini API key not found in DB config. Gemini token calculation might fail.")
                self.gemini_configured = False
        else:
             self.gemini_configured = False

        # Initialize Anthropic
        if _ANTHROPIC_AVAILABLE:
            api_key = settings.anthropic_api_key
            if api_key:
                try:
                    self.anthropic_client = anthropic.Anthropic(api_key=api_key)
                    print("Anthropic client initialized using API key from DB.")
                except Exception as e:
                    self.anthropic_client = None
                    print(f"Error initializing Anthropic client: {e}")
            else:
                self.anthropic_client = None
                print("Warning: Anthropic API key not found in DB config. Claude token calculation via API disabled.")
        else:
            self.anthropic_client = None


    def calculate_tokens(
        self,
        model_type: str,
        model_name: str,
        text: str,
        attachments: Optional[List[Dict[str, Any]]] = None
    ) -> Optional[int]:
        """
        Calculates the number of tokens for the given text and attachments
        based on the model type and name.

        Args:
            model_type: "GPT", "Claude", or "Gemini".
            model_name: The specific model identifier.
            text: The input text to tokenize.
            attachments: List of attached items (dicts with 'type', 'name', 'data'/'path').

        Returns:
            The calculated token count, or None if calculation fails.
        """
        print(f"Calculating tokens for Model Type: {model_type}, Model Name: {model_name}")
        attachments = attachments or []

        # Re-initialize clients in case API keys changed in DB (though config is loaded once now)
        # self._init_clients() # Might be redundant if config is loaded once

        if model_type == "GPT":
            if attachments:
                print("Warning: GPT token calculation currently only supports text. Attachments ignored.")
            return self._calculate_gpt_tokens(text)
        elif model_type == "Claude":
            if attachments:
                 print("Warning: Claude token calculation currently only supports text. Attachments ignored.")
            return self._calculate_claude_tokens(model_name, text)
        elif model_type == "Gemini":
            return self._calculate_gemini_tokens(model_name, text, attachments)
        else:
            print(f"Error: Unknown model type '{model_type}'")
            return None

    def _calculate_gpt_tokens(self, text: str) -> Optional[int]:
        """Calculates tokens using tiktoken (assuming o200k_base for newer models)."""
        enc = _get_encoding("o200k_base")
        if enc is None:
            print("Token calculation failed: Tiktoken encoding not available.")
            return None
        try:
            if not text: return 0
            return len(enc.encode(text))
        except Exception as e:
            print(f"Error calculating GPT tokens with tiktoken: {str(e)}")
            return None

    def _calculate_claude_tokens(self, model_name: str, text: str) -> Optional[int]:
        """Calculates tokens using the Anthropic API (currently text only)."""
        if not _ANTHROPIC_AVAILABLE or self.anthropic_client is None:
            print("Claude token calculation skipped: Anthropic SDK not available or API key missing/invalid.")
            return None
        if not model_name:
            print("Claude token calculation skipped: Model name is required.")
            return None
        if not text: return 0

        try:
            messages = [{"role": "user", "content": text}]
            count_response = self.anthropic_client.messages.count_tokens(
                model=model_name,
                messages=messages
            )
            token_count = count_response.input_tokens
            print(f"Claude API token count (text only): {token_count}")
            return token_count
        except anthropic.APIConnectionError as e:
             print(f"Claude API connection error during token count: {e}")
             return None
        except anthropic.AuthenticationError as e:
             print(f"Claude API authentication error (check API key): {e}")
             return None
        except anthropic.RateLimitError as e:
             print(f"Claude API rate limit exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Claude tokens via API: {str(e)}")
            return None

    def _calculate_gemini_tokens(
        self,
        model_name: str,
        text: str,
        attachments: List[Dict[str, Any]]
    ) -> Optional[int]:
        """Calculates tokens using the google-generativeai SDK (multimodal)."""
        if not _GOOGLE_GENAI_AVAILABLE:
            print("Gemini token calculation skipped: google-generativeai SDK not available.")
            return None
        if not self.gemini_configured:
             print("Gemini token calculation skipped: Gemini API key not configured or invalid.")
             return None
        if not model_name:
            print("Gemini token calculation skipped: Model name is required.")
            return None

        contents_list: List[Union[str, Dict[str, Any]]] = []
        effective_model_name = ""
        try:
            if text:
                contents_list.append(text)

            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type')
                    item_name = attachment.get('name', 'unknown')
                    item_data = attachment.get('data')
                    item_path = attachment.get('path')

                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e:
                            logger.error(f"Token Calc: Failed to read attachment {item_path}: {e}")
                            continue
                    if not item_data: continue

                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name)
                        if not mime_type: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list:
                print("Token calculation skipped: No content (text or attachments) provided.")
                return 0

            effective_model_name = model_name.replace("models/", "")
            print(f"Instantiating genai.GenerativeModel for token count: {effective_model_name}")
            model = genai.GenerativeModel(effective_model_name)

            print(f"Calling model.count_tokens for model: {effective_model_name} with {len(contents_list)} content parts")
            response = model.count_tokens(contents=contents_list)

            token_count = response.total_tokens
            print(f"Gemini API token count (multimodal): {token_count}")
            return token_count

        except AttributeError as e:
             log_message = (
                 f"AttributeError during Gemini token calculation: {e}. "
                 f"Check SDK version and content structure."
             )
             logger.error(log_message, exc_info=True)
             print(f"Gemini token calculation failed due to AttributeError: {e}")
             return None
        except google_api_exceptions.PermissionDenied as e:
             print(f"Gemini API permission error during token count (check API key): {e}")
             # Invalidate configuration if key is bad?
             # self.gemini_configured = False
             return None
        except google_api_exceptions.InvalidArgument as e:
             print(f"Gemini API invalid argument error during token count: {e}")
             print(f"Hint: Check if model '{effective_model_name}' supports multimodal count_tokens or the provided content types/structure.")
             return None
        except google_api_exceptions.ResourceExhausted as e:
             print(f"Gemini API rate limit likely exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Gemini tokens via API: {str(e)}")
            logger.error(f"Unexpected error calculating Gemini tokens: {e}", exc_info=True)
            return None

# Preload default encoding on module import
_get_encoding()



======== src\core\services\xml_service.py ========
import os
import xml.etree.ElementTree as ET
from typing import Dict, List
import logging # ë¡œê¹… ì¶”ê°€

logger = logging.getLogger(__name__) # ë¡œê±° ì„¤ì •

class XmlService:
    def apply_changes_from_xml(self, xml_string: str, project_directory: str) -> Dict[str, List[str]]:
        """
        Parses XML string and applies file changes (CREATE, UPDATE, DELETE)
        within the specified project directory.
        Handles removing surrounding Markdown code block markers if present.
        Removes leading whitespace/newlines from file content before writing.
        Handles trailing Markdown code block markers (like ```)

        Returns a dictionary summarizing the results:
        {
            "created": [list of created file paths],
            "updated": [list of updated file paths],
            "deleted": [list of deleted file paths],
            "errors": [list of error messages]
        }
        """
        result = {
            "created": [],
            "updated": [],
            "deleted": [],
            "errors": []
        }

        if not project_directory or not os.path.isdir(project_directory):
            result["errors"].append(f"Invalid project directory: {project_directory}")
            return result

        if not xml_string or not xml_string.strip():
            result["errors"].append("XML input string is empty.")
            return result

        # --- Add logic to strip Markdown code block markers ---
        cleaned_xml_string = xml_string.strip()
        # ë‹¤ì–‘í•œ ë§ˆì»¤ í˜•íƒœ ê³ ë ¤ (ì˜ˆ: ```xml, ```, ````xml, ```` ë“±)
        markdown_markers = ["```xml", "```", "````xml", "````", '"""', "'''"] # ì¢…ë£Œ ë§ˆì»¤ ì¶”ê°€

        # ì‹œì‘ ë§ˆì»¤ ì œê±°
        for marker in markdown_markers:
            if cleaned_xml_string.startswith(marker):
                # ë§ˆì»¤ ê¸¸ì´ë§Œí¼ ì œê±°í•˜ê³ , ì´í›„ ê³µë°±/ì¤„ë°”ê¿ˆ ì œê±°
                cleaned_xml_string = cleaned_xml_string[len(marker):].lstrip()
                logger.debug(f"Removed starting marker: {marker}")
                break # í•˜ë‚˜ì˜ ì‹œì‘ ë§ˆì»¤ë§Œ ì²˜ë¦¬

        # ë ë§ˆì»¤ ì œê±° (ìˆ˜ì •: ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ì¢…ë£Œ ë§ˆì»¤ ì œê±°)
        temp_string = cleaned_xml_string.rstrip() # ë ë§ˆì»¤ í™•ì¸ ì „ í›„í–‰ ê³µë°±/ì¤„ë°”ê¿ˆ ì œê±°
        marker_removed = False
        for marker in markdown_markers:
            if temp_string.endswith(marker):
                # ë§ˆì»¤ ê¸¸ì´ë§Œí¼ ì œê±°í•˜ê³ , ì´ì „ ê³µë°±/ì¤„ë°”ê¿ˆ ì œê±°
                cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                logger.debug(f"Removed ending marker: {marker}")
                marker_removed = True
                break # í•˜ë‚˜ì˜ ë ë§ˆì»¤ë§Œ ì²˜ë¦¬
        # ë§Œì•½ ë§ˆì»¤ ì œê±° í›„ì—ë„ ë§ˆì»¤ê°€ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆëŠ” ê²½ìš°(ì˜ˆ: """\n```) ì¶”ê°€ ì²˜ë¦¬
        if marker_removed:
            temp_string = cleaned_xml_string.rstrip()
            for marker in markdown_markers:
                 if temp_string.endswith(marker):
                      cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                      logger.debug(f"Removed secondary ending marker: {marker}")
                      break

        if not cleaned_xml_string:
             result["errors"].append("XML input string became empty after removing potential Markdown markers.")
             logger.warning("XML input is empty after cleaning.")
             return result
        # --- End of Markdown marker stripping logic ---

        try:
            # XML íŒŒì‹± (ì •ë¦¬ëœ ë¬¸ìì—´ ì‚¬ìš©)
            logger.info("Attempting to parse cleaned XML string...")
            root = ET.fromstring(cleaned_xml_string)
            logger.info(f"XML parsed successfully. Root element: <{root.tag}>")
        except ET.ParseError as e:
            error_msg = f"Invalid XML format after cleaning: {str(e)}"
            result["errors"].append(error_msg)
            # íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë¬¸ì œ ë¬¸ìì—´ ì¼ë¶€ ë¡œê¹…
            context_length = 100 # ì˜¤ë¥˜ ì£¼ë³€ ë¬¸ìì—´ ê¸¸ì´
            error_line = getattr(e, 'lineno', '?')
            error_pos = getattr(e, 'offset', '?') # position ì†ì„±ì´ ì—†ì„ ìˆ˜ ìˆìŒ (offset ì‚¬ìš©)
            start = max(0, e.position[1] - context_length//2) if hasattr(e, 'position') else 0
            end = start + context_length
            problematic_xml_snippet = cleaned_xml_string[start:end]
            logger.error(f"XML ParseError: {e}, Line: {error_line}, Pos: {error_pos}. Problematic snippet near error: ...{problematic_xml_snippet}...")
            return result
        except Exception as e:
             # Catch other potential errors during fromstring
             error_msg = f"Error parsing XML string: {str(e)}"
             result["errors"].append(error_msg)
             logger.exception(f"Unexpected error during XML parsing: {e}") # ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¡œê¹…
             return result


        changed_files_node = root.find('changed_files')
        if changed_files_node is None:
            # If <changed_files> is missing but parsing was successful, it might be an empty XML response.
            # Treat as no changes rather than an error, unless it's entirely empty or unexpected structure.
            # Let's check if the root tag itself is also unexpected.
            if root.tag not in ['code_changes', 'root', 'response']: # Add common root tags
                 result["errors"].append(f"No <changed_files> node found and unexpected root tag '{root.tag}' in XML.")
                 logger.warning(f"XML parsing successful but no <changed_files> node found and unexpected root tag: {root.tag}")
            else:
                 # Successful parse, but no changed_files node. Assume no changes.
                 logger.info("XML parsed successfully but no <changed_files> node found. Assuming no changes.") # ë¡œê¹… ì‚¬ìš©
            return result # Return with errors if any added, or empty result

        for file_node in changed_files_node.findall('file'):
            file_op_node = file_node.find('file_operation')
            file_path_node = file_node.find('file_path')
            file_code_node = file_node.find('file_code') # CDATA ë‚´ìš© í¬í•¨

            if file_op_node is None or file_path_node is None:
                result["errors"].append("Skipping file entry: missing file_operation or file_path.")
                logger.warning("Skipping file entry in XML: missing file_operation or file_path.")
                continue

            operation = file_op_node.text.strip().upper() if file_op_node.text else "UNKNOWN"
            relative_path = file_path_node.text.strip() if file_path_node.text else None

            if not relative_path:
                result["errors"].append(f"Skipping file entry: file_path is empty for operation {operation}.")
                logger.warning(f"Skipping file entry in XML: file_path is empty for operation {operation}.")
                continue

            # ë³´ì•ˆ: ê²½ë¡œ ì¡°ì‘ ë°©ì§€ (ìƒëŒ€ ê²½ë¡œê°€ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ í™•ì¸)
            # ì •ê·œí™”ëœ ê²½ë¡œ ì‚¬ìš©
            try:
                 target_path = os.path.abspath(os.path.join(project_directory, relative_path.lstrip('/\\')))
                 if not target_path.startswith(os.path.abspath(project_directory)):
                    result["errors"].append(f"Skipping potentially unsafe path: {relative_path}")
                    logger.error(f"Security risk: Attempted path traversal detected! Path: '{relative_path}', Target: '{target_path}', Project Root: '{os.path.abspath(project_directory)}'")
                    continue
            except Exception as path_e:
                 result["errors"].append(f"Error processing path '{relative_path}': {path_e}")
                 logger.error(f"Error processing path '{relative_path}': {path_e}", exc_info=True)
                 continue

            # Ensure path separator consistency if needed, but os.path.join handles this locally.
            # For comparison against input, maybe normalize relative_path too? Not critical for security check here.

            file_code = file_code_node.text if file_code_node is not None and file_code_node.text is not None else None

            try:
                if operation in ["CREATE", "UPDATE"]:
                    # Allow empty file_code for creating/updating empty files
                    # if file_code is None: # Changed: Allow None/empty string for file_code
                    #     result["errors"].append(f"Skipping {operation} for '{relative_path}': file_code is missing.")
                    #     continue

                    # Ensure directory exists
                    os.makedirs(os.path.dirname(target_path), exist_ok=True)

                    # Write file, handle None/empty file_code as empty content
                    # *** ìˆ˜ì •: íŒŒì¼ ë‚´ìš© ì•ìª½ ê³µë°±/ê°œí–‰ ì œê±° ***
                    with open(target_path, 'w', encoding='utf-8') as f:
                        # file_codeê°€ Noneì´ ì•„ë‹ˆê³ , ë¬¸ìì—´ì¼ ê²½ìš° ì•ìª½ ê³µë°±/ê°œí–‰ ì œê±°
                        content_to_write = file_code.lstrip() if file_code is not None and isinstance(file_code, str) else ""
                        f.write(content_to_write)
                        logger.debug(f"Writing content (leading whitespace stripped) to: {target_path}") # ë¡œê¹… ì¶”ê°€

                    if operation == "CREATE":
                        result["created"].append(target_path)
                        logger.info(f"File CREATED: {target_path}") # ë¡œê¹… ì‚¬ìš©
                    else: # UPDATE
                        result["updated"].append(target_path)
                        logger.info(f"File UPDATED: {target_path}") # ë¡œê¹… ì‚¬ìš©

                elif operation == "DELETE":
                    if os.path.exists(target_path):
                        if os.path.isfile(target_path):
                            os.remove(target_path)
                            result["deleted"].append(target_path)
                            logger.info(f"File DELETED: {target_path}") # ë¡œê¹… ì‚¬ìš©
                        elif os.path.isdir(target_path):
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is a directory, not a file.")
                             logger.warning(f"Skipping DELETE for directory: {target_path}")
                        else:
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is not a regular file.")
                             logger.warning(f"Skipping DELETE for non-file item: {target_path}")
                    else:
                        # ì‚­ì œí•  íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°, ì˜¤ë¥˜ë³´ë‹¤ëŠ” ê²½ê³  ë˜ëŠ” ë¬´ì‹œê°€ ë‚˜ì„ ìˆ˜ ìˆìŒ
                        logger.warning(f"File not found for deletion (ignored): {target_path}") # ë¡œê¹… ì‚¬ìš©

                elif operation == "NONE":
                    # ìˆ˜ì • ì—†ìŒ ì²˜ë¦¬ (ë¡œê·¸ ë˜ëŠ” ì•„ë¬´ ì‘ì—… ì•ˆ í•¨)
                    logger.debug(f"Operation NONE for: {target_path}") # Log level DEBUG
                    pass

                else:
                    result["errors"].append(f"Unknown file operation '{operation}' for file: {relative_path}")
                    logger.warning(f"Unknown file operation '{operation}' found in XML for path: {relative_path}")

            except OSError as e:
                 result["errors"].append(f"OS error during {operation} for '{relative_path}': {e}")
                 logger.error(f"OS error during {operation} for '{relative_path}': {e}", exc_info=True) # ë¡œê¹… ì¶”ê°€
            except Exception as e:
                result["errors"].append(f"Unexpected error during {operation} for '{relative_path}': {str(e)}")
                logger.exception(f"Unexpected error during {operation} for '{relative_path}'") # ë¡œê¹… ì¶”ê°€

        return result



======== src\core\__init__.py ========
# This file makes Python treat the directory core as a package.



======== src\core\langgraph_state.py ========

from typing import TypedDict, Optional, List, Dict, Any # List, Dict, Any ì¶”ê°€

class GeminiGraphState(TypedDict):
    """
    LangGraph ìƒíƒœ ì •ì˜: Gemini API í˜¸ì¶œ ë° ê²°ê³¼ ì²˜ë¦¬ë¥¼ ìœ„í•œ ìƒíƒœ ê´€ë¦¬
    """
    input_prompt: str             # Gemini APIì— ì „ë‹¬ë  ìµœì¢… í…ìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸
    input_attachments: List[Dict[str, Any]] # ì²¨ë¶€ëœ íŒŒì¼/ì´ë¯¸ì§€ ë°ì´í„° ëª©ë¡ (ë©€í‹°ëª¨ë‹¬ìš©)
    selected_model_name: str      # LangGraph ì‹¤í–‰ ì‹œ ì„ íƒëœ ëª¨ë¸ëª… (ì¶”ê°€)
    gemini_response: str          # Gemini APIì˜ ì›ì‹œ ì‘ë‹µ
    xml_output: str               # íŒŒì‹±ëœ XML ë¶€ë¶„
    summary_output: str           # íŒŒì‹±ëœ Summary ë¶€ë¶„
    error_message: Optional[str] = None # ì˜¤ë¥˜ ë°œìƒ ì‹œ ë©”ì‹œì§€ ì €ì¥ (ì„ íƒì )
    log_id: Optional[int] = None  # DB ë¡œê·¸ ID ì €ì¥ (ì¶”ê°€)




======== src\ui\controllers\__init__.py ========
# This file makes Python treat the directory controllers as a package.



======== src\ui\controllers\file_tree_controller.py ========
import os
import shutil
from typing import Optional, List, Set
from PyQt6.QtCore import Qt, QModelIndex, QItemSelection # PyQt5 -> PyQt6
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox # PyQt5 -> PyQt6
import logging # ë¡œê¹… ì¶”ê°€

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.services.filesystem_service import FilesystemService
from core.services.config_service import ConfigService

# MainWindowëŠ” íƒ€ì… íŒíŠ¸ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

logger = logging.getLogger(__name__) # ë¡œê±° ì„¤ì •

class FileTreeController:
    """
    Handles logic related to the file tree view, including interactions,
    filesystem operations, and gitignore handling.
    """
    def __init__(self, main_window: 'MainWindow', fs_service: FilesystemService, config_service: ConfigService):
        self.mw = main_window
        self.fs_service = fs_service
        self.config_service = config_service
        self.gitignore_path: Optional[str] = None # .gitignore íŒŒì¼ ê²½ë¡œ ì €ì¥

    def select_project_folder(self):
        """Opens a dialog to select the project folder and updates the UI."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” í”„ë¡œì íŠ¸ í´ë” ì„ íƒì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.")
            return

        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        folder = QFileDialog.getExistingDirectory(self.mw, "í”„ë¡œì íŠ¸ í´ë” ì„ íƒ", start_dir)

        if folder:
            logger.info(f"Project folder selected: {folder}")
            # í´ë” ì„ íƒ ì‹œ ìƒíƒœ ì´ˆê¸°í™” (UI ë° ë‚´ë¶€ ë³€ìˆ˜)
            self.mw.reset_state() # MainWindow ìƒíƒœ ì´ˆê¸°í™” (íŠ¸ë¦¬ ë¦¬ì…‹ í¬í•¨)
            self.mw.current_project_folder = folder
            folder_name = os.path.basename(folder)
            self.mw.project_folder_label.setText(f"í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: {folder}")

            self.load_gitignore_settings() # gitignore ë¡œë“œ ë° í•„í„° ì„¤ì •

            # ëª¨ë¸ì— ë£¨íŠ¸ ê²½ë¡œ ì„¤ì • ë° íŠ¸ë¦¬ë·° ì—…ë°ì´íŠ¸
            if hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
                # Use setRootPathFiltered directly on the source model
                logger.info("Setting root path on source model...")
                idx = self.mw.dir_model.setRootPathFiltered(folder) # Use setRootPathFiltered
                if not idx.isValid():
                     logger.warning(f"Source model returned invalid index for root path: {folder}")
                # Map the source index to the proxy model index
                root_proxy_index = self.mw.checkable_proxy.mapFromSource(idx)
                if not root_proxy_index.isValid():
                     logger.warning(f"Proxy model returned invalid index for root path: {folder}")
                # Set the root index for the tree view
                self.mw.tree_view.setRootIndex(root_proxy_index) # ìœ íš¨í•œ ë£¨íŠ¸ ì¸ë±ìŠ¤ ì„¤ì •
                logger.info(f"Tree view root index set. Proxy index valid: {root_proxy_index.isValid()}")
                self.mw.status_bar.showMessage(f"Project Folder: {folder}")

                # ë£¨íŠ¸ í´ë” ìë™ ì²´í¬ (ì„ íƒì )
                if root_proxy_index.isValid():
                    # Check the root folder by default
                    logger.info("Setting root folder check state to Checked.")
                    self.mw.checkable_proxy.setData(root_proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole) # Qt.Checked -> Qt.CheckState.Checked, Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole

            self.mw.update_window_title(folder_name)
            # í”„ë¡œì íŠ¸ í´ë” ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
            self.mw.state_changed_signal.emit()

    def load_gitignore_settings(self):
        """Loads .gitignore patterns and updates the filter model."""
        self.gitignore_path = None
        patterns: Set[str] = set()

        settings = self.config_service.get_settings()
        patterns.update(settings.default_ignore_list)

        if self.mw.current_project_folder:
            possible_path = os.path.join(self.mw.current_project_folder, ".gitignore")
            if os.path.isfile(possible_path):
                self.gitignore_path = possible_path
                try:
                    with open(self.gitignore_path, 'r', encoding='utf-8') as f:
                        lines = f.read().splitlines()
                    gitignore_lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                    patterns.update(gitignore_lines)
                    logger.info(f"Loaded {len(gitignore_lines)} patterns from {self.gitignore_path}")
                except Exception as e:
                    QMessageBox.warning(self.mw, "Error", f".gitignore ë¡œë“œ ì¤‘ ì˜¤ë¥˜: {str(e)}")
                    logger.error(f"Error loading .gitignore: {e}", exc_info=True)

        # config.ymlì˜ excluded_dirs ì¶”ê°€
        patterns.update(settings.excluded_dirs)
        logger.info(f"Total ignore patterns (including defaults and excluded_dirs): {len(patterns)}")

        # í•„í„° ëª¨ë¸ì— íŒ¨í„´ ì„¤ì •
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(patterns)
             # í•„í„°ê°€ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ íŠ¸ë¦¬ ë·°ë¥¼ ìƒˆë¡œ ê³ ì³ì•¼ í•  ìˆ˜ ìˆìŒ
             self.refresh_tree() # í•„í„° ì ìš© í›„ íŠ¸ë¦¬ ìƒˆë¡œê³ ì¹¨

    def save_gitignore_settings(self):
        """Saves the content of the gitignore editor to the .gitignore file. (Moved to SettingsDialog)"""
        QMessageBox.information(self.mw, "ì •ë³´", ".gitignore ì €ì¥ì€ í™˜ê²½ ì„¤ì • ë©”ë‰´ì—ì„œ ìˆ˜í–‰í•´ì£¼ì„¸ìš”.")

    def reset_gitignore_and_filter(self):
        """Resets gitignore filter to defaults based on config.yml."""
        logger.info("Resetting gitignore filter to defaults.")
        default_settings = self.config_service.get_settings()
        default_patterns = set(default_settings.default_ignore_list).union(default_settings.excluded_dirs)
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(default_patterns)
             self.refresh_tree() # í•„í„° ë¦¬ì…‹ í›„ íŠ¸ë¦¬ ìƒˆë¡œê³ ì¹¨

    def reset_file_tree(self):
        """Resets the file tree view to an empty state."""
        logger.info("Resetting file tree view.")
        if hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
            # Set root path to empty string on the source model
            idx = self.mw.dir_model.setRootPathFiltered("") # Use setRootPathFiltered
            # Set an invalid index as the root for the view
            self.mw.tree_view.setRootIndex(QModelIndex())
            # Clear the internal check state dictionary
            self.mw.checkable_proxy.checked_files_dict.clear()
            logger.debug("Cleared checked_files_dict during tree reset.")
            self.mw.tree_view.collapseAll()
            logger.info("File tree reset to empty state.")


    def generate_directory_tree_structure(self):
        """Generates the directory tree structure based on checked items."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” ë””ë ‰í† ë¦¬ íŠ¸ë¦¬ ê¸°ëŠ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.")
            return False

        if not self.mw.current_project_folder or not os.path.isdir(self.mw.current_project_folder):
            QMessageBox.warning(self.mw, "ê²½ê³ ", "í”„ë¡œì íŠ¸ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.")
            return False

        all_checked_paths = self.mw.checkable_proxy.get_all_checked_paths() if hasattr(self.mw, 'checkable_proxy') else []
        if not all_checked_paths:
            message = "ì„ íƒëœ íŒŒì¼ì´ë‚˜ í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤."
            if hasattr(self.mw, "dir_structure_tab"):
                self.mw.dir_structure_tab.setText(message)
                self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
            self.mw.status_bar.showMessage("íŒŒì¼ íŠ¸ë¦¬ë¥¼ ìƒì„±í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤!")
            return False

        logger.info(f"Generating directory tree for {len(all_checked_paths)} checked items.")
        try:
            tree_string = self.fs_service.get_directory_tree(all_checked_paths, self.mw.current_project_folder)
        except Exception as e:
             QMessageBox.critical(self.mw, "ì˜¤ë¥˜", f"ë””ë ‰í† ë¦¬ íŠ¸ë¦¬ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
             logger.error(f"Error generating directory tree: {e}", exc_info=True)
             return False

        if hasattr(self.mw, "dir_structure_tab"):
            self.mw.dir_structure_tab.setText(tree_string)
            self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
        self.mw.status_bar.showMessage("File tree generated!")
        self.mw.tree_generated = True # MainWindow ìƒíƒœ ì—…ë°ì´íŠ¸
        logger.info("Directory tree generation successful.")
        return True

    def rename_item(self, file_path):
        """Renames a file or directory."""
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return

        base_dir = os.path.dirname(file_path)
        old_name = os.path.basename(file_path)
        new_name, ok = QInputDialog.getText(self.mw, "ì´ë¦„ ë³€ê²½", f"'{old_name}'ì˜ ìƒˆ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:", text=old_name)

        if ok and new_name and new_name.strip():
            new_name_stripped = new_name.strip()
            if new_name_stripped == old_name: return
            new_path = os.path.join(base_dir, new_name_stripped)
            if os.path.exists(new_path):
                 QMessageBox.warning(self.mw, "Error", f"'{new_name_stripped}' ì´ë¦„ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
                 return

            logger.info(f"Renaming item: '{file_path}' -> '{new_path}'")
            try:
                os.rename(file_path, new_path)
                self.mw.status_bar.showMessage(f"'{old_name}' -> '{new_name_stripped}' ì´ë¦„ ë³€ê²½ ì™„ë£Œ")
                # Update check state dictionary if the renamed item was checked
                if hasattr(self.mw, 'checkable_proxy'):
                    if file_path in self.mw.checkable_proxy.checked_files_dict:
                        is_checked = self.mw.checkable_proxy.checked_files_dict.pop(file_path)
                        self.mw.checkable_proxy.checked_files_dict[new_path] = is_checked
                        logger.debug(f"Updated checked_files_dict for renamed item: {new_path}")
                self.refresh_tree()
                self.mw.state_changed_signal.emit() # íŒŒì¼ êµ¬ì¡° ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"ì´ë¦„ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
                logger.error(f"Error renaming item: {e}", exc_info=True)
        elif ok:
             QMessageBox.warning(self.mw, "Error", "ìƒˆ ì´ë¦„ì€ ë¹„ì›Œë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def delete_item(self, file_path):
        """Deletes a file or directory."""
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return

        item_name = os.path.basename(file_path)
        item_type = "í´ë”" if os.path.isdir(file_path) else "íŒŒì¼"
        reply = QMessageBox.question(self.mw, "ì‚­ì œ í™•ì¸",
                                     f"ì •ë§ë¡œ '{item_name}' {item_type}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No

        if reply == QMessageBox.StandardButton.Yes: # QMessageBox.Yes -> QMessageBox.StandardButton.Yes
            logger.info(f"Deleting item: {file_path}")
            try:
                if os.path.isdir(file_path):
                    shutil.rmtree(file_path)
                else:
                    os.remove(file_path)
                self.mw.status_bar.showMessage(f"'{item_name}' ì‚­ì œ ì™„ë£Œ")
                # Remove the deleted item and any children from the check state dictionary
                if hasattr(self.mw, 'checkable_proxy'):
                    paths_to_remove = [p for p in self.mw.checkable_proxy.checked_files_dict if p == file_path or p.startswith(file_path + os.sep)]
                    removed_count = 0
                    for p in paths_to_remove:
                        if p in self.mw.checkable_proxy.checked_files_dict:
                            del self.mw.checkable_proxy.checked_files_dict[p]
                            removed_count += 1
                    logger.debug(f"Removed {removed_count} items from checked_files_dict after deletion.")
                self.refresh_tree()
                self.mw.state_changed_signal.emit() # íŒŒì¼ êµ¬ì¡° ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
                logger.error(f"Error deleting item: {e}", exc_info=True)

    def refresh_tree(self):
        """Refreshes the file explorer tree view."""
        logger.info("Refreshing file tree view...")
        if self.mw.current_project_folder and hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
            # Invalidate the proxy filter to re-evaluate items
            self.mw.checkable_proxy.invalidateFilter()
            # Set the root path again on the source model
            idx = self.mw.dir_model.setRootPathFiltered(self.mw.current_project_folder) # Use setRootPathFiltered
            # Map to proxy index and set as root for the view
            root_proxy_index = self.mw.checkable_proxy.mapFromSource(idx)
            self.mw.tree_view.setRootIndex(root_proxy_index)
            # Reapply check states based on the dictionary
            self._reapply_check_states(root_proxy_index)
            self.mw.status_bar.showMessage("íŒŒì¼ íŠ¸ë¦¬ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ.")
            logger.info("File tree refresh complete.")
        else:
             logger.warning("Cannot refresh tree: Project folder not set or models not available.")


    def _reapply_check_states(self, parent_proxy_index: QModelIndex):
         """Recursively reapply check states based on the dictionary after a refresh."""
         # This function might be slow if it traverses the entire visible tree.
         # It's necessary after invalidateFilter() or setRootPath().
         if not parent_proxy_index.isValid(): return

         parent_path = self.mw.checkable_proxy.get_file_path_from_index(parent_proxy_index)
         if parent_path:
             is_checked = self.mw.checkable_proxy.checked_files_dict.get(parent_path, False)
             current_state = self.mw.checkable_proxy.data(parent_proxy_index, Qt.ItemDataRole.CheckStateRole) # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole
             target_state = Qt.CheckState.Checked if is_checked else Qt.CheckState.Unchecked # Qt.Checked/Unchecked -> Qt.CheckState.Checked/Unchecked
             if current_state != target_state:
                 # Use setData to ensure signals are emitted correctly if state changes
                 self.mw.checkable_proxy.setData(parent_proxy_index, target_state, Qt.ItemDataRole.CheckStateRole) # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole

         # Recursively check children (only those currently loaded/visible)
         row_count = self.mw.checkable_proxy.rowCount(parent_proxy_index)
         for row in range(row_count):
             child_proxy_index = self.mw.checkable_proxy.index(row, 0, parent_proxy_index)
             if child_proxy_index.isValid():
                 self._reapply_check_states(child_proxy_index)


    def on_data_changed(self, topLeft: QModelIndex, bottomRight: QModelIndex, roles: List[int]):
        """Handles updates when data in the CheckableProxyModel changes (e.g., check state)."""
        if Qt.ItemDataRole.CheckStateRole in roles and hasattr(self.mw, 'checkable_proxy'): # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole
            # Get checked files (optimized version without os.path.getsize)
            checked_files = self.mw.checkable_proxy.get_checked_files() # This now uses os.path.isfile or QFileInfo
            self.mw.selected_files_data = []
            # --- Removed file size calculation ---
            # total_size = 0
            # for fpath in checked_files:
            #     try:
            #         # size = os.path.getsize(fpath) # Removed size calculation
            #         self.mw.selected_files_data.append((fpath, 0)) # Store path with size 0
            #         # total_size += size
            #     except Exception:
            #         pass # ì˜¤ë¥˜ ë¬´ì‹œ
            # self.mw.status_bar.showMessage(f"{len(checked_files)} files selected, Total size: {total_size:,} bytes")
            # --- End of removal ---
            self.mw.status_bar.showMessage(f"{len(checked_files)} files selected.") # Update status bar without size
            # í† í° ê³„ì‚°ì€ ë²„íŠ¼ í´ë¦­ ì‹œì—ë§Œ ìˆ˜í–‰ë˜ë„ë¡ ë³€ê²½ë¨
            # íŒŒì¼ ì²´í¬ ìƒíƒœ ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ (ìë™ ì €ì¥ìš©) -> ì‹œê·¸ë„ ì—°ê²° íŒŒì¼ì—ì„œ ì²˜ë¦¬
            # logger.debug("Check state changed, state_changed_signal emitted.") # Signal emitted via connect_signals



======== src\ui\controllers\main_controller.py ========

import os
import base64 # ì¶”ê°€
import mimetypes # ì¶”ê°€
import logging # ë¡œê¹… ì¶”ê°€
from typing import Optional, List, Dict, Any
from PyQt6.QtCore import Qt, QModelIndex, QMimeData, QObject, QThread, pyqtSignal, QBuffer, QIODevice # PyQt5 -> PyQt6, QBuffer, QIODevice ì¶”ê°€
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QApplication, QListWidgetItem # PyQt5 -> PyQt6
from PyQt6.QtGui import QImage # PyQt5 -> PyQt6

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.pydantic_models.app_state import AppState
from utils.helpers import calculate_char_count

# MainWindowëŠ” íƒ€ì… íŒíŠ¸ìš©ìœ¼ë¡œë§Œ ì‚¬ìš© (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .resource_controller import ResourceController
    from .prompt_controller import PromptController
    from .xml_controller import XmlController
    from .file_tree_controller import FileTreeController

# Pillow import ì‹œë„ (ì´ë¯¸ì§€ ì²˜ë¦¬ìš©)
try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False
    print("Warning: Pillow library not installed. Image handling from clipboard might be limited.")

logger = logging.getLogger(__name__) # ë¡œê±° ì„¤ì •

# --- í† í° ê³„ì‚°ì„ ìœ„í•œ Worker í´ë˜ìŠ¤ ---
class TokenWorker(QObject):
    finished = pyqtSignal(int)      # ê³„ì‚°ëœ í† í° ìˆ˜ ì „ë‹¬
    error = pyqtSignal(str)         # ì˜¤ë¥˜ ë©”ì‹œì§€ ì „ë‹¬

    def __init__(self, token_service: TokenCalculationService, model_type: str, model_name: str, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        super().__init__()
        self.token_service = token_service
        self.model_type = model_type
        self.model_name = model_name
        self.text = text
        self.attachments = attachments or []

    def run(self):
        """í† í° ê³„ì‚° ë¡œì§ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."""
        try:
            logger.info(f"Starting token calculation in worker thread for {self.model_type} - {self.model_name}")
            token_count = self.token_service.calculate_tokens(
                self.model_type, self.model_name, self.text, self.attachments
            )
            if token_count is not None:
                logger.info(f"Token calculation finished successfully: {token_count}")
                self.finished.emit(token_count)
            else:
                logger.warning(f"Token calculation returned None for {self.model_type} - {self.model_name}")
                self.error.emit(f"{self.model_type} í† í° ê³„ì‚° ì‹¤íŒ¨ (None ë°˜í™˜)")
        except Exception as e:
            logger.exception(f"Error during token calculation in worker thread for {self.model_type} - {self.model_name}")
            self.error.emit(f"í† í° ê³„ì‚° ì˜¤ë¥˜: {str(e)}")


class MainController:
    """
    ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì „ë°˜ì ì¸ íë¦„ê³¼
    ë‹¤ë¥¸ ì»¨íŠ¸ë¡¤ëŸ¬ ê°„ì˜ ì¡°ì • ì—­í• ì„ ë‹´ë‹¹ (í•„ìš”í•œ ê²½ìš°).
    ì£¼ìš” ê¸°ëŠ¥ ë¡œì§ì€ ê° ì „ë¬¸ ì»¨íŠ¸ë¡¤ëŸ¬ì— ìœ„ì„.
    í† í° ê³„ì‚°ì„ ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    """
    def __init__(self, main_window: 'MainWindow'):
        self.mw = main_window
        self.token_service: TokenCalculationService = self.mw.token_service
        self.config_service: ConfigService = self.mw.config_service
        self.last_token_count: Optional[int] = None
        self.token_thread: Optional[QThread] = None
        self.token_worker: Optional[TokenWorker] = None

    def reset_program(self):
        """Resets the application to its initial state."""
        self._initialized = False
        self.mw.reset_state()
        self._initialized = False

        self.mw.project_folder_label.setText("í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: (ì„ íƒ ì•ˆ ë¨)")
        self.mw.system_tab.clear()
        self.mw.user_tab.clear()
        if hasattr(self.mw, "dir_structure_tab"): self.mw.dir_structure_tab.clear()
        if hasattr(self.mw, "xml_input_tab"): self.mw.xml_input_tab.clear()
        if hasattr(self.mw, "prompt_output_tab"): self.mw.prompt_output_tab.clear()
        if hasattr(self.mw, "summary_tab"): self.mw.summary_tab.clear()
        if hasattr(self.mw, "attachment_list_widget"): self.mw.attachment_list_widget.clear() # ì²¨ë¶€ ëª©ë¡ í´ë¦¬ì–´

        self.mw.file_tree_controller.reset_gitignore_and_filter()
        self.mw.file_tree_controller.reset_file_tree()

        self.mw.llm_combo.setCurrentIndex(self.mw.llm_combo.findText("Gemini"))
        self.on_llm_selected()

        self.update_char_count_for_active_tab()
        self.reset_token_label()
        if hasattr(self.mw, 'api_time_label'): # API ì‹œê°„ ë¼ë²¨ ì´ˆê¸°í™” ì¶”ê°€
            self.mw.api_time_label.setText("API ì‹œê°„: -")

        self.mw.update_window_title()
        self.mw.status_bar.showMessage("í”„ë¡œê·¸ë¨ ë¦¬ì…‹ ì™„ë£Œ.")

        self._initialized = True
        QMessageBox.information(self.mw, "Info", "í”„ë¡œê·¸ë¨ì´ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.")
        self.mw.state_changed_signal.emit() # ë¦¬ì…‹ í›„ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ

    def update_char_count(self, text: str):
        """Updates character count in the status bar."""
        char_count = calculate_char_count(text)
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

    def update_char_count_for_active_tab(self):
        """Updates the character count based on the currently active text edit tab."""
        current_widget = self.mw.build_tabs.currentWidget()
        if hasattr(current_widget, 'toPlainText'):
            self.update_char_count(current_widget.toPlainText())
        else:
            self.mw.char_count_label.setText("Chars: 0")

    def reset_token_label(self):
        """Resets the token count label to its default state."""
        if hasattr(self.mw, '_initialized') and self.mw._initialized:
            self.mw.token_count_label.setText("í† í° ê³„ì‚°: -")
            self.last_token_count = None
            # ì§„í–‰ ì¤‘ì¸ í† í° ê³„ì‚° ìŠ¤ë ˆë“œ ì¤‘ì§€ (í•„ìš” ì‹œ)
            self._stop_token_calculation_thread()

    def handle_text_changed(self):
        """Handles text changes in editors: updates char count and resets token label."""
        self.update_char_count_for_active_tab()
        self.reset_token_label()
        # í…ìŠ¤íŠ¸ ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ (ìë™ ì €ì¥ìš©)
        self.mw.state_changed_signal.emit()


    def calculate_and_display_tokens(self, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        """
        Starts the token calculation in a background thread and updates the status bar.
        """
        if not hasattr(self.mw, '_initialized') or not self.mw._initialized:
            logger.warning("Token calculation skipped: MainWindow not initialized.")
            self.reset_token_label()
            return

        attachments = attachments or []
        char_count = calculate_char_count(text)
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

        # ì´ì „ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì´ë©´ ì¤‘ì§€
        self._stop_token_calculation_thread()

        # í…ìŠ¤íŠ¸ì™€ ì²¨ë¶€íŒŒì¼ ëª¨ë‘ ì—†ìœ¼ë©´ ê³„ì‚° ì•ˆ í•¨
        if not text and not attachments:
            logger.info("Token calculation skipped: Text and attachments are empty.")
            self.mw.token_count_label.setText("í† í° ê³„ì‚°: -")
            self.last_token_count = 0 # ëª…ì‹œì ìœ¼ë¡œ 0ìœ¼ë¡œ ì„¤ì •
            return

        selected_llm = self.mw.llm_combo.currentText()
        model_name = self.mw.model_name_combo.currentText().strip()

        if not model_name:
            token_text = f"{selected_llm} ëª¨ë¸ëª…ì„ ì„ íƒí•˜ê±°ë‚˜ ì…ë ¥í•˜ì„¸ìš”."
            logger.warning("Token calculation skipped: Model name is empty.")
            self.mw.token_count_label.setText(token_text)
            self.last_token_count = None
            return

        token_text = f"{selected_llm} í† í° ê³„ì‚° ì¤‘..."
        self.mw.token_count_label.setText(token_text)
        self.last_token_count = None
        QApplication.processEvents() # UI ì—…ë°ì´íŠ¸ ê°•ì œ

        logger.info(f"Starting token calculation worker for {selected_llm}, {model_name}...")

        # ìŠ¤ë ˆë“œ ë° ì›Œì»¤ ìƒì„±
        self.token_thread = QThread()
        self.token_worker = TokenWorker(self.token_service, selected_llm, model_name, text, attachments)
        self.token_worker.moveToThread(self.token_thread)

        # ì‹œê·¸ë„ ì—°ê²°
        self.token_thread.started.connect(self.token_worker.run)
        self.token_worker.finished.connect(self._handle_token_result)
        self.token_worker.error.connect(self._handle_token_error)
        # ìŠ¤ë ˆë“œ ì¢…ë£Œ ë° ê°ì²´ ì •ë¦¬ ì—°ê²° (QThread.finished ì‚¬ìš©)
        self.token_thread.finished.connect(self._cleanup_token_thread) # ìŠ¤ë ˆë“œ ì™„ë£Œ ì‹œ ì •ë¦¬ í•¨ìˆ˜ í˜¸ì¶œ
        self.token_worker.finished.connect(self.token_worker.deleteLater) # ì›Œì»¤ ì™„ë£Œ ì‹œ deleteLater
        self.token_worker.error.connect(self.token_worker.deleteLater) # ì›Œì»¤ ì˜¤ë¥˜ ì‹œ deleteLater
        # ì›Œì»¤ ì™„ë£Œ/ì˜¤ë¥˜ ì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œ ìš”ì²­
        self.token_worker.finished.connect(self.token_thread.quit)
        self.token_worker.error.connect(self.token_thread.quit)
        # ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹œ deleteLater (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
        self.token_thread.finished.connect(self.token_thread.deleteLater)


        # ìŠ¤ë ˆë“œ ì‹œì‘
        self.token_thread.start()

    def _handle_token_result(self, token_count: int):
        """Handles the successful result from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText() # í˜„ì¬ ì„ íƒëœ LLM í™•ì¸
        token_text = f"Total Token ({selected_llm}): {token_count:,}"
        self.last_token_count = token_count
        logger.info(f"Token calculation successful. Updating label to: {token_text}")
        self.mw.token_count_label.setText(token_text)
        # self._cleanup_token_thread() # ìŠ¤ë ˆë“œ ì •ë¦¬ëŠ” thread.finished ì‹œê·¸ë„ì—ì„œ ì²˜ë¦¬

    def _handle_token_error(self, error_msg: str):
        """Handles the error signal from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText() # í˜„ì¬ ì„ íƒëœ LLM í™•ì¸
        token_text = f"{selected_llm} í† í° ê³„ì‚° ì˜¤ë¥˜"
        self.last_token_count = None
        logger.error(f"Token calculation failed: {error_msg}")
        self.mw.token_count_label.setText(token_text)
        # Optionally show a more detailed error in status bar or tooltip
        self.mw.status_bar.showMessage(f"í† í° ê³„ì‚° ì˜¤ë¥˜: {error_msg}", 5000) # 5ì´ˆê°„ í‘œì‹œ
        # self._cleanup_token_thread() # ìŠ¤ë ˆë“œ ì •ë¦¬ëŠ” thread.finished ì‹œê·¸ë„ì—ì„œ ì²˜ë¦¬

    def _stop_token_calculation_thread(self):
        """Stops the currently running token calculation thread, if any."""
        if self.token_thread and self.token_thread.isRunning():
            logger.info("Stopping previous token calculation thread...")
            self.token_thread.quit() # ì¢…ë£Œ ìš”ì²­
            # wait() í˜¸ì¶œ - ì§€ì •ëœ ì‹œê°„(ms) ë™ì•ˆ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¼
            if not self.token_thread.wait(1000): # ìµœëŒ€ 1ì´ˆ ëŒ€ê¸°
                # ìŠ¤ë ˆë“œê°€ ì œ ì‹œê°„ ì•ˆì— ì¢…ë£Œë˜ì§€ ì•Šì€ ê²½ìš°
                logger.warning("Token calculation thread did not quit gracefully within 1 second.")
                # terminate() ì‚¬ìš© ì œê±°: ê°•ì œ ì¢…ë£ŒëŠ” ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ë‚˜ ë¶ˆì•ˆì •ì„±ì„ ì•¼ê¸°í•  ìˆ˜ ìˆìŒ
                # self.token_thread.terminate()
                # self.token_thread.wait() # terminate í›„ì—ë„ waitëŠ” í•„ìš”í•  ìˆ˜ ìˆìŒ
            else:
                logger.info("Previous token calculation thread finished gracefully.")
            # ìŠ¤ë ˆë“œ ì¢…ë£Œ í›„ ì •ë¦¬ í•¨ìˆ˜ í˜¸ì¶œ (ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ì—ì„œ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ë„ë¡ ë³€ê²½ë¨)
            # self._cleanup_token_thread() # ì—¬ê¸°ì„œ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ


    def _cleanup_token_thread(self):
        """Cleans up the token thread and worker objects."""
        logger.debug("Cleaning up token thread and worker objects.") # ë””ë²„ê·¸ ë ˆë²¨ë¡œ ë³€ê²½
        # ìŠ¤ë ˆë“œ ê°ì²´ ì°¸ì¡° í•´ì œ (ì´ë¯¸ deleteLater ì—°ê²°ë¨)
        self.token_thread = None
        self.token_worker = None


    def on_llm_selected(self):
        """Handles the selection change in the LLM dropdown."""
        selected_llm = self.mw.llm_combo.currentText()
        available_models = self.config_service.get_available_models(selected_llm)

        self.mw.model_name_combo.blockSignals(True)
        self.mw.model_name_combo.clear()
        self.mw.model_name_combo.addItems(available_models)
        self.mw.model_name_combo.blockSignals(False)

        default_model = self.config_service.get_default_model_name(selected_llm)
        default_index = self.mw.model_name_combo.findText(default_model)
        if default_index != -1:
            self.mw.model_name_combo.setCurrentIndex(default_index)
        elif available_models:
            self.mw.model_name_combo.setCurrentIndex(0)
            logger.warning(f"Default model '{default_model}' not found for {selected_llm}. Selecting first available.")
        else:
             logger.warning(f"No available models found for {selected_llm}.")

        self.reset_token_label()
        self.update_char_count_for_active_tab()

        is_gemini_selected = (selected_llm == "Gemini")
        if hasattr(self.mw, 'gemini_param_widget'):
            self.mw.gemini_param_widget.setVisible(is_gemini_selected)

        # LLM ë˜ëŠ” ëª¨ë¸ ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
        self.mw.state_changed_signal.emit()

    # --- Attachment Handling ---
    def attach_files(self):
        """Opens a file dialog to select multiple files for attachment."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "ì •ë³´", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” íŒŒì¼ ì²¨ë¶€ê°€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.")
            return

        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        # getOpenFileNamesëŠ” íŒŒì¼ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ì™€ í•„í„° ë¬¸ìì—´ì„ ë°˜í™˜
        file_paths, _ = QFileDialog.getOpenFileNames(
            self.mw,
            "íŒŒì¼ ì²¨ë¶€",
            start_dir,
            "ëª¨ë“  íŒŒì¼ (*.*);;ì´ë¯¸ì§€ íŒŒì¼ (*.png *.jpg *.jpeg *.webp);;í…ìŠ¤íŠ¸ íŒŒì¼ (*.txt *.md *.py *.json *.yaml *.yml *.html *.css *.js)"
        )

        if file_paths:
            added_count = 0
            for file_path in file_paths:
                if not os.path.exists(file_path): continue

                file_name = os.path.basename(file_path)
                # ì¤‘ë³µ ì²´í¬ (ê²½ë¡œ ê¸°ì¤€)
                if any(item.get('path') == file_path for item in self.mw.attached_items):
                    logger.info(f"Skipping duplicate attachment: {file_name}")
                    continue

                # íŒŒì¼ íƒ€ì… ì¶”ì • (ì´ë¯¸ì§€ vs ì¼ë°˜ íŒŒì¼)
                mime_type, _ = mimetypes.guess_type(file_path)
                item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'

                # ì²¨ë¶€ ëª©ë¡ì— ì¶”ê°€ (ë°ì´í„°ëŠ” í•„ìš” ì‹œ ë¡œë“œ)
                attachment_info = {
                    "type": item_type,
                    "path": file_path,
                    "name": file_name,
                    "data": None # í•„ìš” ì‹œ ë¡œë“œí•˜ë„ë¡ Noneìœ¼ë¡œ ì´ˆê¸°í™”
                }
                self.mw.attached_items.append(attachment_info)
                added_count += 1

            if added_count > 0:
                self.mw._update_attachment_list_ui() # UI ì—…ë°ì´íŠ¸
                self.mw.status_bar.showMessage(f"{added_count}ê°œ íŒŒì¼ ì²¨ë¶€ ì™„ë£Œ.")
                self.reset_token_label() # ì²¨ë¶€ ë³€ê²½ ì‹œ í† í° ë¦¬ì…‹
                self.mw.state_changed_signal.emit() # ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
            else:
                self.mw.status_bar.showMessage("ì„ íƒí•œ íŒŒì¼ì´ ì´ë¯¸ ì²¨ë¶€ë˜ì–´ ìˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

    def paste_from_clipboard(self):
        """Pastes image or file paths from the clipboard."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "ì •ë³´", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” í´ë¦½ë³´ë“œ ì²¨ë¶€ê°€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.")
            return

        clipboard = QApplication.clipboard()
        mime_data = clipboard.mimeData()
        added_count = 0

        if mime_data.hasImage():
            qimage = clipboard.image()
            if not qimage.isNull():
                # QImageë¥¼ bytesë¡œ ë³€í™˜ (Pillow ì‚¬ìš© ê¶Œì¥)
                image_data = None
                image_format = "PNG" # ê¸°ë³¸ í¬ë§·
                if _PILLOW_AVAILABLE:
                    try:
                        pil_image = ImageQt(qimage).copy() # Pillow Imageë¡œ ë³€í™˜
                        # RGBA -> RGB ë³€í™˜ (JPEG ì €ì¥ ì‹œ í•„ìš”í•  ìˆ˜ ìˆìŒ)
                        if pil_image.mode == 'RGBA':
                             pil_image = pil_image.convert('RGB')
                        # ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ì—¬ bytes ì–»ê¸°
                        import io
                        buffer = io.BytesIO()
                        # ì´ë¯¸ì§€ í¬ë§· ê²°ì • (ì˜ˆ: PNG ë˜ëŠ” JPEG)
                        # íˆ¬ëª…ë„ ì—†ìœ¼ë©´ JPEG, ìˆìœ¼ë©´ PNG ê³ ë ¤
                        save_format = "JPEG" if pil_image.mode == 'RGB' else "PNG"
                        pil_image.save(buffer, format=save_format)
                        image_data = buffer.getvalue()
                        image_format = save_format
                        logger.info(f"Pasted image converted to {save_format} bytes.")
                    except Exception as e:
                        logger.error(f"Error converting QImage with Pillow: {e}")
                else:
                    # Pillow ì—†ìœ¼ë©´ QBuffer ì‚¬ìš© ì‹œë„ (ëœ ì•ˆì •ì ì¼ ìˆ˜ ìˆìŒ)
                    try:
                        import io
                        buffer = QBuffer()
                        buffer.open(QIODevice.OpenModeFlag.ReadWrite) # QIODevice.ReadWrite -> QIODevice.OpenModeFlag.ReadWrite
                        # PNGë¡œ ì €ì¥ ì‹œë„
                        if qimage.save(buffer, "PNG"):
                            image_data = bytes(buffer.data()) # QByteArray -> bytes (PyQt6)
                            image_format = "PNG"
                            logger.info("Pasted image converted to PNG bytes using QBuffer.")
                        else:
                            logger.warning("Failed to save QImage using QBuffer.")
                        buffer.close()
                    except Exception as e:
                        logger.error(f"Error converting QImage with QBuffer: {e}")


                if image_data:
                    # ì¤‘ë³µ ì²´í¬ (ë°ì´í„° ê¸°ì¤€ - ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŒ)
                    # if any(item.get('data') == image_data for item in self.mw.attached_items if item['type'] == 'image'):
                    #     print("Skipping duplicate image data from clipboard.")
                    # else:
                    # ì„ì‹œ ì´ë¦„ ìƒì„±
                    import time
                    timestamp = time.strftime("%Y%m%d_%H%M%S")
                    image_name = f"clipboard_image_{timestamp}.{image_format.lower()}"
                    attachment_info = {
                        "type": "image",
                        "path": None, # í´ë¦½ë³´ë“œ ì´ë¯¸ì§€ëŠ” ê²½ë¡œ ì—†ìŒ
                        "name": image_name,
                        "data": image_data
                    }
                    self.mw.attached_items.append(attachment_info)
                    added_count += 1
                    logger.info(f"Image pasted from clipboard: {image_name}")

        elif mime_data.hasUrls():
            urls = mime_data.urls()
            for url in urls:
                if url.isLocalFile():
                    file_path = url.toLocalFile()
                    if os.path.exists(file_path):
                        file_name = os.path.basename(file_path)
                        # ì¤‘ë³µ ì²´í¬ (ê²½ë¡œ ê¸°ì¤€)
                        if any(item.get('path') == file_path for item in self.mw.attached_items):
                            logger.info(f"Skipping duplicate attachment from clipboard: {file_name}")
                            continue

                        mime_type, _ = mimetypes.guess_type(file_path)
                        item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'

                        attachment_info = {
                            "type": item_type,
                            "path": file_path,
                            "name": file_name,
                            "data": None
                        }
                        self.mw.attached_items.append(attachment_info)
                        added_count += 1
                        logger.info(f"File path pasted from clipboard: {file_name}")
                    else:
                        logger.warning(f"Ignoring non-existent file path from clipboard: {file_path}")
                else:
                    logger.warning(f"Ignoring non-local URL from clipboard: {url.toString()}")

        if added_count > 0:
            self.mw._update_attachment_list_ui()
            self.mw.status_bar.showMessage(f"{added_count}ê°œ í•­ëª© í´ë¦½ë³´ë“œì—ì„œ ì²¨ë¶€ ì™„ë£Œ.")
            self.reset_token_label() # ì²¨ë¶€ ë³€ê²½ ì‹œ í† í° ë¦¬ì…‹
            self.mw.state_changed_signal.emit() # ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
        else:
            self.mw.status_bar.showMessage("í´ë¦½ë³´ë“œì— ì²¨ë¶€í•  ìˆ˜ ìˆëŠ” ì´ë¯¸ì§€ë‚˜ íŒŒì¼ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.")

    def remove_selected_attachment(self):
        """Removes the selected item from the attachment list."""
        if not hasattr(self.mw, 'attachment_list_widget'): return

        selected_items = self.mw.attachment_list_widget.selectedItems()
        if not selected_items:
            self.mw.status_bar.showMessage("ì œê±°í•  ì²¨ë¶€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.")
            return

        removed_count = 0
        # ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì—ì„œ ì„ íƒëœ í•­ëª©ì˜ ì¸ë±ìŠ¤ë¥¼ ê°€ì ¸ì™€ ì—­ìˆœìœ¼ë¡œ ì œê±° (ì¸ë±ìŠ¤ ë³€ê²½ ë°©ì§€)
        selected_indices = sorted([self.mw.attachment_list_widget.row(item) for item in selected_items], reverse=True)

        for index in selected_indices:
            if 0 <= index < len(self.mw.attached_items):
                removed_item = self.mw.attached_items.pop(index)
                self.mw.attachment_list_widget.takeItem(index) # UIì—ì„œë„ ì œê±°
                logger.info(f"Removed attachment: {removed_item.get('name')}")
                removed_count += 1

        if removed_count > 0:
            self.mw.status_bar.showMessage(f"{removed_count}ê°œ ì²¨ë¶€ íŒŒì¼ ì œê±° ì™„ë£Œ.")
            self.reset_token_label() # ì²¨ë¶€ ë³€ê²½ ì‹œ í† í° ë¦¬ì…‹
            self.mw.state_changed_signal.emit() # ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
        else:
             self.mw.status_bar.showMessage("ì²¨ë¶€ íŒŒì¼ ì œê±° ì¤‘ ì˜¤ë¥˜ ë°œìƒ.")




======== src\ui\controllers\prompt_controller.py ========

import os
import logging # ë¡œê¹… ì¶”ê°€
from PyQt6.QtWidgets import QMessageBox, QApplication # PyQt5 -> PyQt6

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.services.prompt_service import PromptService

# MainWindowëŠ” íƒ€ì… íŒíŠ¸ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

logger = logging.getLogger(__name__) # ë¡œê±° ì„¤ì •

class PromptController:
    """
    Handles logic related to prompt generation and clipboard operations.
    Token calculation is now triggered asynchronously by MainController.
    """
    def __init__(self, main_window: 'MainWindow', prompt_service: PromptService):
        self.mw = main_window
        self.prompt_service = prompt_service

    def generate_prompt(self):
        """Generates the prompt for the Code Enhancer mode and triggers token calculation."""
        if self.mw.mode == "Meta Prompt Builder":
            return self.generate_meta_prompt() # Meta ëª¨ë“œë©´ í•´ë‹¹ í•¨ìˆ˜ í˜¸ì¶œ

        if not self.mw.current_project_folder:
             QMessageBox.warning(self.mw, "ê²½ê³ ", "í”„ë¡œì íŠ¸ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.")
             return False

        checked_files = self.mw.checkable_proxy.get_checked_files() if hasattr(self.mw, 'checkable_proxy') else []
        if not checked_files:
            QMessageBox.warning(self.mw, "ê²½ê³ ", "í”„ë¡¬í”„íŠ¸ì— í¬í•¨í•  íŒŒì¼ì„ í•˜ë‚˜ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return False

        file_contents = []
        self.mw.selected_files_data = []
        read_errors = []
        for fpath in checked_files:
            try:
                size = os.path.getsize(fpath)
                with open(fpath, 'r', encoding='utf-8', errors='ignore') as fp:
                    content = fp.read()
                file_contents.append((fpath, content))
                self.mw.selected_files_data.append((fpath, size))
            except Exception as e:
                error_msg = f"íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ ({os.path.basename(fpath)}): {e}"
                logger.error(error_msg) # ë¡œê¹… ì‚¬ìš©
                read_errors.append(error_msg)
                continue

        if read_errors:
             QMessageBox.warning(self.mw, "íŒŒì¼ ë¡œë”© ì˜¤ë¥˜", "ì¼ë¶€ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n" + "\n".join(read_errors))
             # return False # ì˜¤ë¥˜ ì‹œ ì¤‘ë‹¨ ì›í•˜ë©´ ì£¼ì„ í•´ì œ

        system_text = self.mw.system_tab.toPlainText()
        user_text = self.mw.user_tab.toPlainText()
        dir_structure_content = ""
        if self.mw.tree_generated and hasattr(self.mw, "dir_structure_tab"):
            dir_structure_content = self.mw.dir_structure_tab.toPlainText()

        # --- ì²¨ë¶€ íŒŒì¼ ì •ë³´ ë¡œë“œ ---
        # generate_code_enhancer_promptëŠ” ë§ˆì»¤ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì‹¤ì œ ë°ì´í„° ë¡œë“œëŠ” ë¶ˆí•„ìš”
        # í† í° ê³„ì‚° ì‹œì—ëŠ” ì‹¤ì œ ë°ì´í„°ê°€ í•„ìš”í•˜ë¯€ë¡œ MainControllerì—ì„œ ì²˜ë¦¬
        attachments_metadata = []
        for item in self.mw.attached_items:
            meta_item = item.copy()
            meta_item.pop('data', None) # ë°ì´í„° ì œì™¸í•˜ê³  ë©”íƒ€ë°ì´í„°ë§Œ ì „ë‹¬
            attachments_metadata.append(meta_item)
        # -------------------------

        final_prompt = self.prompt_service.generate_code_enhancer_prompt(
            system_text=system_text,
            user_text=user_text,
            file_contents=file_contents,
            root_dir=self.mw.current_project_folder,
            dir_structure_content=dir_structure_content,
            attached_items=attachments_metadata # ë©”íƒ€ë°ì´í„° ì „ë‹¬
        )

        self.mw.last_generated_prompt = final_prompt
        self.mw.prompt_output_tab.setText(final_prompt)

        # --- Trigger token calculation asynchronously ---
        # Pass the final prompt text and the *original* attached_items list (which might contain data)
        self.mw.main_controller.calculate_and_display_tokens(final_prompt, self.mw.attached_items)
        # -----------------------------------------------

        self.mw.status_bar.showMessage(f"Prompt generated! Length: {len(final_prompt):,} chars. Token calculation started...")
        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        return True

    def generate_meta_prompt(self):
        """Generates the intermediate meta prompt and triggers token calculation."""
        system_text = self.mw.system_tab.toPlainText() # ë©”íƒ€ í…œí”Œë¦¿
        user_text = self.mw.user_tab.toPlainText() # ë©”íƒ€ ì‚¬ìš©ì ì…ë ¥

        final_output = self.prompt_service.generate_meta_prompt(
            meta_template=system_text,
            meta_user_input=user_text
        )

        self.mw.prompt_output_tab.setText(final_output) # ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ì¶œë ¥ íƒ­
        self.mw.last_generated_prompt = final_output

        # --- Trigger token calculation asynchronously ---
        self.mw.main_controller.calculate_and_display_tokens(final_output) # Meta mode has no attachments
        # -----------------------------------------------

        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        self.mw.status_bar.showMessage("META Prompt generated! Token calculation started...")
        return True

    def generate_final_meta_prompt(self):
        """Generates the final prompt by replacing variables and triggers token calculation."""
        meta_prompt_content = ""
        user_prompt_content = ""
        if hasattr(self.mw, 'meta_prompt_tab'):
             meta_prompt_content = self.mw.meta_prompt_tab.toPlainText()
        if hasattr(self.mw, 'user_prompt_tab'):
             user_prompt_content = self.mw.user_prompt_tab.toPlainText()

        variables = {}
        if hasattr(self.mw, 'build_tabs'):
            for i in range(self.mw.build_tabs.count()):
                tab_name = self.mw.build_tabs.tabText(i)
                if tab_name.startswith("var-"):
                    var_name = tab_name[4:]
                    tab_widget = self.mw.build_tabs.widget(i)
                    if tab_widget and hasattr(tab_widget, 'toPlainText'):
                        variables[var_name] = tab_widget.toPlainText()

        final_prompt = self.prompt_service.generate_final_meta_prompt(
            meta_prompt_content=meta_prompt_content,
            user_prompt_content=user_prompt_content,
            variables=variables
        )

        if hasattr(self.mw, 'final_prompt_tab'):
            self.mw.final_prompt_tab.setText(final_prompt)
            self.mw.last_generated_prompt = final_prompt

            # --- Trigger token calculation asynchronously ---
            self.mw.main_controller.calculate_and_display_tokens(final_prompt) # Meta mode has no attachments
            # -----------------------------------------------

            self.mw.build_tabs.setCurrentWidget(self.mw.final_prompt_tab)
            self.mw.status_bar.showMessage("Final Prompt generated! Token calculation started...")
        else:
             QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ìµœì¢… í”„ë¡¬í”„íŠ¸ íƒ­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def copy_to_clipboard(self):
        """Copies the content of the active prompt output tab to the clipboard."""
        current_widget = self.mw.build_tabs.currentWidget()
        prompt_to_copy = ""

        # Code Enhancer ëª¨ë“œì˜ í”„ë¡¬í”„íŠ¸ ì¶œë ¥ íƒ­
        if current_widget == self.mw.prompt_output_tab and self.mw.mode != "Meta Prompt Builder":
            prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        # Meta ëª¨ë“œì˜ ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ì¶œë ¥ íƒ­
        elif current_widget == self.mw.prompt_output_tab and self.mw.mode == "Meta Prompt Builder":
             prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        # Meta ëª¨ë“œì˜ ìµœì¢… í”„ë¡¬í”„íŠ¸ íƒ­
        elif hasattr(self.mw, 'final_prompt_tab') and current_widget == self.mw.final_prompt_tab:
             prompt_to_copy = self.mw.final_prompt_tab.toPlainText()
        # íŒŒì¼ íŠ¸ë¦¬ íƒ­ (ì„ íƒì )
        elif hasattr(self.mw, 'dir_structure_tab') and current_widget == self.mw.dir_structure_tab:
             prompt_to_copy = self.mw.dir_structure_tab.toPlainText()

        # ìœ„ ê²½ìš°ì— í•´ë‹¹í•˜ì§€ ì•Šìœ¼ë©´ ë§ˆì§€ë§‰ ìƒì„±ëœ í”„ë¡¬í”„íŠ¸ ì‚¬ìš© (last_generated_prompt)
        if not prompt_to_copy:
             prompt_to_copy = self.mw.last_generated_prompt

        if prompt_to_copy:
            QApplication.clipboard().setText(prompt_to_copy)
            self.mw.status_bar.showMessage("Copied!")
            return True
        else:
            self.mw.status_bar.showMessage("ë³µì‚¬í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤!")
            return False

    def generate_all_and_copy(self):
        """
        Generates directory tree, prompt, triggers token calculation, and copies to clipboard (Code Enhancer mode only).
        Returns True if prompt generation was successful, False otherwise.
        Clipboard copy failure only logs a warning but doesn't cause the function to return False.
        """
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” ì´ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return False # ì‘ì—… ìˆ˜í–‰ ì•ˆ í•¨

        # FileTreeControllerì˜ íŠ¸ë¦¬ ìƒì„± ë©”ì„œë“œ í˜¸ì¶œ
        tree_success = self.mw.file_tree_controller.generate_directory_tree_structure()
        if not tree_success:
            logger.warning("generate_all_and_copy: Directory tree generation failed.")
            # íŠ¸ë¦¬ ìƒì„± ì‹¤íŒ¨ ì‹œì—ë„ í”„ë¡¬í”„íŠ¸ ìƒì„±ì€ ì‹œë„í•  ìˆ˜ ìˆìŒ (ì„ íƒ ì‚¬í•­)
            # return False # íŠ¸ë¦¬ ìƒì„± ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ì¤‘ë‹¨í•˜ë ¤ë©´ ì£¼ì„ í•´ì œ

        # ìì‹ ì˜ í”„ë¡¬í”„íŠ¸ ìƒì„± ë©”ì„œë“œ í˜¸ì¶œ (ë‚´ë¶€ì—ì„œ í† í° ê³„ì‚° íŠ¸ë¦¬ê±°)
        prompt_success = self.generate_prompt() # This now triggers calculate_and_display_tokens
        if not prompt_success:
            logger.error("generate_all_and_copy: Prompt generation failed.")
            return False # í”„ë¡¬í”„íŠ¸ ìƒì„± ì‹¤íŒ¨ ì‹œ False ë°˜í™˜

        # ìì‹ ì˜ í´ë¦½ë³´ë“œ ë³µì‚¬ ë©”ì„œë“œ í˜¸ì¶œ
        copy_success = self.copy_to_clipboard()
        if not copy_success:
            # ë³µì‚¬ ì‹¤íŒ¨ëŠ” ê²½ê³ ë§Œ ë¡œê¹…í•˜ê³ , í•¨ìˆ˜ëŠ” True ë°˜í™˜ (í”„ë¡¬í”„íŠ¸ ìƒì„± ì„±ê³µ ê¸°ì¤€)
            logger.warning("generate_all_and_copy: Copy to clipboard failed, but prompt generation succeeded.")

        # í”„ë¡¬í”„íŠ¸ ìƒì„±ì´ ì„±ê³µí–ˆìœ¼ë¯€ë¡œ True ë°˜í™˜
        # ìƒíƒœ ë©”ì‹œì§€ëŠ” generate_promptì—ì„œ ì´ë¯¸ ì„¤ì •ë¨ ("... Token calculation started...")
        return True



======== src\ui\controllers\resource_controller.py ========

import os
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QTreeWidgetItem # PyQt5 -> PyQt6, QTreeWidgetItem ì¶”ê°€

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.services.template_service import TemplateService
from core.services.state_service import StateService
from core.pydantic_models.app_state import AppState

# MainWindowëŠ” íƒ€ì… íŒíŠ¸ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

class ResourceController:
    """
    Handles logic related to resource management (templates and states).
    """
    def __init__(self, main_window: 'MainWindow', template_service: TemplateService, state_service: StateService):
        self.mw = main_window
        self.template_service = template_service
        self.state_service = state_service

    def load_templates_list(self):
        """Loads the list of templates or states into the resource tree."""
        self.mw.template_tree.clear() # íŠ¸ë¦¬ ì´ˆê¸°í™”
        current_mode = self.mw.resource_mode_combo.currentText()

        if current_mode == "í”„ë¡¬í”„íŠ¸":
            system_templates = self.template_service.list_templates("prompts/system")
            user_templates = self.template_service.list_templates("prompts/user")

            system_item = self.mw.create_tree_item("System")
            user_item = self.mw.create_tree_item("User")
            for st in sorted(system_templates): self.mw.create_tree_item(st, system_item)
            for ut in sorted(user_templates): self.mw.create_tree_item(ut, user_item)
            system_item.setExpanded(True)
            user_item.setExpanded(True)

        elif current_mode == "ìƒíƒœ":
            states_list = self.state_service.list_states()
            states_item = self.mw.create_tree_item("States")
            for st_file in sorted(states_list): self.mw.create_tree_item(st_file, states_item)
            states_item.setExpanded(True)

        self.update_buttons_label() # ë²„íŠ¼ ë ˆì´ë¸” ì—…ë°ì´íŠ¸

    def load_selected_item(self):
        """Loads the selected template or state."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return

        filename = item.text(0)

        if current_mode == "í”„ë¡¬í”„íŠ¸":
            parent_text = item.parent().text(0)
            relative_path = ""
            target_tab = None
            if parent_text == "System":
                relative_path = os.path.join("prompts", "system", filename)
                target_tab = self.mw.system_tab
            elif parent_text == "User":
                relative_path = os.path.join("prompts", "user", filename)
                target_tab = self.mw.user_tab

            if relative_path and target_tab:
                content = self.template_service.load_template(relative_path)
                target_tab.setText(content)
                self.mw.status_bar.showMessage(f"Loaded {parent_text.lower()} template: {filename}")

        elif current_mode == "ìƒíƒœ":
            fname_no_ext = os.path.splitext(filename)[0]
            loaded_state = self.state_service.load_state(fname_no_ext)
            if loaded_state:
                # ìƒíƒœ ë¡œë“œ ì‹œ ì „ì²´ ë¡œë“œë¡œ ê°„ì£¼ (partial_load=False)
                self.mw.set_current_state(loaded_state, partial_load=False)
            else:
                QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ìƒíƒœ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")

    def save_current_as_item(self):
        """Saves the current prompt or state as a new item."""
        current_mode = self.mw.resource_mode_combo.currentText()

        if current_mode == "í”„ë¡¬í”„íŠ¸":
            template_type = self.mw.template_type_combo.currentText()
            content = ""
            target_dir_relative = ""
            source_tab = None
            if template_type == "ì‹œìŠ¤í…œ":
                source_tab = self.mw.system_tab
                target_dir_relative = os.path.join("prompts", "system")
            else: # ì‚¬ìš©ì
                source_tab = self.mw.user_tab
                target_dir_relative = os.path.join("prompts", "user")

            content = source_tab.toPlainText()
            if not content.strip():
                 QMessageBox.warning(self.mw, "ê²½ê³ ", "ì €ì¥í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.")
                 return

            fname, ok = QInputDialog.getText(self.mw, "í…œí”Œë¦¿ ì €ì¥", "í…œí”Œë¦¿ íŒŒì¼ ì´ë¦„(í™•ì¥ì ì œì™¸)ì„ ì…ë ¥í•˜ì„¸ìš”:")
            if not ok or not fname or not fname.strip(): return
            fname_stripped = fname.strip()
            fname_md = fname_stripped + ".md"
            relative_path = os.path.join(target_dir_relative, fname_md)

            if self.template_service.save_template(relative_path, content):
                self.mw.status_bar.showMessage(f"Template saved: {fname_md}")
                self.load_templates_list()
            else:
                 QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "í…œí”Œë¦¿ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

        elif current_mode == "ìƒíƒœ":
            current_state = self.mw.get_current_state()
            fname, ok = QInputDialog.getText(self.mw, "ìƒíƒœ ì €ì¥", "ìƒíƒœ íŒŒì¼ ì´ë¦„(í™•ì¥ì ì œì™¸)ì„ ì…ë ¥í•˜ì„¸ìš”:")
            if not ok or not fname or not fname.strip(): return
            fname_stripped = fname.strip()

            if self.state_service.save_state(current_state, fname_stripped):
                self.mw.status_bar.showMessage(f"State saved: {fname_stripped}.json")
                self.load_templates_list()
            else:
                QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ìƒíƒœ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

    def delete_selected_item(self):
        """Deletes the selected template or state file."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return

        filename = item.text(0)
        parent_text = item.parent().text(0)

        reply = QMessageBox.question(self.mw, "ì‚­ì œ í™•ì¸", f"ì •ë§ë¡œ '{filename}'ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        deleted = False
        if current_mode == "í”„ë¡¬í”„íŠ¸":
            relative_path = ""
            if parent_text == "System":
                relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User":
                relative_path = os.path.join("prompts", "user", filename)
            if relative_path:
                deleted = self.template_service.delete_template(relative_path)
        elif current_mode == "ìƒíƒœ":
            fname_no_ext = os.path.splitext(filename)[0]
            deleted = self.state_service.delete_state(fname_no_ext)

        if deleted:
            self.mw.status_bar.showMessage(f"Deleted: {filename}")
            self.load_templates_list()
        else:
            QMessageBox.warning(self.mw, "ì˜¤ë¥˜", f"'{filename}' ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

    def update_current_item(self):
        """Updates the selected template or state file with the current content/state."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return

        filename = item.text(0)
        parent_text = item.parent().text(0)

        reply = QMessageBox.question(self.mw, "ì—…ë°ì´íŠ¸ í™•ì¸", f"'{filename}'ì˜ ë‚´ìš©ì„ í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ë‚´ìš©ìœ¼ë¡œ ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.Yes) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        updated = False
        if current_mode == "í”„ë¡¬í”„íŠ¸":
            content = ""
            relative_path = ""
            source_tab = None
            if parent_text == "System":
                source_tab = self.mw.system_tab
                relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User":
                source_tab = self.mw.user_tab
                relative_path = os.path.join("prompts", "user", filename)

            if relative_path and source_tab:
                content = source_tab.toPlainText()
                updated = self.template_service.save_template(relative_path, content)
        elif current_mode == "ìƒíƒœ":
            current_state = self.mw.get_current_state()
            fname_no_ext = os.path.splitext(filename)[0]
            updated = self.state_service.save_state(current_state, fname_no_ext)

        if updated:
            self.mw.status_bar.showMessage(f"Updated: {filename}")
        else:
            QMessageBox.warning(self.mw, "ì˜¤ë¥˜", f"'{filename}' ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

    def save_state_to_default(self):
        """Saves the current state to the default state file ('default.json')."""
        state = self.mw.get_current_state()
        if self.state_service.save_state(state, "default"):
            self.mw.status_bar.showMessage("í˜„ì¬ ì‘ì—… ìë™ ì €ì¥ ì™„ë£Œ!")
        else:
            # ìë™ ì €ì¥ì€ ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ë„ìš°ì§€ ì•ŠìŒ (ë¡œê·¸ë¡œ ëŒ€ì²´ ê°€ëŠ¥)
            print("Error: Failed to auto-save state to default.json")
            # QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ê¸°ë³¸ ìƒíƒœ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

    def load_state_from_default(self):
        """
        Loads the state from the default state file ('default.json').
        Uses partial_load=True to only load specific fields.
        """
        state = self.state_service.load_state("default")
        if state:
            # ë¶€ë¶„ ë¡œë“œ í”Œë˜ê·¸ë¥¼ Trueë¡œ ì„¤ì •í•˜ì—¬ set_current_state í˜¸ì¶œ
            self.mw.set_current_state(state, partial_load=True)
        else:
             # íŒŒì¼ì´ ì—†ê±°ë‚˜ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ìµœì´ˆ ì‹¤í–‰ ë“±)
             QMessageBox.information(self.mw, "ì •ë³´", "ì €ì¥ëœ ì´ì „ ì‘ì—… ìƒíƒœ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def export_state_to_file(self):
        """Exports the current state to a user-selected file."""
        path, _ = QFileDialog.getSaveFileName(self.mw, "ìƒíƒœ ë‚´ë³´ë‚´ê¸°", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            state = self.mw.get_current_state()
            if self.state_service.export_state_to_file(state, path):
                self.mw.status_bar.showMessage("ìƒíƒœ ë‚´ë³´ë‚´ê¸° ì™„ë£Œ!")
            else:
                QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ìƒíƒœ ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

    def import_state_from_file(self):
        """Imports state from a user-selected file."""
        path, _ = QFileDialog.getOpenFileName(self.mw, "ìƒíƒœ ê°€ì ¸ì˜¤ê¸°", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            state = self.state_service.import_state_from_file(path)
            if state:
                # ìƒíƒœ ê°€ì ¸ì˜¤ê¸°ëŠ” ì „ì²´ ë¡œë“œë¡œ ê°„ì£¼ (partial_load=False)
                self.mw.set_current_state(state, partial_load=False)
            else:
                 QMessageBox.warning(self.mw, "ì˜¤ë¥˜", "ìƒíƒœ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆê±°ë‚˜ íŒŒì¼ ë‚´ìš©ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

    # ë°±ì—…/ë³µì› ê´€ë ¨ ë©”ì„œë“œ ì œê±°
    # def backup_all_states_action(self): ...
    # def restore_states_from_backup_action(self): ...

    def update_buttons_label(self):
        """Updates the labels of buttons in the resource manager section based on the mode."""
        current_mode = self.mw.resource_mode_combo.currentText()
        is_prompt_mode = (current_mode == "í”„ë¡¬í”„íŠ¸")

        self.mw.load_selected_template_btn.setText(f"ğŸ“¥ ì„ íƒí•œ {current_mode} ë¶ˆëŸ¬ì˜¤ê¸°")
        self.mw.save_as_template_btn.setText(f"ğŸ’¾ í˜„ì¬ {current_mode}ë¡œ ì €ì¥")
        self.mw.delete_template_btn.setText(f"âŒ ì„ íƒí•œ {current_mode} ì‚­ì œ")
        self.mw.update_template_btn.setText(f"ğŸ”„ í˜„ì¬ {current_mode} ì—…ë°ì´íŠ¸")

        # ë°±ì—…/ë³µì› ë²„íŠ¼ ê´€ë ¨ ì½”ë“œ ì œê±°
        # self.mw.backup_button.setEnabled(not is_prompt_mode)
        # self.mw.restore_button.setEnabled(not is_prompt_mode)
        # self.mw.backup_button.setText("ğŸ“¦ ëª¨ë“  ìƒíƒœ ë°±ì—…" + (" (ë¹„í™œì„±í™”)" if is_prompt_mode else ""))
        # self.mw.restore_button.setText("ğŸ”™ ë°±ì—…ì—ì„œ ìƒíƒœ ë³µì›" + (" (ë¹„í™œì„±í™”)" if is_prompt_mode else ""))

        self.mw.template_type_combo.setVisible(is_prompt_mode)
        self.mw.template_type_label.setVisible(is_prompt_mode)




======== src\ui\controllers\system_prompt_controller.py ========

import os
from PyQt6.QtWidgets import QFileDialog, QMessageBox, QWidget # PyQt5 -> PyQt6

# ë³€ê²½ëœ ê²½ë¡œì—ì„œ import
from utils.helpers import get_resource_path, get_project_root
from core.services.config_service import ConfigService # ConfigService import

# MainWindow íƒ€ì… íŒíŠ¸
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from ui.main_window import MainWindow

# í•¨ìˆ˜ í˜•íƒœë¡œ ìœ ì§€ (MainWindow ë˜ëŠ” SettingsDialogì—ì„œ í˜¸ì¶œ)
def apply_default_system_prompt(main_window: 'MainWindow'):
    """
    Loads the default system prompt specified in config.yml into the system_tab.
    Handles both relative (to project root) and absolute paths.
    """
    # MainWindowê°€ ê°€ì§€ê³  ìˆëŠ” ConfigService ì‚¬ìš©
    if not hasattr(main_window, 'config_service'):
        print("Error: ConfigService not found in MainWindow.")
        return

    config_service: ConfigService = main_window.config_service
    settings = config_service.get_settings()
    default_system_prompt_path_str = settings.default_system_prompt
    prompt_source = ""
    prompt_path = "" # Initialize prompt_path

    if default_system_prompt_path_str:
        prompt_path_input = default_system_prompt_path_str
        # ì„¤ì • íŒŒì¼ì˜ ê²½ë¡œëŠ” í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ ë˜ëŠ” ì ˆëŒ€ ê²½ë¡œë¡œ ê°„ì£¼
        if not os.path.isabs(prompt_path_input):
             # ìƒëŒ€ ê²½ë¡œì¼ ê²½ìš° í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê¸°ì¤€ìœ¼ë¡œ ì ˆëŒ€ ê²½ë¡œ ìƒì„±
             try:
                 project_root = get_project_root()
                 prompt_path = str(project_root / prompt_path_input)
                 prompt_source = f"config.yml (relative: {prompt_path_input})"
             except Exception as e:
                 print(f"Error resolving relative path '{prompt_path_input}': {e}")
                 main_window.status_bar.showMessage(f"ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒëŒ€ ê²½ë¡œ ì˜¤ë¥˜: {prompt_path_input}")
                 return
        else:
            # ì ˆëŒ€ ê²½ë¡œì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
            prompt_path = prompt_path_input
            prompt_source = f"config.yml (absolute: {os.path.basename(prompt_path_input)})"
    else:
        # ì„¤ì •ê°’ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’(XML Guide) ì‚¬ìš© ì‹œë„
        default_path_relative = os.path.join("prompts", "system", "XML_Prompt_Guide.md")
        try:
            prompt_path = get_resource_path(default_path_relative)
            prompt_source = f"Default ({os.path.basename(default_path_relative)})"
            print(f"default_system_prompt not set in config, attempting to load default: {default_path_relative}")
        except Exception as e:
             print(f"Error getting resource path for default prompt: {e}")
             main_window.status_bar.showMessage("ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
             return

    # íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    if not prompt_path or not os.path.exists(prompt_path):
        print(f"Default system prompt file not found at resolved path: {prompt_path}")
        main_window.status_bar.showMessage(
            f"ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì—†ìŒ: {os.path.basename(default_system_prompt_path_str or 'Default')}"
        )
        return

    # íŒŒì¼ ë¡œë“œ ë° UI ì—…ë°ì´íŠ¸
    try:
        with open(prompt_path, "r", encoding="utf-8") as f:
            content = f.read()
        main_window.system_tab.setText(content)
        print(f"Default system prompt loaded from: {prompt_path}")
        main_window.status_bar.showMessage(f"ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ë¡œë“œ ì™„ë£Œ: {prompt_source}")
    except Exception as e:
        print(f"Error loading default system prompt file '{prompt_path}': {e}")
        main_window.status_bar.showMessage(f"ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: {str(e)}")


def select_default_system_prompt(config_service: ConfigService, parent_widget: Optional[QWidget] = None) -> Optional[str]:
    """
    Opens a file dialog to select a default system prompt file (.md, .txt).
    Returns the path to be saved (relative to project root if possible, otherwise absolute).

    Args:
        config_service: The ConfigService instance.
        parent_widget: The parent widget for the file dialog.

    Returns:
        The path string to be saved in config.yml, or None if cancelled.
    """
    settings = config_service.get_settings()
    current_path_str = settings.default_system_prompt
    initial_dir = os.path.expanduser("~") # Default initial directory

    # Determine initial directory for file dialog
    try:
        project_root = get_project_root()
        # Try to resolve current path (relative or absolute)
        if current_path_str:
            resolved_path = current_path_str
            if not os.path.isabs(current_path_str):
                resolved_path = str(project_root / current_path_str)

            if os.path.exists(resolved_path):
                initial_dir = os.path.dirname(resolved_path)
            elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
                 initial_dir = str(project_root / "resources" / "prompts" / "system")
        elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
             initial_dir = str(project_root / "resources" / "prompts" / "system")
    except Exception as e:
        print(f"Error determining initial directory: {e}")
        # Fallback to user home if error occurs

    path, _ = QFileDialog.getOpenFileName(
        parent_widget, # ë¶€ëª¨ ìœ„ì ¯ ì „ë‹¬
        "ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì„ íƒ",
        initial_dir,
        "Text/Markdown Files (*.txt *.md);;All Files (*.*)"
    )

    if path:
        try:
            # ê²½ë¡œë¥¼ í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œë¡œ ë³€í™˜ ì‹œë„
            project_root_str = str(get_project_root())
            # Use os.path.normpath and os.path.abspath for reliable comparison
            abs_path = os.path.abspath(path)
            abs_project_root = os.path.abspath(project_root_str)

            if abs_path.startswith(abs_project_root):
                # Calculate relative path and normalize separators to forward slashes
                relative_path = os.path.relpath(abs_path, abs_project_root).replace(os.sep, '/')
                print(f"Default system prompt selected (relative path): {relative_path}")
                return relative_path
            else:
                # í”„ë¡œì íŠ¸ ì™¸ë¶€ëŠ” ì •ê·œí™”ëœ ì ˆëŒ€ ê²½ë¡œ ì €ì¥ (forward slashes)
                absolute_path_normalized = abs_path.replace(os.sep, '/')
                print(f"Default system prompt selected (absolute path): {absolute_path_normalized}")
                QMessageBox.information(parent_widget, "ì •ë³´", "í”„ë¡œì íŠ¸ ì™¸ë¶€ ê²½ë¡œëŠ” ì ˆëŒ€ ê²½ë¡œë¡œ ì €ì¥ë©ë‹ˆë‹¤.")
                return absolute_path_normalized

        except Exception as e:
            print(f"Error processing selected path: {e}")
            QMessageBox.warning(
                parent_widget,
                "ì˜¤ë¥˜",
                f"ê²½ë¡œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}"
            )
            return None
    return None # ì‚¬ìš©ìê°€ ì·¨ì†Œí•œ ê²½ìš°




======== src\ui\controllers\xml_controller.py ========

import os
from PyQt6.QtWidgets import QMessageBox # PyQt5 -> PyQt6

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.services.xml_service import XmlService

# MainWindowëŠ” íƒ€ì… íŒíŠ¸ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .file_tree_controller import FileTreeController # refresh_tree í˜¸ì¶œìš©

class XmlController:
    """
    Handles logic related to XML parsing and applying file changes.
    """
    def __init__(self, main_window: 'MainWindow', xml_service: XmlService):
        self.mw = main_window
        self.xml_service = xml_service
    def run_xml_parser(self):
        """Parses XML input and applies changes to the project files."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” XML íŒŒì„œ ê¸°ëŠ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.")
            return

        xml_str = ""
        if hasattr(self.mw, "xml_input_tab"):
            xml_str = self.mw.xml_input_tab.toPlainText()
        if not xml_str.strip():
            self.mw.status_bar.showMessage("XML ë‚´ìš©ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.")
            return

        project_dir = self.mw.current_project_folder
        if not project_dir or not os.path.isdir(project_dir):
            QMessageBox.warning(self.mw, "ê²½ê³ ", "í”„ë¡œì íŠ¸ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.")
            return

        try:
            result = self.xml_service.apply_changes_from_xml(xml_str, project_dir)
        except Exception as e:
             QMessageBox.critical(self.mw, "XML íŒŒì‹± ì˜¤ë¥˜", f"XML ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")
             if hasattr(self.mw, 'file_tree_controller'):
                 self.mw.file_tree_controller.refresh_tree() # ì˜¤ë¥˜ ì‹œì—ë„ ìƒˆë¡œê³ ì¹¨
             return

        messages = []
        if result["created"]: messages.append("ìƒì„±ëœ íŒŒì¼:\n" + "\n".join(result["created"]))
        if result["updated"]: messages.append("ìˆ˜ì •ëœ íŒŒì¼:\n" + "\n".join(result["updated"]))
        if result["deleted"]: messages.append("ì‚­ì œëœ íŒŒì¼:\n" + "\n".join(result["deleted"]))
        if result["errors"]: messages.append("ì˜¤ë¥˜:\n" + "\n".join(result["errors"]))
        if not messages: messages.append("ë³€ê²½ ì‚¬í•­ ì—†ìŒ.")

        final_message = "\n\n".join(messages)

        if result["errors"]:
            QMessageBox.warning(self.mw, "XML íŒŒì‹± ê²°ê³¼ (ì˜¤ë¥˜ ë°œìƒ)", final_message)
        else:
            QMessageBox.information(self.mw, "XML íŒŒì‹± ê²°ê³¼", final_message)

        # íŒŒì¼ ë³€ê²½ í›„ íŠ¸ë¦¬ ìƒˆë¡œê³ ì¹¨ (FileTreeController í†µí•´)
        if hasattr(self.mw, 'file_tree_controller'):
            self.mw.file_tree_controller.refresh_tree()
        self.mw.status_bar.showMessage("XML íŒŒì‹± ì™„ë£Œ!")




======== src\ui\models\__init__.py ========
# This file makes Python treat the directory models as a package.



======== src\ui\models\file_system_models.py ========
import os
import fnmatch
from PyQt6.QtCore import QSortFilterProxyModel, Qt, QModelIndex, QFileInfo # QFileInfo ì¶”ê°€
from PyQt6.QtGui import QFileSystemModel
from PyQt6.QtWidgets import QTreeView
from typing import Callable, Optional, Set, List, Dict, Any # List, Dict, Any ì¶”ê°€
from core.services.filesystem_service import FilesystemService
import logging

logger = logging.getLogger(__name__)

class FilteredFileSystemModel(QFileSystemModel):
    """
    Custom file system model using Qt's default lazy loading behavior.
    The eager recursive loading (_fetch_all_recursively) has been removed
    to improve performance on large or remote directories.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        # Lazy loading is the default behavior, no extra options needed here.
        # Options like DontWatchForChanges can be set if needed, but might affect responsiveness.
        # self.setOption(QFileSystemModel.Option.DontWatchForChanges, True) # Example if needed

    def setRootPathFiltered(self, path: str) -> QModelIndex:
        """
        Sets the root path for the model. Lazy loading will occur as needed
        when the view requests more data (e.g., expanding a directory).
        """
        logger.info(f"Setting root path (lazy loading enabled): {path}")
        # Simply call the base class method. Qt handles fetching as needed.
        root_index = super().setRootPath(path)
        # The _fetch_all_recursively call is removed.
        return root_index

    # _fetch_all_recursively method is removed entirely.


class CheckableProxyModel(QSortFilterProxyModel):
    """
    Proxy model that provides checkable items and filters based on ignore patterns.
    Handles recursive checking for folders and multi-selection checking.
    Optimized to reduce filesystem access in `data` and `filterAcceptsRow`.
    """
    def __init__(self, fs_model: FilteredFileSystemModel, project_folder_getter: Callable[[], Optional[str]], fs_service: FilesystemService, tree_view: QTreeView, parent=None):
        super().__init__(parent)
        self.fs_model = fs_model
        self.project_folder_getter = project_folder_getter
        self.fs_service = fs_service
        self.tree_view = tree_view
        self.checked_files_dict: Dict[str, bool] = {} # {file_path: bool} - Stores the check state
        self._ignore_patterns: Set[str] = set()
        self._is_setting_data = False # ì¬ê·€ì  setData í˜¸ì¶œ ë°©ì§€ í”Œë˜ê·¸

    def set_ignore_patterns(self, patterns: Set[str]):
        """Sets the ignore patterns used for filtering."""
        if self._ignore_patterns != patterns:
            self._ignore_patterns = patterns
            logger.info(f"Ignore patterns updated. Invalidating filter.")
            self.invalidateFilter()

    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool:
        """
        Determines if a row should be shown based on ignore patterns.
        Uses QFileInfo for potentially cached attributes.
        """
        source_index = self.sourceModel().index(source_row, 0, source_parent)
        if not source_index.isValid():
            return False

        # Use QFileInfo provided by the source model, which might cache attributes.
        file_info: QFileInfo = self.sourceModel().fileInfo(source_index)
        file_path = file_info.filePath() # Get absolute path
        is_dir = file_info.isDir()

        project_root = self.project_folder_getter()

        # Allow items outside the project root or the root itself
        if not project_root or not file_path.startswith(project_root) or file_path == project_root:
            return True

        # Check against ignore patterns using the FilesystemService
        # This call is now potentially faster as is_dir is obtained from QFileInfo.
        if self.fs_service.should_ignore(file_path, project_root, self._ignore_patterns, is_dir):
            if file_path in self.checked_files_dict:
                # Remove filtered items from the check state dictionary
                logger.debug(f"Removing filtered item from checked_files_dict: {file_path}")
                del self.checked_files_dict[file_path]
            # logger.debug(f"Ignoring item: {file_path}") # Can be verbose
            return False

        return True

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """
        Returns data for the item, including check state.
        Removed file size calculation for performance.
        """
        if not index.isValid():
            return None

        if index.column() == 0:
            if role == Qt.ItemDataRole.CheckStateRole:
                file_path = self.get_file_path_from_index(index)
                is_checked = self.checked_files_dict.get(file_path, False)
                return Qt.CheckState.Checked if is_checked else Qt.CheckState.Unchecked
            elif role == Qt.ItemDataRole.DisplayRole:
                # Return only the base name, removing the size calculation.
                return super().data(index, role)
                # --- Removed file size calculation ---
                # base_name = super().data(index, role)
                # src_index = self.mapToSource(index)
                # if src_index.isValid() and not self.fs_model.isDir(src_index):
                #     file_path = self.fs_model.filePath(src_index)
                #     try:
                #         # This os.path.getsize call is expensive on network drives.
                #         size = os.path.getsize(file_path)
                #         return f"{base_name} ({size:,} bytes)"
                #     except OSError:
                #         return f"{base_name} (size error)"
                # return base_name
                # --- End of removal ---

        return super().data(index, role)

    def flags(self, index: QModelIndex) -> Qt.ItemFlag:
        """Returns item flags, adding ItemIsUserCheckable."""
        flags = super().flags(index)
        if index.column() == 0:
            # Ensure items are enabled, checkable, and selectable
            flags |= Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsSelectable
        return flags

    def setData(self, index: QModelIndex, value: Any, role: int = Qt.ItemDataRole.EditRole) -> bool:
        """
        Sets data for the item, handling check state changes, including multi-select and folder recursion.
        Removed calls to ensure_loaded as lazy loading is now used.
        """
        # ì¬ê·€ í˜¸ì¶œ ë°©ì§€ í”Œë˜ê·¸ ì²´í¬
        if self._is_setting_data:
            logger.debug(f"setData blocked by flag for index: {self.get_file_path_from_index(index)}")
            return False
        # ì²´í¬ ìƒíƒœ ì—­í•  ë° 0ë²ˆ ì»¬ëŸ¼ì¸ì§€ í™•ì¸
        if index.column() != 0 or role != Qt.ItemDataRole.CheckStateRole:
            return super().setData(index, value, role)

        file_path = self.get_file_path_from_index(index)
        if not file_path:
            logger.warning(f"setData failed: Could not get file path for index {index.row()},{index.column()}")
            return False

        logger.debug(f"â–¶ setData called: path={file_path}, role={role}, value={value}")
        self._is_setting_data = True # í”Œë˜ê·¸ ì„¤ì •
        try:
            # PyQt6ì—ì„œëŠ” valueê°€ CheckState enum ê°’ì¼ ìˆ˜ ìˆìŒ
            if isinstance(value, Qt.CheckState):
                new_check_state = value
            elif isinstance(value, int): # Fallback for integer
                new_check_state = Qt.CheckState(value)
            else:
                logger.warning(f"setData: Unexpected value type for CheckStateRole: {type(value)}")
                self._is_setting_data = False
                return False

            is_checked = (new_check_state == Qt.CheckState.Checked)
            # Use get() with default False for cleaner check
            current_state_in_dict = self.checked_files_dict.get(file_path, False)

            # ìƒíƒœê°€ ì‹¤ì œë¡œ ë³€ê²½ë˜ëŠ” ê²½ìš°ì—ë§Œ ì²˜ë¦¬
            if is_checked == current_state_in_dict:
                logger.debug(f"setData: No state change needed for {file_path}. Current: {current_state_in_dict}, New: {is_checked}")
                self._is_setting_data = False
                return True # ìƒíƒœ ë³€ê²½ ì—†ì–´ë„ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬

            logger.debug(f"setData processing state change for: {file_path}, New state: {is_checked}")

            # ìƒíƒœ ë”•ì…”ë„ˆë¦¬ ì—…ë°ì´íŠ¸
            if is_checked:
                self.checked_files_dict[file_path] = True
            elif file_path in self.checked_files_dict:
                # ì²´í¬ í•´ì œ ì‹œ ë”•ì…”ë„ˆë¦¬ì—ì„œ ì œê±°
                del self.checked_files_dict[file_path]
                logger.debug(f"  Item unchecked and removed from checked_files_dict: {file_path}")

            # ë³€ê²½ëœ ì¸ë±ìŠ¤ ëª©ë¡ ì´ˆê¸°í™”
            indices_to_signal = {index} # ìê¸° ìì‹  í¬í•¨

            # í´ë”ì¸ ê²½ìš° í•˜ìœ„ í•­ëª© ì²˜ë¦¬
            src_index = self.mapToSource(index)
            if src_index.isValid() and self.fs_model.isDir(src_index):
                logger.debug(f"  {file_path} is a directory. Updating children...")
                # ensure_loaded call removed - rely on lazy loading
                # self.ensure_loaded(src_index) # í•˜ìœ„ í•­ëª© ë¡œë“œ ë³´ì¥ (REMOVED)

                # update_children_state í˜¸ì¶œí•˜ì—¬ í•˜ìœ„ í•­ëª© ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ë³€ê²½ëœ ì¸ë±ìŠ¤ ë°›ê¸°
                # This might only affect already loaded children due to lazy loading.
                changed_children_indices = self.update_children_state(src_index, is_checked)
                indices_to_signal.update(changed_children_indices) # ë³€ê²½ëœ í•˜ìœ„ ì¸ë±ìŠ¤ ì¶”ê°€
                logger.debug(f"  Finished updating children for {file_path}. Total signals needed: {len(indices_to_signal)}")

                # í´ë”ê°€ ì²´í¬ë˜ì—ˆì„ ë•Œ í™•ì¥ (ì„ íƒì )
                if is_checked:
                    logger.debug(f"  Expanding checked folder: {file_path}")
                    self.expand_index_recursively(index)

            # dataChanged ì‹œê·¸ë„ ë°œìƒ (ë³€ê²½ëœ ëª¨ë“  ì¸ë±ìŠ¤ì— ëŒ€í•´)
            logger.debug(f"Emitting dataChanged for {len(indices_to_signal)} indices.")
            for idx_to_signal in indices_to_signal:
                if idx_to_signal.isValid():
                    logger.debug(f"    Emitting for: {self.get_file_path_from_index(idx_to_signal)}")
                    # dataChanged ì‹œê·¸ë„ ë°œìƒì‹œì¼œ UI ì—…ë°ì´íŠ¸
                    self.dataChanged.emit(idx_to_signal, idx_to_signal, [Qt.ItemDataRole.CheckStateRole])

            logger.debug(f"setData returning True for path: {file_path}")
            return True # ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë¨

        except Exception as e:
            logger.exception(f"Error in setData for path {file_path}: {e}")
            return False # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì‹¤íŒ¨ ë°˜í™˜
        finally:
            logger.debug("setData finished. Releasing flag.")
            self._is_setting_data = False # í”Œë˜ê·¸ í•´ì œ

    # ensure_loaded method is removed as it relied on _fetch_all_recursively.

    def update_children_state(self, parent_src_index: QModelIndex, checked: bool) -> Set[QModelIndex]:
        """
        Recursively updates check state for all *currently loaded* visible children
        based on the 'checked' parameter. Updates the internal dictionary and
        returns a set of *proxy* indices whose state was changed.
        Due to lazy loading, this might not affect children that haven't been fetched yet.
        """
        changed_indices = set()
        # Check if the source model has fetched children for this parent
        if not self.fs_model.hasChildren(parent_src_index):
             # If it has children but they aren't fetched, rowCount might be 0 initially.
             # We might need to fetch them first if we want to update them immediately.
             # However, for performance, we'll only update loaded children.
             # If canFetchMore is true, it means children exist but aren't loaded.
             # logger.debug(f"    update_children_state: Parent {self.fs_model.filePath(parent_src_index)} has no loaded children.")
             pass # Continue without fetching for performance

        row_count = self.fs_model.rowCount(parent_src_index)
        parent_path = self.fs_model.filePath(parent_src_index)
        # logger.debug(f"    update_children_state for {parent_path}, checked={checked}, loaded children={row_count}")

        for row in range(row_count):
            child_src_index = self.fs_model.index(row, 0, parent_src_index)
            if not child_src_index.isValid(): continue

            child_proxy_index = self.mapFromSource(child_src_index)
            # í•„í„°ë§ë˜ì–´ ë³´ì´ì§€ ì•ŠëŠ” í•­ëª©ì€ ê±´ë„ˆëœ€
            if not child_proxy_index.isValid():
                # logger.debug(f"      Skipping filtered child: {self.fs_model.filePath(child_src_index)}")
                continue

            file_path = self.fs_model.filePath(child_src_index)
            current_state_in_dict = self.checked_files_dict.get(file_path, False)
            needs_update = (checked != current_state_in_dict)

            if needs_update:
                if checked:
                    self.checked_files_dict[file_path] = True
                elif file_path in self.checked_files_dict:
                    # ì²´í¬ í•´ì œ ì‹œ ë”•ì…”ë„ˆë¦¬ì—ì„œ ì œê±°
                    del self.checked_files_dict[file_path]
                    logger.debug(f"      Child unchecked and removed from checked_files_dict: {file_path}")
                changed_indices.add(child_proxy_index) # ë³€ê²½ëœ í”„ë¡ì‹œ ì¸ë±ìŠ¤ ì¶”ê°€
                # logger.debug(f"      Child state changed: {file_path}, Added proxy index.")

            # í•˜ìœ„ í´ë” ì¬ê·€ í˜¸ì¶œ (í´ë”ì¸ ê²½ìš°ì—ë§Œ)
            if self.fs_model.isDir(child_src_index):
                # ensure_loaded call removed
                # self.ensure_loaded(child_src_index) # í•˜ìœ„ í•­ëª© ë¡œë“œ ë³´ì¥ (REMOVED)
                grandchildren_indices = self.update_children_state(child_src_index, checked)
                changed_indices.update(grandchildren_indices) # ì¬ê·€ì ìœ¼ë¡œ ë³€ê²½ëœ ì¸ë±ìŠ¤ ì¶”ê°€

        # logger.debug(f"    Finished update_children_state for {parent_path}. Returning {len(changed_indices)} changed indices.")
        return changed_indices


    def expand_index_recursively(self, proxy_index: QModelIndex):
        """Recursively expands the given index and its children in the tree view."""
        if not proxy_index.isValid(): return

        self.tree_view.expand(proxy_index)
        # With lazy loading, rowCount might be 0 until children are fetched.
        # Expanding might trigger fetching, but we might need to wait or re-check.
        # For simplicity, we only recurse if children are already loaded.
        child_count = self.rowCount(proxy_index)
        for row in range(child_count):
            child_proxy_idx = self.index(row, 0, proxy_index)
            if child_proxy_idx.isValid():
                 child_src_idx = self.mapToSource(child_proxy_idx)
                 if self.fs_model.isDir(child_src_idx):
                      self.expand_index_recursively(child_proxy_idx)


    def get_file_path_from_index(self, proxy_index: QModelIndex) -> Optional[str]:
        """Gets the file path from a proxy index."""
        src_index = self.mapToSource(proxy_index)
        if src_index.isValid():
            # ì ˆëŒ€ ê²½ë¡œ ë°˜í™˜
            return self.fs_model.filePath(src_index)
        return None

    def get_all_checked_paths(self) -> List[str]:
        """Returns a list of all paths currently marked as checked."""
        logger.debug(f"get_all_checked_paths called. Returning {len(self.checked_files_dict)} paths.")
        return list(self.checked_files_dict.keys())


    def get_checked_files(self) -> List[str]:
        """
        Returns a list of checked paths that correspond to actual files.
        Uses os.path.isfile, which might be slow on network drives.
        Consider caching or alternative approach if this becomes a bottleneck.
        """
        # This check might still be slow on network drives.
        # If performance is still an issue, consider storing type (file/dir)
        # in checked_files_dict when items are checked.
        checked_files = []
        for path in self.checked_files_dict.keys():
            try:
                # Use QFileInfo from source model for potentially cached type info
                src_index = self.fs_model.index(path)
                if src_index.isValid():
                    file_info: QFileInfo = self.fs_model.fileInfo(src_index)
                    if file_info.isFile():
                        checked_files.append(path)
                else:
                    # Fallback to os.path.isfile if index is invalid (less likely)
                    if os.path.isfile(path):
                        checked_files.append(path)
            except OSError as e:
                logger.warning(f"Error checking if path is file in get_checked_files: {path}, Error: {e}")

        logger.debug(f"get_checked_files called. Returning {len(checked_files)} file paths.")
        return checked_files



======== src\ui\widgets\__init__.py ========
# This file makes Python treat the directory widgets as a package.



======== src\ui\widgets\check_box_delegate.py ========

# src/ui/widgets/check_box_delegate.py
from PyQt6.QtCore import Qt, QEvent, QRect, QModelIndex, QAbstractItemModel
from PyQt6.QtWidgets import QStyledItemDelegate, QApplication, QStyleOptionViewItem, QWidget, QStyle
from PyQt6.QtGui import QMouseEvent
import logging

logger = logging.getLogger(__name__)

class CheckBoxDelegate(QStyledItemDelegate):
    """
    ì²´í¬ë°•ìŠ¤ ì˜ì—­ì„ í´ë¦­í–ˆì„ ë•Œë§Œ ì²´í¬ ìƒíƒœ í† ê¸€ì„ ì²˜ë¦¬í•˜ëŠ” Delegate
    """
    def __init__(self, parent: QWidget = None):
        super().__init__(parent)

    def editorEvent(self, event: QEvent, model: QAbstractItemModel, option: QStyleOptionViewItem, index: QModelIndex) -> bool:
        """
        ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ì—¬ ì²´í¬ë°•ìŠ¤ ì˜ì—­ í´ë¦­ ì‹œ ëª¨ë¸ ë°ì´í„°ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        """
        # ì²´í¬ë°•ìŠ¤ëŠ” 0ë²ˆ ì»¬ëŸ¼ì—ë§Œ ìˆìœ¼ë‹ˆ, ê·¸ ì™¸ ì»¬ëŸ¼ì€ ê¸°ë³¸ ë™ì‘
        if index.column() != 0:
            return super().editorEvent(event, model, option, index)

        # ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸ì´ê³ , ì™¼ìª½ ë²„íŠ¼ì¼ ë•Œë§Œ ë°˜ì‘
        if event.type() == QEvent.Type.MouseButtonRelease and isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            # ì²´í¬ë°•ìŠ¤ ì‚¬ê°ì˜ì—­ ê³„ì‚°
            style = QApplication.style() if self.parent() is None else self.parent().style()
            cb_rect = style.subElementRect(QStyle.SubElement.SE_ItemViewItemCheckIndicator, option, self.parent())

            # ë§ˆìš°ìŠ¤ í´ë¦­ ìœ„ì¹˜ê°€ ì²´í¬ë°•ìŠ¤ ë‚´ë¶€ë¼ë©´
            if cb_rect.contains(event.position().toPoint()):
                current_value = model.data(index, Qt.ItemDataRole.CheckStateRole)
                # PyQt6ì—ì„œëŠ” data()ê°€ CheckState enum ê°’ì„ ì§ì ‘ ë°˜í™˜í•  ìˆ˜ ìˆìŒ
                if isinstance(current_value, Qt.CheckState):
                    current_state = current_value
                elif isinstance(current_value, int): # Fallback for integer representation
                    current_state = Qt.CheckState(current_value)
                else: # ì˜ˆìƒì¹˜ ëª»í•œ íƒ€ì…ì´ë©´ ì²˜ë¦¬ ì¤‘ë‹¨
                    logger.warning(f"Unexpected data type for CheckStateRole: {type(current_value)}")
                    return False

                # ì²´í¬ ìƒíƒœ í† ê¸€
                new_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked

                # ëª¨ë¸ ë°ì´í„° ë³€ê²½ ì‹œë„ ë° ê²°ê³¼ ë¡œê¹…
                logger.debug(f"CheckBoxDelegate: Attempting setData for index {index.row()},{index.column()} with state {new_state}")
                success = model.setData(index, new_state, Qt.ItemDataRole.CheckStateRole)
                logger.debug(f"CheckBoxDelegate: setData call result: {success}")

                # setDataê°€ ì„±ê³µì ìœ¼ë¡œ ëª¨ë¸ ë°ì´í„°ë¥¼ ë³€ê²½í–ˆìœ¼ë©´ True ë°˜í™˜
                if success:
                    return True # ì´ë²¤íŠ¸ ì²˜ë¦¬ ì™„ë£Œ, ë‹¤ë¥¸ í•¸ë“¤ëŸ¬ í˜¸ì¶œ ë°©ì§€
                else:
                    # setData ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ë‚¨ê¸°ê³  ê¸°ë³¸ ì²˜ë¦¬ë¡œ ë„˜ì–´ê°
                    logger.warning(f"CheckBoxDelegate: setData failed for index {index.row()},{index.column()}")
                    return False # setData ì‹¤íŒ¨ ì‹œ False ë°˜í™˜

        # ë‹¤ë¥¸ ì´ë²¤íŠ¸ëŠ” ê¸°ë³¸ ì²˜ë¦¬
        return super().editorEvent(event, model, option, index)

    # paint ë©”ì„œë“œëŠ” ê¸°ë³¸ QStyledItemDelegateì˜ ë™ì‘ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ì˜¤ë²„ë¼ì´ë“œ ë¶ˆí•„ìš”
    # def paint(self, painter: QPainter, option: QStyleOptionViewItem, index: QModelIndex):
    #     super().paint(painter, option, index)




======== src\ui\widgets\custom_tab_bar.py ========

from PyQt6.QtWidgets import QTabBar, QTabWidget, QInputDialog, QMessageBox, QMainWindow # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from PyQt6.QtGui import QMouseEvent # PyQt5 -> PyQt6
from .tab_manager import is_tab_deletable

class CustomTabBar(QTabBar):
    """
    Custom tab bar with features like adding new tabs, closing tabs with middle-click,
    and renaming tabs with double-click.
    """
    def __init__(self, parent: QTabWidget, main_window: QMainWindow):
        super().__init__(parent)
        self.main_window = main_window # MainWindow ì°¸ì¡° (ìƒˆ íƒ­ ì¶”ê°€ ì‹œ í•„ìš”)
        self.setTabsClosable(False) # ê¸°ë³¸ ë‹«ê¸° ë²„íŠ¼ ìˆ¨ê¹€ (ë¯¸ë“¤ í´ë¦­ ì‚¬ìš©)
        self.setMovable(True) # íƒ­ ì´ë™ ê°€ëŠ¥
        # "+" íƒ­ ì¶”ê°€ (ìƒˆ íƒ­ ìƒì„±ìš©)
        self.addTab("+")

    def mousePressEvent(self, event: QMouseEvent):
        """Handles left mouse button press for adding new tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            # "+" íƒ­ í´ë¦­ ì‹œ ìƒˆ íƒ­ ì¶”ê°€ ë™ì‘ ì—°ê²°
            if index >= 0 and self.tabText(index) == "+":
                # MainWindowì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ìƒˆ íƒ­ ì¶”ê°€
                if hasattr(self.main_window, 'add_new_custom_tab'):
                    self.main_window.add_new_custom_tab()
                return # ì´ë²¤íŠ¸ ì²˜ë¦¬ ì™„ë£Œ
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handles middle mouse button release for closing tabs."""
        if event.button() == Qt.MouseButton.MiddleButton: # Qt.MiddleButton -> Qt.MouseButton.MiddleButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                if tab_text != "+" and is_tab_deletable(tab_text):
                    self.parentWidget().removeTab(index)
                elif tab_text != "+":
                    QMessageBox.warning(self.parentWidget(), "ê²½ê³ ", f"'{tab_text}' íƒ­ì€ ì œê±°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                # "+" íƒ­ì€ ì•„ë¬´ ë™ì‘ ì•ˆ í•¨
        super().mouseReleaseEvent(event)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """Handles left mouse button double-click for renaming tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                # ë³´í˜¸ëœ íƒ­ ë˜ëŠ” "+" íƒ­ì€ ì´ë¦„ ë³€ê²½ ë¶ˆê°€
                if tab_text != "+" and is_tab_deletable(tab_text):
                    new_name, ok = QInputDialog.getText(self.parentWidget(), "íƒ­ ì´ë¦„ ë³€ê²½",
                                                        "ìƒˆ íƒ­ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:", text=tab_text)
                    if ok and new_name and new_name.strip():
                        new_name_stripped = new_name.strip()
                        # ë³´í˜¸ëœ ì´ë¦„ìœ¼ë¡œ ë³€ê²½ ë¶ˆê°€ ì²˜ë¦¬
                        if not is_tab_deletable(new_name_stripped):
                             QMessageBox.warning(self.parentWidget(), "ê²½ê³ ", f"'{new_name_stripped}'(ìœ¼)ë¡œëŠ” ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                             return
                        # ì¤‘ë³µ íƒ­ ì´ë¦„ ê²€ì‚¬
                        for i in range(self.count()):
                            if i != index and self.tabText(i) == new_name_stripped:
                                QMessageBox.warning(self.parentWidget(), "ê²½ê³ ", f"'{new_name_stripped}' íƒ­ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
                                return
                        # ì´ë¦„ ë³€ê²½ ì ìš©
                        self.setTabText(index, new_name_stripped)
                    elif ok:
                         QMessageBox.warning(self.parentWidget(), "ê²½ê³ ", "íƒ­ ì´ë¦„ì€ ë¹„ì›Œë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        super().mouseDoubleClickEvent(event)




======== src\ui\widgets\custom_text_edit.py ========

from PyQt6.QtWidgets import QTextEdit # PyQt5 -> PyQt6
from PyQt6.QtCore import QMimeData # PyQt5 -> PyQt6

class CustomTextEdit(QTextEdit):
    """
    Custom QTextEdit that only allows plain text pasting.
    """
    def __init__(self, parent=None):
        super().__init__(parent)

    def insertFromMimeData(self, source: QMimeData):
        """Overrides insertFromMimeData to paste only plain text."""
        if source.hasText():
            self.insertPlainText(source.text())



======== src\ui\widgets\file_tree_view.py ========
from PyQt6.QtWidgets import QTreeView, QApplication
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QMouseEvent

class FileTreeView(QTreeView):
    """
    ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì—¬ëŸ¬ íŒŒì¼ ì„ íƒ ì‹œ í•¸ë“¤ë§í•˜ì—¬
    ì„ íƒëœ ëª¨ë“  íŒŒì¼ì˜ ì²´í¬ ìƒíƒœë¥¼ í† ê¸€í•©ë‹ˆë‹¤.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._drag_start_pos = None
        self._dragging = False

    def mousePressEvent(self, event):
        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            self._drag_start_pos = event.pos()
            self._dragging = False
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._drag_start_pos:
            distance = (event.pos() - self._drag_start_pos).manhattanLength()
            if distance > QApplication.startDragDistance():
                self._dragging = True
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton and self._dragging:
            # ë“œë˜ê·¸ë¡œ ì„ íƒëœ í›„ ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì‹œ ì„ íƒëœ ëª¨ë“  íŒŒì¼ í† ê¸€
            super().mouseReleaseEvent(event)
            indexes = self.selectionModel().selectedIndexes()
            # 0ë²ˆ ì»¬ëŸ¼ë§Œ í•„í„°ë§
            col0_indexes = []
            rows = set()
            for idx in indexes:
                if idx.column() == 0 and idx.row() not in rows:
                    col0_indexes.append(idx)
                    rows.add(idx.row())
            if col0_indexes:
                first_state = self.model().data(col0_indexes[0], Qt.ItemDataRole.CheckStateRole)
                if isinstance(first_state, Qt.CheckState):
                    current_state = first_state
                elif isinstance(first_state, int):
                    current_state = Qt.CheckState(first_state)
                else:
                    return
                target_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked
                for idx in col0_indexes:
                    self.model().setData(idx, target_state, Qt.ItemDataRole.CheckStateRole)
            self._drag_start_pos = None
            self._dragging = False
        else:
            super().mouseReleaseEvent(event) 


======== src\ui\widgets\tab_manager.py ========
PROTECTED_TABS = {
    # ê¸°ë³¸ UI íƒ­
    "ì‹œìŠ¤í…œ", "ì‚¬ìš©ì", "íŒŒì¼ íŠ¸ë¦¬", "í”„ë¡¬í”„íŠ¸ ì¶œë ¥", "XML ì…ë ¥",
    "ë©”íƒ€ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿", "ë©”íƒ€ ì‚¬ìš©ì ì…ë ¥", "ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ì¶œë ¥",
    "ë©”íƒ€ í”„ë¡¬í”„íŠ¸", "ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸", "ìµœì¢… í”„ë¡¬í”„íŠ¸", 
    # ê¸°ëŠ¥ì„± íƒ­
    "+", # ìƒˆ íƒ­ ì¶”ê°€ ë²„íŠ¼
    "   |   ", 

}

def is_tab_deletable(tab_name: str) -> bool:
    """Checks if a tab with the given name can be deleted or renamed by the user."""
    # ë³´í˜¸ ëª©ë¡ì— ì—†ìœ¼ë©´ ì‚­ì œ/ì´ë¦„ ë³€ê²½ ê°€ëŠ¥
    return tab_name not in PROTECTED_TABS


======== src\ui\__init__.py ========
# This file makes Python treat the directory ui as a package.



======== src\ui\main_window.py ========
import os
import io
import logging
import datetime
from typing import Optional, List, Dict, Any
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox,
    QAbstractItemView, QMenuBar, QSplitter, QStyleFactory, QApplication, QMenu,
    QTreeWidget, QTreeWidgetItem, QComboBox, QFileDialog, QInputDialog, QMessageBox,
    QFrame, QLineEdit, QDialog, QListWidget, QListWidgetItem, QStyle
)
from PyQt6.QtGui import QKeySequence, QIcon, QCursor, QMouseEvent, QFont, QDesktopServices, QPixmap, QImage, QAction, QKeyEvent # PyQt5 -> PyQt6, QAction, QKeyEvent ì¶”ê°€
from PyQt6.QtCore import Qt, QSize, QStandardPaths, QModelIndex, QItemSelection, QUrl, QThread, pyqtSignal, QObject, QBuffer, QIODevice, QTimer, QEvent # PyQt5 -> PyQt6, QEvent ì¶”ê°€

# ì„œë¹„ìŠ¤ ë° ëª¨ë¸ import
from core.pydantic_models.app_state import AppState
from core.services.db_service import DbService
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.services.gemini_service import build_gemini_graph
from core.langgraph_state import GeminiGraphState

# UI ê´€ë ¨ import
from ui.models.file_system_models import FilteredFileSystemModel, CheckableProxyModel
from ui.controllers.main_controller import MainController # MainController import ìˆ˜ì •
from ui.controllers.resource_controller import ResourceController
from ui.controllers.prompt_controller import PromptController
from ui.controllers.xml_controller import XmlController
from ui.controllers.file_tree_controller import FileTreeController
from ui.controllers.system_prompt_controller import apply_default_system_prompt

from .main_window_setup_ui import create_menu_bar, create_widgets, create_layout, create_status_bar
from .main_window_setup_signals import connect_signals
from .settings_dialog import SettingsDialog
from ui.widgets.custom_text_edit import CustomTextEdit
from ui.widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from utils.notifications import show_notification # ì•Œë¦¼ ê¸°ëŠ¥ ì„í¬íŠ¸

# Pillow import ì‹œë„
try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)

# --- Gemini API í˜¸ì¶œì„ ìœ„í•œ Worker í´ë˜ìŠ¤ ---
class GeminiWorker(QObject):
    finished = pyqtSignal(str, str) # XML, Summary ê²°ê³¼ ì „ë‹¬
    error = pyqtSignal(str)         # ì˜¤ë¥˜ ë©”ì‹œì§€ ì „ë‹¬

    def __init__(self, graph_app, initial_state: GeminiGraphState): # ì´ˆê¸° ìƒíƒœ ì§ì ‘ ë°›ê¸°
        super().__init__()
        self.graph_app = graph_app
        self.initial_state = initial_state # ì „ë‹¬ë°›ì€ ì´ˆê¸° ìƒíƒœ ì €ì¥

    def run(self):
        """LangGraph ì›Œí¬í”Œë¡œìš°ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."""
        try:
            logger.info("Starting Gemini worker thread.")
            # LangGraph ì‹¤í–‰ (.invoke ì‚¬ìš©, ì €ì¥ëœ ì´ˆê¸° ìƒíƒœ ì „ë‹¬)
            final_state = self.graph_app.invoke(self.initial_state)
            logger.info(f"Gemini worker finished. Final state error: {final_state.get('error_message')}")

            if final_state.get("error_message"):
                self.error.emit(final_state["error_message"])
            else:
                xml_result = final_state.get("xml_output", "")
                summary_result = final_state.get("summary_output", "")
                self.finished.emit(xml_result, summary_result)
        except Exception as e:
            logger.exception("Error during LangGraph execution in worker thread.")
            self.error.emit(f"LangGraph ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")


class MainWindow(QMainWindow):
    # ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œê·¸ë„ (ìƒíƒœ ë³€ê²½ ì‹œ íƒ€ì´ë¨¸ ì¬ì‹œì‘ìš©)
    state_changed_signal = pyqtSignal()

    def __init__(self, mode="Code Enhancer Prompt Builder"):
        super().__init__()
        self._initialized = False
        self.mode = mode
        self.base_title = "DuckPrompt"
        self.update_window_title()

        QApplication.setStyle(QStyleFactory.create("Fusion"))

        # --- ìƒíƒœ ë³€ìˆ˜ ---
        self.current_project_folder: Optional[str] = None
        self.last_generated_prompt: str = ""
        self.selected_files_data: List[tuple] = []
        self.tree_generated: bool = False
        self._is_saving_gemini_settings = False # Still needed to prevent signal loops
        self.attached_items: List[Dict[str, Any]] = []
        self.api_call_start_time: Optional[datetime.datetime] = None # API í˜¸ì¶œ ì‹œì‘ ì‹œê°„ ì €ì¥
        self.api_timer = QTimer(self) # API ê²½ê³¼ ì‹œê°„ ì—…ë°ì´íŠ¸ìš© íƒ€ì´ë¨¸ ì¶”ê°€
        self.api_timer.timeout.connect(self._update_api_elapsed_time) # íƒ€ì´ë¨¸ ì‹œê·¸ë„ ì—°ê²°

        # --- ìë™ ì €ì¥ íƒ€ì´ë¨¸ ---
        self.auto_save_timer = QTimer(self)
        self.auto_save_timer.setInterval(30000) # 30ì´ˆ ê°„ê²©ìœ¼ë¡œ ë³€ê²½
        self.auto_save_timer.setSingleShot(True) # í•œ ë²ˆë§Œ ì‹¤í–‰ (ìƒíƒœ ë³€ê²½ ì‹œ ì¬ì‹œì‘)

        # --- ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ---
        try:
            self.db_service = DbService() # Initialize DbService first
            self.config_service = ConfigService(self.db_service) # Inject DbService
        except ConnectionError as e:
             QMessageBox.critical(self, "Database Error", f"ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨: {e}\ní”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
             # Exit the application gracefully
             # QApplication.instance().quit() # This might not work before app.exec()
             # Instead, prevent further initialization and let the app close
             raise SystemExit(f"Database connection failed: {e}") # Exit if DB fails
        except ValueError as e:
             QMessageBox.critical(self, "Configuration Error", f"ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}\ní”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
             raise SystemExit(f"Configuration load failed: {e}") # Exit if config load fails

        self.state_service = StateService()
        self.template_service = TemplateService()
        self.prompt_service = PromptService()
        self.xml_service = XmlService()
        self.fs_service = FilesystemService(self.config_service) # Pass DB-backed config
        self.token_service = TokenCalculationService(self.config_service) # Pass DB-backed config
        self.gemini_graph = build_gemini_graph(self.config_service) # Pass DB-backed config
        self.gemini_thread: Optional[QThread] = None
        self.gemini_worker: Optional[GeminiWorker] = None

        # --- UI êµ¬ì„± ìš”ì†Œ ìƒì„± ---
        create_menu_bar(self)
        create_widgets(self)
        create_layout(self)
        create_status_bar(self)

        # --- ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± ë° ì—°ê²° ---
        self.main_controller = MainController(self)
        self.resource_controller = ResourceController(self, self.template_service, self.state_service)
        self.prompt_controller = PromptController(self, self.prompt_service)
        self.xml_controller = XmlController(self, self.xml_service)
        self.file_tree_controller = FileTreeController(self, self.fs_service, self.config_service)

        # --- ì‹œê·¸ë„ ì—°ê²° ---
        connect_signals(self)
        # ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œê·¸ë„ ì—°ê²°
        self.auto_save_timer.timeout.connect(self.resource_controller.save_state_to_default)
        self.state_changed_signal.connect(self.restart_auto_save_timer) # ìƒíƒœ ë³€ê²½ ì‹œ íƒ€ì´ë¨¸ ì¬ì‹œì‘

        # --- ì´ˆê¸°í™” ì‘ì—… ---
        self.resource_controller.load_templates_list()
        self._apply_initial_settings() # ê¸°ë³¸ ì„¤ì • ì ìš© (DB ë¡œë“œ ë“±)

        self.status_bar.showMessage("Ready (DB Connected)")
        initial_width = 1200; initial_height = 800
        self.resize(initial_width, initial_height)
        left_width = int(initial_width * 0.35)
        right_width = initial_width - left_width
        self.center_splitter.setSizes([left_width, right_width])
        self.build_tabs.setCurrentIndex(1) # ì‚¬ìš©ì íƒ­ì„ ê¸°ë³¸ìœ¼ë¡œ
        self.file_tree_controller.reset_file_tree() # íŒŒì¼ íŠ¸ë¦¬ ì´ˆê¸°í™”

        # --- ì‚¬ìš©ì íƒ­ì— ì´ë²¤íŠ¸ í•„í„° ì„¤ì¹˜ ---
        if hasattr(self, 'user_tab'):
            self.user_tab.installEventFilter(self)
            logger.info("Event filter installed on user_tab.")
        # ---------------------------------

        self._initialized = True
        # í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ ê¸°ë³¸ ìƒíƒœ ë¡œë“œ ì œê±° -> ì‚¬ìš©ìê°€ ë²„íŠ¼ í´ë¦­ ì‹œ ë¡œë“œ
        # self.resource_controller.load_state_from_default()
        self.restart_auto_save_timer() # ì´ˆê¸° ë¡œë“œ í›„ ìë™ ì €ì¥ ì‹œì‘

    def _apply_initial_settings(self):
        """Applies initial settings loaded from ConfigService."""
        logger.info("Applying initial settings from ConfigService...")
        # 1. ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©
        apply_default_system_prompt(self)

        # 2. Meta ëª¨ë“œì¼ ê²½ìš° ê¸°ë³¸ ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ë¡œë“œ
        if self.mode == "Meta Prompt Builder":
            meta_prompt_path_relative = os.path.join("prompts", "system", "META_Prompt.md")
            try:
                meta_prompt_path = get_resource_path(meta_prompt_path_relative)
                if os.path.exists(meta_prompt_path):
                    with open(meta_prompt_path, "r", encoding="utf-8") as f:
                        self.system_tab.setText(f.read())
            except Exception as e: logger.error(f"Error loading default META prompt: {e}")

        # 3. LLM ë° ëª¨ë¸ ì½¤ë³´ë°•ìŠ¤ ì„¤ì • (ê¸°ë³¸ê°’ ì„ íƒ)
        self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini")) # ê¸°ë³¸ LLM ì„¤ì •
        self.main_controller.on_llm_selected() # ëª¨ë¸ ëª©ë¡ ë¡œë“œ ë° ê¸°ë³¸ ëª¨ë¸ ì„ íƒ

        # 4. Gemini íŒŒë¼ë¯¸í„° UI ì—…ë°ì´íŠ¸
        self.load_gemini_settings_to_ui()

        # 5. íŒŒì¼ í•„í„°ë§/gitignore ì„¤ì • ë¡œë“œ
        self.file_tree_controller.load_gitignore_settings()

        # 6. ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ë²„íŠ¼ ë ˆì´ë¸” ì—…ë°ì´íŠ¸
        self.resource_controller.update_buttons_label()
        logger.info("Initial settings applied.")


    def _restart_with_mode(self, new_mode: str):
        """Restarts the application with the specified mode."""
        self._initialized = False
        self.auto_save_timer.stop() # íƒ€ì´ë¨¸ ì¤‘ì§€
        self.db_service.disconnect() # Disconnect DB before closing
        self.close()
        # Note: Restarting might re-trigger DB connection errors if they persist
        new_window = MainWindow(mode=new_mode)
        new_window.show()

    def _toggle_mode(self):
        """Toggles between application modes."""
        new_mode = "Meta Prompt Builder" if self.mode == "Code Enhancer Prompt Builder" else "Code Enhancer Prompt Builder"
        self._restart_with_mode(new_mode)

    def _open_readme(self):
        """Opens the README.md file."""
        readme_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'README.md'))
        if os.path.exists(readme_path):
            url = QUrl.fromLocalFile(readme_path)
            if not QDesktopServices.openUrl(url):
                QMessageBox.warning(self, "ì˜¤ë¥˜", "README.md íŒŒì¼ì„ ì—¬ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        else:
            QMessageBox.warning(self, "ì˜¤ë¥˜", "README.md íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def open_settings_dialog(self):
        """Opens the settings dialog."""
        dialog = SettingsDialog(self, self)
        # Dialog is now mostly read-only for config settings
        # It only saves .gitignore changes now
        dialog.exec() # exec_() -> exec()
        # SettingsDialogì—ì„œ ì„¤ì •ì„ ì €ì¥í•˜ë©´ MainWindowì˜ UIë„ ì—…ë°ì´íŠ¸í•´ì•¼ í•¨
        # (SettingsDialog.save_config_settings ì—ì„œ MainWindow ì—…ë°ì´íŠ¸ ë¡œì§ í˜¸ì¶œ)
        logger.info("Settings dialog closed.")


    # --- Public Methods ---

    def reset_state(self):
        """Resets internal state variables."""
        logger.info("Resetting application state...")
        was_initialized = self._initialized
        self._initialized = False
        self.auto_save_timer.stop() # ë¦¬ì…‹ ì‹œ íƒ€ì´ë¨¸ ì¤‘ì§€

        self.current_project_folder = None
        self.last_generated_prompt = ""
        self.selected_files_data = []
        self.tree_generated = False
        self.attached_items = []
        self.api_call_start_time = None # API ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
        self.api_timer.stop() # API íƒ€ì´ë¨¸ ì¤‘ì§€

        # ì²´í¬ ìƒíƒœ ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™”
        if hasattr(self, 'checkable_proxy'):
            logger.debug("Clearing checked_files_dict in reset_state.")
            self.checkable_proxy.checked_files_dict.clear()

        if hasattr(self, 'attachment_list_widget'): self.attachment_list_widget.clear()
        self.update_window_title()

        # íŒŒì¼ íŠ¸ë¦¬ ë¦¬ì…‹ (ë‚´ë¶€ì—ì„œ checked_files_dict ì´ˆê¸°í™” í¬í•¨)
        if hasattr(self, 'file_tree_controller'):
            self.file_tree_controller.reset_file_tree()

        # LLM ë° í† í° ìƒíƒœ ë¦¬ì…‹
        if hasattr(self, 'main_controller'):
            self.main_controller.on_llm_selected() # ê¸°ë³¸ LLM/ëª¨ë¸ ì„¤ì •
            self.main_controller._stop_token_calculation_thread() # í† í° ê³„ì‚° ìŠ¤ë ˆë“œ ì¤‘ì§€
            self.main_controller.reset_token_label() # í† í° ë¼ë²¨ ë¦¬ì…‹

        # íƒ­ ë‚´ìš© í´ë¦¬ì–´
        if hasattr(self, 'system_tab'): self.system_tab.clear()
        if hasattr(self, 'user_tab'): self.user_tab.clear()
        if hasattr(self, 'dir_structure_tab'): self.dir_structure_tab.clear()
        if hasattr(self, 'xml_input_tab'): self.xml_input_tab.clear()
        if hasattr(self, 'prompt_output_tab'): self.prompt_output_tab.clear()
        if hasattr(self, 'summary_tab'): self.summary_tab.clear()
        # Meta ëª¨ë“œ íƒ­ í´ë¦¬ì–´ (ì¡´ì¬ ì‹œ)
        if hasattr(self, 'meta_prompt_tab'): self.meta_prompt_tab.clear()
        if hasattr(self, 'user_prompt_tab'):
            user_prompt_tab_widget = getattr(self, 'user_prompt_tab', None)
            if user_prompt_tab_widget: user_prompt_tab_widget.clear()
        if hasattr(self, 'final_prompt_tab'):
            final_prompt_tab_widget = getattr(self, 'final_prompt_tab', None)
            if final_prompt_tab_widget: final_prompt_tab_widget.clear()

        # ê¸°íƒ€ UI ì´ˆê¸°í™”
        if hasattr(self, 'project_folder_label'): self.project_folder_label.setText("í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: (ì„ íƒ ì•ˆ ë¨)")
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API ì‹œê°„: -") # API ì‹œê°„ ë¼ë²¨ ì´ˆê¸°í™”

        # ê¸°ë³¸ ì„¤ì • ë‹¤ì‹œ ì ìš© (ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ë“±)
        self._apply_initial_settings()

        self._initialized = was_initialized # ì›ë˜ ì´ˆê¸°í™” ìƒíƒœ ë³µì›
        self.restart_auto_save_timer() # ë¦¬ì…‹ í›„ ìë™ ì €ì¥ ì¬ì‹œì‘
        logger.info("Application state reset complete.")


    def update_window_title(self, folder_name: Optional[str] = None):
        """Updates the window title."""
        title = f"{folder_name} - {self.base_title}" if folder_name else self.base_title
        self.setWindowTitle(title)

    def get_current_state(self) -> AppState:
        """Gathers the current UI state for saving (full or partial)."""
        checked_paths = self.checkable_proxy.get_all_checked_paths() if hasattr(self, 'checkable_proxy') else []
        selected_llm = self.llm_combo.currentText() if hasattr(self, 'llm_combo') else "Gemini"
        selected_model_name = self.model_name_combo.currentText().strip() if hasattr(self, 'model_name_combo') else ""

        # ì²¨ë¶€ íŒŒì¼ ë©”íƒ€ë°ì´í„°ë§Œ ì§ë ¬í™”
        serializable_attachments = []
        for item in self.attached_items:
            s_item = item.copy()
            s_item.pop('data', None) # ë°ì´í„° ì œì™¸
            serializable_attachments.append(s_item)

        # AppState ëª¨ë¸ ìƒì„± (ëª¨ë“  í•„ë“œ í¬í•¨)
        state_data = {
            "mode": self.mode,
            "project_folder": self.current_project_folder,
            "system_prompt": self.system_tab.toPlainText(),
            "user_prompt": self.user_tab.toPlainText(),
            "checked_files": checked_paths, # checked_files_dictì˜ í‚¤ ë¦¬ìŠ¤íŠ¸ ì €ì¥
            "selected_llm": selected_llm,
            "selected_model_name": selected_model_name,
            "attached_items": serializable_attachments,
        }
        try:
            app_state = AppState(**state_data)
            return app_state
        except Exception as e:
             logger.error(f"Error creating AppState model: {e}")
             # ì˜¤ë¥˜ ë°œìƒ ì‹œ ìµœì†Œí•œì˜ ì •ë³´ë¡œ ê¸°ë³¸ ìƒíƒœ ë°˜í™˜
             return AppState(
                 mode=self.mode,
                 project_folder=self.current_project_folder,
                 user_prompt=self.user_tab.toPlainText(),
                 checked_files=checked_paths,
                 attached_items=serializable_attachments,
                 selected_llm=selected_llm,
                 selected_model_name=selected_model_name
             )

    def set_current_state(self, state: AppState, partial_load: bool = False):
        """
        Sets the UI state based on the provided AppState model.
        If partial_load is True, only loads project folder, checked files, user prompt, and attachments.
        """
        logger.info(f"Setting current state. Partial load: {partial_load}")
        # UI ì—…ë°ì´íŠ¸ ì¤‘ ì‹œê·¸ë„/íƒ€ì´ë¨¸ ë°©ì§€
        was_initialized = self._initialized
        self._initialized = False
        self.auto_save_timer.stop()

        # --- ë¶€ë¶„ ë¡œë“œ (ë§ˆì§€ë§‰ ì‘ì—… ë¶ˆëŸ¬ì˜¤ê¸°) ---
        if partial_load:
            # 1. í”„ë¡œì íŠ¸ í´ë” ë¡œë“œ (í´ë” ë³€ê²½ ì‹œ íŠ¸ë¦¬ ë¦¬ì…‹ ë° gitignore ë¡œë“œ í¬í•¨)
            folder_name = None
            if state.project_folder and os.path.isdir(state.project_folder):
                if self.current_project_folder != state.project_folder:
                    # reset_state ëŒ€ì‹  í•„ìš”í•œ ë¶€ë¶„ë§Œ ì´ˆê¸°í™”
                    self.current_project_folder = state.project_folder
                    folder_name = os.path.basename(state.project_folder)
                    self.project_folder_label.setText(f"í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: {state.project_folder}")
                    if hasattr(self, 'dir_model') and hasattr(self, 'checkable_proxy'):
                        # ì²´í¬ ìƒíƒœ ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™” (í´ë” ë³€ê²½ ì‹œ)
                        self.checkable_proxy.checked_files_dict.clear()
                        logger.debug("Cleared checked_files_dict due to project folder change (partial load).")
                        idx = self.dir_model.setRootPathFiltered(state.project_folder)
                        root_proxy_index = self.checkable_proxy.mapFromSource(idx)
                        self.tree_view.setRootIndex(root_proxy_index)
                    self.status_bar.showMessage(f"Project Folder: {state.project_folder}")
                    self.file_tree_controller.load_gitignore_settings() # í´ë” ë³€ê²½ ì‹œ gitignore ë‹¤ì‹œ ë¡œë“œ
                    self.update_window_title(folder_name)
                else:
                    # ê°™ì€ í´ë”ë©´ í˜„ì¬ í´ë” ì´ë¦„ ìœ ì§€
                    folder_name = os.path.basename(self.current_project_folder)
            elif not state.project_folder and self.current_project_folder:
                # ìƒíƒœ íŒŒì¼ì— í´ë” ì •ë³´ê°€ ì—†ìœ¼ë©´ í˜„ì¬ í´ë” ìœ ì§€
                folder_name = os.path.basename(self.current_project_folder)
                pass
            else:
                # ìƒíƒœ íŒŒì¼ì—ë„ ì—†ê³  í˜„ì¬ë„ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
                self.current_project_folder = None
                self.project_folder_label.setText("í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: (ì„ íƒ ì•ˆ ë¨)")
                self.file_tree_controller.reset_file_tree() # íŠ¸ë¦¬ ë° ì²´í¬ ìƒíƒœ ì´ˆê¸°í™”
                self.update_window_title()

            # 2. ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ë¡œë“œ
            self.user_tab.setText(state.user_prompt)

            # 3. ì²¨ë¶€ íŒŒì¼ ë¡œë“œ
            self.attached_items = state.attached_items or []
            self._update_attachment_list_ui()

            # 4. ì²´í¬ëœ íŒŒì¼ ë³µì› (í”„ë¡œì íŠ¸ í´ë” ë¡œë“œ í›„ì— ìˆ˜í–‰)
            if self.current_project_folder and hasattr(self, 'checkable_proxy'):
                # ë¶€ë¶„ ë¡œë“œ ì‹œì—ë„ ì²´í¬ ìƒíƒœ ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™” (í´ë” ë³€ê²½ ì‹œ ì´ë¯¸ ì´ˆê¸°í™”ë¨)
                if self.current_project_folder == state.project_folder: # ê°™ì€ í´ë”ì¼ ë•Œë§Œ ì´ˆê¸°í™”
                    self.checkable_proxy.checked_files_dict.clear()
                    logger.debug("Cleared checked_files_dict before restoring checks (partial load, same folder).")

                items_to_check = []
                logger.info(f"Restoring checked files from state: {len(state.checked_files)} items")
                for fpath in state.checked_files:
                    try:
                        abs_fpath = os.path.abspath(fpath)
                        abs_proj_folder = os.path.abspath(self.current_project_folder)
                        if abs_fpath.startswith(abs_proj_folder):
                            if os.path.exists(abs_fpath):
                                src_index = self.dir_model.index(abs_fpath)
                                if src_index.isValid():
                                    proxy_index = self.checkable_proxy.mapFromSource(src_index)
                                    if proxy_index.isValid():
                                        # checked_files_dict ì§ì ‘ ìˆ˜ì • ëŒ€ì‹  setData í˜¸ì¶œì— ì˜ì¡´
                                        # self.checkable_proxy.checked_files_dict[abs_fpath] = True
                                        items_to_check.append(proxy_index)
                                        logger.debug(f"  Queueing {abs_fpath} to be checked via setData.")
                                    else: logger.warning(f"  Could not map source index to proxy for: {abs_fpath}")
                                else: logger.warning(f"  Could not get source index for: {abs_fpath}")
                            else: logger.warning(f"  Checked file path from state does not exist: {abs_fpath}")
                        else: logger.warning(f"  Checked file path from state is outside current project folder: {abs_fpath}")
                    except Exception as e: logger.error(f"  Error processing checked file path '{fpath}': {e}")

                # UI ì—…ë°ì´íŠ¸ (setData í˜¸ì¶œ)
                logger.info(f"Applying check state for {len(items_to_check)} restored items using setData.")
                for proxy_index in items_to_check:
                    # setData í˜¸ì¶œí•˜ì—¬ ëª¨ë¸ ë°ì´í„° ë³€ê²½ ë° UI ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
                    self.checkable_proxy.setData(proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole)
                    logger.debug(f"  Called setData(Checked) for: {self.checkable_proxy.get_file_path_from_index(proxy_index)}")

            # ë¶€ë¶„ ë¡œë“œ ì‹œ ë‹¤ë¥¸ UI ìš”ì†ŒëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ (ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸, LLM ì„¤ì • ë“±)
            self.status_bar.showMessage("ë§ˆì§€ë§‰ ì‘ì—… ìƒíƒœ ë¡œë“œ ì™„ë£Œ.")

        # --- ì „ì²´ ë¡œë“œ (ìƒíƒœ ê°€ì ¸ì˜¤ê¸° ë“±) ---
        else:
            if self.mode != state.mode:
                logger.info(f"Mode mismatch. Restarting...")
                self._restart_with_mode(state.mode)
                return # ì¬ì‹œì‘ í›„ì—ëŠ” ì´ í•¨ìˆ˜ ë‹¤ì‹œ í˜¸ì¶œ ì•ˆ ë¨

            # ì „ì²´ ë¦¬ì…‹ ëŒ€ì‹  í•„ìš”í•œ ë¶€ë¶„ë§Œ ì—…ë°ì´íŠ¸
            folder_name = None
            if state.project_folder and os.path.isdir(state.project_folder):
                if self.current_project_folder != state.project_folder:
                    self.current_project_folder = state.project_folder
                    folder_name = os.path.basename(state.project_folder)
                    self.project_folder_label.setText(f"í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: {state.project_folder}")
                    if hasattr(self, 'dir_model') and hasattr(self, 'checkable_proxy'):
                        self.checkable_proxy.checked_files_dict.clear() # í´ë” ë³€ê²½ ì‹œ ì´ˆê¸°í™”
                        logger.debug("Cleared checked_files_dict due to project folder change (full load).")
                        idx = self.dir_model.setRootPathFiltered(state.project_folder)
                        root_proxy_index = self.checkable_proxy.mapFromSource(idx)
                        self.tree_view.setRootIndex(root_proxy_index)
                    self.status_bar.showMessage(f"Project Folder: {state.project_folder}")
                    self.file_tree_controller.load_gitignore_settings() # í´ë” ë³€ê²½ ì‹œ gitignore ë‹¤ì‹œ ë¡œë“œ
                else:
                    folder_name = os.path.basename(self.current_project_folder)
            else:
                 self.current_project_folder = None
                 self.project_folder_label.setText("í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: (ì„ íƒ ì•ˆ ë¨)")
                 self.file_tree_controller.reset_file_tree() # íŠ¸ë¦¬ ë° ì²´í¬ ìƒíƒœ ì´ˆê¸°í™”

            self.system_tab.setText(state.system_prompt)
            self.user_tab.setText(state.user_prompt)

            llm_index = self.llm_combo.findText(state.selected_llm)
            if llm_index != -1:
                self.llm_combo.setCurrentIndex(llm_index)
                # on_llm_selected í˜¸ì¶œ ì „ì— ëª¨ë¸ ëª©ë¡ ë¡œë“œ
                available_models = self.config_service.get_available_models(state.selected_llm)
                self.model_name_combo.blockSignals(True)
                self.model_name_combo.clear()
                self.model_name_combo.addItems(available_models)
                self.model_name_combo.blockSignals(False)
                # ì €ì¥ëœ ëª¨ë¸ëª… ì„ íƒ ì‹œë„
                model_index = self.model_name_combo.findText(state.selected_model_name)
                if model_index != -1:
                    self.model_name_combo.setCurrentIndex(model_index)
                elif available_models:
                    self.model_name_combo.setCurrentIndex(0) # ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ëª¨ë¸ ì„ íƒ
                    logger.warning(f"Warning: Saved model '{state.selected_model_name}' not found for {state.selected_llm}. Selecting first available.")
                else:
                    logger.warning(f"No available models found for {state.selected_llm}.")
            else:
                # ì €ì¥ëœ LLM ìì²´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
                self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini"))
                self.main_controller.on_llm_selected()

            # ì²¨ë¶€ íŒŒì¼ ë³µì›
            self.attached_items = state.attached_items or []
            self._update_attachment_list_ui()

            # ì²´í¬ëœ íŒŒì¼ ë³µì› (ë¶€ë¶„ ë¡œë“œì™€ ë™ì¼ ë¡œì§)
            if self.current_project_folder and hasattr(self, 'checkable_proxy'):
                # ì „ì²´ ë¡œë“œ ì‹œì—ë„ ì²´í¬ ìƒíƒœ ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™” (í´ë” ë³€ê²½ ì‹œ ì´ë¯¸ ì´ˆê¸°í™”ë¨)
                if self.current_project_folder == state.project_folder: # ê°™ì€ í´ë”ì¼ ë•Œë§Œ ì´ˆê¸°í™”
                    self.checkable_proxy.checked_files_dict.clear()
                    logger.debug("Cleared checked_files_dict before restoring checks (full load, same folder).")

                items_to_check = []
                logger.info(f"Restoring checked files from state: {len(state.checked_files)} items")
                for fpath in state.checked_files:
                    try:
                        abs_fpath = os.path.abspath(fpath)
                        abs_proj_folder = os.path.abspath(self.current_project_folder)
                        if abs_fpath.startswith(abs_proj_folder):
                            if os.path.exists(abs_fpath):
                                src_index = self.dir_model.index(abs_fpath)
                                if src_index.isValid():
                                    proxy_index = self.checkable_proxy.mapFromSource(src_index)
                                    if proxy_index.isValid():
                                        # checked_files_dict ì§ì ‘ ìˆ˜ì • ëŒ€ì‹  setData í˜¸ì¶œì— ì˜ì¡´
                                        # self.checkable_proxy.checked_files_dict[abs_fpath] = True
                                        items_to_check.append(proxy_index)
                                        logger.debug(f"  Queueing {abs_fpath} to be checked via setData.")
                                    else: logger.warning(f"  Could not map source index to proxy for: {abs_fpath}")
                                else: logger.warning(f"  Could not get source index for: {abs_fpath}")
                            else: logger.warning(f"  Checked file path from state does not exist: {abs_fpath}")
                        else: logger.warning(f"  Checked file path from state is outside current project folder: {abs_fpath}")
                    except Exception as e: logger.error(f"  Error processing checked file path '{fpath}': {e}")

                # UI ì—…ë°ì´íŠ¸ (setData í˜¸ì¶œ)
                logger.info(f"Applying check state for {len(items_to_check)} restored items using setData.")
                for proxy_index in items_to_check:
                    # setData í˜¸ì¶œí•˜ì—¬ ëª¨ë¸ ë°ì´í„° ë³€ê²½ ë° UI ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
                    self.checkable_proxy.setData(proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole)
                    logger.debug(f"  Called setData(Checked) for: {self.checkable_proxy.get_file_path_from_index(proxy_index)}")

            # ì „ì²´ ë¡œë“œ ì‹œì—ëŠ” gitignore ë¡œë“œ ë° Gemini íŒŒë¼ë¯¸í„° ë¡œë“œ í•„ìš”
            if self.current_project_folder:
                self.file_tree_controller.load_gitignore_settings() # gitignore ë¡œë“œ
            self.update_window_title(folder_name)
            self.resource_controller.update_buttons_label()
            self.load_gemini_settings_to_ui() # Gemini íŒŒë¼ë¯¸í„° ë¡œë“œ

            self.status_bar.showMessage("State loaded successfully!")

        # ê³µí†µ ë§ˆë¬´ë¦¬ ì‘ì—…
        self._initialized = was_initialized # ì›ë˜ ìƒíƒœë¡œ ë³µì›
        self.main_controller.update_char_count_for_active_tab()
        self.token_count_label.setText("í† í° ê³„ì‚°: -")
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API ì‹œê°„: -")
        self.restart_auto_save_timer() # ìƒíƒœ ë¡œë“œ í›„ ìë™ ì €ì¥ ì¬ì‹œì‘

    def uncheck_all_files(self):
        """Unchecks all items in the file tree view."""
        if not hasattr(self, 'checkable_proxy'): return
        paths_to_uncheck = list(self.checkable_proxy.checked_files_dict.keys())
        self.checkable_proxy.checked_files_dict.clear()
        for fpath in paths_to_uncheck:
            src_index = self.dir_model.index(fpath)
            if src_index.isValid():
                proxy_index = self.checkable_proxy.mapFromSource(src_index)
                if proxy_index.isValid():
                    self.checkable_proxy.dataChanged.emit(proxy_index, proxy_index, [Qt.ItemDataRole.CheckStateRole]) # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole
        self.state_changed_signal.emit() # ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ

    def create_tree_item(self, text, parent=None) -> QTreeWidgetItem:
        """Helper method to create items in the template/state tree."""
        item = QTreeWidgetItem([text])
        if parent is None: self.template_tree.addTopLevelItem(item)
        else: parent.addChild(item)
        return item

    def add_new_custom_tab(self):
        """Adds a new custom tab."""
        new_tab_name, ok = QInputDialog.getText(self, "ìƒˆ íƒ­ ì¶”ê°€", "ìƒˆ íƒ­ì˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:")
        if ok and new_tab_name and new_tab_name.strip():
            new_name = new_tab_name.strip()
            from ui.widgets.tab_manager import is_tab_deletable
            if not is_tab_deletable(new_name):
                 QMessageBox.warning(self, "ê²½ê³ ", f"'{new_name}'ì€(ëŠ”) ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” íƒ­ ì´ë¦„ì…ë‹ˆë‹¤.")
                 return
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == new_name:
                    QMessageBox.warning(self, "ê²½ê³ ", f"'{new_name}' íƒ­ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
                    return
            new_tab = CustomTextEdit(); new_tab.setPlaceholderText(f"{new_name} ë‚´ìš© ì…ë ¥...")
            plus_tab_index = -1
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == "+": plus_tab_index = i; break
            if plus_tab_index != -1:
                 self.build_tabs.insertTab(plus_tab_index, new_tab, new_name)
                 self.build_tabs.setCurrentIndex(plus_tab_index)
            else:
                 self.build_tabs.addTab(new_tab, new_name)
                 self.build_tabs.setCurrentIndex(self.build_tabs.count() - 1)
            # ìƒˆ íƒ­ì˜ textChanged ì‹œê·¸ë„ ì—°ê²°
            new_tab.textChanged.connect(self.main_controller.handle_text_changed)
            self.state_changed_signal.emit() # ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
        elif ok: QMessageBox.warning(self, "ê²½ê³ ", "íƒ­ ì´ë¦„ì€ ë¹„ì›Œë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # --- Attachment UI Update ---
    def _update_attachment_list_ui(self):
        """Updates the attachment list widget based on self.attached_items."""
        if not hasattr(self, 'attachment_list_widget'): return
        self.attachment_list_widget.clear()
        for item in self.attached_items:
            item_name = item.get('name', 'Unknown')
            item_type = item.get('type', 'unknown')
            display_text = f"[{item_type.upper()}] {item_name}"
            list_item = QListWidgetItem(display_text)
            icon = QIcon()
            if item_type == 'image':
                img_data = item.get('data')
                if not img_data and item.get('path') and os.path.exists(item['path']):
                    try:
                        with open(item['path'], 'rb') as f: img_data = f.read()
                    except Exception: pass

                if img_data:
                    try:
                        pixmap = QPixmap()
                        pixmap.loadFromData(img_data)
                        if not pixmap.isNull():
                            icon = QIcon(pixmap.scaled(QSize(32, 32), Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)) # Qt.KeepAspectRatio -> Qt.AspectRatioMode.KeepAspectRatio, Qt.SmoothTransformation -> Qt.TransformationMode.SmoothTransformation
                        else:
                           icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
                    except Exception as e:
                        logger.error(f"Error creating thumbnail for {item_name}: {e}")
                        icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
                else:
                    icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon

            elif item_type == 'file':
                icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
            else:
                icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
            list_item.setIcon(icon)
            self.attachment_list_widget.addItem(list_item)
        # ì²¨ë¶€ ëª©ë¡ ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ (ìë™ ì €ì¥ìš©)
        # self.state_changed_signal.emit() # ì—¬ê¸°ì„œ í˜¸ì¶œí•˜ë©´ ë„ˆë¬´ ë¹ˆë²ˆí•  ìˆ˜ ìˆìŒ. attach/paste/remove í•¨ìˆ˜ì—ì„œ í˜¸ì¶œ.

    # --- LangGraph ê´€ë ¨ ë©”ì„œë“œ ---
    def send_prompt_to_gemini(self):
        """ Sends the prompt and attachments to Gemini via LangGraph worker thread. """
        if self.mode == "Meta Prompt Builder":
            QMessageBox.information(self, "ì •ë³´", "Meta Prompt Builder ëª¨ë“œì—ì„œëŠ” Gemini ì „ì†¡ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return
        if not hasattr(self, 'prompt_output_tab'):
            QMessageBox.warning(self, "ì˜¤ë¥˜", "í”„ë¡¬í”„íŠ¸ ì¶œë ¥ íƒ­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return

        prompt_text = self.prompt_output_tab.toPlainText()
        loaded_attachments = []
        for item in self.attached_items:
            if not item.get('data') and item.get('path') and os.path.exists(item['path']):
                try:
                    with open(item['path'], 'rb') as f:
                        item['data'] = f.read()
                    logger.info(f"Loaded data for attachment: {item['name']}")
                except Exception as e:
                    QMessageBox.warning(self, "ì²¨ë¶€ íŒŒì¼ ì˜¤ë¥˜", f"ì²¨ë¶€ íŒŒì¼ '{item['name']}' ë¡œë“œ ì‹¤íŒ¨: {e}")
            loaded_attachments.append(item)


        if not prompt_text.strip() and not loaded_attachments:
            QMessageBox.warning(self, "ê²½ê³ ", "Geminiì— ì „ì†¡í•  í”„ë¡¬í”„íŠ¸ ë‚´ìš©ì´ë‚˜ ì²¨ë¶€ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return

        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(False)
        self.status_bar.showMessage("Gemini API í˜¸ì¶œ ì¤‘...")
        # API í˜¸ì¶œ ì‹œì‘ ì‹œê°„ ê¸°ë¡ ë° í‘œì‹œ
        self.api_call_start_time = datetime.datetime.now()
        start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
        if hasattr(self, 'api_time_label'):
            self.api_time_label.setText(f"API ì‹œì‘: {start_time_str}, ê²½ê³¼: 0:00:00") # ì´ˆê¸° ê²½ê³¼ ì‹œê°„ í‘œì‹œ
        self.api_timer.start(1000) # 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
        QApplication.processEvents()

        if self.gemini_thread and self.gemini_thread.isRunning():
            logger.warning("Terminating previous Gemini thread...")
            self.gemini_thread.quit(); self.gemini_thread.wait()

        selected_model_name = self.model_name_combo.currentText().strip()
        initial_state: GeminiGraphState = {
            "input_prompt": prompt_text,
            "input_attachments": loaded_attachments,
            "selected_model_name": selected_model_name,
            "gemini_response": "",
            "xml_output": "",
            "summary_output": "",
            "error_message": None,
            "log_id": None # log_id ì¶”ê°€
        }

        self.gemini_thread = QThread()
        self.gemini_worker = GeminiWorker(self.gemini_graph, initial_state)
        self.gemini_worker.moveToThread(self.gemini_thread)

        self.gemini_thread.started.connect(self.gemini_worker.run)
        self.gemini_worker.finished.connect(self.handle_gemini_response)
        self.gemini_worker.error.connect(self.handle_gemini_error)
        self.gemini_worker.finished.connect(self.gemini_thread.quit)
        self.gemini_worker.finished.connect(self.gemini_worker.deleteLater)
        self.gemini_thread.finished.connect(self.gemini_thread.deleteLater)
        self.gemini_worker.error.connect(self.gemini_thread.quit)
        self.gemini_worker.error.connect(self.gemini_worker.deleteLater)
        self.gemini_thread.finished.connect(self.cleanup_gemini_thread)

        self.gemini_thread.start()

    def _update_api_elapsed_time(self):
        """ Updates the API elapsed time label. """
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            elapsed_time = datetime.datetime.now() - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS í˜•ì‹
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API ì‹œì‘: {start_time_str}, ê²½ê³¼: {elapsed_str}")
        else:
            # Stop timer if start time is somehow lost
            self.api_timer.stop()

    def handle_gemini_response(self, xml_result: str, summary_result: str):
        """ Handles Gemini response. """
        logger.info("--- Handling Gemini Response ---")
        self.api_timer.stop() # íƒ€ì´ë¨¸ ì¤‘ì§€
        if hasattr(self, 'xml_input_tab'):
            self.xml_input_tab.setPlainText(xml_result)
            logger.info(f"XML Output Length: {len(xml_result)}")
        if hasattr(self, 'summary_tab'):
            self.summary_tab.setPlainText(summary_result)
            logger.info(f"Summary Output Length: {len(summary_result)}")
            self.build_tabs.setCurrentWidget(self.summary_tab)

        # API ê²½ê³¼ ì‹œê°„ ê³„ì‚° ë° í‘œì‹œ (ìµœì¢…)
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now()
            elapsed_time = end_time - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS í˜•ì‹
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API ì‹œì‘: {start_time_str}, ê²½ê³¼: {elapsed_str} (ì™„ë£Œ)")

        self.status_bar.showMessage("Gemini ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ.")
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)

        # --- ì‘ì—… ì™„ë£Œ ì•Œë¦¼ ---
        show_notification("Gemini ì‘ë‹µ ì™„ë£Œ", "Gemini API ì‘ë‹µ ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def handle_gemini_error(self, error_msg: str):
        """ Handles Gemini error, showing user-friendly message for specific API response issues. """
        logger.error(f"--- Handling Gemini Error: {error_msg} ---")
        self.api_timer.stop() # íƒ€ì´ë¨¸ ì¤‘ì§€

        # API ê²½ê³¼ ì‹œê°„ ê³„ì‚° ë° í‘œì‹œ (ì˜¤ë¥˜ ì‹œì—ë„)
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now()
            elapsed_time = end_time - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS í˜•ì‹
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API ì‹œì‘: {start_time_str}, ê²½ê³¼: {elapsed_str} (ì˜¤ë¥˜)")

        user_display_error = error_msg
        if "Gemini API ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜" in error_msg or "Gemini API ì‘ë‹µ ë¬¸ì œ ë°œìƒ" in error_msg:
             user_display_error = "Gemini API ì‘ë‹µ ë¬¸ì œì…ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ Summary íƒ­ì„ í™•ì¸í•˜ì„¸ìš”."
             if hasattr(self, 'summary_tab'):
                 self.summary_tab.setPlainText(f"Gemini ì˜¤ë¥˜ ìƒì„¸:\n{error_msg}")

        QMessageBox.critical(self, "Gemini API ì˜¤ë¥˜", user_display_error)
        self.status_bar.showMessage("Gemini API í˜¸ì¶œ ì˜¤ë¥˜.")
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)

        # --- ì‘ì—… ì˜¤ë¥˜ ì•Œë¦¼ ---
        # ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ ë„ˆë¬´ ê¸¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¼ë¶€ë§Œ í‘œì‹œ
        notification_msg = f"Gemini API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {error_msg[:100]}"
        if len(error_msg) > 100: notification_msg += "..."
        show_notification("Gemini ì˜¤ë¥˜", notification_msg)


    def cleanup_gemini_thread(self):
        """ Cleans up Gemini thread and worker objects. """
        logger.info("--- Cleaning up Gemini thread and worker ---")
        self.api_timer.stop() # ìŠ¤ë ˆë“œ ì •ë¦¬ ì‹œ íƒ€ì´ë¨¸ ì¤‘ì§€
        self.gemini_thread = None
        self.gemini_worker = None
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)


    # --- Gemini íŒŒë¼ë¯¸í„° ê´€ë¦¬ ë©”ì„œë“œ ---
    def load_gemini_settings_to_ui(self):
        """Loads Gemini parameters from DB (via config_service) to UI."""
        # _initialized ì²´í¬ ì œê±°: ì´ˆê¸°í™” ì¤‘ì—ë„ í˜¸ì¶œë  ìˆ˜ ìˆìŒ
        # if not self._initialized: return
        try:
            settings = self.config_service.get_settings()
            if not settings:
                logger.warning("Cannot load Gemini settings to UI: Config settings not available.")
                return

            logger.info("Loading Gemini settings to UI...")
            # ì‹œê·¸ë„ ì°¨ë‹¨
            self.gemini_temp_edit.blockSignals(True); self.gemini_thinking_checkbox.blockSignals(True)
            self.gemini_budget_edit.blockSignals(True); self.gemini_search_checkbox.blockSignals(True)

            # UI ì—…ë°ì´íŠ¸
            self.gemini_temp_edit.setText(str(settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(settings.gemini_enable_search)
            logger.info(f"  Temp: {settings.gemini_temperature}, Thinking: {settings.gemini_enable_thinking}, Budget: {settings.gemini_thinking_budget}, Search: {settings.gemini_enable_search}")

            # ì‹œê·¸ë„ ë³µêµ¬
            self.gemini_temp_edit.blockSignals(False); self.gemini_thinking_checkbox.blockSignals(False)
            self.gemini_budget_edit.blockSignals(False); self.gemini_search_checkbox.blockSignals(False)

            # ìœ„ì ¯ ê°€ì‹œì„± ì„¤ì •
            is_gemini_selected = (self.llm_combo.currentText() == "Gemini")
            if hasattr(self, 'gemini_param_widget'): self.gemini_param_widget.setVisible(is_gemini_selected)
            logger.info("Gemini settings loaded to UI successfully.")

        except Exception as e:
            logger.error(f"Error loading Gemini settings to UI: {e}", exc_info=True)
            QMessageBox.warning(self, "ì˜¤ë¥˜", f"Gemini ì„¤ì •ì„ UIì— ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")


    def save_gemini_settings(self):
        """Saves Gemini parameters from UI to DB (Not Implemented)."""
        # This function is now disabled because saving config back to DB is not implemented.
        # We keep the method to avoid breaking signal connections, but it does nothing.
        if not self._initialized or self._is_saving_gemini_settings: return
        # logger.warning("Saving Gemini parameters to database is currently disabled.")

        # --- Keep the logic to prevent signal loops ---
        self._is_saving_gemini_settings = True
        # Read UI values (optional, could be removed if truly disabled)
        try:
            temp_str = self.gemini_temp_edit.text().strip(); temperature = float(temp_str) if temp_str else 0.0
            enable_thinking = self.gemini_thinking_checkbox.isChecked()
            budget_str = self.gemini_budget_edit.text().strip(); thinking_budget = int(budget_str) if budget_str else 0
            enable_search = self.gemini_search_checkbox.isChecked()
            # print(f"Gemini UI Params: T={temperature}, Think={enable_thinking}, Bud={thinking_budget}, Srch={enable_search}")
        except ValueError:
            pass # Ignore errors if UI has invalid temp values temporarily
        finally:
            self._is_saving_gemini_settings = False
        # --- End of signal loop prevention ---

        # --- Actual saving logic is removed ---
        # try:
        #     # ... (read UI values) ...
        #     update_data = { ... }
        #     # self.config_service.update_settings(**update_data) # This line is removed/commented
        #     print(f"Gemini settings UI changed, but saving to DB is disabled.")
        # except Exception as e:
        #     print(f"Error preparing Gemini settings (saving disabled): {e}")
        # finally: self._is_saving_gemini_settings = False


    # --- Event Handlers ---
    def on_copy_shortcut(self):
        """Handles Ctrl+C shortcut."""
        current_widget = self.build_tabs.currentWidget()
        if isinstance(current_widget, CustomTextEdit):
            if current_widget.textCursor().hasSelection(): current_widget.copy()
            elif current_widget == self.prompt_output_tab or \
                 (hasattr(self, 'final_prompt_tab') and current_widget == self.final_prompt_tab):
                self.prompt_controller.copy_to_clipboard()

    def on_tree_view_context_menu(self, position):
        """Handles context menu requests on the file tree view."""
        index = self.tree_view.indexAt(position)
        if not index.isValid(): return
        file_path = self.checkable_proxy.get_file_path_from_index(index)
        if not file_path: return
        menu = QMenu()
        rename_action = QAction("ì´ë¦„ ë³€ê²½", self) # PyQt6: QAction(text, parent)
        delete_action = QAction("ì‚­ì œ", self) # PyQt6: QAction(text, parent)
        menu.addAction(rename_action)
        menu.addAction(delete_action)
        action = menu.exec(self.tree_view.viewport().mapToGlobal(position)) # exec_() -> exec()
        if action == rename_action: self.file_tree_controller.rename_item(file_path)
        elif action == delete_action: self.file_tree_controller.delete_item(file_path)

    def on_tree_view_item_clicked(self, index: QModelIndex):
        """
        Handles item clicks in the tree view to toggle check state for selected items.
        Applies the toggled state of the clicked item to all currently selected items.
        """
        if not index.isValid() or index.column() != 0:
            return

        # í´ë¦­ëœ ì•„ì´í…œì˜ í˜„ì¬ ì²´í¬ ìƒíƒœ í™•ì¸
        current_state_value = self.checkable_proxy.data(index, Qt.ItemDataRole.CheckStateRole)
        if isinstance(current_state_value, Qt.CheckState):
            current_check_state = current_state_value
        elif isinstance(current_state_value, int):
            current_check_state = Qt.CheckState(current_state_value)
        else:
            logger.warning(f"on_tree_view_item_clicked: Unexpected data type for CheckStateRole: {type(current_state_value)}")
            return

        # ëª©í‘œ ì²´í¬ ìƒíƒœ ê²°ì • (í´ë¦­ëœ ì•„ì´í…œ ê¸°ì¤€ í† ê¸€)
        target_check_state = Qt.CheckState.Unchecked if current_check_state == Qt.CheckState.Checked else Qt.CheckState.Checked

        # í˜„ì¬ ì„ íƒëœ ëª¨ë“  ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
        selection_model = self.tree_view.selectionModel()
        selected_indexes = selection_model.selectedIndexes()

        logger.debug(f"Clicked item: {self.checkable_proxy.get_file_path_from_index(index)}, Target state: {target_check_state}, Selected count: {len(selected_indexes)}")

        # ì„ íƒëœ ëª¨ë“  ì•„ì´í…œì— ëŒ€í•´ ëª©í‘œ ìƒíƒœ ì ìš©
        indices_processed = set() # ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€

        try:
            for selected_index in selected_indexes:
                # 0ë²ˆ ì»¬ëŸ¼ì´ê³ , ì•„ì§ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì¸ë±ìŠ¤ë§Œ
                if selected_index.isValid() and selected_index.column() == 0 and selected_index not in indices_processed:
                    # setData í˜¸ì¶œí•˜ì—¬ ëª¨ë¸ ë°ì´í„° ë³€ê²½ ë° UI ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
                    # setData ë‚´ë¶€ì—ì„œ ì‹¤ì œ ë³€ê²½ì´ í•„ìš”í•œì§€ í™•ì¸í•˜ê³  ì²˜ë¦¬í•¨
                    logger.debug(f"  Calling setData for selected index: {self.checkable_proxy.get_file_path_from_index(selected_index)} with state {target_check_state}")
                    self.checkable_proxy.setData(selected_index, target_check_state, Qt.ItemDataRole.CheckStateRole)
                    indices_processed.add(selected_index) # ì²˜ë¦¬ëœ ì¸ë±ìŠ¤ ê¸°ë¡

        finally:
            pass # í”Œë˜ê·¸ ê´€ë¦¬ëŠ” setData ë‚´ë¶€ì—ì„œ ì²˜ë¦¬

        # ì²´í¬ ìƒíƒœ ë³€ê²½ í›„ ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì¬ì‹œì‘
        self.state_changed_signal.emit()


    def restart_auto_save_timer(self):
        """Restarts the auto-save timer."""
        if self._initialized:
            # logger.debug("Restarting auto-save timer.")
            self.auto_save_timer.start(30000) # 30ì´ˆ í›„ ì €ì¥ìœ¼ë¡œ ë³€ê²½

    def eventFilter(self, source: QObject, event: QEvent) -> bool:
        """
        Filters events for specific widgets, handling Ctrl+Enter in the user tab.
        Modified to run "Generate All" then "Send to Gemini".
        Checks if prompt was generated before sending.
        """
        # ì‚¬ìš©ì íƒ­(user_tab)ì—ì„œ ë°œìƒí•˜ëŠ” í‚¤ ì…ë ¥ ì´ë²¤íŠ¸ì¸ì§€ í™•ì¸
        if source == self.user_tab and event.type() == QEvent.Type.KeyPress:
            # QKeyEvent íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ… (PyQt6ì—ì„œëŠ” í•„ìš” ì—†ì„ ìˆ˜ ìˆìœ¼ë‚˜ ëª…ì‹œì )
            key_event = event
            if isinstance(key_event, QKeyEvent):
                # Ctrl í‚¤ì™€ Enter í‚¤ê°€ í•¨ê»˜ ëˆŒë ¸ëŠ”ì§€ í™•ì¸
                is_control_pressed = bool(key_event.modifiers() & Qt.KeyboardModifier.ControlModifier) # Qt.ControlModifier -> Qt.KeyboardModifier.ControlModifier
                is_enter_key = key_event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter)

                if is_control_pressed and is_enter_key:
                    logger.info("Ctrl+Enter detected in user_tab. Triggering 'Generate All' then 'Send to Gemini'.")

                    # Code Enhancer ëª¨ë“œì—ì„œë§Œ ë™ì‘
                    if self.mode == "Code Enhancer Prompt Builder":
                        logger.info("Running 'Generate All'...")
                        # generate_all_and_copyëŠ” í”„ë¡¬í”„íŠ¸ ìƒì„± ì„±ê³µ ì‹œ True ë°˜í™˜
                        success_generate_all = self.prompt_controller.generate_all_and_copy()

                        # í”„ë¡¬í”„íŠ¸ê°€ ì‹¤ì œë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸ (last_generated_prompt ì‚¬ìš©)
                        prompt_generated = bool(self.last_generated_prompt and self.last_generated_prompt.strip())

                        if prompt_generated:
                            logger.info("Prompt generated. Proceeding to 'Send to Gemini'.")
                            if not success_generate_all:
                                # í”„ë¡¬í”„íŠ¸ëŠ” ìƒì„±ë˜ì—ˆì§€ë§Œ, íŠ¸ë¦¬ ìƒì„± ë˜ëŠ” ë³µì‚¬ ì‹¤íŒ¨ ì‹œ ì •ë³´ ë©”ì‹œì§€
                                logger.warning("'Generate All' returned False, but prompt was generated. Sending to Gemini anyway.")
                                # ì‚¬ìš©ìì—ê²Œ ì•Œë¦´ í•„ìš”ëŠ” ì—†ì„ ìˆ˜ ìˆìŒ (ìƒíƒœë°” ë©”ì‹œì§€ë¡œ ëŒ€ì²´ ê°€ëŠ¥)
                                # QMessageBox.information(self, "ì •ë³´", "ì¼ë¶€ ì‘ì—…(íŠ¸ë¦¬ ìƒì„± ë˜ëŠ” ë³µì‚¬)ì— ì‹¤íŒ¨í–ˆì§€ë§Œ Gemini ì „ì†¡ì„ ì‹œë„í•©ë‹ˆë‹¤.")
                                self.status_bar.showMessage("ì¼ë¶€ ì‘ì—… ì‹¤íŒ¨, Gemini ì „ì†¡ ì‹œë„...")
                            # Gemini ì „ì†¡ ì‹¤í–‰
                            self.send_prompt_to_gemini()
                        else:
                            # í”„ë¡¬í”„íŠ¸ ìƒì„± ìì²´ê°€ ì‹¤íŒ¨í•œ ê²½ìš°
                            logger.error("'Generate All' failed to generate a prompt. Skipping 'Send to Gemini'.")
                            QMessageBox.warning(self, "ì‹¤íŒ¨", "'í•œë²ˆì— ì‹¤í–‰' ì‘ì—… ì¤‘ í”„ë¡¬í”„íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í•˜ì—¬ Geminië¡œ ì „ì†¡í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
                    else:
                        # Meta ëª¨ë“œì—ì„œëŠ” ë‹¤ë¥¸ ë™ì‘ ë˜ëŠ” ë¹„í™œì„±í™”
                        logger.info("Ctrl+Enter ignored in Meta Prompt Builder mode.")

                    return True # ì´ë²¤íŠ¸ ì²˜ë¦¬ ì™„ë£Œ (ê¸°ë³¸ ë™ì‘ ë°©ì§€)

        # ë‹¤ë¥¸ ìœ„ì ¯ì´ë‚˜ ì´ë²¤íŠ¸ëŠ” ê¸°ë³¸ ì²˜ë¦¬
        return super().eventFilter(source, event)


    def closeEvent(self, event):
        """Ensure database connection is closed and threads are stopped when the window closes."""
        logger.info("Closing MainWindow. Stopping threads and disconnecting database.")
        self.auto_save_timer.stop() # ìœˆë„ìš° ë‹«ì„ ë•Œ ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì¤‘ì§€
        self.api_timer.stop() # ìœˆë„ìš° ë‹«ì„ ë•Œ API íƒ€ì´ë¨¸ ì¤‘ì§€
        # ì§„í–‰ ì¤‘ì¸ ìŠ¤ë ˆë“œ ì¤‘ì§€ ì‹œë„
        if hasattr(self, 'main_controller'):
            self.main_controller._stop_token_calculation_thread()
        if self.gemini_thread and self.gemini_thread.isRunning():
            logger.warning("Terminating Gemini thread on close...")
            self.gemini_thread.quit()
            self.gemini_thread.wait(1000) # Wait up to 1 second
            if self.gemini_thread and self.gemini_thread.isRunning():
                self.gemini_thread.terminate()
                self.gemini_thread.wait()
            self.cleanup_gemini_thread()

        # ë§ˆì§€ë§‰ ìƒíƒœ ì €ì¥ ì‹œë„ (ì„ íƒì )
        try:
            logger.info("Attempting to save final state before closing...")
            self.resource_controller.save_state_to_default()
        except Exception as e:
            logger.error(f"Error saving final state: {e}")

        if hasattr(self, 'db_service'):
            self.db_service.disconnect()
        super().closeEvent(event)



======== src\ui\main_window_setup_signals.py ========
from PyQt6.QtGui import QKeySequence, QAction # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow íƒ€ì… íŒíŠ¸
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# ì»¨íŠ¸ë¡¤ëŸ¬ import (í•¨ìˆ˜ í˜¸ì¶œìš©)
def connect_signals(mw: 'MainWindow'):
    """Connects widget signals to controller slots."""
    # ìƒë‹¨ ë²„íŠ¼
    mw.mode_toggle_btn.clicked.connect(mw._toggle_mode)
    mw.reset_program_btn.clicked.connect(mw.main_controller.reset_program) # MainController
    mw.load_previous_work_btn.clicked.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.save_current_work_btn.clicked.connect(mw.resource_controller.save_state_to_default) # ResourceController (save default)
    mw.select_project_btn.clicked.connect(mw.file_tree_controller.select_project_folder) # FileTreeController

    # íŒŒì¼ íŠ¸ë¦¬
    mw.tree_view.customContextMenuRequested.connect(mw.on_tree_view_context_menu) # MainWindow (ì»¨íŠ¸ë¡¤ëŸ¬ í˜¸ì¶œ)
    mw.tree_view.clicked.connect(mw.on_tree_view_item_clicked) # ì•„ì´í…œ í´ë¦­ ì‹œ ì²´í¬ ìƒíƒœ í† ê¸€ (ì—°ê²° ë³µì›)
    mw.checkable_proxy.dataChanged.connect(mw.file_tree_controller.on_data_changed) # FileTreeController
    # íŒŒì¼ ì²´í¬ ìƒíƒœ ë³€ê²½ ì‹œ MainWindowì˜ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
    mw.checkable_proxy.dataChanged.connect(lambda topLeft, bottomRight, roles: mw.state_changed_signal.emit() if Qt.ItemDataRole.CheckStateRole in roles else None) # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole


    # ì‹¤í–‰ ë²„íŠ¼
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn.clicked.connect(mw.file_tree_controller.generate_directory_tree_structure) # FileTreeController
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_prompt) # PromptController (Calculates tokens)
        mw.send_to_gemini_btn.clicked.connect(mw.send_prompt_to_gemini) # MainWindow (LangGraph í˜¸ì¶œ)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        mw.run_xml_parser_btn.clicked.connect(mw.xml_controller.run_xml_parser) # XmlController
        mw.generate_all_btn.clicked.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens via generate_prompt)
    else:
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        if hasattr(mw, "generate_final_prompt_btn"):
            mw.generate_final_prompt_btn.clicked.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)

    # ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
    mw.resource_mode_combo.currentIndexChanged.connect(mw.resource_controller.load_templates_list) # ResourceController
    mw.load_selected_template_btn.clicked.connect(mw.resource_controller.load_selected_item) # ResourceController
    mw.save_as_template_btn.clicked.connect(mw.resource_controller.save_current_as_item) # ResourceController
    mw.delete_template_btn.clicked.connect(mw.resource_controller.delete_selected_item) # ResourceController
    mw.update_template_btn.clicked.connect(mw.resource_controller.update_current_item) # ResourceController
    # ë°±ì—…/ë³µì› ë²„íŠ¼ ì‹œê·¸ë„ ì—°ê²° ì œê±°
    # mw.backup_button.clicked.connect(mw.resource_controller.backup_all_states_action)
    # mw.restore_button.clicked.connect(mw.resource_controller.restore_states_from_backup_action)
    mw.template_tree.itemDoubleClicked.connect(mw.resource_controller.load_selected_item) # ResourceController

    # ì²¨ë¶€ íŒŒì¼ ê´€ë¦¬ ë²„íŠ¼ (ì¶”ê°€)
    if hasattr(mw, 'attach_file_btn'):
        mw.attach_file_btn.clicked.connect(mw.main_controller.attach_files) # MainController
    if hasattr(mw, 'paste_clipboard_btn'):
        mw.paste_clipboard_btn.clicked.connect(mw.main_controller.paste_from_clipboard) # MainController
    if hasattr(mw, 'remove_attachment_btn'):
        mw.remove_attachment_btn.clicked.connect(mw.main_controller.remove_selected_attachment) # MainController

    # ìƒíƒœë°” & ëª¨ë¸ ì„ íƒ
    mw.llm_combo.currentIndexChanged.connect(mw.main_controller.on_llm_selected) # MainController (Resets token label)
    # ëª¨ë¸ëª… ë³€ê²½ ì‹œ ìƒíƒœ ë³€ê²½ ì‹œê·¸ë„ ë°œìƒ
    mw.model_name_combo.currentIndexChanged.connect(lambda: mw.state_changed_signal.emit())
    mw.model_name_combo.lineEdit().editingFinished.connect(lambda: mw.state_changed_signal.emit())


    # --- Gemini íŒŒë¼ë¯¸í„° ë³€ê²½ ì‹œê·¸ë„ ì—°ê²° ì œê±° (DB ì €ì¥ ë¹„í™œì„±í™”) ---
    # mw.gemini_temp_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_thinking_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # mw.gemini_budget_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_search_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # -----------------------------------------------------------

    # í…ìŠ¤íŠ¸ ë³€ê²½ ì‹œ ë¬¸ì ìˆ˜ ì—…ë°ì´íŠ¸ ë° í† í° ë ˆì´ë¸” ë¦¬ì…‹ (í˜„ì¬ í™œì„± íƒ­ ê¸°ì¤€)
    mw.build_tabs.currentChanged.connect(mw.main_controller.update_char_count_for_active_tab) # Update char counts when tab changes
    # Connect textChanged for all relevant text edit widgets to the new handler
    mw.system_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.user_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.prompt_output_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'dir_structure_tab'):
        mw.dir_structure_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'xml_input_tab'):
        mw.xml_input_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'summary_tab'): # Summary íƒ­ ì—°ê²° ì¶”ê°€
        mw.summary_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'meta_prompt_tab'):
        mw.meta_prompt_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'user_prompt_tab'):
        user_prompt_tab_widget = getattr(mw, 'user_prompt_tab', None)
        if user_prompt_tab_widget:
            user_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'final_prompt_tab'):
        final_prompt_tab_widget = getattr(mw, 'final_prompt_tab', None)
        if final_prompt_tab_widget:
            final_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    # Custom tabs added later will have their signals connected in add_new_custom_tab

    # ë©”ë‰´ ì•¡ì…˜
    mw.settings_action.triggered.connect(mw.open_settings_dialog) # ì„¤ì • ë©”ë‰´ ì—°ê²°
    mw.save_state_action.triggered.connect(mw.resource_controller.save_state_to_default) # ResourceController
    mw.load_state_action.triggered.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.export_state_action.triggered.connect(mw.resource_controller.export_state_to_file) # ResourceController
    mw.import_state_action.triggered.connect(mw.resource_controller.import_state_from_file) # ResourceController

    # ë‹¨ì¶•í‚¤
    # Ctrl+Enter ë‹¨ì¶•í‚¤ëŠ” MainWindowì˜ eventFilterì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì œê±°
    # shortcut_generate = QAction(mw) # PyQt6: QAction(parent)
    # shortcut_generate.setShortcut(QKeySequence(Qt.Modifier.CTRL | Qt.Key.Key_Return)) # PyQt6: Use Qt.Modifier and Qt.Key
    # if mw.mode == "Meta Prompt Builder":
    #      if hasattr(mw, "generate_final_prompt_btn"):
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)
    #      else:
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
    # else:
    #      shortcut_generate.triggered.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens)
    # mw.addAction(shortcut_generate)

    shortcut_copy = QAction(mw) # PyQt6: QAction(parent)
    shortcut_copy.setShortcut(QKeySequence(QKeySequence.StandardKey.Copy)) # PyQt6: Use StandardKey enum
    shortcut_copy.triggered.connect(mw.on_copy_shortcut) # MainWindow
    mw.addAction(shortcut_copy)

    # ì‚¬ìš©ì íƒ­ì— ì´ë²¤íŠ¸ í•„í„° ì„¤ì¹˜ (MainWindow ìƒì„±ìì—ì„œ ìˆ˜í–‰)
    # if hasattr(mw, 'user_tab'):
    #     mw.user_tab.installEventFilter(mw)



======== src\ui\main_window_setup_ui.py ========
import os
import sys
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QWidget, QVBoxLayout, QHBoxLayout, QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox, QAbstractItemView, QMenuBar,
    QSplitter, QStyleFactory, QApplication, QMenu, QTreeWidget, QComboBox,
    QFrame, QLineEdit, QGroupBox, QSpacerItem, QSizePolicy, QListWidget,
    QGridLayout
)
from PyQt6.QtGui import QFont, QFontDatabase, QAction # PyQt5 -> PyQt6, QAction ì¶”ê°€
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow íƒ€ì… íŒíŠ¸
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# ëª¨ë¸ ë° ìœ„ì ¯ import
from .models.file_system_models import FilteredFileSystemModel, CheckableProxyModel
from .widgets.custom_text_edit import CustomTextEdit
from .widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from .widgets.check_box_delegate import CheckBoxDelegate
from .widgets.file_tree_view import FileTreeView

def create_menu_bar(mw: 'MainWindow'):
    """Creates the main menu bar."""
    mw.menubar = QMenuBar(mw)
    mw.setMenuBar(mw.menubar)

    # "íŒŒì¼" ë©”ë‰´ ì œê±°, "í™˜ê²½ ì„¤ì •" ë©”ë‰´ë¥¼ ì²« ë²ˆì§¸ë¡œ ì¶”ê°€
    settings_menu = mw.menubar.addMenu("í™˜ê²½ ì„¤ì •") # "íŒŒì¼" ëŒ€ì‹  "í™˜ê²½ ì„¤ì •" ë©”ë‰´ ì¶”ê°€
    mw.settings_action = QAction("í™˜ê²½ ì„¤ì • ì—´ê¸°...", mw) # PyQt6: QAction(text, parent)
    settings_menu.addAction(mw.settings_action)
    settings_menu.addSeparator() # í•„ìš” ì‹œ êµ¬ë¶„ì„  ì¶”ê°€

    # ë‚˜ë¨¸ì§€ ë©”ë‰´ë“¤
    mode_menu = mw.menubar.addMenu("ëª¨ë“œ")
    switch_to_code_action = QAction("ì½”ë“œ ê°•í™” ë¹Œë”ë¡œ ì „í™˜", mw) # PyQt6: QAction(text, parent)
    switch_to_meta_action = QAction("ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ë¹Œë”ë¡œ ì „í™˜", mw) # PyQt6: QAction(text, parent)
    switch_to_code_action.triggered.connect(lambda: mw._restart_with_mode("Code Enhancer Prompt Builder"))
    switch_to_meta_action.triggered.connect(lambda: mw._restart_with_mode("Meta Prompt Builder"))
    mode_menu.addAction(switch_to_code_action)
    mode_menu.addAction(switch_to_meta_action)

    state_menu = mw.menubar.addMenu("ìƒíƒœ")
    mw.save_state_action = QAction("ìƒíƒœ ì €ì¥(ê¸°ë³¸)", mw) # PyQt6: QAction(text, parent)
    mw.load_state_action = QAction("ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°(ê¸°ë³¸)", mw) # PyQt6: QAction(text, parent)
    mw.export_state_action = QAction("ìƒíƒœ ë‚´ë³´ë‚´ê¸°", mw) # PyQt6: QAction(text, parent)
    mw.import_state_action = QAction("ìƒíƒœ ê°€ì ¸ì˜¤ê¸°", mw) # PyQt6: QAction(text, parent)
    state_menu.addAction(mw.save_state_action)
    state_menu.addAction(mw.load_state_action)
    state_menu.addAction(mw.export_state_action)
    state_menu.addAction(mw.import_state_action)

    help_menu = mw.menubar.addMenu("ë„ì›€ë§")
    open_readme_action = QAction("README ì—´ê¸°", mw) # PyQt6: QAction(text, parent)
    open_readme_action.triggered.connect(mw._open_readme)
    help_menu.addAction(open_readme_action)


def create_widgets(mw: 'MainWindow'):
    """Creates the main widgets used in the window."""
    # --- OSë³„ ê¸°ë³¸ í°íŠ¸ ì„¤ì • ---
    default_font = QFont()
    font_family_name = ""
    if sys.platform == "win32":
        try:
            font_path = get_resource_path("fonts/malgun.ttf")
            font_id = QFontDatabase.addApplicationFont(font_path)
            if font_id != -1:
                family = QFontDatabase.applicationFontFamilies(font_id)[0]
                print(f"Loaded custom font: {family} from {font_path}")
                default_font = QFont(family, 10)
                font_family_name = family
            else:
                print(f"Failed to load custom font from {font_path}. Using system default.")
                default_font.setFamily("Malgun Gothic")
                default_font.setPointSize(10)
                font_family_name = "Malgun Gothic (Fallback)"
        except Exception as e:
            print(f"Error loading custom font: {e}. Using system default.")
            default_font.setFamily("Malgun Gothic")
            default_font.setPointSize(10)
            font_family_name = "Malgun Gothic (Exception Fallback)"
    elif sys.platform == "darwin":
        default_font.setFamily("Apple SD Gothic Neo")
        default_font.setPointSize(11)
        font_family_name = "Apple SD Gothic Neo"
    else:
        default_font.setStyleHint(QFont.StyleHint.SansSerif) # QFont.SansSerif -> QFont.StyleHint.SansSerif
        default_font.setPointSize(10)
        font_family_name = "System Default Sans-Serif"
    print(f"Applying default font: {font_family_name}, Size: {default_font.pointSize()}")

    # --- ìƒë‹¨ ë²„íŠ¼ ë° ë ˆì´ë¸” ---
    mw.mode_toggle_btn = QPushButton("ğŸ”„ ëª¨ë“œ ì „í™˜")
    mw.reset_program_btn = QPushButton("ğŸ—‘ï¸ ì „ì²´ í”„ë¡œê·¸ë¨ ë¦¬ì…‹")
    mw.load_previous_work_btn = QPushButton("âª ë§ˆì§€ë§‰ ì‘ì—… ë¶ˆëŸ¬ì˜¤ê¸°") # ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
    mw.save_current_work_btn = QPushButton("ğŸ’¾ í˜„ì¬ ì‘ì—… ì €ì¥") # ì‘ì—… ì €ì¥ ë²„íŠ¼ ì¶”ê°€
    mw.select_project_btn = QPushButton("ğŸ“ í”„ë¡œì íŠ¸ í´ë” ì„ íƒ")
    for btn in [mw.mode_toggle_btn, mw.reset_program_btn, mw.load_previous_work_btn, mw.save_current_work_btn, mw.select_project_btn]: # ìƒˆ ë²„íŠ¼ í¬í•¨
        btn.setFixedHeight(30)
    mw.project_folder_label = QLabel("í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”: (ì„ íƒ ì•ˆ ë¨)")
    font_lbl = mw.project_folder_label.font()
    font_lbl.setPointSize(10); font_lbl.setBold(True)
    mw.project_folder_label.setFont(font_lbl)

    # --- íŒŒì¼ íƒìƒ‰ê¸° (ì™¼ìª½) ---
    mw.dir_model = FilteredFileSystemModel()
    mw.tree_view = FileTreeView()
    project_folder_getter = lambda: mw.current_project_folder
    mw.checkable_proxy = CheckableProxyModel(mw.dir_model, project_folder_getter, mw.fs_service, mw.tree_view)
    mw.checkable_proxy.setSourceModel(mw.dir_model)
    mw.tree_view.setModel(mw.checkable_proxy)
    mw.tree_view.setColumnWidth(0, 250)
    mw.tree_view.hideColumn(1); mw.tree_view.hideColumn(2); mw.tree_view.hideColumn(3)
    mw.tree_view.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    mw.tree_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu) # Qt.CustomContextMenu -> Qt.ContextMenuPolicy.CustomContextMenu
    mw.tree_view.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers) # QAbstractItemView.NoEditTriggers -> QAbstractItemView.EditTrigger.NoEditTriggers
    mw.tree_view.setItemDelegateForColumn(0, CheckBoxDelegate(mw.tree_view))

    # --- ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ (ì˜¤ë¥¸ìª½ í•˜ë‹¨) ---
    mw.resource_manager_group = QGroupBox("ë¦¬ì†ŒìŠ¤ ê´€ë¦¬")
    resource_manager_layout = QGridLayout() # QVBoxLayout ëŒ€ì‹  QGridLayout ì‚¬ìš©
    resource_manager_layout.setContentsMargins(5, 5, 5, 5); resource_manager_layout.setSpacing(5)

    # ìœ„ì ¯ ìƒì„± (ê¸°ì¡´ ì½”ë“œ ì¬ì‚¬ìš©)
    mw.resource_mode_combo = QComboBox(); mw.resource_mode_combo.addItems(["í”„ë¡¬í”„íŠ¸", "ìƒíƒœ"])
    mw.template_tree = QTreeWidget(); mw.template_tree.setHeaderHidden(True)
    mw.load_selected_template_btn = QPushButton("ğŸ“¥ ì„ íƒ ë¶ˆëŸ¬ì˜¤ê¸°")
    mw.save_as_template_btn = QPushButton("ğŸ’¾ í˜„ì¬ ë‚´ìš©ìœ¼ë¡œ ì €ì¥")
    mw.template_type_label = QLabel("ì €ì¥ íƒ€ì…:")
    mw.template_type_combo = QComboBox(); mw.template_type_combo.addItems(["ì‹œìŠ¤í…œ", "ì‚¬ìš©ì"])
    mw.delete_template_btn = QPushButton("âŒ ì„ íƒ ì‚­ì œ")
    mw.update_template_btn = QPushButton("ğŸ”„ í˜„ì¬ ë‚´ìš© ì—…ë°ì´íŠ¸")

    # --- ë ˆì´ì•„ì›ƒ ì¬êµ¬ì„± (2ì—´ ê·¸ë¦¬ë“œ) ---
    # ì™¼ìª½ ì—´ (Column 0)
    resource_manager_layout.addWidget(QLabel("ì•„ë˜ì—ì„œ ë¡œë“œ/ì €ì¥í•  ë¦¬ì†ŒìŠ¤ ì„ íƒ:"), 0, 0, 1, 2) # ë¼ë²¨ì€ 2ì—´ì— ê±¸ì³ í‘œì‹œ
    resource_manager_layout.addWidget(mw.template_tree, 1, 0, 6, 1) # íŠ¸ë¦¬ëŠ” 1í–‰ë¶€í„° 6ê°œ í–‰ì— ê±¸ì³ í‘œì‹œ

    # ì˜¤ë¥¸ìª½ ì—´ (Column 1) - ìœ„ì ¯ ë°°ì¹˜ ìˆœì„œ ì¡°ì •
    resource_manager_layout.addWidget(mw.load_selected_template_btn, 1, 1) # í–‰ 1

    # ì €ì¥ íƒ€ì… ë ˆì´ì•„ì›ƒ (HBox)
    save_type_layout = QHBoxLayout()
    save_type_layout.addWidget(mw.template_type_label)
    save_type_layout.addWidget(mw.template_type_combo)
    save_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(save_type_layout, 2, 1) # í–‰ 2

    # ë¦¬ì†ŒìŠ¤ íƒ€ì… ì„ íƒ ë ˆì´ì•„ì›ƒ (HBox)
    resource_type_layout = QHBoxLayout()
    resource_type_layout.addWidget(QLabel("ë¦¬ì†ŒìŠ¤ íƒ€ì… ì„ íƒ:"))
    resource_type_layout.addWidget(mw.resource_mode_combo)
    resource_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(resource_type_layout, 3, 1) # í–‰ 3

    resource_manager_layout.addWidget(mw.save_as_template_btn, 4, 1) # í–‰ 4
    resource_manager_layout.addWidget(mw.update_template_btn, 5, 1) # í–‰ 5
    resource_manager_layout.addWidget(mw.delete_template_btn, 6, 1) # í–‰ 6

    # ì˜¤ë¥¸ìª½ ì—´ í•˜ë‹¨ì— ë¹ˆ ê³µê°„ ì¶”ê°€ (ì„ íƒì )
    resource_manager_layout.addItem(QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding), 7, 1) # QSizePolicy.Minimum -> QSizePolicy.Policy.Minimum, QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding

    # ì—´ ë„ˆë¹„ ë¹„ìœ¨ ì„¤ì • (ì„ íƒì )
    resource_manager_layout.setColumnStretch(0, 1) # ì™¼ìª½ ì—´(íŠ¸ë¦¬)ì´ ë‚¨ëŠ” ê³µê°„ ì°¨ì§€
    resource_manager_layout.setColumnStretch(1, 0) # ì˜¤ë¥¸ìª½ ì—´(ë²„íŠ¼)ì€ í•„ìš”í•œ ë§Œí¼ë§Œ

    mw.resource_manager_group.setLayout(resource_manager_layout) # ìµœì¢… ë ˆì´ì•„ì›ƒ ì„¤ì •

    # --- ì²¨ë¶€ íŒŒì¼ ê´€ë¦¬ (ì™¼ìª½ í•˜ë‹¨ìœ¼ë¡œ ì´ë™) ---
    mw.attachment_group = QGroupBox("ì²¨ë¶€ íŒŒì¼")
    attachment_layout = QVBoxLayout()
    attachment_layout.setContentsMargins(5, 5, 5, 5); attachment_layout.setSpacing(5)
    attachment_button_layout = QHBoxLayout()
    mw.attach_file_btn = QPushButton("ğŸ“ íŒŒì¼ ì²¨ë¶€")
    mw.paste_clipboard_btn = QPushButton("ğŸ“‹ í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸°")
    mw.remove_attachment_btn = QPushButton("â– ì„ íƒ ì œê±°")
    attachment_button_layout.addWidget(mw.attach_file_btn)
    attachment_button_layout.addWidget(mw.paste_clipboard_btn)
    attachment_button_layout.addWidget(mw.remove_attachment_btn)
    attachment_button_layout.addStretch()
    mw.attachment_list_widget = QListWidget() # ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    mw.attachment_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    attachment_layout.addLayout(attachment_button_layout)
    attachment_layout.addWidget(mw.attachment_list_widget, 1) # ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì´ ê³µê°„ ì°¨ì§€
    mw.attachment_group.setLayout(attachment_layout)
    # Code Enhancer ëª¨ë“œì—ì„œë§Œ ë³´ì´ë„ë¡ ì„¤ì • (ì´ˆê¸° ìƒíƒœ)
    mw.attachment_group.setVisible(mw.mode == "Code Enhancer Prompt Builder")


    # --- íƒ­ ìœ„ì ¯ (ì˜¤ë¥¸ìª½ ìƒë‹¨) ---
    mw.build_tabs = QTabWidget()
    custom_tab_bar = CustomTabBar(mw.build_tabs, mw)
    mw.build_tabs.setTabBar(custom_tab_bar)
    system_tab_label = "ë©”íƒ€ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿" if mw.mode == "Meta Prompt Builder" else "ì‹œìŠ¤í…œ"
    user_tab_label = "ë©”íƒ€ ì‚¬ìš©ì ì…ë ¥" if mw.mode == "Meta Prompt Builder" else "ì‚¬ìš©ì"
    prompt_output_label = "ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ì¶œë ¥" if mw.mode == "Meta Prompt Builder" else "í”„ë¡¬í”„íŠ¸ ì¶œë ¥"
    mw.system_tab = CustomTextEdit(); mw.system_tab.setPlaceholderText(f"{system_tab_label} ë‚´ìš© ì…ë ¥..."); mw.system_tab.setFont(default_font); mw.build_tabs.addTab(mw.system_tab, system_tab_label)
    mw.user_tab = CustomTextEdit(); mw.user_tab.setPlaceholderText(f"{user_tab_label} ë‚´ìš© ì…ë ¥..."); mw.user_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_tab, user_tab_label)
    if mw.mode != "Meta Prompt Builder":
        mw.dir_structure_tab = CustomTextEdit(); mw.dir_structure_tab.setReadOnly(True); mw.dir_structure_tab.setFont(default_font); mw.build_tabs.addTab(mw.dir_structure_tab, "íŒŒì¼ íŠ¸ë¦¬")
    mw.prompt_output_tab = CustomTextEdit()
    output_font = QFont("Consolas", 10) if sys.platform == "win32" else QFont("Monaco", 11) if sys.platform == "darwin" else QFont("Monospace", 10); output_font.setStyleHint(QFont.StyleHint.Monospace) # QFont.Monospace -> QFont.StyleHint.Monospace
    mw.prompt_output_tab.setFont(output_font); mw.prompt_output_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.prompt_output_tab, prompt_output_label)
    if mw.mode != "Meta Prompt Builder":
        mw.xml_input_tab = CustomTextEdit(); mw.xml_input_tab.setPlaceholderText("XML ë‚´ìš© ì…ë ¥..."); mw.xml_input_tab.setFont(default_font); mw.build_tabs.addTab(mw.xml_input_tab, "XML ì…ë ¥")
        mw.summary_tab = CustomTextEdit(); mw.summary_tab.setPlaceholderText("Gemini ì‘ë‹µ ìš”ì•½..."); mw.summary_tab.setReadOnly(True); mw.summary_tab.setFont(default_font); mw.build_tabs.addTab(mw.summary_tab, "Summary")
    if mw.mode == "Meta Prompt Builder":
        mw.meta_prompt_tab = CustomTextEdit(); mw.meta_prompt_tab.setPlaceholderText("ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ë‚´ìš©..."); mw.meta_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.meta_prompt_tab, "ë©”íƒ€ í”„ë¡¬í”„íŠ¸")
        mw.user_prompt_tab = CustomTextEdit(); mw.user_prompt_tab.setPlaceholderText("ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ë‚´ìš© ì…ë ¥..."); mw.user_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_prompt_tab, "ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸")
        mw.final_prompt_tab = CustomTextEdit(); mw.final_prompt_tab.setFont(output_font); mw.final_prompt_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.final_prompt_tab, "ìµœì¢… í”„ë¡¬í”„íŠ¸")

    # --- ì‹¤í–‰ ë²„íŠ¼ (ì˜¤ë¥¸ìª½ ìƒë‹¨) ---
    copy_btn_label = "ğŸ“‹ ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ë³µì‚¬" if mw.mode == "Meta Prompt Builder" else "ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬"
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn = QPushButton("ğŸŒ³ íŠ¸ë¦¬ ìƒì„±")
        mw.generate_btn = QPushButton("âœ¨ í”„ë¡¬í”„íŠ¸ ìƒì„±")
        mw.send_to_gemini_btn = QPushButton("â™Š Geminië¡œ ì „ì†¡")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.run_xml_parser_btn = QPushButton("â–¶ï¸ XML íŒŒì„œ ì‹¤í–‰")
        mw.generate_all_btn = QPushButton("âš¡ï¸ í•œë²ˆì— ì‹¤í–‰")
        mw.run_buttons = [mw.generate_tree_btn, mw.generate_btn, mw.send_to_gemini_btn, mw.copy_btn, mw.run_xml_parser_btn, mw.generate_all_btn]
    else:
        mw.generate_btn = QPushButton("ğŸš€ ë©”íƒ€ í”„ë¡¬í”„íŠ¸ ìƒì„±")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.generate_final_prompt_btn = QPushButton("ğŸš€ ìµœì¢… í”„ë¡¬í”„íŠ¸ ìƒì„±")
        mw.run_buttons = [mw.generate_btn, mw.copy_btn, mw.generate_final_prompt_btn]

    # --- ìƒíƒœ í‘œì‹œì¤„ ìœ„ì ¯ ---
    mw.char_count_label = QLabel("Chars: 0")
    mw.token_count_label = QLabel("í† í° ê³„ì‚°: -")
    mw.api_time_label = QLabel("API ì‹œê°„: -") # API ì‹œê°„ í‘œì‹œ ë¼ë²¨ ì¶”ê°€

    # --- LLM ê´€ë ¨ ìœ„ì ¯ (ìƒë‹¨) ---
    mw.llm_combo = QComboBox(); mw.llm_combo.addItems(["Gemini", "Claude", "GPT"])
    mw.model_name_combo = QComboBox(); mw.model_name_combo.setEditable(True); mw.model_name_combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert) # QComboBox.NoInsert -> QComboBox.InsertPolicy.NoInsert
    mw.gemini_temp_label = QLabel("Temp:")
    mw.gemini_temp_edit = QLineEdit(); mw.gemini_temp_edit.setFixedWidth(40); mw.gemini_temp_edit.setPlaceholderText("0.0")
    mw.gemini_thinking_label = QLabel("Thinking:")
    mw.gemini_thinking_checkbox = QCheckBox()
    mw.gemini_budget_label = QLabel("Budget:")
    mw.gemini_budget_edit = QLineEdit(); mw.gemini_budget_edit.setFixedWidth(60); mw.gemini_budget_edit.setPlaceholderText("24576")
    mw.gemini_search_label = QLabel("Search:")
    mw.gemini_search_checkbox = QCheckBox()
    # Gemini íŒŒë¼ë¯¸í„° ìœ„ì ¯ ê·¸ë£¹í™” (ìƒë‹¨ ì´ë™ìš©)
    mw.gemini_param_widget = QWidget()
    gemini_param_layout = QHBoxLayout(mw.gemini_param_widget)
    gemini_param_layout.setContentsMargins(0, 0, 0, 0); gemini_param_layout.setSpacing(5)
    # ìœ„ì ¯ ì¶”ê°€ ìˆœì„œ ë³€ê²½: Temp -> Search -> Thinking -> Budget
    gemini_param_layout.addWidget(mw.gemini_temp_label); gemini_param_layout.addWidget(mw.gemini_temp_edit)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_search_label); gemini_param_layout.addWidget(mw.gemini_search_checkbox) # Search ì´ë™
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_thinking_label); gemini_param_layout.addWidget(mw.gemini_thinking_checkbox)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_budget_label); gemini_param_layout.addWidget(mw.gemini_budget_edit)
    mw.gemini_param_widget.setVisible(mw.llm_combo.currentText() == "Gemini") # ì´ˆê¸° ê°€ì‹œì„± ì„¤ì •


def create_layout(mw: 'MainWindow'):
    """Creates the layout and arranges widgets."""
    central_widget = QWidget()
    mw.setCentralWidget(central_widget)
    main_layout = QVBoxLayout(central_widget)
    main_layout.setContentsMargins(5, 2, 5, 5); main_layout.setSpacing(2)

    # --- ìƒë‹¨ ë ˆì´ì•„ì›ƒ (ë²„íŠ¼ + í”„ë¡œì íŠ¸ ê²½ë¡œ + LLM ì»¨íŠ¸ë¡¤) ---
    top_layout_wrapper = QVBoxLayout(); top_layout_wrapper.setSpacing(2); top_layout_wrapper.setContentsMargins(0, 0, 0, 0)

    # ìƒë‹¨ ë²„íŠ¼ í–‰
    top_button_container = QWidget()
    top_button_layout = QHBoxLayout(top_button_container)
    top_button_layout.setSpacing(10); top_button_layout.setContentsMargins(0, 0, 0, 0)
    top_button_layout.addWidget(mw.mode_toggle_btn)
    top_button_layout.addWidget(mw.reset_program_btn)
    top_button_layout.addWidget(mw.load_previous_work_btn)
    top_button_layout.addWidget(mw.save_current_work_btn) # ì‘ì—… ì €ì¥ ë²„íŠ¼ ì¶”ê°€
    top_button_layout.addWidget(mw.select_project_btn)
    top_button_layout.addStretch(1)
    top_layout_wrapper.addWidget(top_button_container)

    # í”„ë¡œì íŠ¸ ê²½ë¡œ í–‰
    top_layout_wrapper.addWidget(mw.project_folder_label)

    # LLM ì»¨íŠ¸ë¡¤ í–‰ (ìƒˆë¡œ ì¶”ê°€)
    llm_controls_container = QWidget()
    llm_controls_layout = QHBoxLayout(llm_controls_container)
    llm_controls_layout.setContentsMargins(0, 5, 0, 5); llm_controls_layout.setSpacing(10) # ìƒí•˜ ì—¬ë°± ì¶”ê°€
    llm_controls_layout.addWidget(QLabel("Model:"))
    llm_controls_layout.addWidget(mw.llm_combo); mw.llm_combo.setFixedWidth(80)
    llm_controls_layout.addWidget(mw.model_name_combo); mw.model_name_combo.setMinimumWidth(180)
    llm_controls_layout.addWidget(mw.gemini_param_widget) # Gemini íŒŒë¼ë¯¸í„° ê·¸ë£¹ ìœ„ì ¯ ì¶”ê°€
    llm_controls_layout.addStretch(1)
    top_layout_wrapper.addWidget(llm_controls_container)

    main_layout.addLayout(top_layout_wrapper, 0) # ìƒë‹¨ ì „ì²´ ë ˆì´ì•„ì›ƒ ì¶”ê°€

    # --- ì¤‘ì•™ ìŠ¤í”Œë¦¬í„° ---
    mw.center_splitter = QSplitter(Qt.Orientation.Horizontal) # Qt.Horizontal -> Qt.Orientation.Horizontal

    # --- ì™¼ìª½ ì˜ì—­ (íŒŒì¼ íŠ¸ë¦¬ + ì²¨ë¶€ íŒŒì¼) ---
    left_side_widget = QWidget() # ì»¨í…Œì´ë„ˆ ìœ„ì ¯
    left_side_layout = QVBoxLayout(left_side_widget) # ë©”ì¸ ë ˆì´ì•„ì›ƒ
    left_side_layout.setContentsMargins(2, 2, 2, 2); left_side_layout.setSpacing(5)

    # ì„¸ë¡œ ìŠ¤í”Œë¦¬í„° ìƒì„±
    left_splitter = QSplitter(Qt.Orientation.Vertical) # Qt.Vertical -> Qt.Orientation.Vertical
    left_splitter.addWidget(mw.tree_view) # íŒŒì¼ íŠ¸ë¦¬ ì¶”ê°€
    left_splitter.addWidget(mw.attachment_group) # ì²¨ë¶€ íŒŒì¼ ê·¸ë£¹ ì¶”ê°€
    left_splitter.setSizes([400, 200]) # ì´ˆê¸° í¬ê¸° ì„¤ì • (ì¡°ì • ê°€ëŠ¥)

    left_side_layout.addWidget(left_splitter) # ìŠ¤í”Œë¦¬í„°ë¥¼ ë ˆì´ì•„ì›ƒì— ì¶”ê°€

    mw.center_splitter.addWidget(left_side_widget)

    # --- ì˜¤ë¥¸ìª½ ì˜ì—­ (ì‹¤í–‰ ë²„íŠ¼ + ìƒí•˜ ë¶„í•  ì˜ì—­) ---
    right_side_widget = QWidget()
    right_side_layout = QVBoxLayout(right_side_widget)
    right_side_layout.setContentsMargins(0, 0, 0, 0); right_side_layout.setSpacing(0)

    # ì‹¤í–‰ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
    run_buttons_container = QWidget()
    run_layout = QHBoxLayout(run_buttons_container)
    run_layout.setContentsMargins(5, 5, 5, 5); run_layout.setSpacing(10); run_layout.setAlignment(Qt.AlignmentFlag.AlignLeft) # Qt.AlignLeft -> Qt.AlignmentFlag.AlignLeft
    for btn in mw.run_buttons: run_layout.addWidget(btn)
    run_layout.addStretch(1)
    right_side_layout.addWidget(run_buttons_container)

    # êµ¬ë¶„ì„ 
    line_frame = QFrame(); line_frame.setFrameShape(QFrame.Shape.HLine); line_frame.setFrameShadow(QFrame.Shadow.Sunken) # QFrame.HLine -> QFrame.Shape.HLine, QFrame.Sunken -> QFrame.Shadow.Sunken
    right_side_layout.addWidget(line_frame)

    # ì˜¤ë¥¸ìª½ ìƒí•˜ ë¶„í•  ìŠ¤í”Œë¦¬í„°
    right_content_splitter = QSplitter(Qt.Orientation.Vertical) # Qt.Vertical -> Qt.Orientation.Vertical

    # ì˜¤ë¥¸ìª½ ìƒë‹¨: íƒ­ ìœ„ì ¯
    right_content_splitter.addWidget(mw.build_tabs)

    # ì˜¤ë¥¸ìª½ í•˜ë‹¨: ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ë§Œ
    bottom_right_widget = QWidget()
    bottom_right_layout = QVBoxLayout(bottom_right_widget)
    bottom_right_layout.setContentsMargins(0, 5, 0, 0) # ìƒë‹¨ ì—¬ë°± ì¶”ê°€
    bottom_right_layout.setSpacing(5)
    bottom_right_layout.addWidget(mw.resource_manager_group) # ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ê·¸ë£¹ë§Œ ì¶”ê°€
    right_content_splitter.addWidget(bottom_right_widget)

    # ì˜¤ë¥¸ìª½ ìƒí•˜ ìŠ¤í”Œë¦¬í„° í¬ê¸° ë¹„ìœ¨ ì„¤ì • (ì˜ˆ: 2:1)
    right_content_splitter.setSizes([400, 200]) # ì´ˆê¸° ë†’ì´ ì„¤ì • (ì¡°ì • ê°€ëŠ¥)

    # ì˜¤ë¥¸ìª½ ë ˆì´ì•„ì›ƒì— ìƒí•˜ ìŠ¤í”Œë¦¬í„° ì¶”ê°€
    right_side_layout.addWidget(right_content_splitter)

    # ì¤‘ì•™ ìŠ¤í”Œë¦¬í„°ì— ì˜¤ë¥¸ìª½ ì˜ì—­ ì¶”ê°€
    mw.center_splitter.addWidget(right_side_widget)

    # ì¤‘ì•™ ìŠ¤í”Œë¦¬í„° í¬ê¸° ë¹„ìœ¨ ì„¤ì • (ì˜ˆ: 1:3)
    # setStretchFactor is deprecated in PyQt6, use setSizes or handle resize events
    # mw.center_splitter.setStretchFactor(0, 1) # ì™¼ìª½ ì˜ì—­ ë¹„ìœ¨
    # mw.center_splitter.setStretchFactor(1, 3) # ì˜¤ë¥¸ìª½ ì˜ì—­ ë¹„ìœ¨
    # Instead, set initial sizes (already done above)

    # ë©”ì¸ ë ˆì´ì•„ì›ƒì— ì¤‘ì•™ ìŠ¤í”Œë¦¬í„° ì¶”ê°€
    main_layout.addWidget(mw.center_splitter, 1)


def create_status_bar(mw: 'MainWindow'):
    """Creates the status bar."""
    mw.status_bar = QStatusBar()
    mw.setStatusBar(mw.status_bar)
    status_widget = QWidget()
    status_layout = QHBoxLayout(status_widget)
    status_layout.setContentsMargins(5, 2, 5, 2); status_layout.setSpacing(10)

    # ë¬¸ì ìˆ˜ì™€ í† í° ê³„ì‚° ë¼ë²¨ì„ ë¶™ì—¬ì„œ ì¶”ê°€
    status_layout.addWidget(mw.char_count_label)
    status_layout.addWidget(mw.token_count_label) # í† í° ê³„ì‚° ë¼ë²¨ ìœ„ì¹˜ ë³€ê²½

    # API ì‹œê°„ í‘œì‹œ ë¼ë²¨ ì¶”ê°€
    status_layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    status_layout.addWidget(mw.api_time_label)

    # LLM ê´€ë ¨ ìœ„ì ¯ë“¤ì€ ìƒë‹¨ìœ¼ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì œê±°
    # status_layout.addWidget(QLabel("Model:"))
    # status_layout.addWidget(mw.llm_combo); mw.llm_combo.setFixedWidth(80)
    # status_layout.addWidget(mw.model_name_combo); mw.model_name_combo.setMinimumWidth(180)
    # status_layout.addWidget(mw.gemini_param_widget) # Gemini íŒŒë¼ë¯¸í„° ê·¸ë£¹ ìœ„ì ¯ ì¶”ê°€

    status_layout.addStretch(1)
    mw.status_bar.addPermanentWidget(status_widget)





======== src\ui\settings_dialog.py ========
import os
import datetime # datetime ì¶”ê°€
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QPlainTextEdit, QFileDialog, QMessageBox, QGroupBox, QHBoxLayout, QComboBox,
    QCheckBox, QApplication, QListWidget, QListWidgetItem, QAbstractItemView, QInputDialog, QWidget,
    QSplitter, QSizePolicy
)
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from PyQt6.QtGui import QColor, QIcon, QIntValidator, QBrush # PyQt5 -> PyQt6, QIntValidator ì¶”ê°€, QBrush ì¶”ê°€
from typing import Optional, Set, List, Dict, Any, Tuple # Dict, Any, Tuple ì¶”ê°€
from pydantic import ValidationError
import logging # ë¡œê¹… ì¶”ê°€

# ì„œë¹„ìŠ¤ ë° ì»¨íŠ¸ë¡¤ëŸ¬ í•¨ìˆ˜ import
from core.services.config_service import ConfigService
from core.pydantic_models.config_settings import ConfigSettings
from ui.controllers.system_prompt_controller import select_default_system_prompt
# MainWindow íƒ€ì… íŒíŠ¸ (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow
    from core.services.db_service import DbService # DbService íƒ€ì… íŒíŠ¸

logger = logging.getLogger(__name__) # ë¡œê±° ì„¤ì •

# íŒŒìŠ¤í…” ê·¸ë¦° ìƒ‰ìƒ ì •ì˜
PASTEL_GREEN = QColor(152, 251, 152) # ì—°í•œ ë…¹ìƒ‰ (RGB)
# íŒŒìŠ¤í…” ë¸”ë£¨ ìƒ‰ìƒ ì •ì˜ (ì‚¬ìš©ì ì„ íƒ ê°•ì¡°ìš©)
PASTEL_BLUE = QColor(173, 216, 230) # ì—°í•œ íŒŒë€ìƒ‰ (Light Blue)
# íŒŒìŠ¤í…” í¼í”Œ ìƒ‰ìƒ ì •ì˜ (ìë™ ì„ íƒ ì˜ˆì • ê°•ì¡°ìš©)
PASTEL_PURPLE = QColor(221, 160, 221) # ì—°ë³´ë¼ìƒ‰ (Plum)

# --- ëª¨ë¸ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ ---
class AddModelDialog(QDialog):
    """ëª¨ë¸ ì´ë¦„, RPM, Daily Limitì„ ì…ë ¥ë°›ëŠ” ë‹¤ì´ì–¼ë¡œê·¸."""
    def __init__(self, model_type: str, existing_models: List[str], parent=None):
        super().__init__(parent)
        self.model_type = model_type
        self.existing_models = existing_models
        self.setWindowTitle(f"{model_type} ëª¨ë¸ ì¶”ê°€")

        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.model_name_edit = QLineEdit()
        self.rpm_limit_edit = QLineEdit()
        self.daily_limit_edit = QLineEdit()

        # ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•˜ë„ë¡ Validator ì„¤ì •
        self.rpm_limit_edit.setValidator(QIntValidator(0, 999999)) # 0 ì´ìƒ ì •ìˆ˜
        self.daily_limit_edit.setValidator(QIntValidator(0, 9999999)) # 0 ì´ìƒ ì •ìˆ˜

        form_layout.addRow("ëª¨ë¸ ì´ë¦„:", self.model_name_edit)
        form_layout.addRow("RPM Limit (ë¶„ë‹¹ ìš”ì²­ ìˆ˜):", self.rpm_limit_edit)
        form_layout.addRow("Daily Limit (í•˜ë£¨ ìš”ì²­ ìˆ˜):", self.daily_limit_edit)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)

    def validate_and_accept(self):
        """ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬ í›„ accept."""
        model_name = self.model_name_edit.text().strip()
        rpm_limit_str = self.rpm_limit_edit.text().strip()
        daily_limit_str = self.daily_limit_edit.text().strip()

        if not model_name:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ëª¨ë¸ ì´ë¦„ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
            return
        if model_name in self.existing_models:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", f"'{model_name}' ëª¨ë¸ì´ ì´ë¯¸ ëª©ë¡ì— ì¡´ì¬í•©ë‹ˆë‹¤.")
            return
        if not rpm_limit_str:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "RPM Limitì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
            return
        if not daily_limit_str:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "Daily Limitì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
            return

        try:
            int(rpm_limit_str)
            int(daily_limit_str)
        except ValueError:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "RPM ë° Daily Limitì€ ìˆ«ìë¡œ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
            return

        self.accept() # ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì‹œ accept

    def get_model_data(self) -> Optional[Tuple[str, int, int]]:
        """ì…ë ¥ëœ ëª¨ë¸ ë°ì´í„° ë°˜í™˜."""
        if self.result() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_name = self.model_name_edit.text().strip()
            rpm_limit = int(self.rpm_limit_edit.text().strip())
            daily_limit = int(self.daily_limit_edit.text().strip())
            return model_name, rpm_limit, daily_limit
        return None

# --- SettingsDialog ---
class SettingsDialog(QDialog):
    """
    í™˜ê²½ ì„¤ì •ì„ í‘œì‹œí•˜ê³  ìˆ˜ì •í•˜ëŠ” ë‹¤ì´ì–¼ë¡œê·¸ ì°½.
    DBì—ì„œ ë¡œë“œëœ ì„¤ì •ì„ ë³´ì—¬ì£¼ê³ , ìˆ˜ì • í›„ DBì— ì €ì¥í•©ë‹ˆë‹¤.
    .gitignore íŒŒì¼ í¸ì§‘/ì €ì¥ ê¸°ëŠ¥ë„ ìœ ì§€í•©ë‹ˆë‹¤.
    API í‚¤ í•„ë“œëŠ” ì¼ë°˜ í…ìŠ¤íŠ¸ë¡œ í‘œì‹œë©ë‹ˆë‹¤. (ì €ì¥ ë¡œì§ì€ ë³„ë„ ê´€ë¦¬)
    ì‚¬ìš© ê°€ëŠ¥ LLM ëª¨ë¸ ëª©ë¡ ë° API í‚¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ê¸°ëŠ¥ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
    API í‚¤ ëª©ë¡ì— ì”ì—¬ ì‚¬ìš©ëŸ‰ ì •ë³´ë¥¼ í‘œì‹œí•˜ê³ , ì‚¬ìš©ìê°€ ì‚¬ìš©í•  í‚¤ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    ì‚¬ìš© ê°€ëŠ¥ LLM ëª¨ë¸ ëª©ë¡ì—ì„œ í´ë¦­í•˜ì—¬ ê¸°ë³¸ ëª¨ë¸ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    ì‚¬ìš©ìê°€ í‚¤ë¥¼ ì„ íƒí•˜ì§€ ì•Šì•˜ì„ ë•Œ ìë™ìœ¼ë¡œ ì„ íƒë  í‚¤ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """
    PASTEL_GREEN = PASTEL_GREEN # í´ë˜ìŠ¤ ë³€ìˆ˜ë¡œë„ ì •ì˜
    PASTEL_BLUE = PASTEL_BLUE # í´ë˜ìŠ¤ ë³€ìˆ˜ë¡œë„ ì •ì˜
    PASTEL_PURPLE = PASTEL_PURPLE # í´ë˜ìŠ¤ ë³€ìˆ˜ë¡œë„ ì •ì˜

    def __init__(self, main_window: 'MainWindow', parent=None):
        super().__init__(parent)
        self.mw = main_window # MainWindow ì°¸ì¡°
        self.config_service = main_window.config_service
        self.db_service: 'DbService' = main_window.db_service # DbService ì°¸ì¡° ì¶”ê°€
        self.settings: Optional[ConfigSettings] = None # Load in load_config_settings

        self.setWindowTitle("í™˜ê²½ ì„¤ì •") # Title updated
        self.setMinimumWidth(800) # ë„ˆë¹„ ì¦ê°€
        self.setMinimumHeight(750) # ë†’ì´ ì¦ê°€ (ë‚´ìš© í‘œì‹œ ê³µê°„ í™•ë³´)

        # --- UI ìš”ì†Œ ìƒì„± ---
        # ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
        self.default_prompt_group = QGroupBox("ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸")
        prompt_layout = QHBoxLayout()
        self.default_prompt_path_edit = QLineEdit()
        self.default_prompt_path_edit.setPlaceholderText("í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ ë˜ëŠ” ì ˆëŒ€ ê²½ë¡œ")
        self.browse_prompt_button = QPushButton("ì°¾ì•„ë³´ê¸°...") # Button text changed
        prompt_layout.addWidget(self.default_prompt_path_edit)
        prompt_layout.addWidget(self.browse_prompt_button)
        self.default_prompt_group.setLayout(prompt_layout)

        # --- API í‚¤ ê´€ë¦¬ (ê°œì„ ) ---
        self.api_key_management_group = QGroupBox("API í‚¤ ê´€ë¦¬")
        api_key_management_layout = QVBoxLayout()

        # API í‚¤ ëª©ë¡ í‘œì‹œ ë° ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼
        api_list_layout = QHBoxLayout()
        self.api_keys_list = QListWidget()
        self.api_keys_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.api_keys_list.setMinimumHeight(100) # ìµœì†Œ ë†’ì´ ì¦ê°€
        self.api_keys_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        self.refresh_api_usage_btn = QPushButton("ğŸ”„") # ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ì¶”ê°€
        self.refresh_api_usage_btn.setToolTip("API í‚¤ ì‚¬ìš©ëŸ‰ ìƒˆë¡œê³ ì¹¨")
        self.refresh_api_usage_btn.setFixedWidth(30) # ë²„íŠ¼ í¬ê¸° ê³ ì •
        api_list_layout.addWidget(self.api_keys_list)
        api_list_layout.addWidget(self.refresh_api_usage_btn)

        # ë¼ë²¨ ì—…ë°ì´íŠ¸: ì•„ì´ì½˜ ì„¤ëª… ì¶”ê°€ (âœ¨ ì¶”ê°€)
        self.api_key_label = QLabel(
            "ë“±ë¡ëœ API í‚¤ (ğŸ”µ: ì‚¬ìš©ì ì„ íƒë¨, ğŸŸ¢: ë§ˆì§€ë§‰ ì‚¬ìš©, âœ¨: ìë™ ì„ íƒ ì˜ˆì •, ğŸŸ¡: í™œì„±, ğŸ”´: ë¹„í™œì„± / ì”ì—¬ëŸ‰ì€ ê¸°ë³¸ Gemini ëª¨ë¸ ê¸°ì¤€):"
        )
        api_key_management_layout.addWidget(self.api_key_label)
        api_key_management_layout.addLayout(api_list_layout) # ëª©ë¡ê³¼ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ë ˆì´ì•„ì›ƒ ì¶”ê°€

        # API í‚¤ ì¶”ê°€/ì œê±°/ì„ íƒ ë²„íŠ¼
        api_key_buttons_layout = QHBoxLayout()
        self.add_api_key_btn = QPushButton("â• ìƒˆ API í‚¤ ì¶”ê°€")
        self.remove_api_key_btn = QPushButton("â– ì„ íƒí•œ í‚¤ ì œê±°")
        self.set_selected_key_btn = QPushButton("âœ… ì„ íƒí•œ í‚¤ ì‚¬ìš©") # ì‚¬ìš© í‚¤ ì„ íƒ ë²„íŠ¼ ì¶”ê°€
        api_key_buttons_layout.addWidget(self.add_api_key_btn)
        api_key_buttons_layout.addWidget(self.remove_api_key_btn)
        api_key_buttons_layout.addWidget(self.set_selected_key_btn) # ë²„íŠ¼ ë ˆì´ì•„ì›ƒì— ì¶”ê°€
        api_key_buttons_layout.addStretch()
        api_key_management_layout.addLayout(api_key_buttons_layout)

        self.api_key_management_group.setLayout(api_key_management_layout)


        # ì‚¬ìš© ê°€ëŠ¥ LLM ëª¨ë¸ ê´€ë¦¬ (ìœ„ì¹˜ ì´ë™ë¨)
        self.available_models_group = QGroupBox("ì‚¬ìš© ê°€ëŠ¥ LLM ëª¨ë¸ ëª©ë¡ ê´€ë¦¬ (í´ë¦­í•˜ì—¬ ê¸°ë³¸ ëª¨ë¸ ì§€ì •)") # ê·¸ë£¹ ì œëª© ìˆ˜ì •
        available_models_main_layout = QHBoxLayout()

        # Gemini ëª¨ë¸ ëª©ë¡
        gemini_model_widget = QWidget()
        gemini_model_layout = QVBoxLayout(gemini_model_widget)
        gemini_model_layout.addWidget(QLabel("Gemini ëª¨ë¸:"))
        self.gemini_models_list = QListWidget()
        self.gemini_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.gemini_models_list.setMinimumHeight(100) # ìµœì†Œ ë†’ì´ ì¦ê°€
        self.gemini_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gemini_model_buttons = QHBoxLayout()
        self.add_gemini_model_btn = QPushButton("ì¶”ê°€")
        self.remove_gemini_model_btn = QPushButton("ì œê±°")
        gemini_model_buttons.addWidget(self.add_gemini_model_btn)
        gemini_model_buttons.addWidget(self.remove_gemini_model_btn)
        gemini_model_layout.addWidget(self.gemini_models_list)
        gemini_model_layout.addLayout(gemini_model_buttons)

        # Claude ëª¨ë¸ ëª©ë¡
        claude_model_widget = QWidget()
        claude_model_layout = QVBoxLayout(claude_model_widget)
        claude_model_layout.addWidget(QLabel("Claude ëª¨ë¸:"))
        self.claude_models_list = QListWidget()
        self.claude_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.claude_models_list.setMinimumHeight(100) # ìµœì†Œ ë†’ì´ ì¦ê°€
        self.claude_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        claude_model_buttons = QHBoxLayout()
        self.add_claude_model_btn = QPushButton("ì¶”ê°€")
        self.remove_claude_model_btn = QPushButton("ì œê±°")
        claude_model_buttons.addWidget(self.add_claude_model_btn)
        claude_model_buttons.addWidget(self.remove_claude_model_btn)
        claude_model_layout.addWidget(self.claude_models_list)
        claude_model_layout.addLayout(claude_model_buttons)

        # GPT ëª¨ë¸ ëª©ë¡
        gpt_model_widget = QWidget()
        gpt_model_layout = QVBoxLayout(gpt_model_widget)
        gpt_model_layout.addWidget(QLabel("GPT ëª¨ë¸:"))
        self.gpt_models_list = QListWidget()
        self.gpt_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.gpt_models_list.setMinimumHeight(100) # ìµœì†Œ ë†’ì´ ì¦ê°€
        self.gpt_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gpt_model_buttons = QHBoxLayout()
        self.add_gpt_model_btn = QPushButton("ì¶”ê°€")
        self.remove_gpt_model_btn = QPushButton("ì œê±°")
        gpt_model_buttons.addWidget(self.add_gpt_model_btn)
        gpt_model_buttons.addWidget(self.remove_gpt_model_btn)
        gpt_model_layout.addWidget(self.gpt_models_list)
        gpt_model_layout.addLayout(gpt_model_buttons)

        available_models_main_layout.addWidget(gemini_model_widget)
        available_models_main_layout.addWidget(claude_model_widget)
        available_models_main_layout.addWidget(gpt_model_widget)
        self.available_models_group.setLayout(available_models_main_layout)


        # íŒŒì¼ í•„í„°ë§
        self.filtering_group = QGroupBox("íŒŒì¼ í•„í„°ë§")
        filtering_layout = QFormLayout()
        self.allowed_extensions_edit = QLineEdit()
        self.allowed_extensions_edit.setPlaceholderText("ì‰¼í‘œ(,) ë˜ëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ (ì˜ˆ: .py, .js .html)")
        self.excluded_dirs_edit = QPlainTextEdit()
        self.excluded_dirs_edit.setPlaceholderText("í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥ (ì˜ˆ: node_modules/, *.log)")
        self.excluded_dirs_edit.setMinimumHeight(80) # ìµœì†Œ ë†’ì´ ì„¤ì •
        self.excluded_dirs_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        self.default_ignore_list_edit = QPlainTextEdit()
        self.default_ignore_list_edit.setPlaceholderText("í•œ ì¤„ì— í•˜ë‚˜ì”© ì…ë ¥ (ì˜ˆ: .git/, __pycache__/)")
        self.default_ignore_list_edit.setMinimumHeight(80) # ìµœì†Œ ë†’ì´ ì„¤ì •
        self.default_ignore_list_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        filtering_layout.addRow("í—ˆìš© í™•ì¥ì:", self.allowed_extensions_edit)
        filtering_layout.addRow("ì œì™¸ í´ë”/íŒŒì¼:", self.excluded_dirs_edit)
        filtering_layout.addRow("ê¸°ë³¸ ë¬´ì‹œ ëª©ë¡:", self.default_ignore_list_edit)
        self.filtering_group.setLayout(filtering_layout)

        # Gemini íŒŒë¼ë¯¸í„°
        self.gemini_group = QGroupBox("Gemini íŒŒë¼ë¯¸í„°")
        gemini_layout = QFormLayout()
        self.gemini_temp_edit = QLineEdit()
        self.gemini_thinking_checkbox = QCheckBox()
        self.gemini_budget_edit = QLineEdit()
        self.gemini_search_checkbox = QCheckBox()
        # ìœ„ì ¯ ì¶”ê°€ ìˆœì„œ ë³€ê²½: Temp -> Search -> Thinking -> Budget
        gemini_layout.addRow("Temperature (0.0 ~ 2.0):", self.gemini_temp_edit)
        gemini_layout.addRow("Enable Search:", self.gemini_search_checkbox) # Search ì´ë™
        gemini_layout.addRow("Enable Thinking:", self.gemini_thinking_checkbox)
        gemini_layout.addRow("Thinking Budget:", self.gemini_budget_edit)
        self.gemini_group.setLayout(gemini_layout)

        # .gitignore í¸ì§‘
        self.gitignore_group = QGroupBox(".gitignore í¸ì§‘ (í˜„ì¬ í”„ë¡œì íŠ¸)")
        gitignore_layout = QVBoxLayout()
        gitignore_button_layout = QHBoxLayout()
        self.load_gitignore_button = QPushButton("ë¶ˆëŸ¬ì˜¤ê¸°")
        self.save_gitignore_button = QPushButton("ì €ì¥í•˜ê¸°") # This save is for .gitignore only
        gitignore_button_layout.addWidget(self.load_gitignore_button)
        gitignore_button_layout.addWidget(self.save_gitignore_button)
        gitignore_button_layout.addStretch()
        self.gitignore_edit = QPlainTextEdit()
        self.gitignore_edit.setPlaceholderText("í”„ë¡œì íŠ¸ í´ë” ì„ íƒ í›„ '.gitignore' ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¤ê±°ë‚˜ í¸ì§‘/ì €ì¥í•˜ì„¸ìš”.")
        self.gitignore_edit.setMinimumHeight(120) # ìµœì†Œ ë†’ì´ ì„¤ì •
        self.gitignore_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gitignore_layout.addLayout(gitignore_button_layout)
        gitignore_layout.addWidget(self.gitignore_edit)
        self.gitignore_group.setLayout(gitignore_layout)
        self.gitignore_group.setEnabled(bool(self.mw.current_project_folder))

        # ë²„íŠ¼ ë°•ìŠ¤ (Save and Close)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Close) # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Save).setText("ì„¤ì • ì €ì¥") # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Close).setText("ë‹«ê¸°") # QDialogButtonBox.Close -> QDialogButtonBox.StandardButton.Close

        # --- ë ˆì´ì•„ì›ƒ ì„¤ì • (2ë‹¨ ì»¬ëŸ¼ ìŠ¤í”Œë¦¬í„° ì‚¬ìš©) ---
        main_layout = QVBoxLayout(self)

        # ë©”ì¸ ìˆ˜í‰ ìŠ¤í”Œë¦¬í„° ìƒì„±
        main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal) # Qt.Horizontal -> Qt.Orientation.Horizontal

        # ì™¼ìª½ ì»¬ëŸ¼ ìœ„ì ¯ ë° ë ˆì´ì•„ì›ƒ ìƒì„±
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(5, 5, 5, 5)
        left_layout.setSpacing(10)

        # ì™¼ìª½ ì»¬ëŸ¼ì— ê·¸ë£¹ ì¶”ê°€ (ìˆœì„œ ë³€ê²½)
        left_layout.addWidget(self.default_prompt_group)
        left_layout.addWidget(self.available_models_group) # ì‚¬ìš© ê°€ëŠ¥ ëª¨ë¸ ëª©ë¡ ê·¸ë£¹ì„ ì™¼ìª½ìœ¼ë¡œ ì´ë™
        left_layout.addWidget(self.api_key_management_group)
        left_layout.addWidget(self.gemini_group) # Gemini íŒŒë¼ë¯¸í„° ì™¼ìª½ìœ¼ë¡œ ì´ë™
        left_layout.addStretch(1) # ìœ„ì ¯ë“¤ì„ ìœ„ë¡œ ë°€ê¸°

        # ì˜¤ë¥¸ìª½ ì»¬ëŸ¼ ìœ„ì ¯ ë° ë ˆì´ì•„ì›ƒ ìƒì„±
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(5, 5, 5, 5)
        right_layout.setSpacing(10)

        # ì˜¤ë¥¸ìª½ ì»¬ëŸ¼ì— ê·¸ë£¹ ì¶”ê°€
        right_layout.addWidget(self.filtering_group)
        right_layout.addWidget(self.gitignore_group) # gitignore ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
        right_layout.addStretch(1) # ìœ„ì ¯ë“¤ì„ ìœ„ë¡œ ë°€ê¸°

        # ìˆ˜í‰ ìŠ¤í”Œë¦¬í„°ì— ì™¼ìª½/ì˜¤ë¥¸ìª½ ì»¬ëŸ¼ ìœ„ì ¯ ì¶”ê°€
        main_horizontal_splitter.addWidget(left_widget)
        main_horizontal_splitter.addWidget(right_widget)

        # ìˆ˜í‰ ìŠ¤í”Œë¦¬í„° ì´ˆê¸° í¬ê¸° ì„¤ì • (ì˜ˆ: 1:1 ë¹„ìœ¨)
        initial_width = self.width() # í˜„ì¬ ë‹¤ì´ì–¼ë¡œê·¸ ë„ˆë¹„ ì‚¬ìš©
        main_horizontal_splitter.setSizes([initial_width // 2, initial_width // 2])

        # ë©”ì¸ ë ˆì´ì•„ì›ƒì— ìˆ˜í‰ ìŠ¤í”Œë¦¬í„°ì™€ ë²„íŠ¼ ë°•ìŠ¤ ì¶”ê°€
        main_layout.addWidget(main_horizontal_splitter, 1) # ìŠ¤í”Œë¦¬í„°ê°€ ë‚¨ëŠ” ê³µê°„ ì°¨ì§€
        main_layout.addWidget(self.button_box)

        # --- ì‹œê·¸ë„ ì—°ê²° ---
        self.browse_prompt_button.clicked.connect(self.browse_default_prompt)
        self.load_gitignore_button.clicked.connect(self.load_gitignore)
        self.save_gitignore_button.clicked.connect(self.save_gitignore)
        self.button_box.accepted.connect(self.save_config_settings)
        self.button_box.rejected.connect(self.reject)

        # API í‚¤ ê´€ë¦¬ ë²„íŠ¼ ì‹œê·¸ë„
        self.add_api_key_btn.clicked.connect(self.add_api_key)
        self.remove_api_key_btn.clicked.connect(self.remove_api_key)
        self.refresh_api_usage_btn.clicked.connect(self.load_api_keys_list) # ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ ì—°ê²°
        self.api_keys_list.itemDoubleClicked.connect(self.show_api_key_value) # ë”ë¸”í´ë¦­ ì‹œê·¸ë„ ì—°ê²°
        self.set_selected_key_btn.clicked.connect(self.set_selected_api_key) # í‚¤ ì„ íƒ ë²„íŠ¼ ì—°ê²°

        # ì‚¬ìš© ê°€ëŠ¥ ëª¨ë¸ ì¶”ê°€/ì œê±° ë²„íŠ¼ ì‹œê·¸ë„ ì—°ê²°
        self.add_gemini_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gemini_models_list, "google")) # Provider ì´ë¦„ ì „ë‹¬
        self.remove_gemini_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gemini_models_list))
        self.add_claude_model_btn.clicked.connect(lambda: self.add_model_to_list(self.claude_models_list, "anthropic")) # Provider ì´ë¦„ ì „ë‹¬
        self.remove_claude_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.claude_models_list))
        self.add_gpt_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gpt_models_list, "openai")) # Provider ì´ë¦„ ì „ë‹¬
        self.remove_gpt_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gpt_models_list))

        # ì‚¬ìš© ê°€ëŠ¥ ëª¨ë¸ ë¦¬ìŠ¤íŠ¸ í´ë¦­ ì‹œê·¸ë„ ì—°ê²° (ê¸°ë³¸ ëª¨ë¸ ì§€ì •ìš©)
        self.gemini_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gemini_models_list, 'gemini'))
        self.claude_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.claude_models_list, 'claude'))
        self.gpt_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gpt_models_list, 'gpt'))

        # --- ì´ˆê¸° ì„¤ì •ê°’ ë¡œë“œ ---
        self.load_config_settings()
        self.load_api_keys_list() # API í‚¤ ëª©ë¡ ë¡œë“œ
        if self.mw.current_project_folder:
            self.load_gitignore()

    def load_config_settings(self):
        """UI ìœ„ì ¯ì— í˜„ì¬ DB ì„¤ì •ê°’ì„ ë¡œë“œí•˜ê³  ê¸°ë³¸ ëª¨ë¸ì„ í•˜ì´ë¼ì´íŠ¸í•©ë‹ˆë‹¤."""
        try:
            # ConfigServiceë¥¼ í†µí•´ ìµœì‹  ì„¤ì • ë¡œë“œ
            self.settings = self.config_service.get_settings()
            if not self.settings:
                 QMessageBox.critical(self, "ì˜¤ë¥˜", "DBì—ì„œ ì„¤ì •ì„ ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
                 return

            logger.info("Loading config settings into SettingsDialog UI...")

            # UI ìœ„ì ¯ ì—…ë°ì´íŠ¸ (ì‹œê·¸ë„ ì°¨ë‹¨ ë¶ˆí•„ìš”, ë¡œë“œ ì‹œì ì—ëŠ” ì‚¬ìš©ì ì…ë ¥ ì—†ìŒ)
            self.default_prompt_path_edit.setText(self.settings.default_system_prompt or "")

            # ì‚¬ìš© ê°€ëŠ¥ ëª¨ë¸ ëª©ë¡ ë¡œë“œ ë° ê¸°ë³¸ ëª¨ë¸ í•˜ì´ë¼ì´íŠ¸
            self._populate_and_highlight_model_list(self.gemini_models_list, self.settings.gemini_available_models, self.settings.gemini_default_model)
            self._populate_and_highlight_model_list(self.claude_models_list, self.settings.claude_available_models, self.settings.claude_default_model)
            self._populate_and_highlight_model_list(self.gpt_models_list, self.settings.gpt_available_models, self.settings.gpt_default_model)

            self.allowed_extensions_edit.setText(", ".join(sorted(list(self.settings.allowed_extensions or set()))))
            self.excluded_dirs_edit.setPlainText("\n".join(sorted(self.settings.excluded_dirs or [])))
            self.default_ignore_list_edit.setPlainText("\n".join(sorted(self.settings.default_ignore_list or [])))

            self.gemini_temp_edit.setText(str(self.settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(self.settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(self.settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(self.settings.gemini_enable_search)

            logger.info("SettingsDialog UI updated with loaded config.")

        except Exception as e:
            QMessageBox.critical(self, "ë¡œë“œ ì˜¤ë¥˜", f"ì„¤ì •ì„ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")
            logger.exception("Error loading config settings into SettingsDialog UI")

    def _populate_and_highlight_model_list(self, list_widget: QListWidget, models: List[str], default_model: str):
        """Helper function to populate a model list and highlight the default."""
        list_widget.clear()
        list_widget.addItems(models or [])
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() == default_model:
                item.setBackground(self.PASTEL_GREEN) # ê¸°ë³¸ ëª¨ë¸ í•˜ì´ë¼ì´íŠ¸
            else:
                # ëª…ì‹œì ìœ¼ë¡œ ê¸°ë³¸ ë°°ê²½ìƒ‰ ì„¤ì • (ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°)
                # ê¸°ë³¸ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì •í•˜ì—¬ ì‹œìŠ¤í…œ í…Œë§ˆ ë”°ë¥´ë„ë¡ ìˆ˜ì •
                item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent

    def handle_model_click(self, clicked_item: QListWidgetItem, list_widget: QListWidget, model_type: str):
        """Handles clicks on model list items to set the default model."""
        if not self.settings: return
        new_default_model = clicked_item.text()
        old_default_model = ""

        # Update the settings object and get the old default model
        if model_type == 'gemini':
            old_default_model = self.settings.gemini_default_model
            self.settings.gemini_default_model = new_default_model
        elif model_type == 'claude':
            old_default_model = self.settings.claude_default_model
            self.settings.claude_default_model = new_default_model
        elif model_type == 'gpt':
            old_default_model = self.settings.gpt_default_model
            self.settings.gpt_default_model = new_default_model
        else:
            return

        logger.info(f"Set default {model_type} model to: {new_default_model}")

        # Update highlighting in the list widget
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            # ì´ì „ ê¸°ë³¸ ëª¨ë¸ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            if item.text() == old_default_model:
                 item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent
            # ìƒˆ ê¸°ë³¸ ëª¨ë¸ í•˜ì´ë¼ì´íŠ¸ ì ìš©
            if item.text() == new_default_model:
                item.setBackground(self.PASTEL_GREEN)

    def load_api_keys_list(self):
        """DBì—ì„œ API í‚¤ ëª©ë¡ì„ ë¡œë“œí•˜ì—¬ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì— í‘œì‹œí•˜ê³  ìƒíƒœ(ì‚¬ìš©ì ì„ íƒ, ë§ˆì§€ë§‰ ì‚¬ìš©, ìë™ ì„ íƒ ì˜ˆì • ë“±)ë¥¼ ê°•ì¡°í•©ë‹ˆë‹¤."""
        self.api_keys_list.clear()
        try:
            all_keys = self.db_service.list_api_keys() # ëª¨ë“  í‚¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì‚¬ìš©ëŸ‰ í¬í•¨)
            if not all_keys:
                self.api_keys_list.addItem("ë“±ë¡ëœ API í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤.")
                self.api_keys_list.setEnabled(False)
                return

            self.api_keys_list.setEnabled(True)

            user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
            last_used_key_id = self.config_service.get_last_used_gemini_key_id()
            logger.info(f"Current User Selected Key ID: {user_selected_key_id}, Last Used Key ID: {last_used_key_id}")

            default_gemini_model = self.config_service.get_default_model_name('Gemini')
            # Rate limit info is fetched inside the loop now if needed

            # --- ìë™ ì„ íƒ ì˜ˆì • í‚¤ ì‹ë³„ (ê°œì„ ) ---
            auto_select_candidate_id: Optional[int] = None
            if user_selected_key_id is None:
                logger.info("Identifying auto-select candidate key...")
                candidate_keys = []
                # í™œì„± Google í‚¤ í•„í„°ë§
                active_google_keys_info = [k for k in all_keys if k.get('provider') == 'google' and k.get('is_active')]

                for key_info in active_google_keys_info:
                    key_id = key_info['id']
                    # Rate Limit ì²´í¬
                    is_limited, reason = self.db_service.is_key_rate_limited(key_id, default_gemini_model)
                    if not is_limited:
                        # Rate Limit ì•ˆ ê±¸ë¦° í‚¤ë§Œ í›„ë³´ë¡œ ì¶”ê°€
                        # ìœ íš¨ ì¼ì¼ ì‚¬ìš©ëŸ‰ ê³„ì‚° (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                        now = datetime.datetime.now(datetime.timezone.utc)
                        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
                        raw_calls_day = key_info.get('calls_this_day', 0)
                        day_start = key_info.get('day_start_timestamp')
                        if day_start and day_start.tzinfo is None: # íƒ€ì„ì¡´ ì •ë³´ ì—†ìœ¼ë©´ UTCë¡œ ê°„ì£¼
                             day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                        effective_daily_calls = raw_calls_day if day_start and day_start >= current_day_start else 0
                        candidate_keys.append({'id': key_id, 'effective_calls': effective_daily_calls})
                        logger.debug(f"  Candidate Key ID: {key_id} (Not Rate Limited, Effective Daily Calls: {effective_daily_calls})")
                    else:
                        logger.debug(f"  Skipping Key ID: {key_id} (Rate Limited: {reason})")

                # ìœ íš¨ ì¼ì¼ ì‚¬ìš©ëŸ‰ ê¸°ì¤€ ì •ë ¬
                candidate_keys.sort(key=lambda x: x['effective_calls'])

                # ê°€ì¥ ì‚¬ìš©ëŸ‰ ì ì€ í‚¤ê°€ ìë™ ì„ íƒ í›„ë³´
                if candidate_keys:
                    auto_select_candidate_id = candidate_keys[0]['id']
                    logger.info(f"Auto-select candidate key ID identified: {auto_select_candidate_id} (Effective Daily Calls: {candidate_keys[0]['effective_calls']})")
                else:
                    logger.warning("No suitable auto-select candidate key found (all active keys might be rate-limited).")
            # -----------------------------

            # --- í‚¤ ëª©ë¡ UI ì—…ë°ì´íŠ¸ ---
            rate_limit_info = self.db_service.get_model_rate_limit(default_gemini_model) # Get rate limit info once
            rpm_limit = rate_limit_info.get('rpm_limit') if rate_limit_info else None
            daily_limit = rate_limit_info.get('daily_limit') if rate_limit_info else None
            now = datetime.datetime.now(datetime.timezone.utc) # Get current time once

            for key_info in all_keys:
                key_id = key_info['id']
                provider = key_info.get('provider', 'N/A')
                description = key_info.get('description', '')
                api_key_value = key_info.get('api_key', '')
                api_key_display = api_key_value[:4] + "..." + api_key_value[-4:] if len(api_key_value) > 8 else api_key_value[:4] + "..."
                is_active = key_info.get('is_active', False)

                status_icon = ""
                item_color = QBrush(Qt.GlobalColor.transparent) # ê¸°ë³¸ ë°°ê²½ íˆ¬ëª…
                display_text = f"[{provider.upper()}] {description or api_key_display}"
                extra_info = "" # ìƒíƒœ í‘œì‹œìš© ì¶”ê°€ í…ìŠ¤íŠ¸
                tooltip_status = "" # íˆ´íŒìš© ìƒíƒœ ë¬¸ìì—´

                # ìƒíƒœ ê²°ì • (ìš°ì„ ìˆœìœ„: ì‚¬ìš©ì ì„ íƒ > ìë™ ì„ íƒ ì˜ˆì • > ë§ˆì§€ë§‰ ì‚¬ìš© > í™œì„± > ë¹„í™œì„±)
                if provider == 'google' and key_id == user_selected_key_id:
                    status_icon = "ğŸ”µ" # ì‚¬ìš©ì ì„ íƒ
                    item_color = QBrush(self.PASTEL_BLUE) # ì—°í•œ íŒŒë€ìƒ‰ ë°°ê²½
                    extra_info = " (ì‚¬ìš©ì ì„ íƒ)"
                    tooltip_status = "User Selected"
                elif provider == 'google' and key_id == auto_select_candidate_id:
                    status_icon = "âœ¨" # ìë™ ì„ íƒ ì˜ˆì •
                    item_color = QBrush(self.PASTEL_PURPLE) # ì—°ë³´ë¼ìƒ‰ ë°°ê²½
                    extra_info = " (ìë™ ì„ íƒ ì˜ˆì •)"
                    tooltip_status = "Auto-Select Candidate"
                elif provider == 'google' and key_id == last_used_key_id:
                    status_icon = "ğŸŸ¢" # ë§ˆì§€ë§‰ ì‚¬ìš©
                    item_color = QBrush(self.PASTEL_GREEN) # ì—°í•œ ë…¹ìƒ‰ ë°°ê²½
                    extra_info = " (ë§ˆì§€ë§‰ ì‚¬ìš©)"
                    tooltip_status = "Last Used"
                elif is_active:
                    status_icon = "ğŸŸ¡" # í™œì„±
                    item_color = QBrush(QColor("lightyellow")) # ì—°í•œ ë…¸ë€ìƒ‰ ë°°ê²½
                    tooltip_status = "Active"
                else:
                    status_icon = "ğŸ”´" # ë¹„í™œì„±
                    item_color = QBrush(QColor("lightcoral")) # ì—°í•œ ì‚°í˜¸ìƒ‰ ë°°ê²½
                    tooltip_status = "Inactive"

                display_text = f"{status_icon}{display_text}{extra_info}"

                # ì”ì—¬ ì‚¬ìš©ëŸ‰ ê³„ì‚° (Gemini í‚¤)
                remaining_rpm_str, remaining_daily_str = "N/A", "N/A"
                tooltip_rpm, tooltip_daily = "N/A", "N/A"
                if provider == 'google' and rpm_limit is not None and daily_limit is not None:
                    calls_this_minute = key_info.get('calls_this_minute', 0)
                    minute_start = key_info.get('minute_start_timestamp')
                    calls_this_day = key_info.get('calls_this_day', 0)
                    day_start = key_info.get('day_start_timestamp')
                    if minute_start and minute_start.tzinfo is None: minute_start = minute_start.replace(tzinfo=datetime.timezone.utc)
                    if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc)

                    current_minute_calls = calls_this_minute
                    # ë¶„ ì‹œì‘ ì‹œê°„ì´ ìˆê³ , í˜„ì¬ ì‹œê°„ì´ ë¶„ ì‹œì‘ ì‹œê°„ + 1ë¶„ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë©´ 0ìœ¼ë¡œ ë¦¬ì…‹
                    if minute_start and now >= minute_start + datetime.timedelta(minutes=1):
                        current_minute_calls = 0
                    remaining_rpm = max(0, rpm_limit - current_minute_calls)
                    remaining_rpm_str = f"{remaining_rpm}/{rpm_limit}"
                    tooltip_rpm = f"{remaining_rpm} / {rpm_limit} (Used: {current_minute_calls})"

                    current_day_calls = calls_this_day
                    # ì¼ ì‹œì‘ ì‹œê°„ì´ ìˆê³ , í˜„ì¬ ì‹œê°„ì´ ì¼ ì‹œì‘ ì‹œê°„ + 1ì¼ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë©´ 0ìœ¼ë¡œ ë¦¬ì…‹
                    if day_start and now >= day_start + datetime.timedelta(days=1):
                        current_day_calls = 0
                    remaining_daily = max(0, daily_limit - current_day_calls)
                    remaining_daily_str = f"{remaining_daily}/{daily_limit}"
                    tooltip_daily = f"{remaining_daily} / {daily_limit} (Used: {current_day_calls})"

                    display_text += f" (RPM: {remaining_rpm_str}, Daily: {remaining_daily_str})"
                elif provider == 'google':
                    logger.warning(f"Rate limit info not found for model '{default_gemini_model}'. Cannot calculate remaining usage for key ID {key_id}.")

                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, key_id) # í‚¤ ID ì €ì¥
                item.setData(Qt.ItemDataRole.UserRole + 1, api_key_value) # ì‹¤ì œ í‚¤ ê°’ ì €ì¥
                item.setData(Qt.ItemDataRole.UserRole + 2, provider) # í”„ë¡œë°”ì´ë” ì €ì¥
                item.setBackground(item_color) # ë°°ê²½ìƒ‰ ì„¤ì • (QBrush ì‚¬ìš©)

                # íˆ´íŒ ì—…ë°ì´íŠ¸
                tooltip_text = (
                    f"ID: {key_id}\nProvider: {provider}\nKey: {api_key_display}\nStatus: {tooltip_status}"
                )
                if provider == 'google':
                     tooltip_text += f"\nRemaining RPM (vs {default_gemini_model}): {tooltip_rpm}\nRemaining Daily (vs {default_gemini_model}): {tooltip_daily}"
                item.setToolTip(tooltip_text)

                self.api_keys_list.addItem(item)

        except Exception as e:
            QMessageBox.critical(self, "API í‚¤ ë¡œë“œ ì˜¤ë¥˜", f"API í‚¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")
            logger.exception("Error loading API keys list")
            self.api_keys_list.addItem("API í‚¤ ë¡œë“œ ì˜¤ë¥˜")
            self.api_keys_list.setEnabled(False)


    def add_api_key(self):
        """ìƒˆ API í‚¤ë¥¼ ì¶”ê°€í•˜ëŠ” ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ ë„ìš°ê³  DBì— ì €ì¥í•©ë‹ˆë‹¤."""
        provider, ok1 = QInputDialog.getItem(self, "API í‚¤ ì¶”ê°€", "Provider ì„ íƒ:", ["google", "anthropic", "openai"], 0, False)
        if not ok1: return
        # QLineEdit.Password ëŒ€ì‹  QLineEdit.Normal ì‚¬ìš©
        api_key, ok2 = QInputDialog.getText(self, "API í‚¤ ì¶”ê°€", f"{provider} API í‚¤ ì…ë ¥:", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok2 or not api_key.strip(): return
        description, ok3 = QInputDialog.getText(self, "API í‚¤ ì¶”ê°€", "ì„¤ëª… (ì„ íƒ ì‚¬í•­):", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok3: description = ""

        try:
            key_id = self.db_service.add_api_key(provider, api_key.strip(), description.strip())
            if key_id is not None:
                QMessageBox.information(self, "ì„±ê³µ", "API í‚¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.")
                self.load_api_keys_list() # ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            else:
                QMessageBox.warning(self, "ì‹¤íŒ¨", "API í‚¤ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"API í‚¤ ì¶”ê°€ ì¤‘ ì˜ˆì™¸ ë°œìƒ:\n{e}")

    def remove_api_key(self):
        """ì„ íƒëœ API í‚¤ë¥¼ DBì—ì„œ ì œê±°í•©ë‹ˆë‹¤."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "ì„ íƒ ì˜¤ë¥˜", "ì œê±°í•  API í‚¤ë¥¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        display_text = item.text()

        # ì‚¬ìš©ì ì„ íƒ í‚¤ëŠ” ì œê±° ë¶ˆê°€
        user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
        if key_id == user_selected_key_id:
            QMessageBox.warning(self, "ì œê±° ë¶ˆê°€", "í˜„ì¬ ì‚¬ìš©í•˜ë„ë¡ ì„ íƒëœ API í‚¤ëŠ” ì œê±°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në‹¤ë¥¸ í‚¤ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ì„ íƒì„ í•´ì œí•œ í›„ ì‹œë„í•˜ì„¸ìš”.")
            return

        reply = QMessageBox.question(self, "ì‚­ì œ í™•ì¸", f"ì •ë§ë¡œ API í‚¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n({display_text})",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        try:
            success = self.db_service.delete_api_key(key_id)
            if success:
                QMessageBox.information(self, "ì„±ê³µ", "API í‚¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.")
                self.load_api_keys_list() # ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            else:
                QMessageBox.warning(self, "ì‹¤íŒ¨", "API í‚¤ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"API í‚¤ ì œê±° ì¤‘ ì˜ˆì™¸ ë°œìƒ:\n{e}")

    def show_api_key_value(self, item: QListWidgetItem):
        """ë”ë¸”í´ë¦­ëœ API í‚¤ì˜ ì‹¤ì œ ê°’ì„ ë©”ì‹œì§€ ë°•ìŠ¤ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤."""
        api_key_value = item.data(Qt.ItemDataRole.UserRole + 1) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        if api_key_value:
            QMessageBox.information(self, "API í‚¤ ê°’ í™•ì¸",
                                    f"ì„ íƒí•œ API í‚¤ ê°’:\n\n{api_key_value}\n\n"
                                    "ì£¼ì˜: ì´ í‚¤ëŠ” ë¯¼ê°í•œ ì •ë³´ì´ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ì„¸ìš”.",
                                    QMessageBox.StandardButton.Ok) # QMessageBox.Ok -> QMessageBox.StandardButton.Ok
        else:
            QMessageBox.warning(self, "ì˜¤ë¥˜", "API í‚¤ ê°’ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def set_selected_api_key(self):
        """ì„ íƒëœ API í‚¤ë¥¼ ì‚¬ìš©ìê°€ ì‚¬ìš©í•  í‚¤ë¡œ ì„¤ì •í•©ë‹ˆë‹¤ (Gemini í‚¤ë§Œ í•´ë‹¹)."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "ì„ íƒ ì˜¤ë¥˜", "ì‚¬ìš©í•  API í‚¤ë¥¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole)
        provider = item.data(Qt.ItemDataRole.UserRole + 2)

        if provider != 'google':
            QMessageBox.information(self, "ì •ë³´", "Google (Gemini) API í‚¤ë§Œ ì‚¬ìš©í•˜ë„ë¡ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            return

        # ë¹„í™œì„± í‚¤ëŠ” ì„ íƒ ë¶ˆê°€
        if "ğŸ”´" in item.text():
             QMessageBox.warning(self, "ì„ íƒ ë¶ˆê°€", "ë¹„í™œì„±í™”ëœ API í‚¤ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
             return

        current_selected_id = self.config_service.get_user_selected_gemini_key_id()

        if key_id == current_selected_id:
            # ì´ë¯¸ ì„ íƒëœ í‚¤ë¥¼ ë‹¤ì‹œ ì„ íƒí•˜ë©´ ì„ íƒ í•´ì œ
            self.config_service.set_user_selected_gemini_key(None)
            QMessageBox.information(self, "ì„ íƒ í•´ì œ", "API í‚¤ ì„ íƒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.\nì´ì œ ì‚¬ìš©ëŸ‰ì´ ê°€ì¥ ì ì€ í‚¤ë¶€í„° ìë™ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.")
        else:
            # ìƒˆ í‚¤ ì„ íƒ
            self.config_service.set_user_selected_gemini_key(key_id)
            QMessageBox.information(self, "í‚¤ ì„ íƒ ì™„ë£Œ", f"API í‚¤ ID {key_id}ê°€ ì‚¬ìš©ë˜ë„ë¡ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.")

        # UI ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ
        self.load_api_keys_list()


    def browse_default_prompt(self):
        """Opens a file dialog to select the default system prompt and updates the line edit."""
        selected_path = select_default_system_prompt(self.config_service, self)
        if selected_path is not None:
            self.default_prompt_path_edit.setText(selected_path)

    def add_model_to_list(self, list_widget: QListWidget, provider: str):
        """ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì— ìƒˆ ëª¨ë¸ ì´ë¦„ê³¼ Rate Limitì„ ì¶”ê°€í•˜ê³  DBì— ì €ì¥í•©ë‹ˆë‹¤."""
        existing_models = [list_widget.item(i).text() for i in range(list_widget.count())]
        dialog = AddModelDialog(provider.capitalize(), existing_models, self)
        if dialog.exec() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_data = dialog.get_model_data()
            if model_data:
                model_name, rpm_limit, daily_limit = model_data
                try:
                    # DBì— Rate Limit ì •ë³´ ì €ì¥
                    self.db_service.insert_or_update_rate_limit(
                        model_name=model_name,
                        provider=provider,
                        rpm_limit=rpm_limit,
                        daily_limit=daily_limit
                    )
                    # UI ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì— ëª¨ë¸ ì´ë¦„ ì¶”ê°€
                    list_widget.addItem(model_name)
                    QMessageBox.information(self, "ì„±ê³µ", f"ëª¨ë¸ '{model_name}' ë° Rate Limit ì •ë³´ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.")
                except Exception as e:
                    QMessageBox.critical(self, "DB ì˜¤ë¥˜", f"ëª¨ë¸ Rate Limit ì •ë³´ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")
                    logger.exception(f"Error saving rate limit for model {model_name}")

    def remove_model_from_list(self, list_widget: QListWidget):
        """ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ì—ì„œ ì„ íƒëœ ëª¨ë¸ ì´ë¦„ì„ ì œê±°í•˜ê³  DBì—ì„œë„ Rate Limit ì •ë³´ë¥¼ ì œê±°í•©ë‹ˆë‹¤."""
        selected_items = list_widget.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "ì„ íƒ ì˜¤ë¥˜", "ì œê±°í•  ëª¨ë¸ì„ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.")
            return

        model_to_remove = selected_items[0].text()
        is_default = False
        if list_widget == self.gemini_models_list and self.settings and model_to_remove == self.settings.gemini_default_model: is_default = True
        elif list_widget == self.claude_models_list and self.settings and model_to_remove == self.settings.claude_default_model: is_default = True
        elif list_widget == self.gpt_models_list and self.settings and model_to_remove == self.settings.gpt_default_model: is_default = True


        if is_default:
            QMessageBox.warning(self, "ì œê±° ë¶ˆê°€", f"'{model_to_remove}' ëª¨ë¸ì€ í˜„ì¬ ê¸°ë³¸ ëª¨ë¸ë¡œ ì§€ì •ë˜ì–´ ìˆì–´ ì œê±°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në‹¤ë¥¸ ëª¨ë¸ì„ ê¸°ë³¸ìœ¼ë¡œ ì§€ì •í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
            return

        # ê¸°ë³¸ ëª¨ë¸ì´ ì•„ë‹ˆë©´ ì œê±° ì§„í–‰
        reply = QMessageBox.question(self, "ëª¨ë¸ ì œê±° í™•ì¸",
                                     f"ì •ë§ë¡œ '{model_to_remove}' ëª¨ë¸ì„ ëª©ë¡ê³¼ DBì—ì„œ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(Rate Limit ì •ë³´ë„ í•¨ê»˜ ì œê±°ë©ë‹ˆë‹¤)",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            # DBì—ì„œ Rate Limit ì •ë³´ ì œê±° ì‹œë„
            success_db = self.db_service.delete_rate_limit(model_name=model_to_remove)
            if success_db:
                logger.info(f"Successfully removed rate limit info for model '{model_to_remove}' from DB.")
                # DB ì œê±° ì„±ê³µ ì‹œ UI ëª©ë¡ì—ì„œë„ ì œê±°
                for item in selected_items:
                    list_widget.takeItem(list_widget.row(item))
                QMessageBox.information(self, "ì„±ê³µ", f"ëª¨ë¸ '{model_to_remove}'ì´(ê°€) ëª©ë¡ê³¼ DBì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.")
            else:
                # DB ì œê±° ì‹¤íŒ¨ ë˜ëŠ” í•´ë‹¹ ëª¨ë¸ ì •ë³´ ì—†ìŒ
                logger.warning(f"Failed to remove rate limit info for model '{model_to_remove}' from DB (or not found).")
                # UI ëª©ë¡ì—ì„œë§Œ ì œê±°í• ì§€ ì—¬ë¶€ ê²°ì • (ì—¬ê¸°ì„œëŠ” DB ì‹¤íŒ¨ ì‹œ UIë„ ìœ ì§€)
                QMessageBox.warning(self, "DB ì˜¤ë¥˜", f"DBì—ì„œ '{model_to_remove}' ëª¨ë¸ì˜ Rate Limit ì •ë³´ë¥¼ ì œê±°í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")

        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ëª¨ë¸ ì œê±° ì¤‘ ì˜ˆì™¸ ë°œìƒ:\n{e}")
            logger.exception(f"Error removing model {model_to_remove}")


    def save_config_settings(self):
        """UIì—ì„œ ì„¤ì •ê°’ì„ ì½ì–´ ConfigSettings ëª¨ë¸ì„ ì—…ë°ì´íŠ¸í•˜ê³  DBì— ì €ì¥í•©ë‹ˆë‹¤."""
        if not self.settings:
            QMessageBox.critical(self, "ì˜¤ë¥˜", "ì„¤ì • ê°ì²´ê°€ ë¡œë“œë˜ì§€ ì•Šì•„ ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return

        try:
            # --- UIì—ì„œ ê°’ ì½ê¸° (ê¸°ë³¸ ëª¨ë¸ì€ self.settingsì—ì„œ ì§ì ‘ ì½ìŒ) ---
            default_prompt = self.default_prompt_path_edit.text().strip()
            gemini_model = self.settings.gemini_default_model # í´ë¦­ í•¸ë“¤ëŸ¬ê°€ ì—…ë°ì´íŠ¸í•œ ê°’ ì‚¬ìš©
            claude_model = self.settings.claude_default_model # í´ë¦­ í•¸ë“¤ëŸ¬ê°€ ì—…ë°ì´íŠ¸í•œ ê°’ ì‚¬ìš©
            gpt_model = self.settings.gpt_default_model     # í´ë¦­ í•¸ë“¤ëŸ¬ê°€ ì—…ë°ì´íŠ¸í•œ ê°’ ì‚¬ìš©

            gemini_available = [self.gemini_models_list.item(i).text() for i in range(self.gemini_models_list.count())]
            claude_available = [self.claude_models_list.item(i).text() for i in range(self.claude_models_list.count())]
            gpt_available = [self.gpt_models_list.item(i).text() for i in range(self.gpt_models_list.count())]

            # ê¸°ë³¸ ëª¨ë¸ì´ ì‚¬ìš© ê°€ëŠ¥ ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸
            if gemini_model not in gemini_available and gemini_available:
                 QMessageBox.warning(self, "ì„¤ì • ì˜¤ë¥˜", f"Gemini ê¸°ë³¸ ëª¨ë¸ '{gemini_model}'ì´(ê°€) ì‚¬ìš© ê°€ëŠ¥ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤. ëª©ë¡ì— ì¶”ê°€í•˜ê±°ë‚˜ ë‹¤ë¥¸ ëª¨ë¸ì„ ê¸°ë³¸ìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.")
                 return
            if claude_model not in claude_available and claude_available:
                 QMessageBox.warning(self, "ì„¤ì • ì˜¤ë¥˜", f"Claude ê¸°ë³¸ ëª¨ë¸ '{claude_model}'ì´(ê°€) ì‚¬ìš© ê°€ëŠ¥ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤. ëª©ë¡ì— ì¶”ê°€í•˜ê±°ë‚˜ ë‹¤ë¥¸ ëª¨ë¸ì„ ê¸°ë³¸ìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.")
                 return
            if gpt_model not in gpt_available and gpt_available:
                 QMessageBox.warning(self, "ì„¤ì • ì˜¤ë¥˜", f"GPT ê¸°ë³¸ ëª¨ë¸ '{gpt_model}'ì´(ê°€) ì‚¬ìš© ê°€ëŠ¥ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤. ëª©ë¡ì— ì¶”ê°€í•˜ê±°ë‚˜ ë‹¤ë¥¸ ëª¨ë¸ì„ ê¸°ë³¸ìœ¼ë¡œ ì„ íƒí•˜ì„¸ìš”.")
                 return

            allowed_ext_str = self.allowed_extensions_edit.text().strip()
            allowed_extensions = {ext.strip() for ext in allowed_ext_str.replace(',', ' ').split() if ext.strip()}

            excluded_dirs = [line.strip() for line in self.excluded_dirs_edit.toPlainText().splitlines() if line.strip()]
            default_ignore = [line.strip() for line in self.default_ignore_list_edit.toPlainText().splitlines() if line.strip()]

            temp_str = self.gemini_temp_edit.text().strip()
            gemini_temp = float(temp_str) if temp_str else 0.0
            gemini_thinking = self.gemini_thinking_checkbox.isChecked()
            budget_str = self.gemini_budget_edit.text().strip()
            gemini_budget = int(budget_str) if budget_str else 0
            gemini_search = self.gemini_search_checkbox.isChecked()

            # --- ì—…ë°ì´íŠ¸í•  ë°ì´í„° ì¤€ë¹„ ---
            # self.settings ê°ì²´ëŠ” ì´ë¯¸ í´ë¦­ í•¸ë“¤ëŸ¬ì— ì˜í•´ ê¸°ë³¸ ëª¨ë¸ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìœ¼ë¯€ë¡œ,
            # ë‚˜ë¨¸ì§€ í•„ë“œë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
            update_data = self.settings.model_copy(deep=True)
            update_data.default_system_prompt = default_prompt if default_prompt else None
            # ê¸°ë³¸ ëª¨ë¸ì€ ì´ë¯¸ self.settingsì— ë°˜ì˜ë¨
            update_data.allowed_extensions = allowed_extensions
            update_data.excluded_dirs = set(excluded_dirs)
            update_data.default_ignore_list = default_ignore
            update_data.gemini_available_models = gemini_available
            update_data.claude_available_models = claude_available
            update_data.gpt_available_models = gpt_available
            update_data.gemini_temperature = gemini_temp
            update_data.gemini_enable_thinking = gemini_thinking
            update_data.gemini_thinking_budget = gemini_budget
            update_data.gemini_enable_search = gemini_search

            # --- Pydantic ìœ íš¨ì„± ê²€ì‚¬ ---
            validated_settings = ConfigSettings(**update_data.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})) # API í‚¤ëŠ” ê²€ì¦/ì €ì¥ ì œì™¸

            # --- ë¡œê¹… ì¶”ê°€: ì €ì¥ë  ìµœì¢… ì„¤ì • ë°ì´í„° í™•ì¸ ---
            logger.info("Validated settings data before saving to DB:")
            logger.info(f"{validated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})}")
            # ---------------------------------------------

            # --- DB ì €ì¥ ---
            if self.config_service.update_settings(validated_settings):
                # QMessageBox.information(self, "ì„±ê³µ", "ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.") # í™•ì¸ ë©”ì‹œì§€ ì œê±°
                logger.info("Application settings saved successfully.")
                # MainWindowì˜ ê´€ë ¨ UI ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
                self.mw.main_controller.on_llm_selected() # LLM/ëª¨ë¸ ì½¤ë³´ë°•ìŠ¤ ì—…ë°ì´íŠ¸
                self.mw.load_gemini_settings_to_ui() # ë©”ì¸ ìœˆë„ìš°ì˜ Gemini íŒŒë¼ë¯¸í„° UI ì—…ë°ì´íŠ¸
                self.mw.file_tree_controller.load_gitignore_settings() # í•„í„°ë§ ê·œì¹™ ì—…ë°ì´íŠ¸
                self.accept() # ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
            else:
                QMessageBox.critical(self, "ì €ì¥ ì‹¤íŒ¨", "ì„¤ì •ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

        except ValidationError as e:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", f"ì„¤ì • ê°’ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨:\n{e}")
        except ValueError as e:
             QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", f"ìˆ«ì í•„ë“œ(ì˜¨ë„, ì˜ˆì‚°)ì— ìœ íš¨í•œ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n{e}")
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì„¤ì • ì €ì¥ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ:\n{e}")


    def load_gitignore(self):
        """í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”ì˜ .gitignore íŒŒì¼ì„ ë¡œë“œí•˜ì—¬ í¸ì§‘ê¸°ì— í‘œì‹œí•©ë‹ˆë‹¤."""
        if not self.mw.current_project_folder:
            self.gitignore_edit.setPlainText("")
            self.gitignore_edit.setEnabled(False)
            return

        self.gitignore_edit.setEnabled(True)
        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = ""
        try:
            if os.path.isfile(gitignore_path):
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.gitignore_edit.setPlainText(content)
            else:
                self.gitignore_edit.setPlainText("# .gitignore íŒŒì¼ ì—†ìŒ")
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f".gitignore íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")
            self.gitignore_edit.setPlainText(f"# ì˜¤ë¥˜: {e}")

    def save_gitignore(self):
        """í¸ì§‘ê¸° ë‚´ìš©ì„ í˜„ì¬ í”„ë¡œì íŠ¸ í´ë”ì˜ .gitignore íŒŒì¼ì— ì €ì¥í•©ë‹ˆë‹¤."""
        if not self.mw.current_project_folder:
            QMessageBox.warning(self, "ì˜¤ë¥˜", "í”„ë¡œì íŠ¸ í´ë”ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return

        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = self.gitignore_edit.toPlainText()

        try:
            with open(gitignore_path, 'w', encoding='utf-8') as f:
                f.write(content)
            QMessageBox.information(self, "ì„±ê³µ", f".gitignore íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:\n{gitignore_path}")
            if hasattr(self.mw, 'file_tree_controller'):
                self.mw.file_tree_controller.load_gitignore_settings()
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f".gitignore íŒŒì¼ì„ ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")



======== src\utils\__init__.py ========

# This file makes Python treat the directory utils as a package.

from .helpers import get_project_root, get_resource_path, calculate_char_count
from .notifications import show_notification

__all__ = [
    "get_project_root",
    "get_resource_path",
    "calculate_char_count",
    "show_notification",
]



======== src\utils\db_migration_script.py ========

import psycopg2
import logging
from typing import Dict, Any, Optional, List

# --- Database Connection Details (from db_service.py or environment) ---
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389" # Warning: Hardcoded password

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def run_migration():
    """Performs the database migration: adds usage columns to api_keys, migrates data, drops api_key_usage."""
    conn = None
    try:
        # 1. Connect to the database
        logger.info(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )
        conn.autocommit = False # Start transaction
        logger.info("Database connection successful.")
        cur = conn.cursor()

        # 2. Add new columns to api_keys table if they don't exist
        logger.info("Adding usage tracking columns to api_keys table (if they don't exist)...")
        columns_to_add = [
            ("last_api_call_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_minute", "INTEGER", "NOT NULL DEFAULT 0"),
            ("minute_start_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_day", "INTEGER", "NOT NULL DEFAULT 0"),
            ("day_start_timestamp", "TIMESTAMPTZ", "NULL")
        ]
        for col_name, col_type, col_constraint in columns_to_add:
            try:
                alter_sql = f"ALTER TABLE api_keys ADD COLUMN IF NOT EXISTS {col_name} {col_type} {col_constraint};"
                logger.debug(f"Executing: {alter_sql}")
                cur.execute(alter_sql)
                logger.info(f"Column '{col_name}' added or already exists in api_keys.")
            except psycopg2.Error as e:
                logger.error(f"Error adding column '{col_name}' to api_keys: {e}")
                raise # Stop migration if altering fails

        # 3. Check if api_key_usage table exists before attempting migration
        cur.execute("SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'api_key_usage');")
        usage_table_exists = cur.fetchone()[0]

        if usage_table_exists:
            logger.info("api_key_usage table exists. Migrating data...")

            # 4. Fetch data from api_key_usage
            logger.info("Fetching data from api_key_usage table...")
            try:
                cur.execute("""
                    SELECT api_key_id, last_api_call_timestamp, calls_this_minute,
                           minute_start_timestamp, calls_this_day, day_start_timestamp
                    FROM api_key_usage;
                """)
                usage_data = cur.fetchall()
                logger.info(f"Fetched {len(usage_data)} rows from api_key_usage.")
            except psycopg2.Error as e:
                logger.error(f"Error fetching data from api_key_usage: {e}")
                raise

            # 5. Update api_keys table with migrated data
            logger.info("Updating api_keys table with migrated usage data...")
            update_count = 0
            for row in usage_data:
                key_id, last_call, calls_min, min_start, calls_day, day_start = row
                try:
                    update_sql = """
                        UPDATE api_keys
                        SET last_api_call_timestamp = %s,
                            calls_this_minute = %s,
                            minute_start_timestamp = %s,
                            calls_this_day = %s,
                            day_start_timestamp = %s,
                            updated_at = NOW()
                        WHERE id = %s;
                    """
                    cur.execute(update_sql, (last_call, calls_min, min_start, calls_day, day_start, key_id))
                    if cur.rowcount == 1:
                        update_count += 1
                    else:
                        logger.warning(f"API key ID {key_id} not found in api_keys table during migration update.")
                except psycopg2.Error as e:
                    logger.error(f"Error updating api_keys for key_id {key_id}: {e}")
                    # Decide whether to continue or stop on error
                    # raise # Uncomment to stop on first error
            logger.info(f"Successfully updated {update_count} rows in api_keys with usage data.")

            # 6. Drop the api_key_usage table
            logger.info("Dropping api_key_usage table...")
            try:
                cur.execute("DROP TABLE IF EXISTS api_key_usage;")
                logger.info("api_key_usage table dropped successfully.")
            except psycopg2.Error as e:
                logger.error(f"Error dropping api_key_usage table: {e}")
                raise
        else:
            logger.info("api_key_usage table does not exist. Skipping data migration and table drop.")

        # 7. Commit transaction
        conn.commit()
        logger.info("Database migration completed successfully.")

    except (Exception, psycopg2.Error) as error:
        logger.error(f"Database migration failed: {error}", exc_info=True)
        if conn:
            conn.rollback()
            logger.info("Transaction rolled back.")
    finally:
        if conn:
            cur.close()
            conn.close()
            logger.info("Database connection closed.")

if __name__ == "__main__":
    run_migration()



======== src\utils\helpers.py ========
import os
import sys
# import tiktoken # No longer directly used here, moved to TokenCalculationService
from typing import Union, Optional
# import threading # No longer needed for preloading here
from pathlib import Path # pathlib ì‚¬ìš©

# --- ê²½ë¡œ ê´€ë ¨ ---
def get_project_root() -> Path:
    """Gets the project root directory reliably."""
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # PyInstaller ë²ˆë“¤ í™˜ê²½
        return Path(sys._MEIPASS)
    else:
        # ê°œë°œ í™˜ê²½ (main.py ë˜ëŠ” src/app.pyì—ì„œ ì‹¤í–‰ ê°€ì •)

        src_dir = Path(__file__).parent.parent.resolve()
        # í”„ë¡œì íŠ¸ ë£¨íŠ¸ëŠ” src í´ë”ì˜ ë¶€ëª¨
        return src_dir.parent

def get_resource_path(relative_path: str) -> str:
    """
    Gets the absolute path to a resource file/directory.
    Assumes the 'resources' directory is at the project root.
    """
    project_root = get_project_root()
    resource_path = project_root / "resources" / relative_path
    return str(resource_path)

# --- í…ìŠ¤íŠ¸ ê³„ì‚° ê´€ë ¨ ---
def calculate_char_count(text: str) -> int:
    """Calculates the number of characters in the text."""
    return len(text)

# calculate_token_count is now handled by TokenCalculationService
# def calculate_token_count(text: str) -> Optional[int]:
#     """
#     Calculates the number of tokens using the preloaded tiktoken encoding.
#     Returns None if encoding is not available or an error occurs.
#     """
#     # ... (old implementation removed) ...

# init_utils and preload_encoding are removed as tiktoken loading is now
# handled within TokenCalculationService when needed.
# def preload_encoding():
#     """Preloads the tiktoken encoding in a separate thread."""
#     # ... (old implementation removed) ...

# def init_utils():
#     """Initializes utility functions, including preloading encoding."""
#     # ... (old implementation removed) ...

# def get_encoding() -> Optional[tiktoken.Encoding]:
#     """Returns the preloaded tiktoken encoding, loading if necessary."""
#     # ... (old implementation removed) ...



======== src\utils\notifications.py ========
import logging
import os
from typing import Optional

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ë¦„ ì „ì—­ ë³€ìˆ˜
_APP_NAME = "DuckPrompt"

# winotify import ì‹œë„
try:
    from winotify import Notification
    # winotifyëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Windowsì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤.
    _WINOTIFY_AVAILABLE = os.name == 'nt'
except ImportError:
    _WINOTIFY_AVAILABLE = False
    logging.warning("winotify library not found or OS is not Windows. Desktop notifications will be disabled.")

# helpersì—ì„œ ì•„ì´ì½˜ ê²½ë¡œ í•¨ìˆ˜ ê°€ì ¸ì˜¤ê¸°
from .helpers import get_resource_path

logger = logging.getLogger(__name__)

def show_notification(title: str, message: str, app_name: str = None, timeout: Optional[int] = None):
    """
    Displays a desktop notification using winotify (Windows only).

    Args:
        title: The title of the notification.
        message: The main message content of the notification.
        app_name: The name of the application sending the notification.
        timeout: Duration in seconds (winotify doesn't directly support timeout, Windows setting applies).
    """
    if not _WINOTIFY_AVAILABLE:
        logger.warning(f"Notification not shown (winotify unavailable or not Windows): Title='{title}', Message='{message[:50]}...'")
        return

    try:
        logger.info(f"Showing notification via winotify: Title='{title}', Message='{message[:50]}...'")

        # ì•„ì´ì½˜ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
        icon_path = ""
        try:
            icon_path = get_resource_path("icons/rubber_duck.ico")
            if not os.path.exists(icon_path):
                logger.warning(f"Notification icon not found at: {icon_path}")
                icon_path = "" # ì•„ì´ì½˜ ê²½ë¡œ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì •
        except Exception as e:
            logger.error(f"Error getting notification icon path: {e}")
            icon_path = ""

        # ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ë¦„ ì„¤ì •
        notification_app_name = app_name if app_name else _APP_NAME

        # winotify Notification ê°ì²´ ìƒì„±
        toast = Notification(
            app_id=notification_app_name,
            title=title,
            msg=message,
            icon=icon_path if icon_path else None  # ì•„ì´ì½˜ ê²½ë¡œ ì„¤ì • (ì—†ìœ¼ë©´ None)
        )

        # ì•Œë¦¼ í‘œì‹œ
        toast.show()
        logger.info("winotify notification shown successfully.")

    except Exception as e:
        logger.error(f"Failed to show winotify notification: {e}", exc_info=True)

# Example usage (for testing):
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    print("Testing winotify notification...")
    if _WINOTIFY_AVAILABLE:
        show_notification("Test Notification", "This is a test message from notifications.py using winotify.")
        print("Notification test finished.")
    else:
        print("winotify is not available on this system (requires Windows and winotify library).")




======== src\utils\postgres_db_initializer.py ========

import psycopg2
import os
import yaml # YAML íŒŒì‹±ì„ ìœ„í•´ ì¶”ê°€
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, List # íƒ€ì… íŒíŠ¸ ì¶”ê°€

# --- Database Connection Details ---
# í™˜ê²½ ë³€ìˆ˜ë‚˜ ë³´ì•ˆ ê´€ë¦¬ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389" # ê²½ê³ : ì‹¤ì œ ë¹„ë°€ë²ˆí˜¸

# --- Project Root and Config File Path ---
# helpers.pyì˜ get_project_root()ë¥¼ ì‚¬ìš©í•˜ì—¬ í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
# ì´ íŒŒì¼ì´ src/utils/ ì— ìˆìœ¼ë¯€ë¡œ, í”„ë¡œì íŠ¸ ë£¨íŠ¸ëŠ” ë‘ ë‹¨ê³„ ìœ„ì…ë‹ˆë‹¤.
try:
    PROJECT_ROOT = Path(__file__).parent.parent.parent.resolve()
except NameError:
    # __file__ì´ ì •ì˜ë˜ì§€ ì•Šì€ ê²½ìš° (ì˜ˆ: ì¸í„°í”„ë¦¬í„°ì—ì„œ ì§ì ‘ ì‹¤í–‰)
    PROJECT_ROOT = Path('.').resolve()

CONFIG_FILE_PATH = PROJECT_ROOT / "src" / "config.yml"


# --- SQL Schema Definition ---
# api_key_usage í…Œì´ë¸” ì œê±°, api_keys í…Œì´ë¸”ì— ì‚¬ìš©ëŸ‰ ì»¬ëŸ¼ ì¶”ê°€
SCHEMA_SQL = """
-- íƒ€ì„ìŠ¤íƒ¬í”„ ìë™ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ í•¨ìˆ˜ ìƒì„± (ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°)
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ (ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•  ê²½ìš°) - ì£¼ì˜: ë°ì´í„° ì†ì‹¤ ë°œìƒ
-- DROP TABLE IF EXISTS application_config CASCADE;
-- DROP TABLE IF EXISTS model_rate_limits CASCADE;
-- DROP TABLE IF EXISTS api_keys CASCADE;
-- DROP TABLE IF EXISTS gemini_api_logs CASCADE;

-- ==== API í‚¤ í…Œì´ë¸” (ì‚¬ìš©ëŸ‰ ì»¬ëŸ¼ ì¶”ê°€) ====
-- í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„± (IF NOT EXISTS ì¶”ê°€)
CREATE TABLE IF NOT EXISTS api_keys (
    id SERIAL PRIMARY KEY,
    api_key TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    description TEXT,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    -- Usage tracking columns added
    last_api_call_timestamp TIMESTAMPTZ,
    calls_this_minute INTEGER NOT NULL DEFAULT 0,
    minute_start_timestamp TIMESTAMPTZ,
    calls_this_day INTEGER NOT NULL DEFAULT 0,
    day_start_timestamp TIMESTAMPTZ,
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- íŠ¸ë¦¬ê±°ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_api_keys_timestamp') THEN
        CREATE TRIGGER set_api_keys_timestamp
        BEFORE UPDATE ON api_keys
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE api_keys IS 'Stores individual API keys, their metadata, and usage tracking.';
COMMENT ON COLUMN api_keys.api_key IS 'The actual API key string. Sensitive data.';
COMMENT ON COLUMN api_keys.provider IS 'The provider of the API key (e.g., google, anthropic).';
COMMENT ON COLUMN api_keys.description IS 'User-friendly description for the key.';
COMMENT ON COLUMN api_keys.is_active IS 'Flag to enable/disable the key for use.';
COMMENT ON COLUMN api_keys.last_api_call_timestamp IS 'Timestamp of the last successful API call using this key.';
COMMENT ON COLUMN api_keys.calls_this_minute IS 'Counter for calls made within the current minute window.';
COMMENT ON COLUMN api_keys.minute_start_timestamp IS 'Timestamp marking the beginning of the current minute window for rate limiting.';
COMMENT ON COLUMN api_keys.calls_this_day IS 'Counter for calls made within the current day window.';
COMMENT ON COLUMN api_keys.day_start_timestamp IS 'Timestamp marking the beginning of the current day window for rate limiting.';


-- ==== ëª¨ë¸ë³„ ê¸°ë³¸ Rate Limit í…Œì´ë¸” ====
-- í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
CREATE TABLE IF NOT EXISTS model_rate_limits (
    id SERIAL PRIMARY KEY,
    model_name TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    rpm_limit INTEGER NOT NULL,
    daily_limit INTEGER NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- íŠ¸ë¦¬ê±°ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_model_rate_limits_timestamp') THEN
        CREATE TRIGGER set_model_rate_limits_timestamp
        BEFORE UPDATE ON model_rate_limits
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE model_rate_limits IS 'Stores default rate limit information per model.';
COMMENT ON COLUMN model_rate_limits.model_name IS 'Identifier for the language model.';
COMMENT ON COLUMN model_rate_limits.rpm_limit IS 'Default Requests Per Minute limit for the model.';
COMMENT ON COLUMN model_rate_limits.daily_limit IS 'Default Requests Per Day limit for the model.';


-- ==== API í‚¤ ì‚¬ìš©ëŸ‰ ì¶”ì  í…Œì´ë¸” (ì œê±°ë¨) ====
-- DROP TABLE IF EXISTS api_key_usage CASCADE;


-- ==== ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì • í…Œì´ë¸” ====
-- í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
CREATE TABLE IF NOT EXISTS application_config (
    id SERIAL PRIMARY KEY,
    profile_name TEXT NOT NULL UNIQUE DEFAULT 'default',
    default_system_prompt TEXT,
    allowed_extensions TEXT[],
    excluded_dirs TEXT[],
    default_ignore_list TEXT[],
    gemini_default_model TEXT,
    claude_default_model TEXT,
    gpt_default_model TEXT,
    gemini_available_models TEXT[],
    claude_available_models TEXT[],
    gpt_available_models TEXT[],
    gemini_temperature NUMERIC(3, 2) DEFAULT 0.0,
    gemini_enable_thinking BOOLEAN DEFAULT TRUE,
    gemini_thinking_budget INTEGER DEFAULT 24576,
    gemini_enable_search BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- íŠ¸ë¦¬ê±°ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_application_config_timestamp') THEN
        CREATE TRIGGER set_application_config_timestamp
        BEFORE UPDATE ON application_config
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE application_config IS 'Stores application-wide configuration settings, replacing config.yml.';
COMMENT ON COLUMN application_config.profile_name IS 'Identifier for the configuration profile (e.g., default, development).';
COMMENT ON COLUMN application_config.allowed_extensions IS 'Array of allowed file extensions.';
COMMENT ON COLUMN application_config.excluded_dirs IS 'Array of directory/file patterns to exclude.';
COMMENT ON COLUMN application_config.default_ignore_list IS 'Array of default patterns to ignore.';
COMMENT ON COLUMN application_config.gemini_available_models IS 'Array of available Gemini model names.';
COMMENT ON COLUMN application_config.claude_available_models IS 'Array of available Claude model names.';
COMMENT ON COLUMN application_config.gpt_available_models IS 'Array of available GPT model names.';
COMMENT ON COLUMN application_config.gemini_temperature IS 'Generation temperature for Gemini models.';

-- ==== Gemini API ë¡œê·¸ í…Œì´ë¸” ====
-- í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
CREATE TABLE IF NOT EXISTS gemini_api_logs (
    id SERIAL PRIMARY KEY,
    request_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    response_timestamp TIMESTAMPTZ,
    model_name TEXT,
    request_prompt TEXT,
    request_attachments JSONB,
    response_text TEXT,
    response_xml TEXT,
    response_summary TEXT,
    error_message TEXT,
    elapsed_time_ms INTEGER,
    token_count INTEGER,
    api_key_id INTEGER REFERENCES api_keys(id) ON DELETE SET NULL -- FK ìœ ì§€
);

-- ì¸ë±ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë§Œ ìƒì„±
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_request_timestamp' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_request_timestamp ON gemini_api_logs(request_timestamp);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_api_key_id' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_api_key_id ON gemini_api_logs(api_key_id);
    END IF;
END $$;

COMMENT ON TABLE gemini_api_logs IS 'Stores logs of requests and responses to the Gemini API.';
COMMENT ON COLUMN gemini_api_logs.request_timestamp IS 'Timestamp when the request was initiated.';
COMMENT ON COLUMN gemini_api_logs.response_timestamp IS 'Timestamp when the response was received.';
COMMENT ON COLUMN gemini_api_logs.model_name IS 'The specific Gemini model used for the request.';
COMMENT ON COLUMN gemini_api_logs.request_prompt IS 'The text prompt sent to the API.';
COMMENT ON COLUMN gemini_api_logs.request_attachments IS 'JSONB data containing metadata about attached files/images (e.g., name, type, path).';
COMMENT ON COLUMN gemini_api_logs.response_text IS 'The raw text response from the Gemini API.';
COMMENT ON COLUMN gemini_api_logs.response_xml IS 'The parsed XML part of the response, if applicable.';
COMMENT ON COLUMN gemini_api_logs.response_summary IS 'The parsed summary part of the response, if applicable.';
COMMENT ON COLUMN gemini_api_logs.error_message IS 'Error message if the API call failed.';
COMMENT ON COLUMN gemini_api_logs.elapsed_time_ms IS 'Total time taken for the API call in milliseconds.';
COMMENT ON COLUMN gemini_api_logs.token_count IS 'Calculated token count for the request/response.';
COMMENT ON COLUMN gemini_api_logs.api_key_id IS 'Foreign key referencing the api_key used for the request.';

"""

def create_tables(conn):
    """Creates database tables based on the SCHEMA_SQL."""
    print("Attempting to create/update database tables...")
    try:
        with conn.cursor() as cur:
            cur.execute(SCHEMA_SQL)
        conn.commit()
        print("Tables created/updated (or already exist) successfully.")
    except psycopg2.Error as e:
        print(f"Error creating/updating tables: {e}")
        conn.rollback() # Roll back changes on error
        raise # Re-raise the exception to stop the script

def load_yaml_config(file_path: Path) -> Optional[Dict[str, Any]]:
    """Loads configuration from a YAML file."""
    if not file_path.exists():
        print(f"Error: Configuration file not found at {file_path}")
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        print(f"Configuration loaded successfully from {file_path}")
        return config
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading configuration file {file_path}: {e}")
        return None

def insert_or_update_config(conn, config_data: Dict[str, Any]):
    """Inserts or updates the 'default' profile in the application_config table."""
    print("Attempting to insert/update application configuration...")
    profile_name = 'default' # Assuming we always update the default profile

    # Prepare data for insertion/update, handling potential missing keys and types
    # Convert sets from YAML (!!set) to lists for PostgreSQL TEXT[]
    allowed_extensions = list(config_data.get('allowed_extensions', set()))
    excluded_dirs = list(config_data.get('excluded_dirs', set()))
    default_ignore_list = list(config_data.get('default_ignore_list', []))
    gemini_available_models = list(config_data.get('gemini_available_models', []))
    claude_available_models = list(config_data.get('claude_available_models', []))
    gpt_available_models = list(config_data.get('gpt_available_models', []))

    # Ensure boolean values are correctly interpreted
    gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
    gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

    # Ensure numeric values are correctly interpreted, providing defaults
    try:
        gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
    except (ValueError, TypeError):
        gemini_temperature = 0.0
    try:
        gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
    except (ValueError, TypeError):
        gemini_thinking_budget = 24576

    # SQL query using ON CONFLICT for upsert
    sql = """
        INSERT INTO application_config (
            profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
            default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
            gemini_available_models, claude_available_models, gpt_available_models,
            gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
        ) VALUES (
            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
        )
        ON CONFLICT (profile_name) DO UPDATE SET
            default_system_prompt = EXCLUDED.default_system_prompt,
            allowed_extensions = EXCLUDED.allowed_extensions,
            excluded_dirs = EXCLUDED.excluded_dirs,
            default_ignore_list = EXCLUDED.default_ignore_list,
            gemini_default_model = EXCLUDED.gemini_default_model,
            claude_default_model = EXCLUDED.claude_default_model,
            gpt_default_model = EXCLUDED.gpt_default_model,
            gemini_available_models = EXCLUDED.gemini_available_models,
            claude_available_models = EXCLUDED.claude_available_models,
            gpt_available_models = EXCLUDED.gpt_available_models,
            gemini_temperature = EXCLUDED.gemini_temperature,
            gemini_enable_thinking = EXCLUDED.gemini_enable_thinking,
            gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
            gemini_enable_search = EXCLUDED.gemini_enable_search,
            updated_at = NOW();
    """
    params = (
        profile_name,
        config_data.get('default_system_prompt'),
        allowed_extensions,
        excluded_dirs,
        default_ignore_list,
        config_data.get('gemini_default_model'),
        config_data.get('claude_default_model'),
        config_data.get('gpt_default_model'),
        gemini_available_models,
        claude_available_models,
        gpt_available_models,
        gemini_temperature,
        gemini_enable_thinking,
        gemini_thinking_budget,
        gemini_enable_search
    )

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"Application configuration for profile '{profile_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating application configuration: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during config update: {e}")
        conn.rollback()

def insert_or_update_api_key(conn, api_key: str, provider: str):
    """Inserts or updates an API key in the api_keys table."""
    if not api_key:
        print(f"Skipping API key insertion/update for {provider}: Key is empty.")
        return

    print(f"Attempting to insert/update API key for provider: {provider}...")
    # Add default NULL/0 values for new usage columns on insert
    sql = """
        INSERT INTO api_keys (api_key, provider, is_active,
                              last_api_call_timestamp, calls_this_minute, minute_start_timestamp,
                              calls_this_day, day_start_timestamp)
        VALUES (%s, %s, %s, NULL, 0, NULL, 0, NULL)
        ON CONFLICT (api_key) DO UPDATE SET
            provider = EXCLUDED.provider,
            is_active = EXCLUDED.is_active,
            -- Do not reset usage columns on conflict update here
            updated_at = NOW();
    """
    params = (api_key, provider, True) # Always set as active when loading from config

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"API key for provider '{provider}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating API key for {provider}: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during API key update for {provider}: {e}")
        conn.rollback()

def insert_or_update_rate_limit(conn, model_name: str, provider: str, rpm_limit: int, daily_limit: int, notes: Optional[str] = None):
    """Inserts or updates a model's rate limit in the model_rate_limits table."""
    print(f"Attempting to insert/update rate limit for model: {model_name}...")
    sql = """
        INSERT INTO model_rate_limits (model_name, provider, rpm_limit, daily_limit, notes)
        VALUES (%s, %s, %s, %s, %s)
        ON CONFLICT (model_name) DO UPDATE SET
            provider = EXCLUDED.provider,
            rpm_limit = EXCLUDED.rpm_limit,
            daily_limit = EXCLUDED.daily_limit,
            notes = EXCLUDED.notes,
            updated_at = NOW();
    """
    params = (model_name, provider, rpm_limit, daily_limit, notes)

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"Rate limit for model '{model_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating rate limit for {model_name}: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during rate limit update for {model_name}: {e}")
        conn.rollback()

def main():
    """Main function to connect, setup/update DB schema, and load config."""
    conn = None
    try:
        # 1. Connect to the database
        print(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )
        print("Database connection successful.")

        # 2. Create/Update tables based on SCHEMA_SQL
        create_tables(conn)
        print("Database schema setup/update complete.")

        # 3. Load configuration from config.yml
        print(f"Loading configuration from: {CONFIG_FILE_PATH}")
        config = load_yaml_config(CONFIG_FILE_PATH)

        if config:
            # 4. Insert/Update application_config table
            insert_or_update_config(conn, config)

            # 5. Insert/Update api_keys table
            gemini_key = config.get('gemini_api_key')
            anthropic_key = config.get('anthropic_api_key')
            # openai_key = config.get('openai_api_key') # If needed in the future

            if gemini_key:
                insert_or_update_api_key(conn, gemini_key, 'google')
            if anthropic_key:
                insert_or_update_api_key(conn, anthropic_key, 'anthropic')
            # if openai_key:
            #     insert_or_update_api_key(conn, openai_key, 'openai')

            print("Configuration data loaded into database.")

            # 6. Insert/Update model_rate_limits table (based on user request)
            print("Inserting/Updating specific model rate limits...")
            insert_or_update_rate_limit(conn, 'gemini-2.5-pro-preview-03-25', 'google', 5, 25, 'Gemini Pro Preview Rate Limit')
            insert_or_update_rate_limit(conn, 'gemini-2.5-flash-preview-04-17', 'google', 10, 500, 'Gemini Flash Preview Rate Limit')
            print("Model rate limits updated.")

        else:
            print("Skipping database update due to configuration loading failure.")

    except psycopg2.OperationalError as e:
        print(f"Database connection failed: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        if conn:
            conn.close()
            print("Database connection closed.")

if __name__ == "__main__":
    main()




======== src\__init__.py ========
# This file makes Python treat the directory src as a package.



======== src\app.py ========

import sys
import os
import ctypes
import logging # ë¡œê¹… ì¶”ê°€
from PyQt6.QtWidgets import QApplication, QMessageBox # PyQt5 -> PyQt6
from PyQt6.QtGui import QIcon # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from ui.main_window import MainWindow
from utils.helpers import get_resource_path
from core.services.db_service import DbService # DbService ì„í¬íŠ¸

def setup_logging():
    """Sets up basic logging configuration."""
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_format)
    # Optionally add file handler later if needed
    # handler = logging.FileHandler('app.log', encoding='utf-8')
    # handler.setFormatter(logging.Formatter(log_format))
    # logging.getLogger().addHandler(handler)
    logging.info("Logging setup complete.")

def cleanup_logs(db_service: DbService):
    """Calls the log cleanup function."""
    try:
        logging.info("Attempting to clean up old Gemini logs...")
        db_service.cleanup_old_gemini_logs(days_to_keep=7) # 7ì¼ ì´ìƒëœ ë¡œê·¸ ì‚­ì œ
        logging.info("Log cleanup process finished.")
    except Exception as e:
        logging.error(f"Error during log cleanup: {e}", exc_info=True)

def main():
    setup_logging() # ë¡œê¹… ì„¤ì • í˜¸ì¶œ

    if sys.platform.startswith("win"):
        try:
            # DPI ì¸ì‹ ì„¤ì • (Windows)
            ctypes.windll.shcore.SetProcessDpiAwareness(1)
            logging.info("Set DPI awareness for Windows.")
        except AttributeError:
            logging.warning("ctypes.windll.shcore not available, DPI awareness not set (might be older Windows).")
        except Exception as e:
            logging.warning(f"Error setting DPI awareness: {e}") # ë¡œê¹… ì‚¬ìš©

    # Qt High DPI ì„¤ì • (PyQt6ì—ì„œëŠ” ê¸°ë³¸ í™œì„±í™”)
    logging.info("PyQt6ì—ì„œëŠ” High DPI ìŠ¤ì¼€ì¼ë§ì´ ê¸°ë³¸ìœ¼ë¡œ í™œì„±í™”ë¨")

    app = QApplication(sys.argv)

    # ì• í”Œë¦¬ì¼€ì´ì…˜ ì•„ì´ì½˜ ì„¤ì •
    try:
        # ì•„ì´ì½˜ ê²½ë¡œë¥¼ get_resource_pathë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¬ë°”ë¥´ê²Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
        icon_path = get_resource_path("icons/rubber_duck.ico")
        logging.info(f"Attempting to load icon from: {icon_path}") # ê²½ë¡œ ë¡œê¹… ì¶”ê°€
        if os.path.exists(icon_path):
            app_icon = QIcon(icon_path)
            app.setWindowIcon(app_icon)
            logging.info(f"Application icon set successfully from: {icon_path}")
        else:
            # ì•„ì´ì½˜ íŒŒì¼ì´ ì—†ì„ ê²½ìš° ê²½ê³  ë¡œê¹…
            logging.warning(f"Icon file not found at resolved path: {icon_path}. Check if the file exists at 'project_root/resources/icons/rubber_duck.ico'.")
    except Exception as e:
        logging.error(f"Error loading application icon: {e}", exc_info=True) # ë¡œê¹… ì‚¬ìš©

    db_service_instance = None # DB ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜
    try:
        # MainWindow ìƒì„± ì „ì— DB ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ë° ë¡œê·¸ ì •ë¦¬ ì‹œë„
        # MainWindow ë‚´ë¶€ì—ì„œë„ DBServiceë¥¼ ì´ˆê¸°í™”í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ë¥¼
        # MainWindowì— ì „ë‹¬í•˜ê±°ë‚˜, MainWindow ë‚´ë¶€ì—ì„œ ë¡œê·¸ ì •ë¦¬ë¥¼ í˜¸ì¶œí•´ì•¼ í•¨.
        # ì—¬ê¸°ì„œëŠ” ë¡œê·¸ ì •ë¦¬ë§Œ ì‹œë„í•˜ê³ , MainWindowëŠ” ìì²´ì ìœ¼ë¡œ DBServiceë¥¼ ìƒì„±í•˜ë„ë¡ ë‘ .
        try:
            db_service_instance = DbService()
            cleanup_logs(db_service_instance)
        except (ConnectionError, ValueError) as db_init_err:
             # DB ì—°ê²° ë˜ëŠ” ì„¤ì • ì˜¤ë¥˜ ì‹œì—ë„ ì¼ë‹¨ ì•± ì‹¤í–‰ ì‹œë„ (MainWindowì—ì„œ ë‹¤ì‹œ ì²˜ë¦¬)
             logging.error(f"Initial DB connection/cleanup failed: {db_init_err}. MainWindow will attempt connection.")
        except Exception as cleanup_err:
             logging.error(f"Error during initial log cleanup: {cleanup_err}")
        finally:
            # ë¡œê·¸ ì •ë¦¬ í›„ ì—°ê²° ë‹«ê¸° (MainWindowì—ì„œ ìƒˆë¡œ ì—°ê²°)
            if db_service_instance:
                db_service_instance.disconnect()
                logging.info("Initial DB connection for cleanup closed.")


        # MainWindow ìƒì„± ë° ì‹¤í–‰
        window = MainWindow(mode="Code Enhancer Prompt Builder")
        window.show()
        sys.exit(app.exec()) # exec_() -> exec()

    except (ConnectionError, ValueError) as e:
         # Catch DB connection or config load errors from MainWindow init
         logging.critical(f"Application initialization failed: {e}", exc_info=True)
         # GUIê°€ ë¶€ë¶„ì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•  ë•Œ ê°„ë‹¨í•œ ë©”ì‹œì§€ ë°•ìŠ¤ í‘œì‹œ (ì„ íƒ ì‚¬í•­)
         QMessageBox.critical(None, "ì¹˜ëª…ì  ì˜¤ë¥˜", f"ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹¤íŒ¨:\n{e}")
         sys.exit(1) # ì˜¤ë¥˜ ì½”ë“œë¡œ ì¢…ë£Œ
    except SystemExit as e:
         # MainWindow ë‚´ë¶€ì—ì„œ DB/Config ì˜¤ë¥˜ë¡œ SystemExit í˜¸ì¶œ ì‹œ
         logging.info(f"Application exited with code {e.code}")
         sys.exit(e.code)
    except Exception as e:
         logging.critical(f"An unexpected error occurred during application startup: {e}", exc_info=True)
         QMessageBox.critical(None, "ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜", f"ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{e}")
         sys.exit(1)

if __name__ == "__main__":
    main()



======== src\config.yml ========
default_system_prompt: resources\prompts\system\unified-diff_en.md
allowed_extensions: !!set {}
excluded_dirs: !!set
  __pycache__/: null
  .gitignore: null
  dist/: null
  node_modules/: null
  .vscode/: null
  .DS_Store: null
  .idea/: null
  .git/: null
  "*.log": null
  build/: null
  .venv/: null
default_ignore_list:
  - "*.egg-info/"
  - "*.pyc"
  - .cursorrules
  - .git/
  - .gitignore
  - .idea/
  - .vscode/
  - .windsurfrules
  - __pycache__/
  - build/
  - dist/
gemini_default_model: gemini-2.5-pro-preview-03-25
claude_default_model: claude-3-7-sonnet-20250219
gpt_default_model: gpt-4o
gemini_available_models:
  - gemini-2.5-pro-preview-03-25
  - gemini-2.5-flash-preview-04-17
claude_available_models:
  - claude-3-7-sonnet-20250219
gpt_available_models:
  - gpt-4o
  - gpt-4-turbo
  - gpt-3.5-turbo
anthropic_api_key: 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
gemini_api_key: AIzaSyC5uUtef7uQnLiP2ioBM7OqIF9EaxAnGQE
gemini_temperature: 0.0
gemini_enable_thinking: false
gemini_thinking_budget: 0
gemini_enable_search: false



File Tree:
 ğŸ“ duck-prompt/
   ğŸ“ ./
   ğŸ“ docs/
     ğŸ“ ë¦¬íŒ©í† ë§/
       ğŸ“„ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œ ê°œì„ _ìºì‹± ë° watchdog ì‚¬ìš©.md (5,600 bytes)
   ğŸ“ src/
     ğŸ“ core/
       ğŸ“ pydantic_models/
         ğŸ“„ __init__.py (76 bytes)
         ğŸ“„ app_state.py (1,319 bytes)
         ğŸ“„ config_settings.py (3,409 bytes)
       ğŸ“ services/
         ğŸ“„ __init__.py (884 bytes)
         ğŸ“„ config_service.py (11,753 bytes)
         ğŸ“„ db_service.py (32,083 bytes)
         ğŸ“„ filesystem_service.py (6,069 bytes)
         ğŸ“„ gemini_service.py (30,577 bytes)
         ğŸ“„ prompt_service.py (3,956 bytes)
         ğŸ“„ state_service.py (7,779 bytes)
         ğŸ“„ template_service.py (3,394 bytes)
         ğŸ“„ token_service.py (12,573 bytes)
         ğŸ“„ xml_service.py (12,145 bytes)
       ğŸ“ utils/
       ğŸ“ workers/
       ğŸ“„ __init__.py (65 bytes)
       ğŸ“„ langgraph_state.py (860 bytes)
     ğŸ“ ui/
       ğŸ“ controllers/
         ğŸ“„ __init__.py (72 bytes)
         ğŸ“„ file_tree_controller.py (18,207 bytes)
         ğŸ“„ main_controller.py (24,125 bytes)
         ğŸ“„ prompt_controller.py (10,846 bytes)
         ğŸ“„ resource_controller.py (13,735 bytes)
         ğŸ“„ system_prompt_controller.py (7,322 bytes)
         ğŸ“„ xml_controller.py (2,883 bytes)
       ğŸ“ models/
         ğŸ“„ __init__.py (67 bytes)
         ğŸ“„ file_system_models.py (17,755 bytes)
       ğŸ“ widgets/
         ğŸ“„ __init__.py (68 bytes)
         ğŸ“„ check_box_delegate.py (3,714 bytes)
         ğŸ“„ custom_tab_bar.py (4,364 bytes)
         ğŸ“„ custom_text_edit.py (501 bytes)
         ğŸ“„ file_tree_view.py (2,439 bytes)
         ğŸ“„ tab_manager.py (613 bytes)
       ğŸ“„ __init__.py (63 bytes)
       ğŸ“„ main_window.py (58,142 bytes)
       ğŸ“„ main_window_setup_signals.py (8,717 bytes)
       ğŸ“„ main_window_setup_ui.py (24,067 bytes)
       ğŸ“„ settings_dialog.py (54,953 bytes)
     ğŸ“ utils/
       ğŸ“„ __init__.py (320 bytes)
       ğŸ“„ db_migration_script.py (5,742 bytes)
       ğŸ“„ helpers.py (2,152 bytes)
       ğŸ“„ notifications.py (2,983 bytes)
       ğŸ“„ postgres_db_initializer.py (20,529 bytes)
     ğŸ“„ __init__.py (64 bytes)
     ğŸ“„ app.py (5,313 bytes)
     ğŸ“„ config.yml (1,155 bytes)
   ğŸ“„ main.py (422 bytes)
   ğŸ“„ pyproject.toml (2,014 bytes)
   ğŸ“„ qt.conf (47 bytes)