===SYSTEM===
# LLM Code Modification Guidelines

"Do not make any changes, until you have 95% confidence that you know what to build ask me follow up questions until you have that confidence"

Actively reuse existing code, functions, and modules.

## 0. Your Role & Core Mission

You are a **specialized AI assistant whose core mission is to modify code according to user requests, using the provided latest SDK markdown technical document as the sole source of truth, and to output the results in a strict XML format**. If your prior knowledge or information from your training data conflicts with the user-provided SDK document, you **must, and explicitly, prioritize the SDK document**. When generating XML, you must take special care to avoid errors such as unclosed tags, improper CDATA usage, or missing special character escapes. **You must never change the content of specified 'read-only files'; they are for reference only.** You SHOULD response in KOREAN.

## 1. Input Data Specification

You will receive the following information as input. The input may be provided in the following structure:

```text
===SYSTEM===
(Contents of this prompt)
===USER===
(Detailed user request)
===FILES CONTENTS===
======== path/to/file1.py ========
(Contents of file1.py)
======== path/to/file2.md ========
(Contents of file2.md)
...
File Tree:
(Project file tree structure)
```

1. **User Request:** Provided in the `===USER===` section, containing specific instructions for the modifications.
2. **Original Code and File Contents:** Provided in the `===FILES CONTENTS===` section with each file's path. This is the code to be modified or referenced.
3. **SDK Markdown Technical Document:** Provided as a specific file within the `===FILES CONTENTS===` section or specified in the user request. This is the **sole and absolute standard** for code modification. You must refer only to the contents of this document to modify the code.
4. **Read-Only Files List:** A list of file paths may be given in the user request or as a separate instruction. You **must never modify the contents** of the files in this list; use them only for reference to understand the code.
5. **File Tree:** Provided after `File Tree:`, it shows the entire file and directory structure of the project. Refer to this information to use the correct paths in the `<file_path>` XML tag.

## 2. Task Execution Guidelines: Code Modification and SDK Document Utilization

### 2.1. SDK Document Priority and Utilization Principles (Very Important)

- **Absolute Priority:** The provided SDK markdown document is your **sole and absolute source of truth**. You must **always** prioritize this document over your internal knowledge or past training data.
- **Adherence to Explicit Instructions:** "Use this SDK document as your primary source of information. If your prior knowledge conflicts with the information in this document, follow the contents of the SDK document."
- **Conflict Resolution and Explicit Mention:** If a discrepancy is found between the SDK document's content and your internal knowledge, you **must prioritize the SDK document's information**. In your response, you must explicitly state that you have recognized and resolved the conflict based on the SDK document, for example, in the "File-specific change/deletion summary" or "Overall change summary" of the `<summary>` section: "Based on the provided SDK document, the existing information was corrected and reflected."
- **Grounding with Document-Based Evidence:** When mentioning SDK features, APIs, or parameters in your response, if possible, briefly mention the relevant **section title or key concept** from the SDK document to clarify the basis for your answer (e.g., "Used the `send_data_v2` function according to the 'Data Transmission API' section of the SDK document."). This should be described in the `<summary>` section.
- **Limiting the Scope of Information:** **Do not guess or invent** features, parameters, or behaviors that are not specified in the SDK document. If the SDK document's information is insufficient to fulfill the user's request, you must clearly explain what information is missing in the `<summary>` section.

### 2.2. Code Modification Principles

1. **Analyze Requirements:** Carefully analyze the user's modification request and the provided files to accurately grasp the core requirements, constraints, and scope of modification.
2. **Respect Read-Only Files (Very Important):**
    - **Guideline:** "If a 'Read-Only Files List' is provided as input, you **must never change or delete the contents of the files in that list.** These files are to be used **for reference only** to understand other parts of the code or their relationship with the files to be modified."
    - Even if the user request implies a change to a read-only file, do not modify it. Instead, explain why it cannot be modified (it is designated as a read-only file) in the `<summary>` section.
3. **Formulate an SDK-Based Solution Strategy:**
    - Identify which APIs, functions, classes, parameters, etc., from the SDK document should be used to satisfy the user's request.
    - Follow the **latest recommended practices** presented in the SDK document. Avoid using deprecated features or outdated patterns.
4. **Step-by-Step Plan (Internal Thought Process):** For complex modifications, internally create and execute a step-by-step plan like the following:
    - **Step 1 (Analyze SDK Information):** Accurately extract the necessary SDK information for the modification from the document (e.g., new parameters for a function, a new required call order).
    - **Step 2 (Design Code Changes):** Based on the extracted SDK information, design specifically how to change which parts **among the modifiable files**.
    - **Step 3 (Execute Code Modification):** Modify the code according to the design. **Do not touch the read-only files.**
5. **Implementation Guidelines:**
    - **Accuracy:** Accurately implement API usage, parameter order and types, return value handling, etc., as specified in the SDK document.
    - **Readability and Maintainability:** The modified code should be clear, easy to understand, and maintain a consistent coding style.
    - **Efficiency:** If there are unnecessary computations or inefficient logic, improve it using the efficient methods recommended in the SDK document.
    - **Error Handling:** Write robust code by referring to the exception situations or error code handling methods specified in the SDK document.
6. **Self-Verification:** Internally review whether the modified code satisfies both the SDK document's specifications and the user's request, and is expected to operate correctly for general inputs and edge cases.

## 3. Task Execution Guidelines: XML Generation and General Error Prevention (Very Important)

All of your final output must follow the XML structure and rules specified in "4. Final Output XML Format" below.

### 3.1. General XML Error Prevention Strategy (Mandatory Compliance)

- **Correct Tag Closing:**
  - **Guideline:** "Crucially, ensure that all XML tags are properly closed (e.g., `<tag>...</tag>` or `<tag/>` for empty elements). Pay close attention to the nesting structure to ensure all inner and outer tags are balanced."
  - **Verification:** You must verify that all tags in the generated XML are correctly opened and closed, and that the nesting relationship is correct.
- **Correct CDATA Section Usage:**
  - **Guideline:** "When including **long text blocks** containing special characters ('<', '>', '&', etc.) that could be interpreted by an XML parser, such as code snippets (`<file_code>`) or scripts, use a CDATA section to prevent parsing errors. Example: `<file_code><![CDATA[if (x < 10 && y > 5) { ... }]]></file_code>`. **However, use CDATA only when absolutely necessary**; do not use it for simple text."
  - **Verification:** The code inside `<file_code>` must always be wrapped in CDATA. For other text blocks, check if code blocks or text with many special characters are wrapped in CDATA, and conversely, if CDATA is not used unnecessarily for simple text.
- **Accurate Special Character Escaping:**
  - **Guideline:** "All special XML characters in text content **outside** of a CDATA section (e.g., text inside `<file_summary>`, `<summary>`) and within attribute values must be correctly escaped: `&` becomes `&amp;`, `<` becomes `&lt;`, `>` becomes `&gt;`, `"` becomes `&quot;`, and `'` becomes `&apos;`. Example: `<file_summary>This is a &quot;test&quot; &amp; an example. Details &lt;here&gt;.</file_summary>`."
  - **Verification:** Check that the special characters listed above are correctly escaped in all text and attribute values outside of CDATA.

### 3.2. XML Self-Correction and Improvement Loop (Mandatory Execution)

After generating a draft of the XML, you **must perform the following self-correction steps** to submit the final XML:

1. **Step 1: Initial XML Generation:** Based on the user request and SDK document, generate a draft XML including code modifications and descriptions. (See "4. Final Output XML Format" below)
2. **Step 2: XML Self-Review and Error Identification (Apply Error-Inducing Prompts):**
    - "Meticulously review the XML you just generated against the following criteria:
        1. **Tag Closing Errors:** Are all tags closed correctly? Is the nesting correct?
        2. **CDATA Usage Errors:** Is the content of `<file_code>` wrapped in CDATA? Is CDATA unnecessarily used or missing in other text?
        3. **Special Character Escaping Errors:** Are `&, <, >, ", '` correctly escaped in text/attributes outside of CDATA?
        4. **Schema/Structure Compliance:** Does it accurately follow the structure specified in "4. Final Output XML Format" (especially the order and content of `<code_changes>` followed by `<summary>`)?
        5. **Exclusion of Read-Only Files:** Are read-only files excluded from `<changed_files>`?
        6. **Exclusion of Unmodified Files:** Are files with no content changes excluded from `<changed_files>`?
        7. **File Path Accuracy:** Does the `<file_path>` exactly match the path provided in the input `File Tree`?
    - **Internally list** all identified errors, their locations, and the corrections needed.
3. **Step 3: XML Correction and Finalization:**
    - Correct all errors identified in Step 2 to generate a **completely valid and accurate XML**.
    - If there were any additional "thoughts" or "reflections" on SDK interpretation or code logic during the correction process, you may briefly include them in the `<summary>` section.

## 4. Final Output XML Format

**Remember: The response must have the XML section followed by the Summary section. The Summary must be concise and under 1000 tokens.**

1. **Response Structure**: **XML Section + Summary Section** (The summary must be located at the very end)

    - **XML Section**: Use `<code_changes>` as the root tag. Information about changed files is described within `<file>` elements inside `<changed_files>`.
    - **Summary Section**: Provide an overall summary of changes, a file-by-file summary of changes/deletions (including reasons), and a summary in Git commit message format (using prefixes like feat, fix, docs, etc., **written in Korean**, **under 1000 tokens**).

2. **Detailed XML Format**:

    - Inside the `<file>` element: Include `<file_summary>`, `<file_operation>` (CREATE, UPDATE, DELETE), `<file_path>`, and `<file_code>` (use a CDATA section; omit for DELETE).
    - **Do not include unmodified files in the XML.**
    - **Do not include files designated as read-only in the XML.** (If the user request intended to change a read-only file, explain why in the `<summary>`.)
    - **File paths must exactly match the paths specified in the 'File Tree' section of the input.** (e.g., `main.py`, `src/sub_project_name/main.py`, `src/sub_project_name/config.yml`, `src/utils/log_manager.py`, `docs/PRD/feature_x.md`, `docker/Dockerfile`)

3. **XML Syntax Check**: **After generating the final response, always double-check that the XML syntax is correct.** (e.g., tag closing, CDATA section format, reserved character escaping, etc.)

**Example XML Snippet according to the requested guidelines:**
(Example update for root `main.py`: reflecting usage of `log_manager`, `config`)

```xml
<code_changes>
    <changed_files>
        <file>
            <file_summary>Project root execution script: Uses common logging and config loader, runs FastAPI app</file_summary>
            <file_operation>UPDATE</file_operation> {/* or CREATE */}
            <file_path>main.py</file_path>
            <file_code><![CDATA[
import uvicorn
import os
import logging
from termcolor import colored

# Import project common utilities
from src.utils.log_manager import setup_logging, get_logger
from src.utils.config import load_config

# Import sub-project app (change according to the app to run)
from src.sub_project_name.main import app

if __name__ == "__main__":
    # Setup logging (using log_manager)
    setup_logging()
    logger = get_logger(__name__)
    logger.info(colored("Starting application from root main.py...", "yellow"))

    # Load configuration (Example: loading sub_project_name config)
    sub_project_name = "sub_project_name" # Specify target sub-project
    try:
        app_config = load_config(sub_project_name)
        logger.info(f"Configuration for '{sub_project_name}' loaded.")
        # Loaded config can be injected into the app or used for other initializations
        # Example: app.state.config = app_config
    except FileNotFoundError:
        logger.warning(f"Configuration file for '{sub_project_name}' not found. Proceeding with defaults or environment variables if applicable.")
    except Exception as e:
        logger.critical(f"Failed to load configuration for '{sub_project_name}': {e}", exc_info=True)
        exit(1) # Exit if config loading fails

    # Run FastAPI (using Uvicorn)
    host = os.getenv("APP_HOST", "127.0.0.1")
    port = int(os.getenv("APP_PORT", "8000"))
    reload = os.getenv("APP_RELOAD", "true").lower() == "true"

    logger.info(f"Starting Uvicorn server on {host}:{port} with reload={reload}")
    try:
        # Specify the path to the app to run as a string
        uvicorn.run(f"src.{sub_project_name}.main:app", host=host, port=port, reload=reload)
    except Exception as e:
        logger.critical(f"Failed to start Uvicorn: {e}", exc_info=True)

]]></file_code>
        </file>
        <file>
            <file_summary>Added common logging manager module</file_summary>
            <file_operation>CREATE</file_operation>
            <file_path>src/utils/log_manager.py</file_path>
            <file_code><![CDATA[
import logging
import logging.handlers
import os
import datetime

LOG_DIR = "logs"
LOG_LEVEL = logging.INFO # Default log level

def setup_logging():
    """Initializes project-wide logging configuration."""
    os.makedirs(LOG_DIR, exist_ok=True)
    log_filename = os.path.join(LOG_DIR, f"app_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log")

    # Default formatter
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )

    # Root logger configuration
    root_logger = logging.getLogger()
    root_logger.setLevel(LOG_LEVEL)

    # Remove existing handlers (prevent duplication)
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # File handler configuration (specify UTF-8 encoding)
    file_handler = logging.FileHandler(log_filename, encoding='utf-8')
    file_handler.setFormatter(formatter)
    root_logger.addHandler(file_handler)

    # Console handler configuration
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    root_logger.addHandler(stream_handler)

    logging.getLogger("uvicorn.access").setLevel(logging.WARNING) # Adjust uvicorn log level (optional)
    logging.getLogger("uvicorn.error").setLevel(logging.WARNING)

    root_logger.info("Logging setup complete.")

def get_logger(name: str) -> logging.Logger:
    """Returns a logger instance with the specified name."""
    return logging.getLogger(name)

# Additional logging helper functions can be defined here if needed
]]></file_code>
        </file>
        <file>
            <file_summary>Added common configuration loader utility</file_summary>
            <file_operation>CREATE</file_operation>
            <file_path>src/utils/config.py</file_path>
            <file_code><![CDATA[
import yaml
import os
from typing import Dict, Any

CONFIG_DIR_TEMPLATE = "src/{sub_project_name}/config.yml"

def load_config(sub_project_name: str) -> Dict[str, Any]:
    """
    Loads the config.yml file for the specified sub-project.

    Args:
        sub_project_name: The name of the sub-project to load config for (e.g., 'my_feature').

    Returns:
        A dictionary containing the configuration content.

    Raises:
        FileNotFoundError: If the configuration file does not exist.
        yaml.YAMLError: If an error occurs during YAML parsing.
        Exception: For other file reading errors.
    """
    config_path = CONFIG_DIR_TEMPLATE.format(sub_project_name=sub_project_name)

    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Configuration file not found at: {config_path}")

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        if config is None: # Handle empty file
            return {}
        return config
    except yaml.YAMLError as e:
        # Log more specific info on YAML format error if needed
        raise yaml.YAMLError(f"Error parsing YAML file {config_path}: {e}")
    except Exception as e:
        raise Exception(f"Error reading configuration file {config_path}: {e}")

# Logic for environment variable overrides or default value handling can be added here if needed
]]></file_code>
        </file>
         <file>
             <file_summary>Created sub-project configuration file</file_summary>
             <file_operation>CREATE</file_operation>
             <file_path>src/sub_project_name/config.yml</file_path>
             <file_code><![CDATA[
# src/sub_project_name/config.yml Example
api_settings:
  service_a:
    api_key: "your_api_key_here"
    base_url: "https://api.service_a.com/v1"
    timeout: 10
database:
  type: "sqlite"
  path: "data/sub_project.db"
app_parameters:
  max_items: 100
]]></file_code>
         </file>
        {/* Other file changes */}
    </changed_files>
</code_changes>

{/* --- Summary Section Start (Positioned after the XML section) --- */}
<summary>
**Overall Change Summary:**
The project structure and management practices have been updated to align with the new guidelines. Key changes include reorganizing the utilities folder structure, introducing common logging and configuration management modules, and changing the location of per-sub-project configuration files. The root `main.py` has been updated to use these common modules for handling logging and configuration, and to run the Uvicorn server.

**File-specific Change/Deletion Summary:**
- `main.py` (UPDATE): Modified to use the common logging (`log_manager`) and configuration loader (`config`) utilities, and updated the FastAPI app execution logic.
- `src/utils/log_manager.py` (CREATE): Added a common module to manage project-wide logging. Includes file/console handlers and default formatting settings.
- `src/utils/config.py` (CREATE): Added a common utility function to load `config.yml` files for each sub-project.
- `src/sub_project_name/config.yml` (CREATE): Created a configuration file for the example sub-project.

**Git Commit Message:**
feat: Refactor project structure and common utilities (logging, config)

(Token count: approx. 200)
</summary>
```

## 5. Important Constraints and Cautions

- **Absolute Prohibition on Using Information Outside the SDK Document:** To reiterate, the provided SDK document is your only source of information.
- **Absolute Protection of Read-Only Files:** Under no circumstances should the specified read-only files be modified.
- **Ensuring XML Validity:** The final output XML must be well-formed, and you must strictly follow all XML error prevention strategies. The order of the `<code_changes>` block followed by the `<summary>` block must be maintained.
- **Concise and Clear Responses:** Keep explanations concise and to the point. In particular, the `<summary>` section must adhere to the 1000-token limit.
- **Utilize "Thinking" Ability:** When dealing with complex SDK interpretations or planning the XML structure, use an internal step-by-step reasoning ("Thinking" process) to enhance accuracy.
- **Acknowledge the Strategic Placement of Instructions:** Be aware that the instructions in this prompt are structured to account for your attention mechanisms and recency bias. Follow all guidelines carefully.


===USER===
현재 코드는 코드 강화, 메타 프롬프트 생성 두가지 모드가 있는데, 메타 프롬프트 생성 모드 내용 모두 제거하고 코드 강화 빌더 모드만 남겨줘. 그리고 메뉴에서 "모드"는 제거해주고.

===FILES CONTENTS===

======== src\core\pydantic_models\__init__.py ========
# This file makes Python treat the directory pydantic_models as a package.



======== src\core\pydantic_models\app_state.py ========

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any # Dict, Any 추가

class AppState(BaseModel):
    """
    Represents the application state.
    저장/로드 시 특정 필드만 사용될 수 있음 (예: 이전 작업 불러오기).
    """
    # --- 이전 작업 저장/로드 대상 필드 ---
    project_folder: Optional[str] = None # 프로젝트 폴더 경로
    checked_files: List[str] = Field(default_factory=list) # 체크된 파일/폴더 경로 목록
    user_prompt: str = "" # 사용자 탭 내용
    attached_items: List[Dict[str, Any]] = Field(default_factory=list) # 첨부 파일/이미지 메타데이터 목록

    # --- 기타 상태 필드 (전체 상태 저장/로드 시 사용) ---
    mode: str = "Code Enhancer Prompt Builder"
    system_prompt: str = "" # 시스템 탭 내용 (기본값 로드 로직 있음)
    selected_llm: str = "Gemini" # 선택된 LLM
    selected_model_name: str = "" # 선택된 모델명

    # Gemini 파라미터는 config.yml에서 관리하므로 AppState에서 제거
    # gemini_temperature: float = 0.0
    # gemini_enable_thinking: bool = True
    # gemini_thinking_budget: int = 24576
    # gemini_enable_search: bool = True

    class Config:
        validate_assignment = True




======== src\core\pydantic_models\config_settings.py ========

from pydantic import BaseModel, Field, field_validator, FieldValidationInfo
from typing import List, Set, Any, Optional, Dict

class ConfigSettings(BaseModel):
    """
    Represents the application configuration settings loaded from the database.
    """
    # --- Fields loaded from application_config table ---
    profile_name: str = 'default' # Included for completeness, usually 'default'
    default_system_prompt: Optional[str] = None
    allowed_extensions: Set[str] = Field(default_factory=set)
    excluded_dirs: Set[str] = Field(default_factory=set)
    default_ignore_list: List[str] = Field(default_factory=list)
    gemini_default_model: str = "gemini-1.5-pro-latest" # Default if DB is missing
    claude_default_model: str = "claude-3-sonnet-20240229"
    gpt_default_model: str = "gpt-4o"
    gemini_available_models: List[str] = Field(default_factory=list)
    claude_available_models: List[str] = Field(default_factory=list)
    gpt_available_models: List[str] = Field(default_factory=list)
    gemini_temperature: float = Field(0.0, ge=0.0, le=2.0)
    gemini_enable_thinking: bool = Field(True)
    gemini_thinking_budget: int = Field(24576, ge=0)
    gemini_enable_search: bool = Field(True)
    # created_at, updated_at are in DB but not needed in the model for app logic

    # --- Fields loaded separately from api_keys table ---
    gemini_api_key: Optional[str] = None
    anthropic_api_key: Optional[str] = None
    # openai_api_key: Optional[str] = None # If needed

    @field_validator('allowed_extensions', 'excluded_dirs', mode='before')
    @classmethod
    def ensure_set_from_list_or_none(cls, v: Any, info: FieldValidationInfo):
        """Converts list (from DB array) or None to a set of strings."""
        if v is None:
            return set()
        if isinstance(v, (list, tuple, set)):
            # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return set(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        # Allow comma or space separated string as fallback (though DB should provide list)
        if isinstance(v, str):
             items = {item.strip() for item in v.replace(',', ' ').split() if item.strip()}
             return items
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    @field_validator('default_ignore_list', 'gemini_available_models', 'claude_available_models', 'gpt_available_models', mode='before')
    @classmethod
    def ensure_list_from_list_or_none(cls, v: Any, info: FieldValidationInfo):
        """Ensures the value is a list of strings, accepting None."""
        if v is None:
            return []
        if isinstance(v, (list, tuple, set)):
             # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return list(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    class Config:
        validate_assignment = True
        # If loading directly from DB dict, extra fields might exist (id, created_at etc.)
        extra = 'ignore' # Ignore extra fields from DB query result




======== src\core\services\__init__.py ========
# This file makes Python treat the directory services as a package.
# It can also be used to expose specific classes or functions.

from .config_service import ConfigService
from .db_service import DbService # Added
from .filesystem_service import FilesystemService
from .prompt_service import PromptService
from .state_service import StateService
from .template_service import TemplateService
from .token_service import TokenCalculationService
from .xml_service import XmlService
from .directory_cache_service import DirectoryCacheService # Added
# from .gemini_service import build_gemini_graph # 함수 직접 임포트 대신 모듈 사용

__all__ = [
    "ConfigService",
    "DbService", # Added
    "DirectoryCacheService", # Added
    "FilesystemService",
    "PromptService",
    "StateService",
    "TemplateService",
    "TokenCalculationService",
    "XmlService",
    # "build_gemini_graph", # 함수 직접 노출 대신 서비스 모듈 사용
]




======== src\core\services\config_service.py ========
import os
import logging
import random # 랜덤 선택을 위해 추가
from pydantic import ValidationError
from typing import Optional, List, Set, Dict, Any # Set, Dict, Any 추가

from core.pydantic_models.config_settings import ConfigSettings
from .db_service import DbService # DbService import

logger = logging.getLogger(__name__)

class ConfigService:
    def __init__(self, db_service: DbService, profile_name: str = 'default'):
        """
        Initializes ConfigService using a DbService instance.

        Args:
            db_service: An instance of DbService to interact with the database.
            profile_name: The configuration profile to load (default: 'default').
        """
        self.db_service = db_service
        self.profile_name = profile_name
        self._settings: ConfigSettings = self._load_config()
        self._user_selected_gemini_key_id: Optional[int] = None # 사용자가 명시적으로 선택한 키 ID (메모리 관리)
        self._last_used_gemini_key: Optional[str] = None # 마지막으로 성공적으로 사용된 키 문자열 (메모리 관리)

    def _load_config(self) -> ConfigSettings:
        """
        Loads configuration from the database.
        Initial active Gemini key is NOT selected here. Selection happens in gemini_service.
        """
        logger.info(f"Loading configuration from database for profile '{self.profile_name}'...")
        try:
            # 1. Fetch application config from DB
            config_data = self.db_service.get_application_config(self.profile_name)

            if not config_data:
                logger.critical(f"Failed to load configuration from database for profile '{self.profile_name}'. Application cannot proceed.")
                raise ValueError(f"Configuration profile '{self.profile_name}' not found in database.")

            # --- 로깅 추가: DB에서 로드된 설정 데이터 확인 ---
            logger.info(f"Raw config data loaded from DB for profile '{self.profile_name}':")
            # 중요 설정값만 로깅 (API 키 제외)
            logged_data = {k: v for k, v in config_data.items() if 'api_key' not in k}
            logger.info(f"{logged_data}")
            # ---------------------------------------------

            # 2. Fetch *active* API keys from DB (just to check availability, not select)
            # This check is mainly for logging warnings if no keys are available initially.
            active_gemini_keys = self.db_service.get_active_api_keys('google')
            active_anthropic_keys = self.db_service.get_active_api_keys('anthropic')

            # --- Initial Gemini Key Selection REMOVED ---
            if not active_gemini_keys:
                logger.warning("No active Gemini API key found in DB. API calls will likely fail until a key is added/activated.")
            else:
                logger.info(f"Found {len(active_gemini_keys)} active Gemini keys. Key selection will occur during API call.")

            # Use the first active Anthropic key if available
            anthropic_key = active_anthropic_keys[0]['api_key'] if active_anthropic_keys else None
            if not anthropic_key: logger.warning("No active Anthropic API key found in DB.")

            # 3. Add the API keys (set to None initially) to the config data dictionary
            config_data['gemini_api_key'] = None # Placeholder, always None initially
            config_data['anthropic_api_key'] = anthropic_key

            # 4. Validate and create ConfigSettings model
            settings = ConfigSettings(**config_data)
            logger.info(f"Configuration loaded successfully from database for profile '{self.profile_name}'.")
            # --- 로깅 추가: Pydantic 모델 생성 후 설정 값 확인 ---
            logger.info("Validated ConfigSettings object created:")
            logger.info(f"  gemini_temperature: {settings.gemini_temperature}")
            # ... other relevant settings ...
            logger.info(f"  Initial gemini_api_key in settings object: {settings.gemini_api_key}") # Should log None
            # -------------------------------------------------
            return settings

        except ValidationError as e:
            logger.critical(f"Database configuration validation error: {e}. Using default settings (or failing).", exc_info=True)
            raise ValueError(f"Configuration validation failed: {e}")
        except Exception as e:
            logger.critical(f"Unexpected error loading config from database: {e}", exc_info=True)
            raise ValueError(f"Failed to load configuration from database: {e}")

    def update_settings(self, updated_settings: ConfigSettings) -> bool:
        """
        Updates the application configuration in the database and in memory.
        API keys are NOT saved via this method. User-selected key preference is not saved to DB.

        Args:
            updated_settings: A ConfigSettings object with the updated values.

        Returns:
            True if the update was successful, False otherwise.
        """
        logger.info(f"Attempting to update configuration in database for profile '{self.profile_name}'...")
        try:
            # Convert Pydantic model to dictionary for DB service
            # Exclude API keys as they are managed separately
            config_dict_to_save = updated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})

            # --- 로깅 추가: DB에 저장될 설정 데이터 확인 ---
            logger.info(f"Data being saved to DB for profile '{self.profile_name}':")
            logger.info(f"{config_dict_to_save}")
            # ---------------------------------------------

            # Call DbService to save the configuration (excluding API keys)
            success = self.db_service.save_application_config(self.profile_name, config_dict_to_save)

            if success:
                # Update in-memory settings only if DB save was successful
                # Keep the currently loaded API keys AND the user selection in the in-memory object
                current_anthropic_key = self._settings.anthropic_api_key # Keep potentially updated Anthropic key
                # Create a fresh copy from the validated input, then restore keys/selection
                self._settings = updated_settings.model_copy(deep=True)
                self._settings.gemini_api_key = self._last_used_gemini_key # Restore last used key string
                self._settings.anthropic_api_key = current_anthropic_key
                # User selection (_user_selected_gemini_key_id) remains as it is in memory.
                logger.info(f"Configuration updated successfully in database and memory for profile '{self.profile_name}'.")
                return True
            else:
                logger.error(f"Failed to save configuration update to database for profile '{self.profile_name}'.")
                return False

        except ValidationError as e:
            logger.error(f"Configuration update validation error: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Unexpected error updating configuration: {e}", exc_info=True)
            return False

    def get_settings(self) -> ConfigSettings:
        """Returns the current configuration settings."""
        if not self._settings:
             logger.error("Configuration settings are not loaded.")
             self._settings = self._load_config() # Attempt to reload
        return self._settings

    def get_default_model_name(self, llm_type: str) -> str:
        """Gets the default model name for a given LLM type from settings."""
        settings = self.get_settings()
        if llm_type == "Gemini": return settings.gemini_default_model
        elif llm_type == "Claude": return settings.claude_default_model
        elif llm_type == "GPT": return settings.gpt_default_model
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for default model."); return ""

    def get_available_models(self, llm_type: str) -> List[str]:
        """Gets the list of available model names for a given LLM type from settings."""
        settings = self.get_settings()
        models = []
        if llm_type == "Gemini": models = settings.gemini_available_models
        elif llm_type == "Claude": models = settings.claude_available_models
        elif llm_type == "GPT": models = settings.gpt_available_models
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for available models.")
        return models if models is not None else []

    # --- User Selected Key Management ---
    def set_user_selected_gemini_key(self, key_id: Optional[int]):
        """Sets the user's preferred Gemini API key ID (managed in memory)."""
        if self._user_selected_gemini_key_id != key_id:
            logger.info(f"Setting user-selected Gemini Key ID to: {key_id}")
            self._user_selected_gemini_key_id = key_id
            # Optionally clear the last used key if a new preference is set? No, keep last used.
        else:
             logger.debug(f"User selected Gemini key ID is already {key_id}.")

    def get_user_selected_gemini_key_id(self) -> Optional[int]:
        """Gets the user's preferred Gemini API key ID."""
        return self._user_selected_gemini_key_id

    # --- Last Used Key Management ---
    def update_last_used_gemini_key(self, key_string: str):
        """
        Updates the last successfully used Gemini API key string in memory
        and updates the placeholder in the settings object.
        Called by gemini_service after a successful API call.
        """
        if self._last_used_gemini_key != key_string:
            logger.info(f"Updating last successfully used Gemini API key string.")
            self._last_used_gemini_key = key_string
            if self._settings:
                # Update the placeholder in the settings object for consistency/display if needed
                self._settings.gemini_api_key = key_string
        else:
            logger.debug("Attempted to update last used Gemini key, but it's the same.")

    def get_last_used_gemini_key_id(self) -> Optional[int]:
        """Gets the database ID of the last successfully used Gemini API key."""
        if self._last_used_gemini_key:
            try:
                # Fetch the ID from the database using the key string
                key_id = self.db_service.get_api_key_id(self._last_used_gemini_key)
                logger.debug(f"Retrieved ID for last used Gemini key: {key_id}")
                return key_id
            except Exception as e:
                logger.error(f"Error getting ID for last used Gemini key '{self._last_used_gemini_key[:4]}...': {e}")
                return None
        else:
            # Log if no key has been successfully used yet
            logger.debug("Cannot get last used Gemini key ID: No key has been successfully used yet.")
            return None

    # Renamed for clarity (was get_current_gemini_key_id)
    # def get_current_gemini_key_id(self) -> Optional[int]:
    #     """Gets the database ID of the currently configured Gemini API key."""
    #     # ... (old logic based on settings.gemini_api_key) ...
    #     # Now replaced by get_last_used_gemini_key_id and get_user_selected_gemini_key_id

    # Renamed for clarity (was update_current_gemini_key)
    # def update_current_gemini_key(self, new_key: str):
    #      # Now replaced by update_last_used_gemini_key



======== src\core\services\db_service.py ========

import psycopg2
import logging
from typing import Optional, Dict, Any, List, Tuple
import json
import datetime
from decimal import Decimal

logger = logging.getLogger(__name__)

# 데이터베이스 접속 정보 (요청에 따라 하드코딩)
DB_CONFIG = {
    "host": "postgresdb.lab.miraker.me",
    "user": "shacea",
    "password": "alfkzj9389",
    "port": 5333,
    "database": "duck_agent"
}

class DbService:
    """Handles database connection and queries for application configuration and logging."""

    def __init__(self, db_config: Dict[str, Any] = DB_CONFIG):
        self.db_config = db_config
        self.connection = None
        self.connect()

    def connect(self):
        """Establishes a connection to the PostgreSQL database."""
        if self.connection and not self.connection.closed:
            return # Already connected

        try:
            logger.info(f"Connecting to database '{self.db_config['database']}' on {self.db_config['host']}...")
            self.connection = psycopg2.connect(**self.db_config)
            logger.info("Database connection successful.")
        except psycopg2.Error as e:
            logger.critical(f"Database connection failed: {e}", exc_info=True)
            self.connection = None
            raise ConnectionError(f"Failed to connect to the database: {e}")

    def disconnect(self):
        """Closes the database connection."""
        if self.connection and not self.connection.closed:
            self.connection.close()
            logger.info("Database connection closed.")
        self.connection = None

    def _execute_query(self, query: str, params: Optional[tuple] = None, fetch_one: bool = False, fetch_all: bool = False, return_id: bool = False) -> Optional[Any]:
        """Executes a SQL query and returns the result."""
        if not self.connection or self.connection.closed:
            logger.error("Cannot execute query: Database connection is not active.")
            logger.info("Attempting to reconnect to the database...")
            self.connect()
            if not self.connection or self.connection.closed:
                 raise ConnectionError("Database connection lost and could not be re-established.")

        cursor = None
        try:
            cursor = self.connection.cursor()
            logger.debug(f"Executing query: {query} with params: {params}")
            cursor.execute(query, params)

            if return_id:
                result = cursor.fetchone()
                self.connection.commit()
                logger.debug(f"Query returned ID: {result[0] if result else None}")
                return result[0] if result else None
            elif fetch_one:
                result = cursor.fetchone()
                if result and cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    row_dict = dict(zip(colnames, result))
                    logger.debug(f"Query fetched one row: {row_dict}")
                    return row_dict
                elif result:
                    logger.debug(f"Query fetched one value: {result[0]}")
                    return result[0]
                else:
                    logger.debug("Query fetched no results (fetch_one).")
                    return None
            elif fetch_all:
                if cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    rows = cursor.fetchall()
                    results_list = [dict(zip(colnames, row)) for row in rows]
                    logger.debug(f"Query fetched {len(results_list)} rows.")
                    return results_list
                else:
                    logger.debug("Query fetched no results (fetch_all).")
                    return []
            else:
                affected_rows = cursor.rowcount
                self.connection.commit()
                logger.debug(f"Query executed successfully. Rows affected: {affected_rows}")
                return affected_rows
        except psycopg2.Error as e:
            logger.error(f"Database query failed: {e}\nQuery: {query}\nParams: {params}", exc_info=True)
            if self.connection:
                self.connection.rollback()
            raise e
        finally:
            if cursor:
                cursor.close()

    def get_application_config(self, profile_name: str = 'default') -> Optional[Dict[str, Any]]:
        """Fetches application configuration for a given profile."""
        query = """
            SELECT * FROM application_config WHERE profile_name = %s;
        """
        try:
            result = self._execute_query(query, (profile_name,), fetch_one=True)
            if result and isinstance(result, dict):
                logger.info(f"Application config loaded for profile '{profile_name}'.")
                config_data = result
                if 'gemini_temperature' in config_data and isinstance(config_data['gemini_temperature'], Decimal):
                    config_data['gemini_temperature'] = float(config_data['gemini_temperature'])
                return config_data
            else:
                logger.error(f"Application config not found for profile '{profile_name}'.")
                return None
        except psycopg2.Error as e:
             logger.error(f"Failed to get application config for profile '{profile_name}': {e}")
             return None

    def save_application_config(self, profile_name: str, config_data: Dict[str, Any]) -> bool:
        """
        Inserts or updates the application configuration for a given profile.
        Handles data type conversions for DB compatibility. Excludes API keys.
        """
        logger.info(f"Attempting to save application configuration for profile '{profile_name}'...")

        allowed_extensions = list(config_data.get('allowed_extensions', []))
        excluded_dirs = list(config_data.get('excluded_dirs', []))
        default_ignore_list = list(config_data.get('default_ignore_list', []))
        gemini_available_models = list(config_data.get('gemini_available_models', []))
        claude_available_models = list(config_data.get('claude_available_models', []))
        gpt_available_models = list(config_data.get('gpt_available_models', []))

        gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
        gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

        try: gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
        except (ValueError, TypeError): gemini_temperature = 0.0
        try: gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
        except (ValueError, TypeError): gemini_thinking_budget = 24576

        sql = """
            INSERT INTO application_config (
                profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
                default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
                gemini_available_models, claude_available_models, gpt_available_models,
                gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (profile_name) DO UPDATE SET
                default_system_prompt = EXCLUDED.default_system_prompt,
                allowed_extensions = EXCLUDED.allowed_extensions,
                excluded_dirs = EXCLUDED.excluded_dirs,
                default_ignore_list = EXCLUDED.default_ignore_list,
                gemini_default_model = EXCLUDED.gemini_default_model,
                claude_default_model = EXCLUDED.claude_default_model,
                gpt_default_model = EXCLUDED.gpt_default_model,
                gemini_available_models = EXCLUDED.gemini_available_models,
                claude_available_models = EXCLUDED.claude_available_models,
                gpt_available_models = EXCLUDED.gpt_available_models,
                gemini_temperature = EXCLUDED.gemini_temperature,
                gemini_enable_thinking = EXCLUDED.gemini_enable_thinking,
                gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
                gemini_enable_search = EXCLUDED.gemini_enable_search,
                updated_at = NOW();
        """
        params = (
            profile_name, config_data.get('default_system_prompt'), allowed_extensions, excluded_dirs,
            default_ignore_list, config_data.get('gemini_default_model'), config_data.get('claude_default_model'),
            config_data.get('gpt_default_model'), gemini_available_models, claude_available_models,
            gpt_available_models, gemini_temperature, gemini_enable_thinking, gemini_thinking_budget,
            gemini_enable_search
        )

        try:
            affected_rows = self._execute_query(sql, params)
            logger.info(f"Application configuration for profile '{profile_name}' saved successfully. Rows affected: {affected_rows}")
            return True
        except psycopg2.Error as e:
            logger.error(f"Error saving application configuration for profile '{profile_name}': {e}")
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during config save for profile '{profile_name}': {e}")
            return False

    # --- API Key Management ---

    def get_active_api_key(self, provider: str) -> Optional[str]:
        """Fetches the first active API key string for a given provider."""
        keys = self.get_active_api_keys(provider)
        return keys[0]['api_key'] if keys else None

    def get_active_api_keys(self, provider: str) -> List[Dict[str, Any]]:
        """Fetches all active API keys for a given provider, ordered by ID."""
        # Removed usage columns from this query as they are fetched in get_active_api_keys_with_usage
        query = """
            SELECT id, api_key, description, is_active FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            result = self._execute_query(query, (provider,), fetch_all=True)
            if result:
                logger.info(f"Found {len(result)} active API key(s) for provider '{provider}'.")
                return result
            else:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []
        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys for provider '{provider}': {e}")
             return []

    def get_active_api_keys_with_usage(self, provider: str) -> List[Dict[str, Any]]:
        """
        Fetches all active API keys for a given provider along with their current daily usage,
        ordered by ID. Calculates effective daily usage considering the reset window.
        (Queries only api_keys table now)
        """
        query = """
            SELECT
                id, api_key, description, is_active,
                COALESCE(calls_this_day, 0) AS raw_calls_this_day,
                day_start_timestamp
            FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            results = self._execute_query(query, (provider,), fetch_all=True)
            if not results:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []

            logger.info(f"Found {len(results)} active API key(s) with usage info for provider '{provider}'.")
            now = datetime.datetime.now(datetime.timezone.utc)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

            # Calculate effective daily usage
            for key_info in results:
                raw_calls = key_info.get('raw_calls_this_day', 0)
                day_start = key_info.get('day_start_timestamp')

                if day_start and day_start.tzinfo is None:
                    day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                    key_info['day_start_timestamp'] = day_start

                if day_start and day_start < current_day_start:
                    key_info['calls_this_day'] = 0
                    logger.debug(f"Key ID {key_info['id']}: Day window reset. Effective calls_this_day = 0")
                else:
                    key_info['calls_this_day'] = raw_calls
                    logger.debug(f"Key ID {key_info['id']}: Within current day window. Effective calls_this_day = {raw_calls}")

            return results

        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys with usage for provider '{provider}': {e}")
             return []
        except Exception as e:
            logger.error(f"Unexpected error getting active API keys with usage for '{provider}': {e}", exc_info=True)
            return []


    def list_api_keys(self, provider: Optional[str] = None) -> List[Dict[str, Any]]:
        """Lists all API keys, optionally filtered by provider."""
        # Added usage columns to the SELECT statement
        select_columns = "id, api_key, provider, description, is_active, last_api_call_timestamp, calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp"
        if provider:
            query = f"SELECT {select_columns} FROM api_keys WHERE provider = %s ORDER BY provider, id;"
            params = (provider,)
        else:
            query = f"SELECT {select_columns} FROM api_keys ORDER BY provider, id;"
            params = None
        try:
            result = self._execute_query(query, params, fetch_all=True)
            logger.info(f"Listed {len(result)} API keys" + (f" for provider '{provider}'." if provider else "."))
            return result if result else []
        except psycopg2.Error as e:
            logger.error(f"Failed to list API keys: {e}")
            return []

    def add_api_key(self, provider: str, api_key: str, description: Optional[str] = None) -> Optional[int]:
        """Adds a new API key to the database."""
        if not provider or not api_key:
            logger.error("Cannot add API key: Provider and API key string are required.")
            return None
        # Added default values for usage columns on insert
        query = """
            INSERT INTO api_keys (provider, api_key, description, is_active,
                                  last_api_call_timestamp, calls_this_minute, minute_start_timestamp,
                                  calls_this_day, day_start_timestamp)
            VALUES (%s, %s, %s, %s, NULL, 0, NULL, 0, NULL)
            RETURNING id;
        """
        params = (provider, api_key, description, True)
        try:
            key_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new API key with ID: {key_id} for provider '{provider}'.")
            return key_id
        except psycopg2.IntegrityError as e:
             logger.error(f"Failed to add API key for '{provider}': Key likely already exists. {e}")
             return None
        except psycopg2.Error as e:
            logger.error(f"Failed to add API key for '{provider}': {e}")
            return None

    def update_api_key(self, key_id: int, description: Optional[str] = None, is_active: Optional[bool] = None) -> bool:
        """Updates the description or active status of an API key."""
        if description is None and is_active is None:
            logger.warning(f"No update provided for API key ID {key_id}.")
            return False

        set_clauses = []
        params = []
        if description is not None:
            set_clauses.append("description = %s")
            params.append(description)
        if is_active is not None:
            set_clauses.append("is_active = %s")
            params.append(is_active)

        query = f"""
            UPDATE api_keys
            SET {', '.join(set_clauses)}, updated_at = NOW()
            WHERE id = %s;
        """
        params.append(key_id)

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} updated successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found or no changes made.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to update API key ID {key_id}: {e}")
            return False

    def delete_api_key(self, key_id: int) -> bool:
        """Deletes an API key from the database."""
        # ON DELETE CASCADE in gemini_api_logs handles foreign key constraint
        query = "DELETE FROM api_keys WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (key_id,))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} deleted successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found for deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to delete API key ID {key_id}: {e}")
            return False

    def get_api_key_id(self, api_key_string: str) -> Optional[int]:
        """Fetches the ID of a given API key string."""
        if not api_key_string: return None
        query = "SELECT id FROM api_keys WHERE api_key = %s;"
        try:
            result_dict = self._execute_query(query, (api_key_string,), fetch_one=True)
            return result_dict['id'] if result_dict and 'id' in result_dict else None
        except psycopg2.Error as e:
            logger.error(f"Failed to get API key ID: {e}")
            return None

    # --- Gemini Log Management ---

    def log_gemini_request(self, model_name: str, request_prompt: str, request_attachments: Optional[List[Dict[str, Any]]], api_key_id: Optional[int]) -> Optional[int]:
        """Logs the initial Gemini API request details and returns the log ID."""
        query = """
            INSERT INTO gemini_api_logs (model_name, request_prompt, request_attachments, api_key_id, request_timestamp)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """
        attachments_json = None
        if request_attachments:
            metadata_attachments = [{k: v for k, v in att.items() if k != 'data'} for att in request_attachments]
            try: attachments_json = json.dumps(metadata_attachments)
            except TypeError as e:
                logger.error(f"Failed to serialize attachments to JSON: {e}")
                attachments_json = json.dumps([{"error": "Serialization failed"}])

        request_timestamp = datetime.datetime.now(datetime.timezone.utc)
        params = (model_name, request_prompt, attachments_json, api_key_id, request_timestamp)
        try:
            log_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Logged Gemini request with ID: {log_id}")
            return log_id
        except psycopg2.Error as e:
            logger.error(f"Failed to log Gemini request: {e}")
            return None

    def update_gemini_log(self, log_id: int, response_text: Optional[str] = None, response_xml: Optional[str] = None, response_summary: Optional[str] = None, error_message: Optional[str] = None, elapsed_time_ms: Optional[int] = None, token_count: Optional[int] = None):
        """Updates the Gemini API log record with response details. Only updates non-None fields."""
        if log_id is None:
            logger.error("Cannot update Gemini log: Invalid log_id provided.")
            return

        update_fields = []
        params = []

        if response_text is not None: update_fields.append("response_text = %s"); params.append(response_text)
        if response_xml is not None: update_fields.append("response_xml = %s"); params.append(response_xml)
        if response_summary is not None: update_fields.append("response_summary = %s"); params.append(response_summary)
        if error_message is not None: update_fields.append("error_message = %s"); params.append(error_message)
        if elapsed_time_ms is not None: update_fields.append("elapsed_time_ms = %s"); params.append(elapsed_time_ms)
        if token_count is not None: update_fields.append("token_count = %s"); params.append(token_count)

        if not update_fields:
            logger.info(f"No fields to update for Gemini log ID: {log_id}")
            return

        update_fields.append("response_timestamp = %s")
        params.append(datetime.datetime.now(datetime.timezone.utc))
        params.append(log_id)

        query = f"""
            UPDATE gemini_api_logs
            SET {', '.join(update_fields)}
            WHERE id = %s;
        """

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1: logger.info(f"Updated Gemini log record ID: {log_id}")
            else: logger.warning(f"Attempted to update Gemini log ID: {log_id}, but no rows were affected (or more than 1).")
        except psycopg2.Error as e:
            logger.error(f"Failed to update Gemini log ID {log_id}: {e}")

    def cleanup_old_gemini_logs(self, days_to_keep: int = 7):
        """Deletes Gemini API log records older than the specified number of days."""
        if days_to_keep <= 0:
            logger.warning("Log cleanup skipped: days_to_keep must be positive.")
            return

        cutoff_date = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=days_to_keep)
        query = "DELETE FROM gemini_api_logs WHERE request_timestamp < %s;"
        try:
            affected_rows = self._execute_query(query, (cutoff_date,))
            if affected_rows is not None and affected_rows > 0:
                logger.info(f"Cleaned up {affected_rows} old Gemini log records older than {cutoff_date.strftime('%Y-%m-%d')}.")
            else: logger.info("No old Gemini log records found to clean up.")
        except psycopg2.Error as e:
            logger.error(f"Failed to clean up old Gemini logs: {e}")

    # --- Rate Limit and Usage Tracking (Modified for api_keys table) ---

    def update_api_key_usage(self, api_key_id: int):
        """Updates the usage statistics for a given API key ID directly in the api_keys table."""
        if api_key_id is None:
            logger.warning("Cannot update API key usage: api_key_id is None.")
            return

        logger.info(f"Updating API key usage for key ID: {api_key_id}")
        now = datetime.datetime.now(datetime.timezone.utc)
        current_minute_start = now.replace(second=0, microsecond=0)
        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

        # --- SQL Query using UPDATE with CASE statements ---
        # This query updates the existing row in api_keys based on the api_key_id.
        # It correctly handles the logic for incrementing counts or resetting them
        # based on whether the current minute/day window has passed.
        query = """
            UPDATE api_keys SET
                last_api_call_timestamp = %(now)s,

                -- Update minute count and timestamp
                calls_this_minute = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN 1
                    ELSE calls_this_minute + 1
                END,
                minute_start_timestamp = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN %(minute_start)s
                    ELSE minute_start_timestamp
                END,

                -- Update day count and timestamp
                calls_this_day = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN 1
                    ELSE calls_this_day + 1
                END,
                day_start_timestamp = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN %(day_start)s
                    ELSE day_start_timestamp
                END,

                -- Always update the updated_at timestamp
                updated_at = NOW()
            WHERE id = %(key_id)s;
        """
        params = {
            'key_id': api_key_id,
            'now': now,
            'minute_start': current_minute_start,
            'day_start': current_day_start
        }

        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1:
                logger.info(f"API key usage updated successfully for key ID: {api_key_id}.")
            elif affected_rows == 0:
                 logger.warning(f"API key usage update failed for key ID {api_key_id}: Key not found.")
            else:
                 # Should not happen with WHERE id = ...
                 logger.error(f"Unexpected number of rows affected ({affected_rows}) during API key usage update for key ID {api_key_id}.")

        except psycopg2.Error as e:
            logger.error(f"Failed to update API key usage for key ID {api_key_id}: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"An unexpected error occurred during API key usage update for key ID {api_key_id}: {e}", exc_info=True)


    def get_model_rate_limit(self, model_name: str) -> Optional[Dict[str, Any]]:
        """Fetches the default rate limit information for a specific model."""
        query = "SELECT rpm_limit, daily_limit FROM model_rate_limits WHERE model_name = %s;"
        try:
            result = self._execute_query(query, (model_name,), fetch_one=True)
            if result:
                logger.info(f"Rate limit found for model '{model_name}': RPM={result.get('rpm_limit')}, Daily={result.get('daily_limit')}")
                return result
            else:
                logger.warning(f"No rate limit information found for model '{model_name}'.")
                return None
        except psycopg2.Error as e:
            logger.error(f"Failed to get rate limit for model '{model_name}': {e}")
            return None

    def get_api_key_usage(self, api_key_id: int) -> Optional[Dict[str, Any]]:
        """Fetches the current usage statistics for a specific API key ID from the api_keys table."""
        if api_key_id is None: return None
        query = """
            SELECT calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp
            FROM api_keys
            WHERE id = %s;
        """
        try:
            result = self._execute_query(query, (api_key_id,), fetch_one=True)
            if result:
                logger.info(f"Usage found for API key ID {api_key_id}.")
                # Ensure timestamps are timezone-aware if they aren't already
                if result.get('minute_start_timestamp') and result['minute_start_timestamp'].tzinfo is None:
                    result['minute_start_timestamp'] = result['minute_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                if result.get('day_start_timestamp') and result['day_start_timestamp'].tzinfo is None:
                    result['day_start_timestamp'] = result['day_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                return result
            else:
                logger.info(f"No usage record found for API key ID {api_key_id}. Assuming 0 usage.")
                # Return default zero usage if no record exists (or key doesn't exist)
                return {
                    'calls_this_minute': 0, 'minute_start_timestamp': None,
                    'calls_this_day': 0, 'day_start_timestamp': None
                }
        except psycopg2.Error as e:
            logger.error(f"Failed to get usage for API key ID {api_key_id}: {e}")
            return None

    def is_key_rate_limited(self, api_key_id: int, model_name: str) -> Tuple[bool, str]:
        """
        Checks if the API key is currently rate-limited for the given model.
        (Uses the modified get_api_key_usage)
        """
        if api_key_id is None:
            return True, "API Key ID is missing."

        try:
            # 1. Get model's default rate limits
            rate_limit_info = self.get_model_rate_limit(model_name)
            if not rate_limit_info:
                logger.warning(f"No rate limit info found for model '{model_name}'. Assuming not limited.")
                return False, "Rate limit info not found."
            rpm_limit = rate_limit_info.get('rpm_limit')
            daily_limit = rate_limit_info.get('daily_limit')

            # 2. Get current usage for the API key (from api_keys table now)
            usage_info = self.get_api_key_usage(api_key_id)
            # get_api_key_usage now returns default 0 if key not found or no usage
            # No need to check if usage_info is None here

            calls_this_minute = usage_info.get('calls_this_minute', 0)
            minute_start = usage_info.get('minute_start_timestamp')
            calls_this_day = usage_info.get('calls_this_day', 0)
            day_start = usage_info.get('day_start_timestamp')
            now = datetime.datetime.now(datetime.timezone.utc)
            current_minute_start = now.replace(second=0, microsecond=0)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)


            # 3. Check RPM limit
            if rpm_limit is not None and rpm_limit > 0:
                current_minute_call_count = calls_this_minute
                if minute_start and minute_start < current_minute_start:
                     current_minute_call_count = 0
                     logger.debug(f"RPM Check: Minute window reset for key {api_key_id}. Current count considered 0.")

                if current_minute_call_count >= rpm_limit:
                    reason = f"RPM limit ({rpm_limit}) reached or exceeded (current minute calls: {current_minute_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            # 4. Check Daily limit
            if daily_limit is not None and daily_limit > 0:
                current_day_call_count = calls_this_day
                if day_start and day_start < current_day_start:
                    current_day_call_count = 0
                    logger.debug(f"Daily Check: Day window reset for key {api_key_id}. Current count considered 0.")

                if current_day_call_count >= daily_limit:
                    reason = f"Daily limit ({daily_limit}) reached or exceeded (current day calls: {current_day_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            logger.debug(f"Rate limit check passed for key ID {api_key_id} and model '{model_name}'.")
            return False, "Rate limit OK."

        except Exception as e:
            logger.error(f"Error checking rate limit for key ID {api_key_id}: {e}", exc_info=True)
            return True, f"Error during rate limit check: {e}"


    def __del__(self):
        """Ensure disconnection when the service object is destroyed."""
        self.disconnect()




======== src\core\services\directory_cache_service.py ========
import os
import time
import logging
from typing import Optional, Dict, Any, Set, List, Callable
from pathlib import Path
import threading
from collections import deque

from PyQt6.QtCore import QObject, pyqtSignal, QThread
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent, DirModifiedEvent, FileModifiedEvent

from .filesystem_service import FilesystemService

logger = logging.getLogger(__name__)

# --- Data Structure for Cache ---
class CacheNode:
    """Represents a node in the directory cache."""
    def __init__(self, name: str, path: str, is_dir: bool, ignored: bool, children: Optional[Dict[str, 'CacheNode']] = None):
        self.name = name
        self.path = path
        self.is_dir = is_dir
        self.ignored = ignored
        self.children: Dict[str, 'CacheNode'] = children if children is not None else {} # {name: CacheNode}

    def to_dict(self) -> Dict[str, Any]:
        """Converts the node to a dictionary (for potential serialization)."""
        return {
            "name": self.name,
            "path": self.path,
            "is_dir": self.is_dir,
            "ignored": self.ignored,
            "children": {name: child.to_dict() for name, child in self.children.items()}
        }

# --- Background Scanner Worker ---
class ScannerWorker(QObject):
    """Worker object to perform directory scanning in a background thread."""
    finished = pyqtSignal(object) # Emits the root CacheNode when done
    progress = pyqtSignal(str)    # Emits status updates
    error = pyqtSignal(str)       # Emits error messages

    def __init__(self, root_path: str, fs_service: FilesystemService, ignore_patterns: Set[str]):
        super().__init__()
        self.root_path = root_path
        self.fs_service = fs_service
        self.ignore_patterns = ignore_patterns
        self._is_cancelled = False

    def cancel(self):
        self._is_cancelled = True

    def run(self):
        """Scans the directory structure starting from root_path."""
        logger.info(f"ScannerWorker started for path: {self.root_path}")
        try:
            root_node = self._scan_directory(self.root_path)
            if self._is_cancelled:
                logger.info("ScannerWorker cancelled.")
                self.error.emit("Scan cancelled.")
            else:
                logger.info(f"ScannerWorker finished successfully for {self.root_path}.")
                self.finished.emit(root_node)
        except Exception as e:
            logger.exception(f"Error during directory scan for {self.root_path}")
            self.error.emit(f"Scan error: {e}")

    def _scan_directory(self, dir_path: str) -> Optional[CacheNode]:
        """Recursively scans a directory and builds CacheNode structure."""
        if self._is_cancelled: return None

        try:
            path_obj = Path(dir_path)
            if not path_obj.exists() or not path_obj.is_dir():
                logger.warning(f"Directory not found or not a directory: {dir_path}")
                return None

            is_root_ignored = self.fs_service.should_ignore(dir_path, self.root_path, self.ignore_patterns, True)
            root_node = CacheNode(name=path_obj.name, path=dir_path, is_dir=True, ignored=is_root_ignored)

            # Use deque for breadth-first or depth-first scanning (here using deque like a stack for DFS)
            scan_queue = deque([(root_node, dir_path)])
            processed_dirs = 0

            while scan_queue:
                if self._is_cancelled: return None
                parent_node, current_dir = scan_queue.pop()

                # Skip scanning children if parent is ignored (optimization)
                if parent_node.ignored:
                    # logger.debug(f"Skipping ignored directory children: {current_dir}")
                    continue

                try:
                    # Use os.scandir for better performance
                    with os.scandir(current_dir) as it:
                        for entry in it:
                            if self._is_cancelled: return None
                            entry_path = entry.path
                            entry_name = entry.name
                            try:
                                is_dir = entry.is_dir()
                                # Check if ignored *before* adding to cache/queue
                                is_ignored = self.fs_service.should_ignore(entry_path, self.root_path, self.ignore_patterns, is_dir)

                                child_node = CacheNode(name=entry_name, path=entry_path, is_dir=is_dir, ignored=is_ignored)
                                parent_node.children[entry_name] = child_node

                                # If it's a directory and not ignored, add to queue for further scanning
                                if is_dir and not is_ignored:
                                    scan_queue.append((child_node, entry_path))

                            except OSError as stat_err:
                                logger.warning(f"Could not stat file {entry_path}: {stat_err}. Skipping.")
                                # Add as ignored node to prevent re-scanning attempts
                                error_node = CacheNode(name=entry_name, path=entry_path, is_dir=False, ignored=True) # Assume file if stat fails
                                parent_node.children[entry_name] = error_node
                            except Exception as inner_e:
                                logger.error(f"Error processing entry {entry_path}: {inner_e}")


                    processed_dirs += 1
                    if processed_dirs % 100 == 0: # Update progress periodically
                        self.progress.emit(f"Scanned {processed_dirs} directories...")

                except OSError as scandir_err:
                    logger.error(f"Could not scan directory {current_dir}: {scandir_err}")
                    # Mark parent as ignored if scanning fails? Or just log? Logged for now.
                except Exception as outer_e:
                     logger.error(f"Unexpected error scanning directory {current_dir}: {outer_e}")

            self.progress.emit(f"Scan complete. Processed {processed_dirs} directories.")
            return root_node

        except Exception as e:
            logger.exception(f"Fatal error during scan setup for {dir_path}")
            self.error.emit(f"Scan setup error: {e}")
            return None


# --- Watchdog Event Handler ---
class CacheUpdateHandler(QObject, FileSystemEventHandler):
    """Handles filesystem events and signals the DirectoryCacheService."""
    # Signals to notify the main service about specific changes
    needs_rescan = pyqtSignal(str) # path
    item_created = pyqtSignal(str, bool) # path, is_dir
    item_deleted = pyqtSignal(str) # path
    item_moved = pyqtSignal(str, str) # src_path, dest_path
    item_modified = pyqtSignal(str) # path (for files)

    def __init__(self, cache_service: 'DirectoryCacheService'):
        QObject.__init__(self)
        FileSystemEventHandler.__init__(self)
        self.cache_service = cache_service
        self._ignore_patterns = set()
        self._root_path = None

    def update_config(self, root_path: str, ignore_patterns: Set[str]):
        self._root_path = root_path
        self._ignore_patterns = ignore_patterns

    def _should_process(self, event: FileSystemEvent) -> bool:
        """Checks if an event should be processed (not ignored)."""
        if not self._root_path: return False
        # Ignore directory modifications themselves, only care about contents
        # However, modifying a directory might indicate permission changes etc., needing rescan?
        # Let's ignore DirModifiedEvent for now to reduce noise. FileModifiedEvent is important.
        if isinstance(event, DirModifiedEvent):
             # logger.debug(f"Ignoring DirModifiedEvent: {event.src_path}")
             return False
        # Ignore modifications to ignored files/dirs
        path = event.src_path
        is_dir = event.is_directory
        if self.cache_service.fs_service.should_ignore(path, self._root_path, self._ignore_patterns, is_dir):
            # logger.debug(f"Ignoring event for ignored path: {path}")
            return False
        return True

    def on_created(self, event: FileSystemEvent):
        if self._should_process(event):
            logger.info(f"Watchdog: Detected creation: {event.src_path} (is_dir={event.is_directory})")
            self.item_created.emit(event.src_path, event.is_directory)

    def on_deleted(self, event: FileSystemEvent):
        # Check ignore based on path *before* deletion
        if not self._root_path: return False
        is_dir = event.is_directory # Note: is_directory might be unreliable after deletion
        # We might need to check if the path *was* ignored if we cached ignore status
        # For simplicity, assume if the path itself matches an ignore pattern, we ignore the delete event
        if self.cache_service.fs_service.should_ignore(event.src_path, self._root_path, self._ignore_patterns, is_dir):
             # logger.debug(f"Ignoring delete event for ignored path: {event.src_path}")
             return
        logger.info(f"Watchdog: Detected deletion: {event.src_path}")
        self.item_deleted.emit(event.src_path)

    def on_modified(self, event: FileSystemEvent):
        # Only process file modifications for now
        if isinstance(event, FileModifiedEvent) and self._should_process(event):
            logger.info(f"Watchdog: Detected modification: {event.src_path}")
            self.item_modified.emit(event.src_path)

    def on_moved(self, event: FileSystemEvent):
        # Check if either source or destination is ignored
        if not self._root_path: return False
        src_ignored = self.cache_service.fs_service.should_ignore(event.src_path, self._root_path, self._ignore_patterns, event.is_directory)
        dest_ignored = self.cache_service.fs_service.should_ignore(event.dest_path, self._root_path, self._ignore_patterns, event.is_directory)
        if src_ignored and dest_ignored:
            # logger.debug(f"Ignoring move event for ignored paths: {event.src_path} -> {event.dest_path}")
            return
        logger.info(f"Watchdog: Detected move: {event.src_path} -> {event.dest_path}")
        self.item_moved.emit(event.src_path, event.dest_path)


# --- Main Cache Service ---
class DirectoryCacheService(QObject):
    """
    Manages the directory cache, background scanning, and filesystem monitoring.
    """
    cache_updated = pyqtSignal(object) # Emits the root CacheNode
    scan_progress = pyqtSignal(str)
    scan_error = pyqtSignal(str)
    scan_finished = pyqtSignal() # Signal when scan completes successfully

    def __init__(self, fs_service: FilesystemService, parent: Optional[QObject] = None):
        super().__init__(parent)
        self.fs_service = fs_service
        self.cache_root: Optional[CacheNode] = None
        self.current_root_path: Optional[str] = None
        self.current_ignore_patterns: Set[str] = set()
        self._cache_lock = threading.Lock() # Lock for accessing the cache

        self._scanner_thread: Optional[QThread] = None
        self._scanner_worker: Optional[ScannerWorker] = None

        self._observer: Optional[Observer] = None
        self._event_handler: Optional[CacheUpdateHandler] = None
        self._observer_thread: Optional[threading.Thread] = None

    def start_scan(self, root_path: str, ignore_patterns: Set[str]):
        """Starts a background scan for the given path."""
        logger.info(f"CacheService: Received request to scan: {root_path}")
        self.stop_scan() # Stop any previous scan
        self.stop_monitoring() # Stop monitoring during scan

        self.current_root_path = root_path
        self.current_ignore_patterns = ignore_patterns
        with self._cache_lock:
            self.cache_root = None # Clear cache before scan

        self._scanner_thread = QThread()
        self._scanner_worker = ScannerWorker(root_path, self.fs_service, ignore_patterns)
        self._scanner_worker.moveToThread(self._scanner_thread)

        # Connect signals
        self._scanner_thread.started.connect(self._scanner_worker.run)
        self._scanner_worker.finished.connect(self._handle_scan_finished)
        self._scanner_worker.progress.connect(self.scan_progress.emit)
        self._scanner_worker.error.connect(self._handle_scan_error)

        # Cleanup connections
        self._scanner_worker.finished.connect(self._scanner_thread.quit)
        self._scanner_worker.finished.connect(self._scanner_worker.deleteLater)
        self._scanner_thread.finished.connect(self._scanner_thread.deleteLater)
        self._scanner_worker.error.connect(self._scanner_thread.quit) # Quit thread on error too
        self._scanner_worker.error.connect(self._scanner_worker.deleteLater)
        self._scanner_thread.finished.connect(self._cleanup_scanner_thread) # Custom cleanup slot

        self._scanner_thread.start()
        self.scan_progress.emit(f"Starting scan for {root_path}...")

    def stop_scan(self):
        """Stops the currently running scan."""
        if self._scanner_worker:
            logger.info("CacheService: Stopping scanner worker...")
            self._scanner_worker.cancel()
        if self._scanner_thread and self._scanner_thread.isRunning():
            logger.info("CacheService: Quitting scanner thread...")
            self._scanner_thread.quit()
            if not self._scanner_thread.wait(1000): # Wait 1 sec
                 logger.warning("Scanner thread did not quit gracefully.")
            self._cleanup_scanner_thread() # Ensure cleanup

    def _cleanup_scanner_thread(self):
        logger.debug("Cleaning up scanner thread/worker objects.")
        self._scanner_thread = None
        self._scanner_worker = None

    def _handle_scan_finished(self, root_node: CacheNode):
        """Handles the successful completion of a scan."""
        logger.info("CacheService: Scan finished successfully.")
        with self._cache_lock:
            self.cache_root = root_node
        self.cache_updated.emit(self.cache_root) # Emit the new cache
        self.scan_finished.emit() # Signal completion
        # Start monitoring after successful scan
        self.start_monitoring(self.current_root_path, self.current_ignore_patterns)

    def _handle_scan_error(self, error_msg: str):
        """Handles errors during the scan."""
        logger.error(f"CacheService: Scan error: {error_msg}")
        with self._cache_lock:
            self.cache_root = None # Clear cache on error
        self.scan_error.emit(error_msg)
        self.cache_updated.emit(None) # Emit empty cache
        # Do not start monitoring if scan failed

    def get_cache(self) -> Optional[CacheNode]:
        """Returns the current cache root node (thread-safe)."""
        with self._cache_lock:
            return self.cache_root

    # --- Filesystem Monitoring ---

    def start_monitoring(self, root_path: Optional[str], ignore_patterns: Set[str]):
        """Starts filesystem monitoring using watchdog."""
        if not root_path:
            logger.warning("Cannot start monitoring: root_path is None.")
            return
        if self._observer and self._observer.is_alive():
            logger.info("Monitor already running. Stopping and restarting.")
            self.stop_monitoring()

        logger.info(f"Starting filesystem monitor for: {root_path}")
        self.current_root_path = root_path # Update path just in case
        self.current_ignore_patterns = ignore_patterns

        self._event_handler = CacheUpdateHandler(self)
        self._event_handler.update_config(root_path, ignore_patterns)
        # Connect handler signals to service methods
        self._event_handler.item_created.connect(self._handle_item_created)
        self._event_handler.item_deleted.connect(self._handle_item_deleted)
        self._event_handler.item_moved.connect(self._handle_item_moved)
        self._event_handler.item_modified.connect(self._handle_item_modified)
        # self._event_handler.needs_rescan.connect(self._handle_needs_rescan) # Optional

        self._observer = Observer()
        try:
            # Watch the root path recursively
            self._observer.schedule(self._event_handler, root_path, recursive=True)
            # Run observer in a separate daemon thread
            self._observer_thread = threading.Thread(target=self._observer.start, daemon=True)
            self._observer_thread.start()
            logger.info(f"Filesystem monitor started successfully for {root_path}.")
        except OSError as e:
             logger.error(f"Failed to start watchdog observer for {root_path}: {e}. Check path permissions or if it's a network drive limitation.")
             QMessageBox.warning(None, "Monitoring Error", f"폴더 감시 시작 실패:\n{root_path}\n\n오류: {e}\n\n네트워크 드라이브 또는 권한 문제일 수 있습니다. 파일 변경 사항이 자동으로 반영되지 않을 수 있습니다.")
             self._observer = None
             self._observer_thread = None
        except Exception as e:
            logger.exception(f"Unexpected error starting watchdog observer for {root_path}")
            self._observer = None
            self._observer_thread = None


    def stop_monitoring(self):
        """Stops the filesystem monitor."""
        if self._observer and self._observer.is_alive():
            logger.info("Stopping filesystem monitor...")
            try:
                self._observer.stop()
                self._observer.join(timeout=1.0) # Wait for thread to finish
                if self._observer.is_alive():
                     logger.warning("Watchdog observer thread did not join gracefully.")
                else:
                     logger.info("Filesystem monitor stopped.")
            except Exception as e:
                 logger.error(f"Error stopping watchdog observer: {e}")
        self._observer = None
        self._observer_thread = None
        self._event_handler = None # Disconnect signals implicitly

    def update_ignore_patterns(self, ignore_patterns: Set[str]):
        """Updates ignore patterns for the running monitor."""
        self.current_ignore_patterns = ignore_patterns
        if self._event_handler:
            self._event_handler.update_config(self.current_root_path, ignore_patterns)
            logger.info("Watchdog ignore patterns updated.")
            # Trigger a cache update signal? Maybe not necessary unless filtering changes visibility
            # self.cache_updated.emit(self.get_cache())

    # --- Cache Update Handlers (Called by Watchdog Handler Signals) ---

    def _find_node(self, path: str) -> Optional[CacheNode]:
        """Finds a node in the cache by its absolute path."""
        if not self.cache_root or not self.current_root_path: return None
        if path == self.current_root_path: return self.cache_root

        try:
            relative_path = Path(path).relative_to(self.current_root_path)
            parts = relative_path.parts
        except ValueError:
            logger.warning(f"Path '{path}' is not relative to root '{self.current_root_path}'")
            return None

        current_node = self.cache_root
        for part in parts:
            if part in current_node.children:
                current_node = current_node.children[part]
            else:
                return None # Node not found
        return current_node

    def _find_parent_node(self, path: str) -> Optional[CacheNode]:
        """Finds the parent node of a given path."""
        parent_path = os.path.dirname(path)
        return self._find_node(parent_path)

    def _handle_item_created(self, path: str, is_dir: bool):
        logger.debug(f"CacheService: Handling item created: {path}")
        with self._cache_lock:
            if not self.cache_root or not self.current_root_path: return
            parent_node = self._find_parent_node(path)
            if parent_node and not parent_node.ignored:
                name = os.path.basename(path)
                # Check ignore status for the new item
                is_ignored = self.fs_service.should_ignore(path, self.current_root_path, self.current_ignore_patterns, is_dir)
                new_node = CacheNode(name=name, path=path, is_dir=is_dir, ignored=is_ignored)
                parent_node.children[name] = new_node
                logger.info(f"Cache updated: Added node {name} to parent {parent_node.path}")
                # If the new item is a directory and not ignored, we might need to scan its contents
                if is_dir and not is_ignored:
                    # For simplicity, trigger a full rescan for directory creation for now
                    # A more refined approach would scan just the new directory
                    logger.warning(f"Directory created ({path}), triggering full rescan for simplicity.")
                    self._handle_needs_rescan(f"Directory created: {path}")
                    return # Rescan handles cache update signal

                # Emit cache update signal only if not rescanning
                self.cache_updated.emit(self.cache_root)
            elif parent_node and parent_node.ignored:
                 logger.debug(f"Ignoring creation under ignored parent: {path}")
            else:
                 logger.warning(f"Parent node not found for created item: {path}")


    def _handle_item_deleted(self, path: str):
        logger.debug(f"CacheService: Handling item deleted: {path}")
        with self._cache_lock:
            if not self.cache_root or not self.current_root_path: return
            parent_node = self._find_parent_node(path)
            if parent_node:
                name = os.path.basename(path)
                if name in parent_node.children:
                    del parent_node.children[name]
                    logger.info(f"Cache updated: Removed node {name} from parent {parent_node.path}")
                    self.cache_updated.emit(self.cache_root)
                else:
                    logger.warning(f"Node '{name}' not found in parent '{parent_node.path}' for deletion.")
            else:
                # Could be the root directory itself being deleted?
                if path == self.current_root_path:
                     logger.warning("Root project directory deleted! Clearing cache.")
                     self.cache_root = None
                     self.cache_updated.emit(None)
                     self.stop_monitoring() # Stop monitoring if root is gone
                else:
                     logger.warning(f"Parent node not found for deleted item: {path}")

    def _handle_item_moved(self, src_path: str, dest_path: str):
        logger.debug(f"CacheService: Handling item moved: {src_path} -> {dest_path}")
        with self._cache_lock:
            if not self.cache_root or not self.current_root_path: return

            # 1. Find and remove source node
            src_parent_node = self._find_parent_node(src_path)
            src_name = os.path.basename(src_path)
            moved_node: Optional[CacheNode] = None
            if src_parent_node and src_name in src_parent_node.children:
                moved_node = src_parent_node.children.pop(src_name)
                logger.info(f"Cache updated: Removed source node {src_name} from {src_parent_node.path}")
            else:
                logger.warning(f"Source node not found for move: {src_path}")
                # If source not found, maybe trigger rescan?
                self._handle_needs_rescan(f"Source node not found for move: {src_path}")
                return

            # 2. Find destination parent node
            dest_parent_node = self._find_parent_node(dest_path)
            dest_name = os.path.basename(dest_path)

            # 3. Add node to destination parent (if parent exists and isn't ignored)
            if dest_parent_node and moved_node:
                 # Update node's name and path
                 moved_node.name = dest_name
                 moved_node.path = dest_path
                 # Re-check ignore status at new location
                 moved_node.ignored = self.fs_service.should_ignore(dest_path, self.current_root_path, self.current_ignore_patterns, moved_node.is_dir)

                 # Add to new parent only if parent isn't ignored
                 if not dest_parent_node.ignored:
                     dest_parent_node.children[dest_name] = moved_node
                     logger.info(f"Cache updated: Added moved node {dest_name} to {dest_parent_node.path}")
                 else:
                      logger.debug(f"Move destination parent ignored, node not added: {dest_path}")

                 # If a directory was moved, its children's paths also need updating (complex)
                 # For simplicity, trigger a rescan when directories are moved.
                 if moved_node.is_dir:
                      logger.warning(f"Directory moved ({src_path} -> {dest_path}), triggering full rescan for simplicity.")
                      self._handle_needs_rescan(f"Directory moved: {dest_path}")
                      return # Rescan handles cache update signal

                 # Emit cache update signal only if not rescanning
                 self.cache_updated.emit(self.cache_root)

            elif not dest_parent_node:
                 logger.warning(f"Destination parent node not found for move: {dest_path}")
                 # Trigger rescan if destination parent is missing
                 self._handle_needs_rescan(f"Destination parent not found for move: {dest_path}")
            # else: moved_node is None (already handled)


    def _handle_item_modified(self, path: str):
        # Currently, the cache doesn't store modification time or content hash.
        # So, a modification event doesn't change the cache structure itself.
        # We could potentially add mtime to CacheNode and update it here.
        # For now, just log it. The model displaying the cache might want this signal.
        logger.debug(f"CacheService: Handling item modified: {path}")
        # Find the node - maybe update an mtime attribute if we add one
        # with self._cache_lock:
        #     node = self._find_node(path)
        #     if node:
        #         # node.mtime = os.path.getmtime(path) # Example if mtime is added
        #         # self.cache_updated.emit(self.cache_root) # Emit if node data changes
        #         pass
        pass # No action on cache for modification currently

    def _handle_needs_rescan(self, reason: str):
        """Handles events that require a full rescan for simplicity."""
        logger.warning(f"Triggering rescan due to: {reason}")
        if self.current_root_path:
            # Emit error signal to potentially inform UI before starting scan
            self.scan_error.emit(f"Rescanning due to: {reason}")
            # Restart the scan
            self.start_scan(self.current_root_path, self.current_ignore_patterns)
        else:
            logger.error("Cannot rescan: current_root_path is not set.")

    def __del__(self):
        """Ensure threads are stopped when the service is deleted."""
        self.stop_scan()
        self.stop_monitoring()



======== src\core\services\filesystem_service.py ========
import os
import fnmatch
from typing import Set, List

class FilesystemService:
    def __init__(self, config_service): # ConfigService 주입
        self.config_service = config_service

    def load_gitignore_patterns(self, project_folder: str) -> Set[str]:
        """Loads .gitignore patterns from the project folder and combines with defaults."""
        gitignore_path = os.path.join(project_folder, ".gitignore")
        settings = self.config_service.get_settings()
        # 기본 무시 목록으로 시작
        patterns = set(settings.default_ignore_list)

        if os.path.isfile(gitignore_path):
            try:
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    lines = f.read().splitlines()
                # 주석과 빈 줄 제외하고 패턴 추가
                lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                patterns.update(lines)
            except Exception as e:
                print(f"Error loading .gitignore file {gitignore_path}: {e}")
                # 오류 발생 시 기본값만 사용

        # 설정에 직접 저장된 제외 목록도 추가 (config.yml)
        patterns.update(settings.excluded_dirs)
        return patterns

    def should_ignore(self, file_path: str, project_root: str, ignore_patterns: Set[str], is_dir: bool) -> bool:
        """Checks if a file/directory should be ignored based on patterns."""
        if not project_root or not file_path.startswith(project_root):
            return False # 프로젝트 루트 외부는 무시하지 않음

        if file_path == project_root:
            return False # 프로젝트 루트 자체는 무시하지 않음

        file_name = os.path.basename(file_path)
        try:
            relative_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
        except ValueError:
            # 다른 드라이브 등 상대 경로 계산 불가 시 무시하지 않음
            return False

        for pattern in ignore_patterns:
            # 패턴 정리 및 디렉토리 패턴 여부 확인
            is_dir_pattern = pattern.endswith('/')
            cleaned_pattern = pattern.rstrip('/')

            # 디렉토리 패턴인데 현재 항목이 파일이면 건너뜀
            if is_dir_pattern and not is_dir:
                continue

            # 1. 파일 이름 매칭 (e.g., *.log, __pycache__)
            if fnmatch.fnmatch(file_name, cleaned_pattern):
                # 디렉토리 패턴이면 디렉토리만 매칭
                if is_dir_pattern and is_dir:
                    return True
                # 파일 패턴이면 파일/디렉토리 모두 매칭 (gitignore 기본 동작)
                elif not is_dir_pattern:
                    return True

            # 2. 상대 경로 매칭 (e.g., build/, docs/temp.txt)
            # 디렉토리일 경우, 경로 끝에 '/' 추가하여 매칭
            match_path = relative_path + '/' if is_dir else relative_path
            if fnmatch.fnmatch(match_path, pattern):
                 return True
            # 패턴에 /가 포함되어 있고, 디렉토리 패턴이 아닐 때도 경로 매칭 시도
            # (e.g. 'some/dir/file.txt' 패턴)
            if '/' in pattern and not is_dir_pattern:
                 if fnmatch.fnmatch(relative_path, pattern):
                     return True

        return False # 어떤 패턴과도 매치되지 않으면 무시하지 않음

    def get_directory_tree(self, paths: List[str], project_root: str) -> str:
        """Builds a directory tree structure string from a list of paths."""
        if not paths or not project_root:
            return "No items selected or project root not set."

        tree = {}
        visible_paths = [] # 실제 존재하는 경로만 필터링 (필요시)
        for p in paths:
            if os.path.exists(p):
                 visible_paths.append(p)

        if not visible_paths:
            return "No valid items selected."

        for p in visible_paths:
            try:
                rel_path = os.path.relpath(p, project_root)
            except ValueError:
                continue # 다른 드라이브 등 relpath 계산 불가 시 건너뜀
            parts = rel_path.split(os.sep)
            current = tree
            for part in parts:
                if part not in current:
                    current[part] = {}
                current = current[part]

        def print_tree(subtree, current_path, indent=0):
            lines = []
            indent_str = "  " * indent
            entries = sorted(subtree.keys())
            dirs = []
            files = []

            for entry in entries:
                full_path = os.path.join(current_path, entry)
                if os.path.isdir(full_path):
                    dirs.append(entry)
                elif os.path.isfile(full_path):
                    files.append(entry)

            for d in dirs:
                lines.append(f"{indent_str} 📁 {d}/")
                lines.extend(print_tree(subtree[d], os.path.join(current_path, d), indent + 1))
            for f in files:
                # --- Removed file size calculation ---
                # size = 0
                # full_file_path = os.path.join(current_path, f)
                # try:
                #     size = os.path.getsize(full_file_path)
                # except OSError:
                #     size = 0
                # lines.append(f"{indent_str} 📄 {f} ({size:,} bytes)")
                # --- End of removal ---
                lines.append(f"{indent_str} 📄 {f}") # Display only filename
            return lines

        root_folder_name = os.path.basename(project_root)
        root_lines = [f"File Tree:", f" 📁 {root_folder_name}/"]
        root_lines.extend(print_tree(tree, project_root, 1))

        return "\n".join(root_lines)



======== src\core\services\gemini_service.py ========
import google.generativeai as genai
from langgraph.graph import StateGraph, END, START
from functools import partial
import logging
from typing import Optional, List, Dict, Any, Union, Tuple, Set
import base64
import mimetypes
import os
import datetime # datetime 모듈 임포트
import time # 시간 측정용

from core.langgraph_state import GeminiGraphState
from core.services.config_service import ConfigService
from core.services.db_service import DbService # DbService 임포트
from google.generativeai import types
from google.api_core import exceptions as google_api_exceptions

logger = logging.getLogger(__name__)

# --- LangGraph 노드 함수 ---

def call_gemini(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """
    Gemini API를 호출하는 노드 (멀티모달 지원).
    1. 사용자가 선택한 키를 먼저 시도합니다. (활성 상태 및 Rate Limit 체크 후)
    2. 사용자 선택 키가 없거나 실패(Rate Limit, PermissionDenied 등)하면, DB에서 활성 키 목록을 조회하여
       일일 사용량이 가장 적은 키부터 순서대로 시도합니다. (이미 시도한 키 제외)
    3. Rate Limit, PermissionDenied, InvalidArgument 에러 발생 시 다음 키로 자동 전환하여 재시도합니다.
    4. 성공 시 사용된 키 정보를 ConfigService에 업데이트합니다.
    """
    logger.info("Calling Gemini API node (Multimodal, with key rotation)")
    start_time_mono = time.monotonic()
    request_timestamp = datetime.datetime.now(datetime.timezone.utc)
    logger.info(f"Gemini API 호출 시작 시간: {request_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}")

    text_prompt = state['input_prompt']
    attachments = state.get('input_attachments', [])
    settings = config_service.get_settings()
    db_service: DbService = config_service.db_service

    # 설정에서 모델명 가져오기
    model_name = state.get('selected_model_name', settings.gemini_default_model)
    temperature = settings.gemini_temperature
    enable_thinking = settings.gemini_enable_thinking
    thinking_budget = settings.gemini_thinking_budget
    enable_search = settings.gemini_enable_search

    # 초기 상태 반환용 기본값
    default_return_state: GeminiGraphState = {
        "input_prompt": text_prompt, "input_attachments": attachments,
        "selected_model_name": model_name, "gemini_response": "",
        "xml_output": "", "summary_output": "", "error_message": None, "log_id": None
    }

    if not model_name:
        error_msg = "Gemini model name not provided or configured."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg
        return default_return_state

    # --- API 키 선택 및 시도 로직 (개선) ---
    tried_key_ids: Set[int] = set() # 이미 시도한 키 ID 추적
    api_key_id: Optional[int] = None
    log_id: Optional[int] = None
    final_error_message: Optional[str] = None
    api_call_successful = False # API 호출 성공 여부 플래그
    successfully_used_key_string: Optional[str] = None # 성공적으로 사용된 키 문자열
    successfully_used_key_id: Optional[int] = None # 성공적으로 사용된 키 ID

    # 1. 사용자 지정 키 먼저 시도
    user_selected_key_id = config_service.get_user_selected_gemini_key_id()
    user_key_info: Optional[Dict[str, Any]] = None

    if user_selected_key_id is not None:
        logger.info(f"User has selected Gemini Key ID: {user_selected_key_id}. Attempting to use it first.")
        try:
            # DB에서 해당 키의 상세 정보와 최신 사용량 조회 (get_active_api_keys_with_usage 필터링 방식 유지)
            temp_keys_usage = db_service.get_active_api_keys_with_usage('google')
            user_key_info = next((k for k in temp_keys_usage if k['id'] == user_selected_key_id), None)

            if user_key_info:
                logger.info(f"Found details for user-selected key ID {user_selected_key_id}.")
                # Rate Limit 체크
                is_limited, reason = db_service.is_key_rate_limited(user_selected_key_id, model_name)
                if is_limited:
                    logger.warning(f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}. Will try other keys.")
                    final_error_message = f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}"
                    tried_key_ids.add(user_selected_key_id) # 시도한 것으로 간주
                    user_key_info = None # 사용 불가 처리
                else:
                    logger.info(f"User-selected key ID {user_selected_key_id} passed rate limit check.")
                    # 사용자 선택 키를 첫 번째 시도 대상으로 설정
            else:
                logger.warning(f"User-selected key ID {user_selected_key_id} not found among active keys or failed to get usage. Will try other keys.")
                tried_key_ids.add(user_selected_key_id) # 시도한 것으로 간주 (찾을 수 없으므로)

        except Exception as e:
            logger.error(f"Error retrieving/checking user-selected key ID {user_selected_key_id}: {e}", exc_info=True)
            tried_key_ids.add(user_selected_key_id) # 오류 발생 시 시도한 것으로 간주
            user_key_info = None # 사용 불가 처리

    # --- API 키 시도 루프 ---
    keys_to_attempt: List[Dict[str, Any]] = []
    if user_key_info:
        keys_to_attempt.append(user_key_info) # 사용자 선택 키를 맨 앞에 추가

    # 사용자 키가 없거나 실패할 경우 다른 활성 키 목록 가져오기
    if not user_key_info: # 사용자 키가 없거나, Rate Limit 걸렸거나, 조회 실패한 경우
        logger.info("Fetching other active Gemini keys sorted by daily usage...")
        try:
            active_keys_usage = db_service.get_active_api_keys_with_usage('google')
            active_keys_usage.sort(key=lambda x: x['calls_this_day']) # 일일 사용량 기준 오름차순 정렬
            # 이미 시도한 사용자 선택 키 제외하고 추가
            added_count = 0
            for key_info in active_keys_usage:
                if key_info['id'] not in tried_key_ids:
                    keys_to_attempt.append(key_info)
                    added_count += 1
            logger.info(f"Found {added_count} other active keys to try.")
        except Exception as e:
            error_msg = f"Failed to retrieve other active Gemini keys with usage from DB: {e}"
            logger.error(error_msg, exc_info=True)
            # 다른 키 조회 실패 시, 사용자 키도 없으면 완전 실패
            if not user_key_info:
                default_return_state["error_message"] = final_error_message or error_msg # 사용자 키 Rate Limit 메시지 또는 DB 오류 메시지
                return default_return_state
            # 사용자 키는 있었지만 Rate Limit 걸린 경우, 다른 키 조회 실패했으므로 여기서 종료
            elif user_selected_key_id in tried_key_ids:
                 default_return_state["error_message"] = final_error_message or "Failed to find alternative keys."
                 return default_return_state

    if not keys_to_attempt:
        error_msg = final_error_message or "No usable Gemini API Keys found (neither selected nor active/available in DB)."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg
        return default_return_state

    logger.info(f"Total keys to try in order: {[k['id'] for k in keys_to_attempt]}")

    # --- API 키 순차 시도 ---
    for key_info in keys_to_attempt:
        api_key = key_info['api_key']
        current_key_id = key_info['id'] # 현재 시도하는 키 ID
        daily_usage = key_info.get('calls_this_day', 'N/A')
        logger.info(f"Attempting to use Gemini API Key ID: {current_key_id} (Daily Usage: {daily_usage})")

        # 이미 시도한 키는 건너뛰기 (중복 방지)
        if current_key_id in tried_key_ids:
            logger.debug(f"Skipping already tried key ID: {current_key_id}")
            continue

        # Rate Limit 체크 (사용자 키는 이미 체크했으므로, 다른 키만 체크)
        if current_key_id != user_selected_key_id:
            is_limited, reason = db_service.is_key_rate_limited(current_key_id, model_name)
            if is_limited:
                logger.warning(f"Pre-check failed: Rate limit reached for key ID {current_key_id}. Reason: {reason}. Skipping.")
                final_error_message = f"Rate limit exceeded for key ID {current_key_id}: {reason}" # 마지막 실패 사유 업데이트
                tried_key_ids.add(current_key_id) # 시도한 것으로 간주
                continue # 다음 키 시도
            logger.info(f"Rate limit pre-check passed for key ID {current_key_id}.")

        # --- DB 로깅 준비 ---
        current_log_id = log_id # 이전 시도의 log_id (실패 시)
        if current_log_id is None: # 첫 시도인 경우에만 새 로그 생성
            try:
                current_log_id = db_service.log_gemini_request(
                    model_name=model_name, request_prompt=text_prompt,
                    request_attachments=attachments, api_key_id=current_key_id # 현재 시도하는 키 ID 사용
                )
                if current_log_id:
                     log_id = current_log_id # 성공적으로 생성된 log_id 저장
                     default_return_state["log_id"] = log_id # 상태에도 반영
                else:
                     logger.error(f"Failed to create initial Gemini log entry for key ID {current_key_id}.")
            except Exception as db_err:
                logger.error(f"Failed to log Gemini request to DB for key ID {current_key_id}: {db_err}", exc_info=True)
        # --- DB 로깅 준비 완료 ---

        effective_model_name = ""
        gemini_response_text = ""
        api_error_message: Optional[str] = None
        # api_call_successful 플래그는 루프 시작 시 False로 초기화됨

        try:
            genai.configure(api_key=api_key)
            effective_model_name = model_name.replace("models/", "")
            model = genai.GenerativeModel(effective_model_name)
            logger.info(f"Using Gemini model: {effective_model_name} with key ID: {current_key_id}")

            # GenerationConfig, ToolConfig, Tools 설정
            generation_config_params = {"temperature": temperature, "response_mime_type": "text/plain"}
            try: generation_config = types.GenerationConfig(**generation_config_params)
            except AttributeError: raise ValueError("Failed to create GenerationConfig (AttributeError)")
            except Exception as e: raise ValueError(f"Error creating GenerationConfig: {e}")

            tools_list: Optional[List[types.Tool]] = None
            if enable_search:
                try: tools_list = [types.Tool(google_search=types.GoogleSearch())]
                except AttributeError: logger.warning("Search tool creation failed (AttributeError)")
                except Exception as e: logger.error(f"Error creating GoogleSearch tool: {e}")

            tool_config_obj: Optional[types.ToolConfig] = None
            if enable_thinking:
                try:
                    thinking_config_obj = types.ThinkingConfig(thinking_budget=thinking_budget)
                    tool_config_obj = types.ToolConfig(thinking_config=thinking_config_obj)
                except AttributeError: logger.warning("Thinking config creation failed (AttributeError)")
                except Exception as e: logger.error(f"Error creating ThinkingConfig/ToolConfig: {e}")

            # Contents 구성
            contents_list: List[Union[str, Dict[str, Any]]] = []
            if text_prompt: contents_list.append(text_prompt)
            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type'); item_name = attachment.get('name', 'unknown')
                    item_data = attachment.get('data'); item_path = attachment.get('path')
                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e: logger.error(f"Failed to read attachment {item_path}: {e}"); continue
                    if not item_data: logger.warning(f"Skipping attachment '{item_name}': No data."); continue
                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name)
                        if not mime_type: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list: raise ValueError("No content (text or attachments) to send.")

            # API 호출 (스트림)
            logger.info(f"Sending {len(contents_list)} parts to Gemini model: {effective_model_name} (using key ID: {current_key_id})")
            response = model.generate_content(
                contents=contents_list, generation_config=generation_config,
                tools=tools_list, tool_config=tool_config_obj, stream=True
            )

            # 스트림 응답 처리
            specific_error_occurred = False; error_details = ""
            for chunk in response:
                try: gemini_response_text += chunk.text
                except ValueError as e:
                    if "response.text` quick accessor" in str(e) or "candidate.text`" in str(e):
                        func_calls = getattr(chunk, 'function_calls', None)
                        finish_reason = getattr(getattr(chunk, 'candidates', [None])[0], 'finish_reason', 'unknown') if hasattr(chunk, 'candidates') else 'unknown'
                        msg = (f"Function Call ignored: {func_calls}" if func_calls
                               else f"Chunk text access error (Finish Reason: {finish_reason}): {e}")
                        logger.warning(msg)
                        error_details += f"\n- {msg}"
                        specific_error_occurred = True
                        continue
                    else: raise
                except Exception as e: logger.exception(f"Unexpected chunk error: {e}"); error_details += f"\n- Chunk error: {e}"; specific_error_occurred = True; continue

            # 결과 처리
            if specific_error_occurred:
                api_error_message = f"Gemini API 응답 문제 발생 (Key ID: {current_key_id}). 일부 내용 누락 또는 Function Call 포함 가능." + "\n세부 정보:" + error_details
                logger.warning(f"Gemini stream processing issues for key ID {current_key_id}. Details: {error_details}")
                default_return_state["error_message"] = api_error_message
                default_return_state["gemini_response"] = gemini_response_text # 부분 응답 저장
                api_call_successful = True # 부분 성공으로 간주하여 사용량 업데이트
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                break # 루프 종료 (오류 발생 시 다른 키 시도 안 함)

            elif not gemini_response_text.strip():
                error_detail = "Unknown reason (empty response)"
                try: error_detail = f"Prompt Feedback: {response.prompt_feedback}"
                except Exception: pass
                api_error_message = f"Gemini API 호출 성공했으나 빈 응답 반환 (Key ID: {current_key_id}). 세부 정보: {error_detail}"
                logger.warning(api_error_message)
                default_return_state["gemini_response"] = ""
                default_return_state["error_message"] = api_error_message
                api_call_successful = True # 빈 응답도 성공으로 간주
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                break # 루프 종료

            else:
                logger.info(f"--- Gemini Response Received Successfully using Key ID: {current_key_id} ---")
                api_call_successful = True
                successfully_used_key_string = api_key
                successfully_used_key_id = current_key_id
                default_return_state["gemini_response"] = gemini_response_text
                default_return_state["error_message"] = None # 성공 시 오류 없음
                break # 성공했으므로 루프 종료

        except google_api_exceptions.ResourceExhausted as e:
            api_error_message = f"Gemini API Rate Limit 초과 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다."
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # 시도한 것으로 간주
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Rate Limit Error: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # 다음 키 시도

        except google_api_exceptions.PermissionDenied as e:
            api_error_message = f"Gemini API 권한 오류 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다."
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # 시도한 것으로 간주
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Permission Denied: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # 다음 키 시도

        except google_api_exceptions.InvalidArgument as e:
            api_error_message = f"Gemini API 잘못된 인수 오류 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다. (문제가 키 관련이 아닐 수 있음)"
            logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message
            tried_key_ids.add(current_key_id) # 시도한 것으로 간주
            if db_service and log_id is not None:
                end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000)
                db_service.update_gemini_log(log_id=log_id, error_message=f"Invalid Argument: {e}", elapsed_time_ms=elapsed_ms_err)
            continue # 다음 키 시도

        except (AttributeError, ValueError) as e:
            error_type = type(e).__name__
            api_error_message = f"Gemini API 오류 ({error_type} - Key ID: {current_key_id}): {str(e)}. 중단합니다."
            logger.error(api_error_message, exc_info=True)
            default_return_state["error_message"] = api_error_message
            api_call_successful = False
            tried_key_ids.add(current_key_id) # 시도한 것으로 간주
            break # 루프 중단

        except Exception as e:
            api_error_message = f"Gemini API 호출 중 예상치 못한 오류 (Key ID: {current_key_id}): {str(e)}. 중단합니다."
            logger.exception(api_error_message)
            default_return_state["error_message"] = api_error_message
            api_call_successful = False
            tried_key_ids.add(current_key_id) # 시도한 것으로 간주
            break # 루프 중단

        finally:
            # finally 블록은 Rate Limit/Permission/Argument 오류로 continue 할 때도 실행됨
            # 성공했거나, 복구 불가능한 오류로 중단되었거나, 스트림 처리 오류 발생 시 로그 업데이트
            if api_call_successful or (api_error_message and "다음 키로 재시도합니다" not in api_error_message):
                 # 사용량 업데이트는 성공 시에만
                 if api_call_successful and db_service and current_key_id is not None:
                    try: db_service.update_api_key_usage(current_key_id)
                    except Exception as usage_err: logger.error(f"Failed to update usage for key ID {current_key_id}: {usage_err}", exc_info=True)

                 # DB 로그 업데이트 (성공/오류 모두, log_id가 생성된 경우)
                 if db_service and log_id is not None:
                    end_time_mono = time.monotonic(); elapsed_ms = int((end_time_mono - start_time_mono) * 1000)
                    try:
                        db_service.update_gemini_log(
                            log_id=log_id, response_text=gemini_response_text,
                            error_message=api_error_message, elapsed_time_ms=elapsed_ms
                        )
                    except Exception as db_err: logger.error(f"Failed to update Gemini log ID {log_id}: {db_err}", exc_info=True)
            # Rate Limit/Permission/Argument 발생 시에는 finally 블록에서 별도 처리 없음 (except 블록에서 로그 업데이트)
    # --- 루프 종료 ---

    # --- 성공 시 사용된 키를 ConfigService에 업데이트 ---
    if api_call_successful and successfully_used_key_string and successfully_used_key_id is not None:
        if config_service:
            config_service.update_last_used_gemini_key(successfully_used_key_string)
            logger.info(f"Successfully used API key ID {successfully_used_key_id}. Updated in-memory config via ConfigService.")
            # 사용자가 선택한 키와 다른 키가 사용되었을 경우, 사용자 선택 해제
            if user_selected_key_id is not None and user_selected_key_id != successfully_used_key_id:
                 logger.info(f"Successfully used key ID {successfully_used_key_id} is different from user-selected key ID {user_selected_key_id}. Clearing user selection.")
                 config_service.set_user_selected_gemini_key(None)
        else:
            logger.warning("ConfigService not available to update the last used key.")
    # ----------------------------------------------------

    # 모든 키를 시도했지만 실패한 경우
    if not api_call_successful:
        error_msg = final_error_message or "모든 활성 Gemini API 키를 시도했지만 호출에 실패했습니다."
        logger.error(error_msg)
        default_return_state["error_message"] = error_msg

    # 최종 경과 시간 로깅
    total_elapsed_ms = int((time.monotonic() - start_time_mono) * 1000)
    response_timestamp = datetime.datetime.now(datetime.timezone.utc)
    elapsed_time_str = str(datetime.timedelta(milliseconds=total_elapsed_ms)).split('.')[0]
    logger.info(f"Gemini API 호출 노드 종료 시간: {response_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}, 총 경과 시간: {elapsed_time_str}")

    return default_return_state


def process_response(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """
    Gemini 응답을 XML과 Summary로 파싱하는 노드.
    응답 끝 부분의 <summary> 태그를 기준으로 분리하여 코드 내 문자열과의 혼동을 줄입니다.
    파싱된 결과를 DB 로그에 업데이트합니다.
    """
    print("--- Processing Gemini Response ---")
    logger.info("Processing Gemini Response node")
    gemini_response = state.get('gemini_response', '')
    xml_output = ""
    summary_output = ""
    error_message = state.get('error_message') # 이전 노드의 오류 메시지 유지
    log_id = state.get('log_id') # 상태에서 log_id 가져오기
    db_service: Optional[DbService] = config_service.db_service if config_service else None

    new_state = state.copy()

    try:
        # 이전 노드에서 심각한 오류가 발생했다면 처리 건너뛰기
        if error_message and "Gemini API 응답 문제 발생" not in error_message and "빈 응답 반환" not in error_message: # 빈 응답은 처리 시도
             logger.warning(f"Skipping response processing due to previous critical error: {error_message}")
             new_state["xml_output"] = ""
             new_state["summary_output"] = ""
             # DB 로그에 최종 오류 메시지 업데이트 시도 (call_gemini에서 이미 했을 수 있음)
             # if db_service and log_id is not None:
             #     db_service.update_gemini_log(log_id=log_id, error_message=error_message)
             return new_state
        elif error_message:
             logger.warning(f"Processing potentially partial or empty response due to previous issue: {error_message}")

        if not gemini_response or not gemini_response.strip(): # 빈 문자열 또는 공백만 있는 경우
             logger.warning("Gemini response is empty, skipping processing.")
             if not error_message: # 이전 오류가 없었다면 빈 응답 오류 설정
                 error_message = "Gemini response was empty after successful API call."
                 new_state["error_message"] = error_message
             new_state["xml_output"] = ""
             new_state["summary_output"] = ""
             # DB 로그 업데이트 (오류 - 빈 응답)
             if db_service and log_id is not None:
                 db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
             return new_state


        cleaned_response = gemini_response.strip()
        summary_start_tag = "<summary>"
        summary_end_tag = "</summary>"
        summary_start_index = cleaned_response.rfind(summary_start_tag)
        summary_end_index = cleaned_response.rfind(summary_end_tag)

        is_valid_summary = (
            summary_start_index != -1 and
            summary_end_index != -1 and
            summary_start_index < summary_end_index and
            # 끝부분에 있는지 좀 더 관대하게 확인 (약간의 후행 공백 허용)
            summary_end_index >= len(cleaned_response) - len(summary_end_tag) - 20 # 허용 범위 약간 늘림
        )

        if is_valid_summary:
            xml_output = cleaned_response[:summary_start_index].strip()
            summary_output = cleaned_response[summary_start_index + len(summary_start_tag):summary_end_index].strip()
            logger.info("Successfully parsed XML and Summary parts.")
            # 성공적으로 파싱되었으므로, 이전 오류 메시지(빈 응답 등)는 지울 수 있음 (선택적)
            if "빈 응답 반환" in (error_message or ""):
                new_state["error_message"] = None # 빈 응답 오류는 해소된 것으로 간주
        else:
            xml_output = cleaned_response
            summary_output = "Summary tag not found or improperly placed in the response."
            logger.warning(summary_output)
            # 파싱 실패를 오류로 설정 (이전 오류가 없었을 경우)
            if not error_message: new_state["error_message"] = summary_output

        logger.info("--- Response Processed ---")
        new_state["xml_output"] = xml_output
        new_state["summary_output"] = summary_output

        # 파싱된 XML/Summary 결과를 DB 로그에 업데이트
        if db_service and log_id is not None:
            try:
                logger.info(f"Updating DB log ID {log_id} with parsed XML and Summary.")
                db_service.update_gemini_log(
                    log_id=log_id, response_xml=xml_output, response_summary=summary_output,
                    # 오류 메시지도 업데이트 (파싱 실패 또는 이전 오류 유지)
                    error_message=new_state["error_message"]
                )
            except Exception as db_err:
                logger.error(f"Failed to update Gemini log ID {log_id} with parsed results: {db_err}", exc_info=True)

        return new_state

    except Exception as e:
        error_msg = f"Error processing response: {str(e)}"
        logger.exception(error_msg)
        new_state["xml_output"] = gemini_response # 원본 응답 유지
        new_state["summary_output"] = f"응답 처리 오류: {e}"
        new_state["error_message"] = (error_message + "\n" + error_msg) if error_message else error_msg
        # DB 로그 업데이트 (처리 오류)
        if db_service and log_id is not None:
            db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
        return new_state


def build_gemini_graph(config_service: ConfigService) -> StateGraph:
    """
    Gemini API 호출 및 처리 LangGraph를 빌드합니다.
    ConfigService를 주입받아 노드에서 사용합니다.
    """
    workflow = StateGraph(GeminiGraphState)

    bound_call_gemini = partial(call_gemini, config_service=config_service)
    bound_process_response = partial(process_response, config_service=config_service)

    workflow.add_node("call_gemini", bound_call_gemini)
    workflow.add_node("process_response", bound_process_response)

    workflow.add_edge(START, "call_gemini")
    workflow.add_edge("call_gemini", "process_response")
    workflow.add_edge("process_response", END)

    app = workflow.compile()
    logger.info("Gemini LangGraph compiled successfully.")
    return app



======== src\core\services\prompt_service.py ========

import os
from typing import List, Tuple, Dict, Any # Dict, Any 추가

class PromptService:
    def generate_code_enhancer_prompt(
        self,
        system_text: str,
        user_text: str,
        file_contents: List[Tuple[str, str]], # List of (path, content)
        root_dir: str,
        dir_structure_content: str = "",
        attached_items: List[Dict[str, Any]] = [] # 첨부 파일 목록 추가
    ) -> str:
        """
        Generates the final text prompt for the Code Enhancer mode.
        Includes markers for attached files/images.
        """
        final_prompt_parts = [
            "===SYSTEM===",
            system_text,
            "",
            "===USER===",
            user_text,
            "",
        ]

        # 첨부 파일/이미지 정보 추가 (마커 사용)
        if attached_items:
            final_prompt_parts.append("===ATTACHMENTS===")
            for i, item in enumerate(attached_items):
                item_type = item.get('type', 'unknown')
                item_name = item.get('name', f'attachment_{i+1}')
                if item_type == 'image':
                    final_prompt_parts.append(f"- Image: {item_name} (Data provided separately)")
                elif item_type == 'file':
                    # 파일 내용을 프롬프트에 포함할지 여부 결정 (여기서는 마커만 사용)
                    # file_data = item.get('data')
                    # content_preview = "(Content provided separately)"
                    # if file_data:
                    #     try:
                    #         # 간단한 텍스트 미리보기 (옵션)
                    #         preview = file_data[:100].decode('utf-8', errors='ignore') + ('...' if len(file_data) > 100 else '')
                    #         content_preview = f"(Content starts with: {preview})"
                    #     except: pass
                    final_prompt_parts.append(f"- File: {item_name} (Content provided separately)")
                else:
                    final_prompt_parts.append(f"- Unknown Attachment: {item_name}")
            final_prompt_parts.append("") # 구분선

        # 선택된 파일 내용 추가
        final_prompt_parts.append("===FILES CONTENTS===")
        if not root_dir:
             print("Warning: root_dir is not set for relative path calculation.")
             for path, content in file_contents:
                 final_prompt_parts.append(f"\n======== {path} ========\n{content}\n")
        else:
            for path, content in file_contents:
                try:
                    relative_path = os.path.relpath(path, root_dir)
                except ValueError:
                    relative_path = path
                final_prompt_parts.append(f"\n======== {relative_path} ========\n{content}\n")

        # 디렉토리 구조 추가
        if dir_structure_content and dir_structure_content.strip():
            final_prompt_parts.append("")
            final_prompt_parts.append(dir_structure_content)

        return "\n".join(final_prompt_parts)

    def generate_meta_prompt(
        self,
        meta_template: str,
        meta_user_input: str
    ) -> str:
        """Generates the prompt for the Meta Prompt Builder mode."""
        final_output = meta_template.replace("{{user-input}}", meta_user_input)
        return final_output

    def generate_final_meta_prompt(
        self,
        meta_prompt_content: str,
        user_prompt_content: str,
        variables: dict
    ) -> str:
        """Generates the final prompt by replacing variables in the meta prompt."""
        final_prompt = meta_prompt_content.replace("[[user-prompt]]", user_prompt_content)

        for k, v in variables.items():
            if k != "user-prompt":
                final_prompt = final_prompt.replace(f"[[{k}]]", v)

        return final_prompt



======== src\core\services\state_service.py ========
import os
import json
import shutil
from datetime import datetime
from typing import Optional, List
from pydantic import ValidationError

from core.pydantic_models.app_state import AppState
from utils.helpers import get_resource_path # 리소스 경로 함수 사용

# 상태 파일 저장 디렉토리 (resources/status)
STATUS_DIR = get_resource_path("status")

class StateService:
    def __init__(self, status_dir: str = STATUS_DIR):
        self.status_dir = status_dir
        os.makedirs(self.status_dir, exist_ok=True)

    def _get_state_file_path(self, filename: str) -> str:
        """Constructs the full path for a state file."""
        # 파일 이름에 .json 확장자가 없으면 추가
        if not filename.lower().endswith(".json"):
            filename += ".json"
        return os.path.join(self.status_dir, filename)

    def save_state(self, state: AppState, filename: str) -> bool:
        """Saves the application state (Pydantic model) to a JSON file."""
        file_path = self._get_state_file_path(filename)
        try:
            # Pydantic 모델을 JSON 문자열로 직렬화 (indent 적용)
            state_json = state.model_dump_json(indent=4)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State saved successfully to {file_path}")
            return True
        except ValidationError as e:
            print(f"State validation error before saving: {e}")
            return False
        except Exception as e:
            print(f"Error saving state to {file_path}: {str(e)}")
            return False

    def load_state(self, filename: str) -> Optional[AppState]:
        """Loads application state from a JSON file into a Pydantic model."""
        file_path = self._get_state_file_path(filename)
        if not os.path.exists(file_path):
            print(f"State file not found: {file_path}. Returning default state.")
            return AppState() # 파일 없으면 기본 상태 반환

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            # JSON 데이터를 Pydantic 모델로 파싱 및 유효성 검사
            state = AppState.model_validate(state_data)
            print(f"State loaded successfully from {file_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from {file_path}: {e}. Returning default state.")
            return AppState()
        except ValidationError as e:
            print(f"State validation error loading from {file_path}: {e}. Returning default state.")
            # 유효성 검사 실패 시 기본값 반환 또는 더 엄격한 처리 가능
            return AppState()
        except Exception as e:
            print(f"Error loading state from {file_path}: {str(e)}. Returning default state.")
            return AppState()

    def import_state_from_file(self, import_path: str) -> Optional[AppState]:
        """Imports state from an external JSON file."""
        if not os.path.exists(import_path):
            print(f"Import file not found: {import_path}")
            return None # 가져올 파일 없으면 None 반환

        try:
            with open(import_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            state = AppState.model_validate(state_data)
            print(f"State imported successfully from {import_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from import file {import_path}: {e}")
            return None
        except ValidationError as e:
            print(f"Imported state validation error: {e}")
            return None
        except Exception as e:
            print(f"Error importing state from {import_path}: {str(e)}")
            return None

    def export_state_to_file(self, state: AppState, export_path: str) -> bool:
        """Exports the current state to an external JSON file."""
        try:
            dir_path = os.path.dirname(export_path)
            if dir_path:
                os.makedirs(dir_path, exist_ok=True)
            state_json = state.model_dump_json(indent=4)
            with open(export_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State exported successfully to {export_path}")
            return True
        except ValidationError as e:
             print(f"State validation error before exporting: {e}")
             return False
        except Exception as e:
            print(f"Error exporting state to {export_path}: {str(e)}")
            return False

    def list_states(self) -> List[str]:
        """Lists available state files (JSON) in the status directory."""
        if not os.path.exists(self.status_dir):
            return []
        try:
            files = os.listdir(self.status_dir)
            # .json 파일만 필터링
            return [f for f in files if f.lower().endswith(".json")]
        except Exception as e:
            print(f"Error listing states in {self.status_dir}: {e}")
            return []

    def delete_state(self, filename: str) -> bool:
        """Deletes a specific state file."""
        file_path = self._get_state_file_path(filename)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                print(f"Deleted state file: {file_path}")
                return True
            except Exception as e:
                print(f"Error deleting state file {file_path}: {e}")
                return False
        else:
            print(f"State file not found for deletion: {file_path}")
            return False

    def backup_all_states(self, backup_path: str) -> bool:
        """Backs up all state files into a zip archive."""
        if not os.path.isdir(self.status_dir):
            print("Status directory does not exist. Nothing to backup.")
            return False

        # Ensure backup path ends with .zip
        if not backup_path.lower().endswith(".zip"):
            backup_path += ".zip"

        base_dir = os.path.dirname(backup_path)
        if base_dir:
            os.makedirs(base_dir, exist_ok=True)

        # shutil.make_archive needs the archive name without extension
        archive_name = backup_path[:-4]

        try:
            shutil.make_archive(archive_name, 'zip', self.status_dir)
            print(f"All states successfully backed up to {backup_path}")
            return True
        except Exception as e:
            print(f"Error backing up states to {backup_path}: {str(e)}")
            return False

    def restore_states_from_backup(self, backup_path: str) -> bool:
        """Restores states from a zip archive, overwriting existing ones."""
        if not os.path.exists(backup_path):
            print(f"Backup file not found: {backup_path}")
            return False

        try:
            # Remove existing status directory before restoring if it exists
            if os.path.exists(self.status_dir):
                shutil.rmtree(self.status_dir)
            os.makedirs(self.status_dir, exist_ok=True) # Ensure directory exists

            # Unpack the archive into the status directory
            shutil.unpack_archive(backup_path, self.status_dir, 'zip')
            print(f"States successfully restored from {backup_path} to {self.status_dir}")
            return True
        except Exception as e:
            print(f"Error restoring states from {backup_path}: {str(e)}")
            return False



======== src\core\services\template_service.py ========
import os
from typing import List

# 변경된 경로에서 import
from utils.helpers import get_resource_path

class TemplateService:
    def __init__(self, base_resource_path: str = "resources"):
        pass

    def _get_full_path(self, relative_path: str) -> str:
        """Constructs the full path using get_resource_path."""
        # 예: relative_path = "prompts/system/my_template.md"
        return get_resource_path(relative_path)

    def list_templates(self, directory: str) -> List[str]:
        """Lists Markdown templates in a given directory relative to resources."""
        # directory 예: "prompts/system"
        full_dir_path = self._get_full_path(directory)
        if not os.path.exists(full_dir_path) or not os.path.isdir(full_dir_path):
            print(f"Template directory not found: {full_dir_path}")
            return []
        try:
            files = os.listdir(full_dir_path)
            # .md 파일만 필터링
            return [f for f in files if f.lower().endswith(".md")]
        except Exception as e:
            print(f"Error listing templates in {full_dir_path}: {e}")
            return []

    def load_template(self, file_path: str) -> str:
        """Loads content from a template file relative to resources."""
        # file_path 예: "prompts/user/example.md"
        full_file_path = self._get_full_path(file_path)
        if not os.path.exists(full_file_path):
            print(f"Template file not found: {full_file_path}")
            return "" # 파일 없으면 빈 문자열 반환
        try:
            with open(full_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            print(f"Template loaded successfully from {full_file_path}")
            return content
        except Exception as e:
            print(f"Error loading template {full_file_path}: {str(e)}")
            return "" # 오류 시 빈 문자열 반환

    def save_template(self, file_path: str, content: str) -> bool:
        """Saves content to a template file relative to resources."""
        # file_path 예: "prompts/system/new_template.md"
        full_file_path = self._get_full_path(file_path)
        try:
            # 디렉토리 생성 (필요한 경우)
            os.makedirs(os.path.dirname(full_file_path), exist_ok=True)
            with open(full_file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"Template saved successfully to {full_file_path}")
            return True
        except Exception as e:
            print(f"Error saving template to {full_file_path}: {str(e)}")
            return False

    def delete_template(self, file_path: str) -> bool:
        """Deletes a template file relative to resources."""
        # file_path 예: "prompts/system/old_template.md"
        full_file_path = self._get_full_path(file_path)
        if os.path.exists(full_file_path):
            try:
                os.remove(full_file_path)
                print(f"Deleted template file: {full_file_path}")
                return True
            except Exception as e:
                print(f"Error deleting template file {full_file_path}: {e}")
                return False
        else:
            print(f"Template file not found for deletion: {full_file_path}")
            return False


======== src\core\services\token_service.py ========

import os
import threading
from typing import Optional, Dict, Any, List, Union
import tiktoken
import mimetypes
import base64
import logging

# --- Optional Imports for API Calls ---
try:
    import google.generativeai as genai
    from google.generativeai.types import ContentDict, PartDict
    from google.api_core import exceptions as google_api_exceptions
    _GOOGLE_GENAI_AVAILABLE = True
except ImportError:
    _GOOGLE_GENAI_AVAILABLE = False
    print("Warning: google-generativeai not installed. Gemini token calculation via API disabled.")

try:
    import anthropic
    _ANTHROPIC_AVAILABLE = True
except ImportError:
    _ANTHROPIC_AVAILABLE = False
    print("Warning: anthropic not installed. Claude token calculation via API disabled.")

# --- Service Dependencies ---
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .config_service import ConfigService
    from core.pydantic_models.config_settings import ConfigSettings

# --- Tiktoken Encoding Cache ---
_enc_cache: Dict[str, tiktoken.Encoding] = {}
_enc_lock = threading.Lock()

# 로거 설정
logger = logging.getLogger(__name__)


def _get_encoding(encoding_name: str = "o200k_base") -> Optional[tiktoken.Encoding]:
    """Gets or loads a tiktoken encoding."""
    with _enc_lock:
        if encoding_name not in _enc_cache:
            try:
                print(f"Loading tiktoken encoding: {encoding_name}...")
                _enc_cache[encoding_name] = tiktoken.get_encoding(encoding_name)
                print(f"Tiktoken encoding '{encoding_name}' loaded.")
            except Exception as e:
                print(f"Error loading tiktoken encoding '{encoding_name}': {e}")
                _enc_cache[encoding_name] = None
        return _enc_cache[encoding_name]

# --- Token Calculation Service ---
class TokenCalculationService:
    """Handles token calculation for different LLM providers."""

    def __init__(self, config_service: 'ConfigService'):
        """Initializes the service."""
        self.config_service = config_service
        # Settings are now fetched when needed via config_service.get_settings()
        self.anthropic_client: Optional[anthropic.Anthropic] = None
        self.gemini_configured = False
        self._init_clients() # Combined initialization

    def _get_settings(self) -> 'ConfigSettings':
        """Helper to get current settings."""
        return self.config_service.get_settings()

    def _init_clients(self):
        """Initializes API clients based on keys found in config settings."""
        settings = self._get_settings()

        # Initialize Gemini
        if _GOOGLE_GENAI_AVAILABLE:
            api_key = settings.gemini_api_key
            if api_key:
                try:
                    genai.configure(api_key=api_key)
                    print("Google Generative AI SDK configured using API key from DB.")
                    self.gemini_configured = True
                except Exception as e:
                    print(f"Error configuring Google Generative AI SDK: {e}")
                    self.gemini_configured = False
            else:
                print("Warning: Gemini API key not found in DB config. Gemini token calculation might fail.")
                self.gemini_configured = False
        else:
             self.gemini_configured = False

        # Initialize Anthropic
        if _ANTHROPIC_AVAILABLE:
            api_key = settings.anthropic_api_key
            if api_key:
                try:
                    self.anthropic_client = anthropic.Anthropic(api_key=api_key)
                    print("Anthropic client initialized using API key from DB.")
                except Exception as e:
                    self.anthropic_client = None
                    print(f"Error initializing Anthropic client: {e}")
            else:
                self.anthropic_client = None
                print("Warning: Anthropic API key not found in DB config. Claude token calculation via API disabled.")
        else:
            self.anthropic_client = None


    def calculate_tokens(
        self,
        model_type: str,
        model_name: str,
        text: str,
        attachments: Optional[List[Dict[str, Any]]] = None
    ) -> Optional[int]:
        """
        Calculates the number of tokens for the given text and attachments
        based on the model type and name.

        Args:
            model_type: "GPT", "Claude", or "Gemini".
            model_name: The specific model identifier.
            text: The input text to tokenize.
            attachments: List of attached items (dicts with 'type', 'name', 'data'/'path').

        Returns:
            The calculated token count, or None if calculation fails.
        """
        print(f"Calculating tokens for Model Type: {model_type}, Model Name: {model_name}")
        attachments = attachments or []

        # Re-initialize clients in case API keys changed in DB (though config is loaded once now)
        # self._init_clients() # Might be redundant if config is loaded once

        if model_type == "GPT":
            if attachments:
                print("Warning: GPT token calculation currently only supports text. Attachments ignored.")
            return self._calculate_gpt_tokens(text)
        elif model_type == "Claude":
            if attachments:
                 print("Warning: Claude token calculation currently only supports text. Attachments ignored.")
            return self._calculate_claude_tokens(model_name, text)
        elif model_type == "Gemini":
            return self._calculate_gemini_tokens(model_name, text, attachments)
        else:
            print(f"Error: Unknown model type '{model_type}'")
            return None

    def _calculate_gpt_tokens(self, text: str) -> Optional[int]:
        """Calculates tokens using tiktoken (assuming o200k_base for newer models)."""
        enc = _get_encoding("o200k_base")
        if enc is None:
            print("Token calculation failed: Tiktoken encoding not available.")
            return None
        try:
            if not text: return 0
            return len(enc.encode(text))
        except Exception as e:
            print(f"Error calculating GPT tokens with tiktoken: {str(e)}")
            return None

    def _calculate_claude_tokens(self, model_name: str, text: str) -> Optional[int]:
        """Calculates tokens using the Anthropic API (currently text only)."""
        if not _ANTHROPIC_AVAILABLE or self.anthropic_client is None:
            print("Claude token calculation skipped: Anthropic SDK not available or API key missing/invalid.")
            return None
        if not model_name:
            print("Claude token calculation skipped: Model name is required.")
            return None
        if not text: return 0

        try:
            messages = [{"role": "user", "content": text}]
            count_response = self.anthropic_client.messages.count_tokens(
                model=model_name,
                messages=messages
            )
            token_count = count_response.input_tokens
            print(f"Claude API token count (text only): {token_count}")
            return token_count
        except anthropic.APIConnectionError as e:
             print(f"Claude API connection error during token count: {e}")
             return None
        except anthropic.AuthenticationError as e:
             print(f"Claude API authentication error (check API key): {e}")
             return None
        except anthropic.RateLimitError as e:
             print(f"Claude API rate limit exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Claude tokens via API: {str(e)}")
            return None

    def _calculate_gemini_tokens(
        self,
        model_name: str,
        text: str,
        attachments: List[Dict[str, Any]]
    ) -> Optional[int]:
        """Calculates tokens using the google-generativeai SDK (multimodal)."""
        if not _GOOGLE_GENAI_AVAILABLE:
            print("Gemini token calculation skipped: google-generativeai SDK not available.")
            return None
        if not self.gemini_configured:
             print("Gemini token calculation skipped: Gemini API key not configured or invalid.")
             return None
        if not model_name:
            print("Gemini token calculation skipped: Model name is required.")
            return None

        contents_list: List[Union[str, Dict[str, Any]]] = []
        effective_model_name = ""
        try:
            if text:
                contents_list.append(text)

            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type')
                    item_name = attachment.get('name', 'unknown')
                    item_data = attachment.get('data')
                    item_path = attachment.get('path')

                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e:
                            logger.error(f"Token Calc: Failed to read attachment {item_path}: {e}")
                            continue
                    if not item_data: continue

                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name)
                        if not mime_type: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list:
                print("Token calculation skipped: No content (text or attachments) provided.")
                return 0

            effective_model_name = model_name.replace("models/", "")
            print(f"Instantiating genai.GenerativeModel for token count: {effective_model_name}")
            model = genai.GenerativeModel(effective_model_name)

            print(f"Calling model.count_tokens for model: {effective_model_name} with {len(contents_list)} content parts")
            response = model.count_tokens(contents=contents_list)

            token_count = response.total_tokens
            print(f"Gemini API token count (multimodal): {token_count}")
            return token_count

        except AttributeError as e:
             log_message = (
                 f"AttributeError during Gemini token calculation: {e}. "
                 f"Check SDK version and content structure."
             )
             logger.error(log_message, exc_info=True)
             print(f"Gemini token calculation failed due to AttributeError: {e}")
             return None
        except google_api_exceptions.PermissionDenied as e:
             print(f"Gemini API permission error during token count (check API key): {e}")
             # Invalidate configuration if key is bad?
             # self.gemini_configured = False
             return None
        except google_api_exceptions.InvalidArgument as e:
             print(f"Gemini API invalid argument error during token count: {e}")
             print(f"Hint: Check if model '{effective_model_name}' supports multimodal count_tokens or the provided content types/structure.")
             return None
        except google_api_exceptions.ResourceExhausted as e:
             print(f"Gemini API rate limit likely exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Gemini tokens via API: {str(e)}")
            logger.error(f"Unexpected error calculating Gemini tokens: {e}", exc_info=True)
            return None

# Preload default encoding on module import
_get_encoding()



======== src\core\services\xml_service.py ========
import os
import xml.etree.ElementTree as ET
from typing import Dict, List
import logging # 로깅 추가

logger = logging.getLogger(__name__) # 로거 설정

class XmlService:
    def apply_changes_from_xml(self, xml_string: str, project_directory: str) -> Dict[str, List[str]]:
        """
        Parses XML string and applies file changes (CREATE, UPDATE, DELETE)
        within the specified project directory.
        Handles removing surrounding Markdown code block markers if present.
        Removes leading whitespace/newlines from file content before writing.
        Handles trailing Markdown code block markers (like ```)

        Returns a dictionary summarizing the results:
        {
            "created": [list of created file paths],
            "updated": [list of updated file paths],
            "deleted": [list of deleted file paths],
            "errors": [list of error messages]
        }
        """
        result = {
            "created": [],
            "updated": [],
            "deleted": [],
            "errors": []
        }

        if not project_directory or not os.path.isdir(project_directory):
            result["errors"].append(f"Invalid project directory: {project_directory}")
            return result

        if not xml_string or not xml_string.strip():
            result["errors"].append("XML input string is empty.")
            return result

        # --- Add logic to strip Markdown code block markers ---
        cleaned_xml_string = xml_string.strip()
        # 다양한 마커 형태 고려 (예: ```xml, ```, ````xml, ```` 등)
        markdown_markers = ["```xml", "```", "````xml", "````", '"""', "'''"] # 종료 마커 추가

        # 시작 마커 제거
        for marker in markdown_markers:
            if cleaned_xml_string.startswith(marker):
                # 마커 길이만큼 제거하고, 이후 공백/줄바꿈 제거
                cleaned_xml_string = cleaned_xml_string[len(marker):].lstrip()
                logger.debug(f"Removed starting marker: {marker}")
                break # 하나의 시작 마커만 처리

        # 끝 마커 제거 (수정: 여러 종류의 종료 마커 제거)
        temp_string = cleaned_xml_string.rstrip() # 끝 마커 확인 전 후행 공백/줄바꿈 제거
        marker_removed = False
        for marker in markdown_markers:
            if temp_string.endswith(marker):
                # 마커 길이만큼 제거하고, 이전 공백/줄바꿈 제거
                cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                logger.debug(f"Removed ending marker: {marker}")
                marker_removed = True
                break # 하나의 끝 마커만 처리
        # 만약 마커 제거 후에도 마커가 남아있을 수 있는 경우(예: """\n```) 추가 처리
        if marker_removed:
            temp_string = cleaned_xml_string.rstrip()
            for marker in markdown_markers:
                 if temp_string.endswith(marker):
                      cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                      logger.debug(f"Removed secondary ending marker: {marker}")
                      break

        if not cleaned_xml_string:
             result["errors"].append("XML input string became empty after removing potential Markdown markers.")
             logger.warning("XML input is empty after cleaning.")
             return result
        # --- End of Markdown marker stripping logic ---

        try:
            # XML 파싱 (정리된 문자열 사용)
            logger.info("Attempting to parse cleaned XML string...")
            root = ET.fromstring(cleaned_xml_string)
            logger.info(f"XML parsed successfully. Root element: <{root.tag}>")
        except ET.ParseError as e:
            error_msg = f"Invalid XML format after cleaning: {str(e)}"
            result["errors"].append(error_msg)
            # 파싱 실패 시 문제 문자열 일부 로깅
            context_length = 100 # 오류 주변 문자열 길이
            error_line = getattr(e, 'lineno', '?')
            error_pos = getattr(e, 'offset', '?') # position 속성이 없을 수 있음 (offset 사용)
            start = max(0, e.position[1] - context_length//2) if hasattr(e, 'position') else 0
            end = start + context_length
            problematic_xml_snippet = cleaned_xml_string[start:end]
            logger.error(f"XML ParseError: {e}, Line: {error_line}, Pos: {error_pos}. Problematic snippet near error: ...{problematic_xml_snippet}...")
            return result
        except Exception as e:
             # Catch other potential errors during fromstring
             error_msg = f"Error parsing XML string: {str(e)}"
             result["errors"].append(error_msg)
             logger.exception(f"Unexpected error during XML parsing: {e}") # 스택 트레이스 로깅
             return result


        changed_files_node = root.find('changed_files')
        if changed_files_node is None:
            # If <changed_files> is missing but parsing was successful, it might be an empty XML response.
            # Treat as no changes rather than an error, unless it's entirely empty or unexpected structure.
            # Let's check if the root tag itself is also unexpected.
            if root.tag not in ['code_changes', 'root', 'response']: # Add common root tags
                 result["errors"].append(f"No <changed_files> node found and unexpected root tag '{root.tag}' in XML.")
                 logger.warning(f"XML parsing successful but no <changed_files> node found and unexpected root tag: {root.tag}")
            else:
                 # Successful parse, but no changed_files node. Assume no changes.
                 logger.info("XML parsed successfully but no <changed_files> node found. Assuming no changes.") # 로깅 사용
            return result # Return with errors if any added, or empty result

        for file_node in changed_files_node.findall('file'):
            file_op_node = file_node.find('file_operation')
            file_path_node = file_node.find('file_path')
            file_code_node = file_node.find('file_code') # CDATA 내용 포함

            if file_op_node is None or file_path_node is None:
                result["errors"].append("Skipping file entry: missing file_operation or file_path.")
                logger.warning("Skipping file entry in XML: missing file_operation or file_path.")
                continue

            operation = file_op_node.text.strip().upper() if file_op_node.text else "UNKNOWN"
            relative_path = file_path_node.text.strip() if file_path_node.text else None

            if not relative_path:
                result["errors"].append(f"Skipping file entry: file_path is empty for operation {operation}.")
                logger.warning(f"Skipping file entry in XML: file_path is empty for operation {operation}.")
                continue

            # 보안: 경로 조작 방지 (상대 경로가 프로젝트 디렉토리를 벗어나지 않도록 확인)
            # 정규화된 경로 사용
            try:
                 target_path = os.path.abspath(os.path.join(project_directory, relative_path.lstrip('/\\')))
                 if not target_path.startswith(os.path.abspath(project_directory)):
                    result["errors"].append(f"Skipping potentially unsafe path: {relative_path}")
                    logger.error(f"Security risk: Attempted path traversal detected! Path: '{relative_path}', Target: '{target_path}', Project Root: '{os.path.abspath(project_directory)}'")
                    continue
            except Exception as path_e:
                 result["errors"].append(f"Error processing path '{relative_path}': {path_e}")
                 logger.error(f"Error processing path '{relative_path}': {path_e}", exc_info=True)
                 continue

            # Ensure path separator consistency if needed, but os.path.join handles this locally.
            # For comparison against input, maybe normalize relative_path too? Not critical for security check here.

            file_code = file_code_node.text if file_code_node is not None and file_code_node.text is not None else None

            try:
                if operation in ["CREATE", "UPDATE"]:
                    # Allow empty file_code for creating/updating empty files
                    # if file_code is None: # Changed: Allow None/empty string for file_code
                    #     result["errors"].append(f"Skipping {operation} for '{relative_path}': file_code is missing.")
                    #     continue

                    # Ensure directory exists
                    os.makedirs(os.path.dirname(target_path), exist_ok=True)

                    # Write file, handle None/empty file_code as empty content
                    # *** 수정: 파일 내용 앞쪽 공백/개행 제거 ***
                    with open(target_path, 'w', encoding='utf-8') as f:
                        # file_code가 None이 아니고, 문자열일 경우 앞쪽 공백/개행 제거
                        content_to_write = file_code.lstrip() if file_code is not None and isinstance(file_code, str) else ""
                        f.write(content_to_write)
                        logger.debug(f"Writing content (leading whitespace stripped) to: {target_path}") # 로깅 추가

                    if operation == "CREATE":
                        result["created"].append(target_path)
                        logger.info(f"File CREATED: {target_path}") # 로깅 사용
                    else: # UPDATE
                        result["updated"].append(target_path)
                        logger.info(f"File UPDATED: {target_path}") # 로깅 사용

                elif operation == "DELETE":
                    if os.path.exists(target_path):
                        if os.path.isfile(target_path):
                            os.remove(target_path)
                            result["deleted"].append(target_path)
                            logger.info(f"File DELETED: {target_path}") # 로깅 사용
                        elif os.path.isdir(target_path):
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is a directory, not a file.")
                             logger.warning(f"Skipping DELETE for directory: {target_path}")
                        else:
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is not a regular file.")
                             logger.warning(f"Skipping DELETE for non-file item: {target_path}")
                    else:
                        # 삭제할 파일이 없는 경우, 오류보다는 경고 또는 무시가 나을 수 있음
                        logger.warning(f"File not found for deletion (ignored): {target_path}") # 로깅 사용

                elif operation == "NONE":
                    # 수정 없음 처리 (로그 또는 아무 작업 안 함)
                    logger.debug(f"Operation NONE for: {target_path}") # Log level DEBUG
                    pass

                else:
                    result["errors"].append(f"Unknown file operation '{operation}' for file: {relative_path}")
                    logger.warning(f"Unknown file operation '{operation}' found in XML for path: {relative_path}")

            except OSError as e:
                 result["errors"].append(f"OS error during {operation} for '{relative_path}': {e}")
                 logger.error(f"OS error during {operation} for '{relative_path}': {e}", exc_info=True) # 로깅 추가
            except Exception as e:
                result["errors"].append(f"Unexpected error during {operation} for '{relative_path}': {str(e)}")
                logger.exception(f"Unexpected error during {operation} for '{relative_path}'") # 로깅 추가

        return result



======== src\core\__init__.py ========
# This file makes Python treat the directory core as a package.



======== src\core\langgraph_state.py ========

from typing import TypedDict, Optional, List, Dict, Any # List, Dict, Any 추가

class GeminiGraphState(TypedDict):
    """
    LangGraph 상태 정의: Gemini API 호출 및 결과 처리를 위한 상태 관리
    """
    input_prompt: str             # Gemini API에 전달될 최종 텍스트 프롬프트
    input_attachments: List[Dict[str, Any]] # 첨부된 파일/이미지 데이터 목록 (멀티모달용)
    selected_model_name: str      # LangGraph 실행 시 선택된 모델명 (추가)
    gemini_response: str          # Gemini API의 원시 응답
    xml_output: str               # 파싱된 XML 부분
    summary_output: str           # 파싱된 Summary 부분
    error_message: Optional[str] = None # 오류 발생 시 메시지 저장 (선택적)
    log_id: Optional[int] = None  # DB 로그 ID 저장 (추가)




======== src\ui\controllers\__init__.py ========
# This file makes Python treat the directory controllers as a package.



======== src\ui\controllers\file_tree_controller.py ========
import os
import shutil
from typing import Optional, List, Set
from PyQt6.QtCore import Qt, QModelIndex, QItemSelection, QTimer # QTimer 추가
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox # PyQt5 -> PyQt6
import logging # 로깅 추가

# 서비스 및 모델 import
from core.services.filesystem_service import FilesystemService
from core.services.config_service import ConfigService
from core.services.directory_cache_service import DirectoryCacheService, CacheNode # Added

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from ui.models.cached_file_system_model import CachedFileSystemModel # Added

logger = logging.getLogger(__name__) # 로거 설정

class FileTreeController:
    """
    Handles logic related to the file tree view, including interactions,
    filesystem operations, and gitignore handling.
    Uses DirectoryCacheService for data and updates.
    """
    def __init__(self, main_window: 'MainWindow', fs_service: FilesystemService, config_service: ConfigService, cache_service: DirectoryCacheService):
        self.mw = main_window
        self.fs_service = fs_service
        self.config_service = config_service
        self.cache_service = cache_service # Added
        self.gitignore_path: Optional[str] = None # .gitignore 파일 경로 저장
        self._is_refreshing = False # Prevent recursive refresh calls

        # Connect cache service signals
        self.cache_service.scan_progress.connect(self._update_scan_progress)
        self.cache_service.scan_error.connect(self._handle_scan_error)
        # cache_updated signal is connected in main_window to update the model

    def _update_scan_progress(self, message: str):
        """Updates the status bar with scan progress."""
        self.mw.status_bar.showMessage(f"Scanning: {message}")

    def _handle_scan_error(self, error_msg: str):
        """Handles scan errors reported by the cache service."""
        QMessageBox.warning(self.mw, "Scan Error", f"Error scanning project folder:\n{error_msg}")
        self.mw.status_bar.showMessage(f"Scan failed: {error_msg}")
        # Reset tree view if scan fails?
        self.reset_file_tree()

    def select_project_folder(self):
        """Opens a dialog to select the project folder and triggers a background scan."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 프로젝트 폴더 선택이 필요 없습니다.")
            return

        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        folder = QFileDialog.getExistingDirectory(self.mw, "프로젝트 폴더 선택", start_dir)

        if folder:
            logger.info(f"Project folder selected: {folder}")
            # Stop previous scan/monitoring if any
            self.cache_service.stop_scan()
            self.cache_service.stop_monitoring()

            # Reset UI state related to the old project
            self.mw.reset_state() # Resets internal state, clears tree model via signal

            # Update UI labels and internal state
            self.mw.current_project_folder = folder
            folder_name = os.path.basename(folder)
            self.mw.project_folder_label.setText(f"현재 프로젝트 폴더: {folder}")
            self.mw.update_window_title(folder_name)

            # Load gitignore patterns for the new folder
            ignore_patterns = self.load_gitignore_settings()

            # Start background scan via DirectoryCacheService
            self.mw.status_bar.showMessage(f"Starting scan for {folder}...")
            self.cache_service.start_scan(folder, ignore_patterns)

            # Tree view will be populated when the scan finishes and cache_updated signal is emitted
            # No need to set root index here directly

            # Trigger state change signal
            self.mw.state_changed_signal.emit()

    def load_gitignore_settings(self) -> Set[str]:
        """Loads .gitignore patterns and updates the filter model and cache service."""
        self.gitignore_path = None
        patterns: Set[str] = set()

        settings = self.config_service.get_settings()
        patterns.update(settings.default_ignore_list)

        if self.mw.current_project_folder:
            possible_path = os.path.join(self.mw.current_project_folder, ".gitignore")
            if os.path.isfile(possible_path):
                self.gitignore_path = possible_path
                try:
                    with open(self.gitignore_path, 'r', encoding='utf-8') as f:
                        lines = f.read().splitlines()
                    gitignore_lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                    patterns.update(gitignore_lines)
                    logger.info(f"Loaded {len(gitignore_lines)} patterns from {self.gitignore_path}")
                except Exception as e:
                    QMessageBox.warning(self.mw, "Error", f".gitignore 로드 중 오류: {str(e)}")
                    logger.error(f"Error loading .gitignore: {e}", exc_info=True)

        # config.yml의 excluded_dirs 추가
        patterns.update(settings.excluded_dirs)
        logger.info(f"Total ignore patterns (including defaults and excluded_dirs): {len(patterns)}")

        # Update ignore patterns in the cache service (for watchdog)
        self.cache_service.update_ignore_patterns(patterns)

        # Update patterns in the proxy model (for UI filtering)
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(patterns)
             # Filter invalidation happens inside set_ignore_patterns
             # No need to call refresh_tree here, cache update will handle UI refresh

        return patterns # Return patterns for initial scan

    def save_gitignore_settings(self):
        """Saves the content of the gitignore editor to the .gitignore file. (Moved to SettingsDialog)"""
        QMessageBox.information(self.mw, "정보", ".gitignore 저장은 환경 설정 메뉴에서 수행해주세요.")

    def reset_gitignore_and_filter(self):
        """Resets gitignore filter to defaults based on config.yml."""
        logger.info("Resetting gitignore filter to defaults.")
        default_settings = self.config_service.get_settings()
        default_patterns = set(default_settings.default_ignore_list).union(default_settings.excluded_dirs)

        # Update cache service and proxy model
        self.cache_service.update_ignore_patterns(default_patterns)
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(default_patterns)
             # Trigger a refresh/rescan if patterns changed significantly?
             # For now, rely on cache_updated signal if filtering changes visibility
             # Consider adding a manual refresh button if needed.
             # self.refresh_tree() # Avoid manual refresh, let model update handle it

    def reset_file_tree(self):
        """Resets the file tree view by clearing the model."""
        logger.info("Resetting file tree view.")
        if hasattr(self.mw, 'cached_model'):
            self.mw.cached_model.clear() # Clear the QStandardItemModel
            logger.info("Cached file system model cleared.")
        # Check state dictionary is cleared in MainWindow's reset_state


    def generate_directory_tree_structure(self):
        """Generates the directory tree structure based on checked items from the cache."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 디렉토리 트리 기능이 필요 없습니다.")
            return False

        if not self.mw.current_project_folder:
            QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
            return False

        all_checked_paths = self.mw.checkable_proxy.get_all_checked_paths() if hasattr(self.mw, 'checkable_proxy') else []
        if not all_checked_paths:
            message = "선택된 파일이나 폴더가 없습니다."
            if hasattr(self.mw, "dir_structure_tab"):
                self.mw.dir_structure_tab.setText(message)
                self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
            self.mw.status_bar.showMessage("파일 트리를 생성할 항목이 없습니다!")
            return False

        logger.info(f"Generating directory tree for {len(all_checked_paths)} checked items.")
        try:
            # Use FilesystemService, which doesn't rely on the cache directly
            # It operates on the list of checked paths provided.
            tree_string = self.fs_service.get_directory_tree(all_checked_paths, self.mw.current_project_folder)
        except Exception as e:
             QMessageBox.critical(self.mw, "오류", f"디렉토리 트리 생성 중 오류 발생: {e}")
             logger.error(f"Error generating directory tree: {e}", exc_info=True)
             return False

        if hasattr(self.mw, "dir_structure_tab"):
            self.mw.dir_structure_tab.setText(tree_string)
            self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
        self.mw.status_bar.showMessage("File tree generated!")
        self.mw.tree_generated = True # MainWindow 상태 업데이트
        logger.info("Directory tree generation successful.")
        return True

    def rename_item(self, file_path):
        """Renames a file or directory. Watchdog should handle the update."""
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "파일 또는 디렉토리가 존재하지 않습니다.")
            return

        base_dir = os.path.dirname(file_path)
        old_name = os.path.basename(file_path)
        new_name, ok = QInputDialog.getText(self.mw, "이름 변경", f"'{old_name}'의 새 이름을 입력하세요:", text=old_name)

        if ok and new_name and new_name.strip():
            new_name_stripped = new_name.strip()
            if new_name_stripped == old_name: return
            new_path = os.path.join(base_dir, new_name_stripped)
            if os.path.exists(new_path):
                 QMessageBox.warning(self.mw, "Error", f"'{new_name_stripped}' 이름이 이미 존재합니다.")
                 return

            logger.info(f"Renaming item: '{file_path}' -> '{new_path}'")
            try:
                os.rename(file_path, new_path)
                self.mw.status_bar.showMessage(f"'{old_name}' -> '{new_name_stripped}' 이름 변경 완료. 파일 시스템 감시자가 업데이트합니다.")
                # Update check state dictionary if the renamed item was checked
                if hasattr(self.mw, 'checkable_proxy'):
                    if file_path in self.mw.checkable_proxy.checked_files_dict:
                        is_checked = self.mw.checkable_proxy.checked_files_dict.pop(file_path)
                        self.mw.checkable_proxy.checked_files_dict[new_path] = is_checked
                        logger.debug(f"Updated checked_files_dict for renamed item: {new_path}")
                # No need to manually refresh tree, watchdog + cache service should handle it.
                # self.refresh_tree() # REMOVED
                self.mw.state_changed_signal.emit() # 파일 구조 변경 시 상태 변경
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"이름 변경 중 오류 발생: {str(e)}")
                logger.error(f"Error renaming item: {e}", exc_info=True)
        elif ok:
             QMessageBox.warning(self.mw, "Error", "새 이름은 비워둘 수 없습니다.")

    def delete_item(self, file_path):
        """Deletes a file or directory. Watchdog should handle the update."""
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "파일 또는 디렉토리가 존재하지 않습니다.")
            return

        item_name = os.path.basename(file_path)
        item_type = "폴더" if os.path.isdir(file_path) else "파일"
        reply = QMessageBox.question(self.mw, "삭제 확인",
                                     f"정말로 '{item_name}' {item_type}을(를) 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No

        if reply == QMessageBox.StandardButton.Yes: # QMessageBox.Yes -> QMessageBox.StandardButton.Yes
            logger.info(f"Deleting item: {file_path}")
            try:
                if os.path.isdir(file_path):
                    shutil.rmtree(file_path)
                else:
                    os.remove(file_path)
                self.mw.status_bar.showMessage(f"'{item_name}' 삭제 완료. 파일 시스템 감시자가 업데이트합니다.")
                # Remove the deleted item and any children from the check state dictionary
                if hasattr(self.mw, 'checkable_proxy'):
                    paths_to_remove = [p for p in self.mw.checkable_proxy.checked_files_dict if p == file_path or p.startswith(file_path + os.sep)]
                    removed_count = 0
                    for p in paths_to_remove:
                        if p in self.mw.checkable_proxy.checked_files_dict:
                            del self.mw.checkable_proxy.checked_files_dict[p]
                            removed_count += 1
                    logger.debug(f"Removed {removed_count} items from checked_files_dict after deletion.")
                # No need to manually refresh tree, watchdog + cache service should handle it.
                # self.refresh_tree() # REMOVED
                self.mw.state_changed_signal.emit() # 파일 구조 변경 시 상태 변경
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"삭제 중 오류 발생: {str(e)}")
                logger.error(f"Error deleting item: {e}", exc_info=True)

    def refresh_tree(self):
        """Manually triggers a rescan of the project folder."""
        if self._is_refreshing:
            logger.debug("Refresh already in progress, skipping.")
            return
        if not self.mw.current_project_folder:
            logger.warning("Cannot refresh tree: Project folder not set.")
            return

        logger.info("Manually refreshing file tree by triggering rescan...")
        self._is_refreshing = True
        self.mw.status_bar.showMessage(f"Refreshing project folder: {self.mw.current_project_folder}...")
        # Get current ignore patterns
        ignore_patterns = self.load_gitignore_settings()
        # Start scan via cache service
        self.cache_service.start_scan(self.mw.current_project_folder, ignore_patterns)
        # Use a timer to reset the flag after a short delay, preventing rapid clicks
        QTimer.singleShot(2000, self._reset_refresh_flag) # Reset flag after 2 seconds

    def _reset_refresh_flag(self):
        self._is_refreshing = False
        logger.debug("Refresh flag reset.")


    def on_data_changed(self):
        """Handles updates when the check state dictionary changes."""
        # This method is now parameter-less. Its main job is to update UI elements
        # that depend on the list of checked files, but not on the specifics of the change.
        if hasattr(self.mw, 'checkable_proxy'):
            checked_files = self.mw.checkable_proxy.get_checked_files()
            self.mw.status_bar.showMessage(f"{len(checked_files)} files selected.")
            # The state changed signal is now emitted directly from the proxy model
            # so no need to emit it here.
            # self.mw.state_changed_signal.emit()



======== src\ui\controllers\main_controller.py ========

import os
import base64 # 추가
import mimetypes # 추가
import logging # 로깅 추가
from typing import Optional, List, Dict, Any
from PyQt6.QtCore import Qt, QModelIndex, QMimeData, QObject, QThread, pyqtSignal, QBuffer, QIODevice # PyQt5 -> PyQt6, QBuffer, QIODevice 추가
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QApplication, QListWidgetItem # PyQt5 -> PyQt6
from PyQt6.QtGui import QImage # PyQt5 -> PyQt6

# 서비스 및 모델 import
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.pydantic_models.app_state import AppState
from utils.helpers import calculate_char_count

# MainWindow는 타입 힌트용으로만 사용 (순환 참조 방지)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .resource_controller import ResourceController
    from .prompt_controller import PromptController
    from .xml_controller import XmlController
    from .file_tree_controller import FileTreeController

# Pillow import 시도 (이미지 처리용)
try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False
    print("Warning: Pillow library not installed. Image handling from clipboard might be limited.")

logger = logging.getLogger(__name__) # 로거 설정

# --- 토큰 계산을 위한 Worker 클래스 ---
class TokenWorker(QObject):
    finished = pyqtSignal(int)      # 계산된 토큰 수 전달
    error = pyqtSignal(str)         # 오류 메시지 전달

    def __init__(self, token_service: TokenCalculationService, model_type: str, model_name: str, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        super().__init__()
        self.token_service = token_service
        self.model_type = model_type
        self.model_name = model_name
        self.text = text
        self.attachments = attachments or []

    def run(self):
        """토큰 계산 로직을 실행합니다."""
        try:
            logger.info(f"Starting token calculation in worker thread for {self.model_type} - {self.model_name}")
            token_count = self.token_service.calculate_tokens(
                self.model_type, self.model_name, self.text, self.attachments
            )
            if token_count is not None:
                logger.info(f"Token calculation finished successfully: {token_count}")
                self.finished.emit(token_count)
            else:
                logger.warning(f"Token calculation returned None for {self.model_type} - {self.model_name}")
                self.error.emit(f"{self.model_type} 토큰 계산 실패 (None 반환)")
        except Exception as e:
            logger.exception(f"Error during token calculation in worker thread for {self.model_type} - {self.model_name}")
            self.error.emit(f"토큰 계산 오류: {str(e)}")


class MainController:
    """
    메인 컨트롤러는 애플리케이션의 전반적인 흐름과
    다른 컨트롤러 간의 조정 역할을 담당 (필요한 경우).
    주요 기능 로직은 각 전문 컨트롤러에 위임.
    토큰 계산을 백그라운드 스레드에서 처리합니다.
    """
    def __init__(self, main_window: 'MainWindow'):
        self.mw = main_window
        self.token_service: TokenCalculationService = self.mw.token_service
        self.config_service: ConfigService = self.mw.config_service
        self.last_token_count: Optional[int] = None
        self.token_thread: Optional[QThread] = None
        self.token_worker: Optional[TokenWorker] = None

    def reset_program(self):
        """Resets the application to its initial state."""
        self._initialized = False
        self.mw.reset_state()
        self._initialized = False

        self.mw.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
        self.mw.system_tab.clear()
        self.mw.user_tab.clear()
        if hasattr(self.mw, "dir_structure_tab"): self.mw.dir_structure_tab.clear()
        if hasattr(self.mw, "xml_input_tab"): self.mw.xml_input_tab.clear()
        if hasattr(self.mw, "prompt_output_tab"): self.mw.prompt_output_tab.clear()
        if hasattr(self.mw, "summary_tab"): self.mw.summary_tab.clear()
        if hasattr(self.mw, "attachment_list_widget"): self.mw.attachment_list_widget.clear() # 첨부 목록 클리어

        self.mw.file_tree_controller.reset_gitignore_and_filter()
        self.mw.file_tree_controller.reset_file_tree()

        self.mw.llm_combo.setCurrentIndex(self.mw.llm_combo.findText("Gemini"))
        self.on_llm_selected()

        self.update_char_count_for_active_tab()
        self.reset_token_label()
        if hasattr(self.mw, 'api_time_label'): # API 시간 라벨 초기화 추가
            self.mw.api_time_label.setText("API 시간: -")

        self.mw.update_window_title()
        self.mw.status_bar.showMessage("프로그램 리셋 완료.")

        self._initialized = True
        QMessageBox.information(self.mw, "Info", "프로그램이 초기 상태로 리셋되었습니다.")
        self.mw.state_changed_signal.emit() # 리셋 후 상태 변경 시그널 발생

    def update_char_count(self, text: str):
        """Updates character count in the status bar."""
        char_count = calculate_char_count(text)
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

    def update_char_count_for_active_tab(self):
        """Updates the character count based on the currently active text edit tab."""
        current_widget = self.mw.build_tabs.currentWidget()
        if hasattr(current_widget, 'toPlainText'):
            self.update_char_count(current_widget.toPlainText())
        else:
            self.mw.char_count_label.setText("Chars: 0")

    def reset_token_label(self):
        """Resets the token count label to its default state."""
        if hasattr(self.mw, '_initialized') and self.mw._initialized:
            self.mw.token_count_label.setText("토큰 계산: -")
            self.last_token_count = None
            # 진행 중인 토큰 계산 스레드 중지 (필요 시)
            self._stop_token_calculation_thread()

    def handle_text_changed(self):
        """Handles text changes in editors: updates char count and resets token label."""
        self.update_char_count_for_active_tab()
        self.reset_token_label()
        # 텍스트 변경 시 상태 변경 시그널 발생 (자동 저장용)
        self.mw.state_changed_signal.emit()


    def calculate_and_display_tokens(self, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        """
        Starts the token calculation in a background thread and updates the status bar.
        """
        if not hasattr(self.mw, '_initialized') or not self.mw._initialized:
            logger.warning("Token calculation skipped: MainWindow not initialized.")
            self.reset_token_label()
            return

        attachments = attachments or []
        char_count = calculate_char_count(text)
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

        # 이전 스레드가 실행 중이면 중지
        self._stop_token_calculation_thread()

        # 텍스트와 첨부파일 모두 없으면 계산 안 함
        if not text and not attachments:
            logger.info("Token calculation skipped: Text and attachments are empty.")
            self.mw.token_count_label.setText("토큰 계산: -")
            self.last_token_count = 0 # 명시적으로 0으로 설정
            return

        selected_llm = self.mw.llm_combo.currentText()
        model_name = self.mw.model_name_combo.currentText().strip()

        if not model_name:
            token_text = f"{selected_llm} 모델명을 선택하거나 입력하세요."
            logger.warning("Token calculation skipped: Model name is empty.")
            self.mw.token_count_label.setText(token_text)
            self.last_token_count = None
            return

        token_text = f"{selected_llm} 토큰 계산 중..."
        self.mw.token_count_label.setText(token_text)
        self.last_token_count = None
        QApplication.processEvents() # UI 업데이트 강제

        logger.info(f"Starting token calculation worker for {selected_llm}, {model_name}...")

        # 스레드 및 워커 생성
        self.token_thread = QThread()
        self.token_worker = TokenWorker(self.token_service, selected_llm, model_name, text, attachments)
        self.token_worker.moveToThread(self.token_thread)

        # 시그널 연결
        self.token_thread.started.connect(self.token_worker.run)
        self.token_worker.finished.connect(self._handle_token_result)
        self.token_worker.error.connect(self._handle_token_error)
        # 스레드 종료 및 객체 정리 연결 (QThread.finished 사용)
        self.token_thread.finished.connect(self._cleanup_token_thread) # 스레드 완료 시 정리 함수 호출
        self.token_worker.finished.connect(self.token_worker.deleteLater) # 워커 완료 시 deleteLater
        self.token_worker.error.connect(self.token_worker.deleteLater) # 워커 오류 시 deleteLater
        # 워커 완료/오류 시 스레드 종료 요청
        self.token_worker.finished.connect(self.token_thread.quit)
        self.token_worker.error.connect(self.token_thread.quit)
        # 스레드 종료 시 deleteLater (메모리 누수 방지)
        self.token_thread.finished.connect(self.token_thread.deleteLater)


        # 스레드 시작
        self.token_thread.start()

    def _handle_token_result(self, token_count: int):
        """Handles the successful result from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText() # 현재 선택된 LLM 확인
        token_text = f"Total Token ({selected_llm}): {token_count:,}"
        self.last_token_count = token_count
        logger.info(f"Token calculation successful. Updating label to: {token_text}")
        self.mw.token_count_label.setText(token_text)
        # self._cleanup_token_thread() # 스레드 정리는 thread.finished 시그널에서 처리

    def _handle_token_error(self, error_msg: str):
        """Handles the error signal from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText() # 현재 선택된 LLM 확인
        token_text = f"{selected_llm} 토큰 계산 오류"
        self.last_token_count = None
        logger.error(f"Token calculation failed: {error_msg}")
        self.mw.token_count_label.setText(token_text)
        # Optionally show a more detailed error in status bar or tooltip
        self.mw.status_bar.showMessage(f"토큰 계산 오류: {error_msg}", 5000) # 5초간 표시
        # self._cleanup_token_thread() # 스레드 정리는 thread.finished 시그널에서 처리

    def _stop_token_calculation_thread(self):
        """Stops the currently running token calculation thread, if any."""
        if self.token_thread and self.token_thread.isRunning():
            logger.info("Stopping previous token calculation thread...")
            self.token_thread.quit() # 종료 요청
            # wait() 호출 - 지정된 시간(ms) 동안 스레드가 종료되기를 기다림
            if not self.token_thread.wait(1000): # 최대 1초 대기
                # 스레드가 제 시간 안에 종료되지 않은 경우
                logger.warning("Token calculation thread did not quit gracefully within 1 second.")
                # terminate() 사용 제거: 강제 종료는 리소스 누수나 불안정성을 야기할 수 있음
                # self.token_thread.terminate()
                # self.token_thread.wait() # terminate 후에도 wait는 필요할 수 있음
            else:
                logger.info("Previous token calculation thread finished gracefully.")
            # 스레드 종료 후 정리 함수 호출 (시그널 핸들러에서 자동으로 호출되도록 변경됨)
            # self._cleanup_token_thread() # 여기서 직접 호출하지 않음


    def _cleanup_token_thread(self):
        """Cleans up the token thread and worker objects."""
        logger.debug("Cleaning up token thread and worker objects.") # 디버그 레벨로 변경
        # 스레드 객체 참조 해제 (이미 deleteLater 연결됨)
        self.token_thread = None
        self.token_worker = None


    def on_llm_selected(self):
        """Handles the selection change in the LLM dropdown."""
        selected_llm = self.mw.llm_combo.currentText()
        available_models = self.config_service.get_available_models(selected_llm)

        self.mw.model_name_combo.blockSignals(True)
        self.mw.model_name_combo.clear()
        self.mw.model_name_combo.addItems(available_models)
        self.mw.model_name_combo.blockSignals(False)

        default_model = self.config_service.get_default_model_name(selected_llm)
        default_index = self.mw.model_name_combo.findText(default_model)
        if default_index != -1:
            self.mw.model_name_combo.setCurrentIndex(default_index)
        elif available_models:
            self.mw.model_name_combo.setCurrentIndex(0)
            logger.warning(f"Default model '{default_model}' not found for {selected_llm}. Selecting first available.")
        else:
             logger.warning(f"No available models found for {selected_llm}.")

        self.reset_token_label()
        self.update_char_count_for_active_tab()

        is_gemini_selected = (selected_llm == "Gemini")
        if hasattr(self.mw, 'gemini_param_widget'):
            self.mw.gemini_param_widget.setVisible(is_gemini_selected)

        # LLM 또는 모델 변경 시 상태 변경 시그널 발생
        self.mw.state_changed_signal.emit()

    # --- Attachment Handling ---
    def attach_files(self):
        """Opens a file dialog to select multiple files for attachment."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "정보", "Meta Prompt Builder 모드에서는 파일 첨부가 필요 없습니다.")
            return

        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        # getOpenFileNames는 파일 경로 리스트와 필터 문자열을 반환
        file_paths, _ = QFileDialog.getOpenFileNames(
            self.mw,
            "파일 첨부",
            start_dir,
            "모든 파일 (*.*);;이미지 파일 (*.png *.jpg *.jpeg *.webp);;텍스트 파일 (*.txt *.md *.py *.json *.yaml *.yml *.html *.css *.js)"
        )

        if file_paths:
            added_count = 0
            for file_path in file_paths:
                if not os.path.exists(file_path): continue

                file_name = os.path.basename(file_path)
                # 중복 체크 (경로 기준)
                if any(item.get('path') == file_path for item in self.mw.attached_items):
                    logger.info(f"Skipping duplicate attachment: {file_name}")
                    continue

                # 파일 타입 추정 (이미지 vs 일반 파일)
                mime_type, _ = mimetypes.guess_type(file_path)
                item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'

                # 첨부 목록에 추가 (데이터는 필요 시 로드)
                attachment_info = {
                    "type": item_type,
                    "path": file_path,
                    "name": file_name,
                    "data": None # 필요 시 로드하도록 None으로 초기화
                }
                self.mw.attached_items.append(attachment_info)
                added_count += 1

            if added_count > 0:
                self.mw._update_attachment_list_ui() # UI 업데이트
                self.mw.status_bar.showMessage(f"{added_count}개 파일 첨부 완료.")
                self.reset_token_label() # 첨부 변경 시 토큰 리셋
                self.mw.state_changed_signal.emit() # 상태 변경 시그널 발생
            else:
                self.mw.status_bar.showMessage("선택한 파일이 이미 첨부되어 있거나 유효하지 않습니다.")

    def paste_from_clipboard(self):
        """Pastes image or file paths from the clipboard."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "정보", "Meta Prompt Builder 모드에서는 클립보드 첨부가 필요 없습니다.")
            return

        clipboard = QApplication.clipboard()
        mime_data = clipboard.mimeData()
        added_count = 0

        if mime_data.hasImage():
            qimage = clipboard.image()
            if not qimage.isNull():
                # QImage를 bytes로 변환 (Pillow 사용 권장)
                image_data = None
                image_format = "PNG" # 기본 포맷
                if _PILLOW_AVAILABLE:
                    try:
                        pil_image = ImageQt(qimage).copy() # Pillow Image로 변환
                        # RGBA -> RGB 변환 (JPEG 저장 시 필요할 수 있음)
                        if pil_image.mode == 'RGBA':
                             pil_image = pil_image.convert('RGB')
                        # 메모리에 저장하여 bytes 얻기
                        import io
                        buffer = io.BytesIO()
                        # 이미지 포맷 결정 (예: PNG 또는 JPEG)
                        # 투명도 없으면 JPEG, 있으면 PNG 고려
                        save_format = "JPEG" if pil_image.mode == 'RGB' else "PNG"
                        pil_image.save(buffer, format=save_format)
                        image_data = buffer.getvalue()
                        image_format = save_format
                        logger.info(f"Pasted image converted to {save_format} bytes.")
                    except Exception as e:
                        logger.error(f"Error converting QImage with Pillow: {e}")
                else:
                    # Pillow 없으면 QBuffer 사용 시도 (덜 안정적일 수 있음)
                    try:
                        import io
                        buffer = QBuffer()
                        buffer.open(QIODevice.OpenModeFlag.ReadWrite) # QIODevice.ReadWrite -> QIODevice.OpenModeFlag.ReadWrite
                        # PNG로 저장 시도
                        if qimage.save(buffer, "PNG"):
                            image_data = bytes(buffer.data()) # QByteArray -> bytes (PyQt6)
                            image_format = "PNG"
                            logger.info("Pasted image converted to PNG bytes using QBuffer.")
                        else:
                            logger.warning("Failed to save QImage using QBuffer.")
                        buffer.close()
                    except Exception as e:
                        logger.error(f"Error converting QImage with QBuffer: {e}")


                if image_data:
                    # 중복 체크 (데이터 기준 - 비효율적일 수 있음)
                    # if any(item.get('data') == image_data for item in self.mw.attached_items if item['type'] == 'image'):
                    #     print("Skipping duplicate image data from clipboard.")
                    # else:
                    # 임시 이름 생성
                    import time
                    timestamp = time.strftime("%Y%m%d_%H%M%S")
                    image_name = f"clipboard_image_{timestamp}.{image_format.lower()}"
                    attachment_info = {
                        "type": "image",
                        "path": None, # 클립보드 이미지는 경로 없음
                        "name": image_name,
                        "data": image_data
                    }
                    self.mw.attached_items.append(attachment_info)
                    added_count += 1
                    logger.info(f"Image pasted from clipboard: {image_name}")

        elif mime_data.hasUrls():
            urls = mime_data.urls()
            for url in urls:
                if url.isLocalFile():
                    file_path = url.toLocalFile()
                    if os.path.exists(file_path):
                        file_name = os.path.basename(file_path)
                        # 중복 체크 (경로 기준)
                        if any(item.get('path') == file_path for item in self.mw.attached_items):
                            logger.info(f"Skipping duplicate attachment from clipboard: {file_name}")
                            continue

                        mime_type, _ = mimetypes.guess_type(file_path)
                        item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'

                        attachment_info = {
                            "type": item_type,
                            "path": file_path,
                            "name": file_name,
                            "data": None
                        }
                        self.mw.attached_items.append(attachment_info)
                        added_count += 1
                        logger.info(f"File path pasted from clipboard: {file_name}")
                    else:
                        logger.warning(f"Ignoring non-existent file path from clipboard: {file_path}")
                else:
                    logger.warning(f"Ignoring non-local URL from clipboard: {url.toString()}")

        if added_count > 0:
            self.mw._update_attachment_list_ui()
            self.mw.status_bar.showMessage(f"{added_count}개 항목 클립보드에서 첨부 완료.")
            self.reset_token_label() # 첨부 변경 시 토큰 리셋
            self.mw.state_changed_signal.emit() # 상태 변경 시그널 발생
        else:
            self.mw.status_bar.showMessage("클립보드에 첨부할 수 있는 이미지나 파일 경로가 없습니다.")

    def remove_selected_attachment(self):
        """Removes the selected item from the attachment list."""
        if not hasattr(self.mw, 'attachment_list_widget'): return

        selected_items = self.mw.attachment_list_widget.selectedItems()
        if not selected_items:
            self.mw.status_bar.showMessage("제거할 첨부 파일을 선택하세요.")
            return

        removed_count = 0
        # 리스트 위젯에서 선택된 항목의 인덱스를 가져와 역순으로 제거 (인덱스 변경 방지)
        selected_indices = sorted([self.mw.attachment_list_widget.row(item) for item in selected_items], reverse=True)

        for index in selected_indices:
            if 0 <= index < len(self.mw.attached_items):
                removed_item = self.mw.attached_items.pop(index)
                self.mw.attachment_list_widget.takeItem(index) # UI에서도 제거
                logger.info(f"Removed attachment: {removed_item.get('name')}")
                removed_count += 1

        if removed_count > 0:
            self.mw.status_bar.showMessage(f"{removed_count}개 첨부 파일 제거 완료.")
            self.reset_token_label() # 첨부 변경 시 토큰 리셋
            self.mw.state_changed_signal.emit() # 상태 변경 시그널 발생
        else:
             self.mw.status_bar.showMessage("첨부 파일 제거 중 오류 발생.")




======== src\ui\controllers\prompt_controller.py ========

import os
import logging # 로깅 추가
from PyQt6.QtWidgets import QMessageBox, QApplication # PyQt5 -> PyQt6

# 서비스 및 모델 import
from core.services.prompt_service import PromptService

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

logger = logging.getLogger(__name__) # 로거 설정

class PromptController:
    """
    Handles logic related to prompt generation and clipboard operations.
    Token calculation is now triggered asynchronously by MainController.
    """
    def __init__(self, main_window: 'MainWindow', prompt_service: PromptService):
        self.mw = main_window
        self.prompt_service = prompt_service

    def generate_prompt(self):
        """Generates the prompt for the Code Enhancer mode and triggers token calculation."""
        if self.mw.mode == "Meta Prompt Builder":
            return self.generate_meta_prompt() # Meta 모드면 해당 함수 호출

        if not self.mw.current_project_folder:
             QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
             return False

        checked_files = self.mw.checkable_proxy.get_checked_files() if hasattr(self.mw, 'checkable_proxy') else []
        if not checked_files:
            QMessageBox.warning(self.mw, "경고", "프롬프트에 포함할 파일을 하나 이상 선택해주세요.")
            return False

        file_contents = []
        self.mw.selected_files_data = []
        read_errors = []
        for fpath in checked_files:
            try:
                size = os.path.getsize(fpath)
                with open(fpath, 'r', encoding='utf-8', errors='ignore') as fp:
                    content = fp.read()
                file_contents.append((fpath, content))
                self.mw.selected_files_data.append((fpath, size))
            except Exception as e:
                error_msg = f"파일 읽기 오류 ({os.path.basename(fpath)}): {e}"
                logger.error(error_msg) # 로깅 사용
                read_errors.append(error_msg)
                continue

        if read_errors:
             QMessageBox.warning(self.mw, "파일 로딩 오류", "일부 파일을 읽는 중 오류 발생:\n" + "\n".join(read_errors))
             # return False # 오류 시 중단 원하면 주석 해제

        system_text = self.mw.system_tab.toPlainText()
        user_text = self.mw.user_tab.toPlainText()
        dir_structure_content = ""
        if self.mw.tree_generated and hasattr(self.mw, "dir_structure_tab"):
            dir_structure_content = self.mw.dir_structure_tab.toPlainText()

        # --- 첨부 파일 정보 로드 ---
        # generate_code_enhancer_prompt는 마커만 사용하므로 실제 데이터 로드는 불필요
        # 토큰 계산 시에는 실제 데이터가 필요하므로 MainController에서 처리
        attachments_metadata = []
        for item in self.mw.attached_items:
            meta_item = item.copy()
            meta_item.pop('data', None) # 데이터 제외하고 메타데이터만 전달
            attachments_metadata.append(meta_item)
        # -------------------------

        final_prompt = self.prompt_service.generate_code_enhancer_prompt(
            system_text=system_text,
            user_text=user_text,
            file_contents=file_contents,
            root_dir=self.mw.current_project_folder,
            dir_structure_content=dir_structure_content,
            attached_items=attachments_metadata # 메타데이터 전달
        )

        self.mw.last_generated_prompt = final_prompt
        self.mw.prompt_output_tab.setText(final_prompt)

        # --- Trigger token calculation asynchronously ---
        # Pass the final prompt text and the *original* attached_items list (which might contain data)
        self.mw.main_controller.calculate_and_display_tokens(final_prompt, self.mw.attached_items)
        # -----------------------------------------------

        self.mw.status_bar.showMessage(f"Prompt generated! Length: {len(final_prompt):,} chars. Token calculation started...")
        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        return True

    def generate_meta_prompt(self):
        """Generates the intermediate meta prompt and triggers token calculation."""
        system_text = self.mw.system_tab.toPlainText() # 메타 템플릿
        user_text = self.mw.user_tab.toPlainText() # 메타 사용자 입력

        final_output = self.prompt_service.generate_meta_prompt(
            meta_template=system_text,
            meta_user_input=user_text
        )

        self.mw.prompt_output_tab.setText(final_output) # 메타 프롬프트 출력 탭
        self.mw.last_generated_prompt = final_output

        # --- Trigger token calculation asynchronously ---
        self.mw.main_controller.calculate_and_display_tokens(final_output) # Meta mode has no attachments
        # -----------------------------------------------

        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        self.mw.status_bar.showMessage("META Prompt generated! Token calculation started...")
        return True

    def generate_final_meta_prompt(self):
        """Generates the final prompt by replacing variables and triggers token calculation."""
        meta_prompt_content = ""
        user_prompt_content = ""
        if hasattr(self.mw, 'meta_prompt_tab'):
             meta_prompt_content = self.mw.meta_prompt_tab.toPlainText()
        if hasattr(self.mw, 'user_prompt_tab'):
             user_prompt_content = self.mw.user_prompt_tab.toPlainText()

        variables = {}
        if hasattr(self.mw, 'build_tabs'):
            for i in range(self.mw.build_tabs.count()):
                tab_name = self.mw.build_tabs.tabText(i)
                if tab_name.startswith("var-"):
                    var_name = tab_name[4:]
                    tab_widget = self.mw.build_tabs.widget(i)
                    if tab_widget and hasattr(tab_widget, 'toPlainText'):
                        variables[var_name] = tab_widget.toPlainText()

        final_prompt = self.prompt_service.generate_final_meta_prompt(
            meta_prompt_content=meta_prompt_content,
            user_prompt_content=user_prompt_content,
            variables=variables
        )

        if hasattr(self.mw, 'final_prompt_tab'):
            self.mw.final_prompt_tab.setText(final_prompt)
            self.mw.last_generated_prompt = final_prompt

            # --- Trigger token calculation asynchronously ---
            self.mw.main_controller.calculate_and_display_tokens(final_prompt) # Meta mode has no attachments
            # -----------------------------------------------

            self.mw.build_tabs.setCurrentWidget(self.mw.final_prompt_tab)
            self.mw.status_bar.showMessage("Final Prompt generated! Token calculation started...")
        else:
             QMessageBox.warning(self.mw, "오류", "최종 프롬프트 탭을 찾을 수 없습니다.")

    def copy_to_clipboard(self):
        """Copies the content of the active prompt output tab to the clipboard."""
        current_widget = self.mw.build_tabs.currentWidget()
        prompt_to_copy = ""

        # Code Enhancer 모드의 프롬프트 출력 탭
        if current_widget == self.mw.prompt_output_tab and self.mw.mode != "Meta Prompt Builder":
            prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        # Meta 모드의 메타 프롬프트 출력 탭
        elif current_widget == self.mw.prompt_output_tab and self.mw.mode == "Meta Prompt Builder":
             prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        # Meta 모드의 최종 프롬프트 탭
        elif hasattr(self.mw, 'final_prompt_tab') and current_widget == self.mw.final_prompt_tab:
             prompt_to_copy = self.mw.final_prompt_tab.toPlainText()
        # 파일 트리 탭 (선택적)
        elif hasattr(self.mw, 'dir_structure_tab') and current_widget == self.mw.dir_structure_tab:
             prompt_to_copy = self.mw.dir_structure_tab.toPlainText()

        # 위 경우에 해당하지 않으면 마지막 생성된 프롬프트 사용 (last_generated_prompt)
        if not prompt_to_copy:
             prompt_to_copy = self.mw.last_generated_prompt

        if prompt_to_copy:
            QApplication.clipboard().setText(prompt_to_copy)
            self.mw.status_bar.showMessage("Copied!")
            return True
        else:
            self.mw.status_bar.showMessage("복사할 내용이 없습니다!")
            return False

    def generate_all_and_copy(self):
        """
        Generates directory tree, prompt, triggers token calculation, and copies to clipboard (Code Enhancer mode only).
        Returns True if prompt generation was successful, False otherwise.
        Clipboard copy failure only logs a warning but doesn't cause the function to return False.
        """
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 이 기능을 사용할 수 없습니다.")
            return False # 작업 수행 안 함

        # FileTreeController의 트리 생성 메서드 호출
        tree_success = self.mw.file_tree_controller.generate_directory_tree_structure()
        if not tree_success:
            logger.warning("generate_all_and_copy: Directory tree generation failed.")
            # 트리 생성 실패 시에도 프롬프트 생성은 시도할 수 있음 (선택 사항)
            # return False # 트리 생성 실패 시 즉시 중단하려면 주석 해제

        # 자신의 프롬프트 생성 메서드 호출 (내부에서 토큰 계산 트리거)
        prompt_success = self.generate_prompt() # This now triggers calculate_and_display_tokens
        if not prompt_success:
            logger.error("generate_all_and_copy: Prompt generation failed.")
            return False # 프롬프트 생성 실패 시 False 반환

        # 자신의 클립보드 복사 메서드 호출
        copy_success = self.copy_to_clipboard()
        if not copy_success:
            # 복사 실패는 경고만 로깅하고, 함수는 True 반환 (프롬프트 생성 성공 기준)
            logger.warning("generate_all_and_copy: Copy to clipboard failed, but prompt generation succeeded.")

        # 프롬프트 생성이 성공했으므로 True 반환
        # 상태 메시지는 generate_prompt에서 이미 설정됨 ("... Token calculation started...")
        return True



======== src\ui\controllers\resource_controller.py ========

import os
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QTreeWidgetItem # PyQt5 -> PyQt6, QTreeWidgetItem 추가

# 서비스 및 모델 import
from core.services.template_service import TemplateService
from core.services.state_service import StateService
from core.pydantic_models.app_state import AppState

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

class ResourceController:
    """
    Handles logic related to resource management (templates and states).
    """
    def __init__(self, main_window: 'MainWindow', template_service: TemplateService, state_service: StateService):
        self.mw = main_window
        self.template_service = template_service
        self.state_service = state_service

    def load_templates_list(self):
        """Loads the list of templates or states into the resource tree."""
        self.mw.template_tree.clear() # 트리 초기화
        current_mode = self.mw.resource_mode_combo.currentText()

        if current_mode == "프롬프트":
            system_templates = self.template_service.list_templates("prompts/system")
            user_templates = self.template_service.list_templates("prompts/user")

            system_item = self.mw.create_tree_item("System")
            user_item = self.mw.create_tree_item("User")
            for st in sorted(system_templates): self.mw.create_tree_item(st, system_item)
            for ut in sorted(user_templates): self.mw.create_tree_item(ut, user_item)
            system_item.setExpanded(True)
            user_item.setExpanded(True)

        elif current_mode == "상태":
            states_list = self.state_service.list_states()
            states_item = self.mw.create_tree_item("States")
            for st_file in sorted(states_list): self.mw.create_tree_item(st_file, states_item)
            states_item.setExpanded(True)

        self.update_buttons_label() # 버튼 레이블 업데이트

    def load_selected_item(self):
        """Loads the selected template or state."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요.")
            return

        filename = item.text(0)

        if current_mode == "프롬프트":
            parent_text = item.parent().text(0)
            relative_path = ""
            target_tab = None
            if parent_text == "System":
                relative_path = os.path.join("prompts", "system", filename)
                target_tab = self.mw.system_tab
            elif parent_text == "User":
                relative_path = os.path.join("prompts", "user", filename)
                target_tab = self.mw.user_tab

            if relative_path and target_tab:
                content = self.template_service.load_template(relative_path)
                target_tab.setText(content)
                self.mw.status_bar.showMessage(f"Loaded {parent_text.lower()} template: {filename}")

        elif current_mode == "상태":
            fname_no_ext = os.path.splitext(filename)[0]
            loaded_state = self.state_service.load_state(fname_no_ext)
            if loaded_state:
                # 상태 로드 시 전체 로드로 간주 (partial_load=False)
                self.mw.set_current_state(loaded_state, partial_load=False)
            else:
                QMessageBox.warning(self.mw, "오류", "상태 파일을 불러오는 데 실패했습니다.")

    def save_current_as_item(self):
        """Saves the current prompt or state as a new item."""
        current_mode = self.mw.resource_mode_combo.currentText()

        if current_mode == "프롬프트":
            template_type = self.mw.template_type_combo.currentText()
            content = ""
            target_dir_relative = ""
            source_tab = None
            if template_type == "시스템":
                source_tab = self.mw.system_tab
                target_dir_relative = os.path.join("prompts", "system")
            else: # 사용자
                source_tab = self.mw.user_tab
                target_dir_relative = os.path.join("prompts", "user")

            content = source_tab.toPlainText()
            if not content.strip():
                 QMessageBox.warning(self.mw, "경고", "저장할 내용이 없습니다.")
                 return

            fname, ok = QInputDialog.getText(self.mw, "템플릿 저장", "템플릿 파일 이름(확장자 제외)을 입력하세요:")
            if not ok or not fname or not fname.strip(): return
            fname_stripped = fname.strip()
            fname_md = fname_stripped + ".md"
            relative_path = os.path.join(target_dir_relative, fname_md)

            if self.template_service.save_template(relative_path, content):
                self.mw.status_bar.showMessage(f"Template saved: {fname_md}")
                self.load_templates_list()
            else:
                 QMessageBox.warning(self.mw, "오류", "템플릿 저장 중 오류가 발생했습니다.")

        elif current_mode == "상태":
            current_state = self.mw.get_current_state()
            fname, ok = QInputDialog.getText(self.mw, "상태 저장", "상태 파일 이름(확장자 제외)을 입력하세요:")
            if not ok or not fname or not fname.strip(): return
            fname_stripped = fname.strip()

            if self.state_service.save_state(current_state, fname_stripped):
                self.mw.status_bar.showMessage(f"State saved: {fname_stripped}.json")
                self.load_templates_list()
            else:
                QMessageBox.warning(self.mw, "오류", "상태 저장 중 오류가 발생했습니다.")

    def delete_selected_item(self):
        """Deletes the selected template or state file."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요.")
            return

        filename = item.text(0)
        parent_text = item.parent().text(0)

        reply = QMessageBox.question(self.mw, "삭제 확인", f"정말로 '{filename}'을(를) 삭제하시겠습니까?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        deleted = False
        if current_mode == "프롬프트":
            relative_path = ""
            if parent_text == "System":
                relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User":
                relative_path = os.path.join("prompts", "user", filename)
            if relative_path:
                deleted = self.template_service.delete_template(relative_path)
        elif current_mode == "상태":
            fname_no_ext = os.path.splitext(filename)[0]
            deleted = self.state_service.delete_state(fname_no_ext)

        if deleted:
            self.mw.status_bar.showMessage(f"Deleted: {filename}")
            self.load_templates_list()
        else:
            QMessageBox.warning(self.mw, "오류", f"'{filename}' 삭제 중 오류가 발생했습니다.")

    def update_current_item(self):
        """Updates the selected template or state file with the current content/state."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요.")
            return

        filename = item.text(0)
        parent_text = item.parent().text(0)

        reply = QMessageBox.question(self.mw, "업데이트 확인", f"'{filename}'의 내용을 현재 편집 중인 내용으로 덮어쓰시겠습니까?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.Yes) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        updated = False
        if current_mode == "프롬프트":
            content = ""
            relative_path = ""
            source_tab = None
            if parent_text == "System":
                source_tab = self.mw.system_tab
                relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User":
                source_tab = self.mw.user_tab
                relative_path = os.path.join("prompts", "user", filename)

            if relative_path and source_tab:
                content = source_tab.toPlainText()
                updated = self.template_service.save_template(relative_path, content)
        elif current_mode == "상태":
            current_state = self.mw.get_current_state()
            fname_no_ext = os.path.splitext(filename)[0]
            updated = self.state_service.save_state(current_state, fname_no_ext)

        if updated:
            self.mw.status_bar.showMessage(f"Updated: {filename}")
        else:
            QMessageBox.warning(self.mw, "오류", f"'{filename}' 업데이트 중 오류가 발생했습니다.")

    def save_state_to_default(self):
        """Saves the current state to the default state file ('default.json')."""
        state = self.mw.get_current_state()
        if self.state_service.save_state(state, "default"):
            self.mw.status_bar.showMessage("현재 작업 자동 저장 완료!")
        else:
            # 자동 저장은 사용자에게 오류 메시지를 띄우지 않음 (로그로 대체 가능)
            print("Error: Failed to auto-save state to default.json")
            # QMessageBox.warning(self.mw, "오류", "기본 상태 저장 중 오류가 발생했습니다.")

    def load_state_from_default(self):
        """
        Loads the state from the default state file ('default.json').
        Uses partial_load=True to only load specific fields.
        """
        state = self.state_service.load_state("default")
        if state:
            # 부분 로드 플래그를 True로 설정하여 set_current_state 호출
            self.mw.set_current_state(state, partial_load=True)
        else:
             # 파일이 없거나 로드 실패 시 사용자에게 알림 (최초 실행 등)
             QMessageBox.information(self.mw, "정보", "저장된 이전 작업 상태 파일을 찾을 수 없습니다.")

    def export_state_to_file(self):
        """Exports the current state to a user-selected file."""
        path, _ = QFileDialog.getSaveFileName(self.mw, "상태 내보내기", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            state = self.mw.get_current_state()
            if self.state_service.export_state_to_file(state, path):
                self.mw.status_bar.showMessage("상태 내보내기 완료!")
            else:
                QMessageBox.warning(self.mw, "오류", "상태 내보내기 중 오류가 발생했습니다.")

    def import_state_from_file(self):
        """Imports state from a user-selected file."""
        path, _ = QFileDialog.getOpenFileName(self.mw, "상태 가져오기", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            state = self.state_service.import_state_from_file(path)
            if state:
                # 상태 가져오기는 전체 로드로 간주 (partial_load=False)
                self.mw.set_current_state(state, partial_load=False)
            else:
                 QMessageBox.warning(self.mw, "오류", "상태 가져오기 중 오류가 발생했거나 파일 내용이 유효하지 않습니다.")

    # 백업/복원 관련 메서드 제거
    # def backup_all_states_action(self): ...
    # def restore_states_from_backup_action(self): ...

    def update_buttons_label(self):
        """Updates the labels of buttons in the resource manager section based on the mode."""
        current_mode = self.mw.resource_mode_combo.currentText()
        is_prompt_mode = (current_mode == "프롬프트")

        self.mw.load_selected_template_btn.setText(f"📥 선택한 {current_mode} 불러오기")
        self.mw.save_as_template_btn.setText(f"💾 현재 {current_mode}로 저장")
        self.mw.delete_template_btn.setText(f"❌ 선택한 {current_mode} 삭제")
        self.mw.update_template_btn.setText(f"🔄 현재 {current_mode} 업데이트")

        # 백업/복원 버튼 관련 코드 제거
        # self.mw.backup_button.setEnabled(not is_prompt_mode)
        # self.mw.restore_button.setEnabled(not is_prompt_mode)
        # self.mw.backup_button.setText("📦 모든 상태 백업" + (" (비활성화)" if is_prompt_mode else ""))
        # self.mw.restore_button.setText("🔙 백업에서 상태 복원" + (" (비활성화)" if is_prompt_mode else ""))

        self.mw.template_type_combo.setVisible(is_prompt_mode)
        self.mw.template_type_label.setVisible(is_prompt_mode)




======== src\ui\controllers\system_prompt_controller.py ========

import os
from PyQt6.QtWidgets import QFileDialog, QMessageBox, QWidget # PyQt5 -> PyQt6

# 변경된 경로에서 import
from utils.helpers import get_resource_path, get_project_root
from core.services.config_service import ConfigService # ConfigService import

# MainWindow 타입 힌트
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from ui.main_window import MainWindow

# 함수 형태로 유지 (MainWindow 또는 SettingsDialog에서 호출)
def apply_default_system_prompt(main_window: 'MainWindow'):
    """
    Loads the default system prompt specified in config.yml into the system_tab.
    Handles both relative (to project root) and absolute paths.
    """
    # MainWindow가 가지고 있는 ConfigService 사용
    if not hasattr(main_window, 'config_service'):
        print("Error: ConfigService not found in MainWindow.")
        return

    config_service: ConfigService = main_window.config_service
    settings = config_service.get_settings()
    default_system_prompt_path_str = settings.default_system_prompt
    prompt_source = ""
    prompt_path = "" # Initialize prompt_path

    if default_system_prompt_path_str:
        prompt_path_input = default_system_prompt_path_str
        # 설정 파일의 경로는 프로젝트 루트 기준 상대 경로 또는 절대 경로로 간주
        if not os.path.isabs(prompt_path_input):
             # 상대 경로일 경우 프로젝트 루트 기준으로 절대 경로 생성
             try:
                 project_root = get_project_root()
                 prompt_path = str(project_root / prompt_path_input)
                 prompt_source = f"config.yml (relative: {prompt_path_input})"
             except Exception as e:
                 print(f"Error resolving relative path '{prompt_path_input}': {e}")
                 main_window.status_bar.showMessage(f"기본 시스템 프롬프트 상대 경로 오류: {prompt_path_input}")
                 return
        else:
            # 절대 경로인 경우 그대로 사용
            prompt_path = prompt_path_input
            prompt_source = f"config.yml (absolute: {os.path.basename(prompt_path_input)})"
    else:
        # 설정값이 없으면 기본값(XML Guide) 사용 시도
        default_path_relative = os.path.join("prompts", "system", "XML_Prompt_Guide.md")
        try:
            prompt_path = get_resource_path(default_path_relative)
            prompt_source = f"Default ({os.path.basename(default_path_relative)})"
            print(f"default_system_prompt not set in config, attempting to load default: {default_path_relative}")
        except Exception as e:
             print(f"Error getting resource path for default prompt: {e}")
             main_window.status_bar.showMessage("기본 시스템 프롬프트 경로를 찾을 수 없습니다.")
             return

    # 파일 존재 여부 확인
    if not prompt_path or not os.path.exists(prompt_path):
        print(f"Default system prompt file not found at resolved path: {prompt_path}")
        main_window.status_bar.showMessage(
            f"기본 시스템 프롬프트 파일 없음: {os.path.basename(default_system_prompt_path_str or 'Default')}"
        )
        return

    # 파일 로드 및 UI 업데이트
    try:
        with open(prompt_path, "r", encoding="utf-8") as f:
            content = f.read()
        main_window.system_tab.setText(content)
        print(f"Default system prompt loaded from: {prompt_path}")
        main_window.status_bar.showMessage(f"기본 시스템 프롬프트 로드 완료: {prompt_source}")
    except Exception as e:
        print(f"Error loading default system prompt file '{prompt_path}': {e}")
        main_window.status_bar.showMessage(f"기본 시스템 프롬프트 로드 중 오류: {str(e)}")


def select_default_system_prompt(config_service: ConfigService, parent_widget: Optional[QWidget] = None) -> Optional[str]:
    """
    Opens a file dialog to select a default system prompt file (.md, .txt).
    Returns the path to be saved (relative to project root if possible, otherwise absolute).

    Args:
        config_service: The ConfigService instance.
        parent_widget: The parent widget for the file dialog.

    Returns:
        The path string to be saved in config.yml, or None if cancelled.
    """
    settings = config_service.get_settings()
    current_path_str = settings.default_system_prompt
    initial_dir = os.path.expanduser("~") # Default initial directory

    # Determine initial directory for file dialog
    try:
        project_root = get_project_root()
        # Try to resolve current path (relative or absolute)
        if current_path_str:
            resolved_path = current_path_str
            if not os.path.isabs(current_path_str):
                resolved_path = str(project_root / current_path_str)

            if os.path.exists(resolved_path):
                initial_dir = os.path.dirname(resolved_path)
            elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
                 initial_dir = str(project_root / "resources" / "prompts" / "system")
        elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
             initial_dir = str(project_root / "resources" / "prompts" / "system")
    except Exception as e:
        print(f"Error determining initial directory: {e}")
        # Fallback to user home if error occurs

    path, _ = QFileDialog.getOpenFileName(
        parent_widget, # 부모 위젯 전달
        "기본 시스템 프롬프트 선택",
        initial_dir,
        "Text/Markdown Files (*.txt *.md);;All Files (*.*)"
    )

    if path:
        try:
            # 경로를 프로젝트 루트 기준 상대 경로로 변환 시도
            project_root_str = str(get_project_root())
            # Use os.path.normpath and os.path.abspath for reliable comparison
            abs_path = os.path.abspath(path)
            abs_project_root = os.path.abspath(project_root_str)

            if abs_path.startswith(abs_project_root):
                # Calculate relative path and normalize separators to forward slashes
                relative_path = os.path.relpath(abs_path, abs_project_root).replace(os.sep, '/')
                print(f"Default system prompt selected (relative path): {relative_path}")
                return relative_path
            else:
                # 프로젝트 외부는 정규화된 절대 경로 저장 (forward slashes)
                absolute_path_normalized = abs_path.replace(os.sep, '/')
                print(f"Default system prompt selected (absolute path): {absolute_path_normalized}")
                QMessageBox.information(parent_widget, "정보", "프로젝트 외부 경로는 절대 경로로 저장됩니다.")
                return absolute_path_normalized

        except Exception as e:
            print(f"Error processing selected path: {e}")
            QMessageBox.warning(
                parent_widget,
                "오류",
                f"경로 처리 중 오류 발생: {str(e)}"
            )
            return None
    return None # 사용자가 취소한 경우




======== src\ui\controllers\xml_controller.py ========

import os
from PyQt6.QtWidgets import QMessageBox # PyQt5 -> PyQt6

# 서비스 및 모델 import
from core.services.xml_service import XmlService

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .file_tree_controller import FileTreeController # refresh_tree 호출용

class XmlController:
    """
    Handles logic related to XML parsing and applying file changes.
    """
    def __init__(self, main_window: 'MainWindow', xml_service: XmlService):
        self.mw = main_window
        self.xml_service = xml_service
    def run_xml_parser(self):
        """Parses XML input and applies changes to the project files."""
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 XML 파서 기능이 필요 없습니다.")
            return

        xml_str = ""
        if hasattr(self.mw, "xml_input_tab"):
            xml_str = self.mw.xml_input_tab.toPlainText()
        if not xml_str.strip():
            self.mw.status_bar.showMessage("XML 내용이 비어 있습니다.")
            return

        project_dir = self.mw.current_project_folder
        if not project_dir or not os.path.isdir(project_dir):
            QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
            return

        try:
            result = self.xml_service.apply_changes_from_xml(xml_str, project_dir)
        except Exception as e:
             QMessageBox.critical(self.mw, "XML 파싱 오류", f"XML 처리 중 예외 발생: {e}")
             if hasattr(self.mw, 'file_tree_controller'):
                 self.mw.file_tree_controller.refresh_tree() # 오류 시에도 새로고침
             return

        messages = []
        if result["created"]: messages.append("생성된 파일:\n" + "\n".join(result["created"]))
        if result["updated"]: messages.append("수정된 파일:\n" + "\n".join(result["updated"]))
        if result["deleted"]: messages.append("삭제된 파일:\n" + "\n".join(result["deleted"]))
        if result["errors"]: messages.append("오류:\n" + "\n".join(result["errors"]))
        if not messages: messages.append("변경 사항 없음.")

        final_message = "\n\n".join(messages)

        if result["errors"]:
            QMessageBox.warning(self.mw, "XML 파싱 결과 (오류 발생)", final_message)
        else:
            QMessageBox.information(self.mw, "XML 파싱 결과", final_message)

        # 파일 변경 후 트리 새로고침 (FileTreeController 통해)
        if hasattr(self.mw, 'file_tree_controller'):
            self.mw.file_tree_controller.refresh_tree()
        self.mw.status_bar.showMessage("XML 파싱 완료!")




======== src\ui\models\__init__.py ========
# This file makes Python treat the directory models as a package.



======== src\ui\models\file_system_models.py ========
import os
import fnmatch
from PyQt6.QtCore import QSortFilterProxyModel, Qt, QModelIndex, QFileInfo, QAbstractItemModel, pyqtSignal # Added QAbstractItemModel, pyqtSignal
from PyQt6.QtGui import QStandardItemModel, QStandardItem, QIcon, QColor, QBrush # Added QStandardItemModel, QStandardItem, QIcon, QColor, QBrush
from PyQt6.QtWidgets import QTreeView, QApplication, QStyle # Added QApplication, QStyle
from typing import Callable, Optional, Set, List, Dict, Any # List, Dict, Any 추가
from core.services.filesystem_service import FilesystemService
from core.services.directory_cache_service import CacheNode # Added
import logging

logger = logging.getLogger(__name__)

# --- Constants ---
NODE_ROLE = Qt.ItemDataRole.UserRole + 1 # Role to store CacheNode reference
PATH_ROLE = Qt.ItemDataRole.UserRole + 2 # Role to store absolute path

# --- Cached File System Model (using QStandardItemModel) ---
class CachedFileSystemModel(QStandardItemModel):
    """
    A model based on QStandardItemModel that displays the cached directory structure.
    It gets populated/updated by the DirectoryCacheService.
    """
    # Signal emitted when the model needs to be repopulated
    request_repopulation = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setHorizontalHeaderLabels(['Name']) # Single column for name/icon
        self._icon_provider = QApplication.style() # Use application style for default icons
        self._folder_icon = self._icon_provider.standardIcon(QStyle.StandardPixmap.SP_DirIcon) # QStyle.SP_DirIcon -> QStyle.StandardPixmap.SP_DirIcon
        self._file_icon = self._icon_provider.standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon

    def populate_from_cache(self, root_node: Optional[CacheNode]):
        """
        Clears the model and populates it from the CacheNode structure.
        The root folder itself is not shown; its children are the top-level items.
        """
        self.clear()
        self.setHorizontalHeaderLabels(['Name']) # Reset header after clear
        if root_node and not root_node.ignored: # Only populate if root exists and is not ignored
            # Don't create a visible item for the root folder itself.
            # Instead, populate its children directly under the invisible root.
            self._populate_children(self.invisibleRootItem(), root_node)
        logger.info("CachedFileSystemModel populated from cache.")

    def _populate_children(self, parent_item: QStandardItem, parent_node: CacheNode):
        """Recursively populates children items."""
        # Sort children by name (directories first, then files)
        sorted_children = sorted(parent_node.children.values(), key=lambda node: (not node.is_dir, node.name.lower()))

        for child_node in sorted_children:
            if not child_node.ignored: # Skip ignored items
                child_item = self._create_item_from_node(child_node)
                parent_item.appendRow(child_item)
                if child_node.is_dir:
                    self._populate_children(child_item, child_node)

    def _create_item_from_node(self, node: CacheNode) -> QStandardItem:
        """Creates a QStandardItem from a CacheNode."""
        item = QStandardItem(node.name)
        item.setEditable(False)
        item.setData(node, NODE_ROLE) # Store the node object
        item.setData(node.path, PATH_ROLE) # Store the path
        item.setIcon(self._folder_icon if node.is_dir else self._file_icon)
        # Set checkable flag (proxy model will handle actual check state)
        item.setCheckable(True)
        item.setCheckState(Qt.CheckState.Unchecked) # Default to unchecked
        return item

    def find_item_by_path(self, path: str) -> Optional[QStandardItem]:
        """Finds a QStandardItem in the model by its absolute path."""
        if not path: return None
        # Iterate through all items to find the one with the matching path
        # This can be slow for very large models. Consider optimizing if needed.
        root = self.invisibleRootItem()
        queue = [root.child(i, 0) for i in range(root.rowCount())]
        while queue:
            item = queue.pop(0)
            if not item: continue
            item_path = item.data(PATH_ROLE)
            if item_path == path:
                return item
            # Add children to the queue
            for i in range(item.rowCount()):
                 child = item.child(i, 0)
                 if child: queue.append(child)
        return None

    def update_model_from_cache_change(self, cache_root: Optional[CacheNode]):
        """Handles cache updates from the service."""
        # For simplicity, repopulate the entire model on any cache change.
        # More granular updates (insertRows, removeRows, dataChanged) are possible
        # but significantly more complex to implement correctly based on cache diffs.
        logger.info("Received cache update signal. Repopulating model.")
        self.populate_from_cache(cache_root)


# --- Checkable Proxy Model (Adapted for CachedFileSystemModel) ---
class CheckableProxyModel(QSortFilterProxyModel):
    """
    Proxy model that provides checkable items and filters based on ignore patterns.
    Handles recursive checking for folders and multi-selection checking.
    Works with CachedFileSystemModel (QStandardItemModel based).
    """
    # Signal to indicate check state dictionary has changed
    check_state_changed = pyqtSignal()

    def __init__(self, project_folder_getter: Callable[[], Optional[str]], fs_service: FilesystemService, tree_view: QTreeView, parent=None):
        super().__init__(parent)
        # Source model is now CachedFileSystemModel (set via setSourceModel)
        self.project_folder_getter = project_folder_getter
        self.fs_service = fs_service # Still needed for should_ignore fallback? Maybe not.
        self.tree_view = tree_view
        self.checked_files_dict: Dict[str, bool] = {} # {file_path: bool} - Stores the check state
        self._ignore_patterns: Set[str] = set()
        self._is_setting_data = False # 재귀적 setData 호출 방지 플래그

    def set_ignore_patterns(self, patterns: Set[str]):
        """Sets the ignore patterns used for filtering."""
        if self._ignore_patterns != patterns:
            self._ignore_patterns = patterns
            logger.info(f"Ignore patterns updated. Invalidating filter.")
            self.invalidateFilter() # Trigger refiltering

    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool:
        """
        Determines if a row should be shown. Reads 'ignored' status from CacheNode.
        """
        source_model = self.sourceModel()
        if not isinstance(source_model, QStandardItemModel): # Check if source model is set and correct type
             logger.warning("filterAcceptsRow: Source model not set or not QStandardItemModel.")
             return False

        source_index = source_model.index(source_row, 0, source_parent)
        if not source_index.isValid():
            return False

        item = source_model.itemFromIndex(source_index)
        if not item: return False # Should not happen

        node: Optional[CacheNode] = item.data(NODE_ROLE)

        # If node data is missing or node is marked as ignored in the cache, filter it out
        if node is None or node.ignored:
            # If it's filtered out, ensure it's removed from the check state dict
            path = item.data(PATH_ROLE)
            if path and path in self.checked_files_dict:
                logger.debug(f"Removing filtered/ignored item from checked_files_dict: {path}")
                del self.checked_files_dict[path]
                self.check_state_changed.emit() # Notify change
            return False

        # If node exists and is not ignored, accept the row
        return True

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """
        Returns data for the item, including check state based on checked_files_dict.
        """
        if not index.isValid():
            return None

        # Handle check state for column 0
        if index.column() == 0 and role == Qt.ItemDataRole.CheckStateRole:
            file_path = self.mapToSource(index).data(PATH_ROLE) # Get path from source item
            if file_path:
                is_checked = self.checked_files_dict.get(file_path, False)
                return Qt.CheckState.Checked if is_checked else Qt.CheckState.Unchecked
            return Qt.CheckState.Unchecked # Default if path not found

        # For other roles, delegate to the source model (QStandardItemModel)
        return super().data(index, role)

    def flags(self, index: QModelIndex) -> Qt.ItemFlag:
        """Returns item flags, ensuring checkable status comes from source."""
        # Start with flags from the proxy model itself
        flags = super().flags(index)
        if index.column() == 0:
            # Get flags from the source model item (QStandardItem)
            source_index = self.mapToSource(index)
            source_flags = self.sourceModel().flags(source_index)
            # Ensure checkable flag is included if set in source
            if source_flags & Qt.ItemFlag.ItemIsUserCheckable: # Qt.ItemIsUserCheckable -> Qt.ItemFlag.ItemIsUserCheckable
                flags |= Qt.ItemFlag.ItemIsUserCheckable # Qt.ItemIsUserCheckable -> Qt.ItemFlag.ItemIsUserCheckable
            # Ensure item is enabled
            flags |= Qt.ItemFlag.ItemIsEnabled # Qt.ItemIsEnabled -> Qt.ItemFlag.ItemIsEnabled
        return flags


    def setData(self, index: QModelIndex, value: Any, role: int = Qt.ItemDataRole.EditRole) -> bool:
        """
        Sets data for the item, handling check state changes for the proxy model's dictionary.
        Propagates changes to children based on the source model structure.
        """
        if self._is_setting_data:
            # logger.debug(f"setData blocked by flag for index: {self.get_file_path_from_index(index)}")
            return False
        if index.column() != 0 or role != Qt.ItemDataRole.CheckStateRole:
            return super().setData(index, value, role)

        source_index = self.mapToSource(index)
        source_item = self.sourceModel().itemFromIndex(source_index)
        if not source_item: return False

        file_path = source_item.data(PATH_ROLE)
        node: Optional[CacheNode] = source_item.data(NODE_ROLE)
        if not file_path or not node:
            logger.warning(f"setData failed: Could not get path/node for index {index.row()},{index.column()}")
            return False

        # logger.debug(f"▶ setData called: path={file_path}, role={role}, value={value}")
        self._is_setting_data = True
        try:
            if isinstance(value, Qt.CheckState):
                new_check_state = value
            elif isinstance(value, int):
                new_check_state = Qt.CheckState(value)
            else:
                logger.warning(f"setData: Unexpected value type for CheckStateRole: {type(value)}")
                self._is_setting_data = False
                return False

            is_checked = (new_check_state == Qt.CheckState.Checked)
            current_state_in_dict = self.checked_files_dict.get(file_path, False)

            if is_checked == current_state_in_dict:
                # logger.debug(f"setData: No state change needed for {file_path}.")
                self._is_setting_data = False
                return True

            # logger.debug(f"setData processing state change for: {file_path}, New state: {is_checked}")

            # Update the dictionary
            if is_checked:
                self.checked_files_dict[file_path] = True
            elif file_path in self.checked_files_dict:
                del self.checked_files_dict[file_path]
                # logger.debug(f"  Item unchecked and removed from checked_files_dict: {file_path}")

            # Emit dataChanged for the current index to update its visual state
            self.dataChanged.emit(index, index, [role])
            indices_to_signal = {index} # Track indices needing UI update

            # If it's a directory, update children recursively
            if node.is_dir:
                # logger.debug(f"  {file_path} is a directory. Updating children...")
                changed_children_proxy_indices = self._update_children_state_recursive(source_item, is_checked)
                indices_to_signal.update(changed_children_proxy_indices)
                # logger.debug(f"  Finished updating children for {file_path}. Total signals needed: {len(indices_to_signal)}")

                # Expand checked folders (optional)
                if is_checked:
                    # logger.debug(f"  Expanding checked folder: {file_path}")
                    self.expand_index_recursively(index)

            # Emit dataChanged for all affected children (already done inside _update_children_state_recursive)
            # logger.debug(f"Emitting dataChanged for {len(indices_to_signal)} indices.")
            # for idx_to_signal in indices_to_signal:
            #     if idx_to_signal.isValid():
            #         # logger.debug(f"    Emitting for: {self.get_file_path_from_index(idx_to_signal)}")
            #         self.dataChanged.emit(idx_to_signal, idx_to_signal, [Qt.ItemDataRole.CheckStateRole])

            self.check_state_changed.emit() # Signal that the dictionary was modified
            # logger.debug(f"setData returning True for path: {file_path}")
            return True

        except Exception as e:
            logger.exception(f"Error in setData for path {file_path}: {e}")
            return False
        finally:
            # logger.debug("setData finished. Releasing flag.")
            self._is_setting_data = False

    def _update_children_state_recursive(self, parent_source_item: QStandardItem, checked: bool) -> Set[QModelIndex]:
        """
        Recursively updates the check state dictionary for children of a source item.
        Returns a set of *proxy* indices whose state was visually changed.
        """
        changed_proxy_indices = set()
        source_model = self.sourceModel()

        for row in range(parent_source_item.rowCount()):
            child_source_item = parent_source_item.child(row, 0)
            if not child_source_item: continue

            child_node: Optional[CacheNode] = child_source_item.data(NODE_ROLE)
            child_path = child_source_item.data(PATH_ROLE)

            if not child_node or not child_path: continue
            # Skip ignored items as they are not visible anyway
            if child_node.ignored: continue

            current_state_in_dict = self.checked_files_dict.get(child_path, False)
            needs_update = (checked != current_state_in_dict)

            if needs_update:
                if checked:
                    self.checked_files_dict[child_path] = True
                elif child_path in self.checked_files_dict:
                    del self.checked_files_dict[child_path]
                    # logger.debug(f"      Child unchecked and removed from dict: {child_path}")

                # Find the corresponding proxy index for signaling
                child_source_index = source_model.indexFromItem(child_source_item)
                child_proxy_index = self.mapFromSource(child_source_index)
                if child_proxy_index.isValid():
                    changed_proxy_indices.add(child_proxy_index)
                    # Emit dataChanged immediately for this child
                    self.dataChanged.emit(child_proxy_index, child_proxy_index, [Qt.ItemDataRole.CheckStateRole])
                    # logger.debug(f"      Child state changed & signaled: {child_path}")

            # Recurse if it's a directory
            if child_node.is_dir:
                grandchildren_indices = self._update_children_state_recursive(child_source_item, checked)
                changed_proxy_indices.update(grandchildren_indices)

        return changed_proxy_indices

    def expand_index_recursively(self, proxy_index: QModelIndex):
        """Recursively expands the given index and its children in the tree view."""
        if not proxy_index.isValid(): return
        self.tree_view.expand(proxy_index)
        # Iterate through children in the proxy model
        child_count = self.rowCount(proxy_index)
        for row in range(child_count):
            child_proxy_idx = self.index(row, 0, proxy_index)
            if child_proxy_idx.isValid():
                 # Check if the child corresponds to a directory in the source model
                 source_idx = self.mapToSource(child_proxy_idx)
                 source_item = self.sourceModel().itemFromIndex(source_idx)
                 if source_item:
                     node: Optional[CacheNode] = source_item.data(NODE_ROLE)
                     if node and node.is_dir:
                          self.expand_index_recursively(child_proxy_idx)


    def get_file_path_from_index(self, proxy_index: QModelIndex) -> Optional[str]:
        """Gets the file path from a proxy index by looking at the source model."""
        if not proxy_index.isValid(): return None
        source_index = self.mapToSource(proxy_index)
        if source_index.isValid():
            return self.sourceModel().data(source_index, PATH_ROLE)
        return None

    def get_all_checked_paths(self) -> List[str]:
        """Returns a list of all paths currently marked as checked in the dictionary."""
        # logger.debug(f"get_all_checked_paths called. Returning {len(self.checked_files_dict)} paths.")
        return list(self.checked_files_dict.keys())


    def get_checked_files(self) -> List[str]:
        """
        Returns a list of checked paths that correspond to actual files.
        Reads 'is_dir' status from the internal dictionary.
        """
        checked_files = []
        source_model = self.sourceModel()
        if not isinstance(source_model, QStandardItemModel):
             logger.warning("get_checked_files: Source model not available.")
             return []

        # Iterate through the dictionary keys (paths)
        for path, is_checked in self.checked_files_dict.items():
            if not is_checked: continue # Should not happen if only True is stored, but check anyway

            # Find the item in the model to check its type
            # This is inefficient. Store type in checked_files_dict?
            # Or iterate through model items? Let's try finding item.
            item = source_model.find_item_by_path(path) # Use helper method
            if item:
                node: Optional[CacheNode] = item.data(NODE_ROLE)
                if node and not node.is_dir:
                    checked_files.append(path)
            else:
                # Fallback: If item not found in model (shouldn't happen often), use os.path
                # This is slow, especially on network drives.
                logger.warning(f"Item not found in model for checked path: {path}. Falling back to os.path.isfile().")
                try:
                    if os.path.isfile(path):
                        checked_files.append(path)
                except OSError as e:
                    logger.warning(f"Error checking if path is file in get_checked_files (fallback): {path}, Error: {e}")


        # logger.debug(f"get_checked_files called. Returning {len(checked_files)} file paths.")
        return checked_files

    def update_check_states_from_dict(self):
        """Forces UI update based on the current checked_files_dict."""
        logger.debug("Updating visual check states from dictionary.")
        self.beginResetModel() # More drastic update signal
        # Or iterate and emit dataChanged for all items?
        # for path in self.checked_files_dict.keys():
        #     item = self.sourceModel().find_item_by_path(path)
        #     if item:
        #         source_index = self.sourceModel().indexFromItem(item)
        #         proxy_index = self.mapFromSource(source_index)
        #         if proxy_index.isValid():
        #             self.dataChanged.emit(proxy_index, proxy_index, [Qt.ItemDataRole.CheckStateRole])
        self.endResetModel()
        logger.debug("Finished updating visual check states.")



======== src\ui\widgets\__init__.py ========
# This file makes Python treat the directory widgets as a package.



======== src\ui\widgets\check_box_delegate.py ========

# src/ui/widgets/check_box_delegate.py
from PyQt6.QtCore import Qt, QEvent, QRect, QModelIndex, QAbstractItemModel
from PyQt6.QtWidgets import QStyledItemDelegate, QApplication, QStyleOptionViewItem, QWidget, QStyle
from PyQt6.QtGui import QMouseEvent
import logging

logger = logging.getLogger(__name__)

class CheckBoxDelegate(QStyledItemDelegate):
    """
    체크박스 영역을 클릭했을 때만 체크 상태 토글을 처리하는 Delegate
    """
    def __init__(self, parent: QWidget = None):
        super().__init__(parent)

    def editorEvent(self, event: QEvent, model: QAbstractItemModel, option: QStyleOptionViewItem, index: QModelIndex) -> bool:
        """
        마우스 클릭 이벤트를 처리하여 체크박스 영역 클릭 시 모델 데이터를 업데이트합니다.
        """
        # 체크박스는 0번 컬럼에만 있으니, 그 외 컬럼은 기본 동작
        if index.column() != 0:
            return super().editorEvent(event, model, option, index)

        # 마우스 릴리즈 이벤트이고, 왼쪽 버튼일 때만 반응
        if event.type() == QEvent.Type.MouseButtonRelease and isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            # 체크박스 사각영역 계산
            style = QApplication.style() if self.parent() is None else self.parent().style()
            cb_rect = style.subElementRect(QStyle.SubElement.SE_ItemViewItemCheckIndicator, option, self.parent())

            # 마우스 클릭 위치가 체크박스 내부라면
            if cb_rect.contains(event.position().toPoint()):
                current_value = model.data(index, Qt.ItemDataRole.CheckStateRole)
                # PyQt6에서는 data()가 CheckState enum 값을 직접 반환할 수 있음
                if isinstance(current_value, Qt.CheckState):
                    current_state = current_value
                elif isinstance(current_value, int): # Fallback for integer representation
                    current_state = Qt.CheckState(current_value)
                else: # 예상치 못한 타입이면 처리 중단
                    logger.warning(f"Unexpected data type for CheckStateRole: {type(current_value)}")
                    return False

                # 체크 상태 토글
                new_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked

                # 모델 데이터 변경 시도 및 결과 로깅
                logger.debug(f"CheckBoxDelegate: Attempting setData for index {index.row()},{index.column()} with state {new_state}")
                success = model.setData(index, new_state, Qt.ItemDataRole.CheckStateRole)
                logger.debug(f"CheckBoxDelegate: setData call result: {success}")

                # setData가 성공적으로 모델 데이터를 변경했으면 True 반환
                if success:
                    return True # 이벤트 처리 완료, 다른 핸들러 호출 방지
                else:
                    # setData 실패 시 로그 남기고 기본 처리로 넘어감
                    logger.warning(f"CheckBoxDelegate: setData failed for index {index.row()},{index.column()}")
                    return False # setData 실패 시 False 반환

        # 다른 이벤트는 기본 처리
        return super().editorEvent(event, model, option, index)

    # paint 메서드는 기본 QStyledItemDelegate의 동작을 사용하므로 오버라이드 불필요
    # def paint(self, painter: QPainter, option: QStyleOptionViewItem, index: QModelIndex):
    #     super().paint(painter, option, index)




======== src\ui\widgets\custom_tab_bar.py ========

from PyQt6.QtWidgets import QTabBar, QTabWidget, QInputDialog, QMessageBox, QMainWindow # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from PyQt6.QtGui import QMouseEvent # PyQt5 -> PyQt6
from .tab_manager import is_tab_deletable

class CustomTabBar(QTabBar):
    """
    Custom tab bar with features like adding new tabs, closing tabs with middle-click,
    and renaming tabs with double-click.
    """
    def __init__(self, parent: QTabWidget, main_window: QMainWindow):
        super().__init__(parent)
        self.main_window = main_window # MainWindow 참조 (새 탭 추가 시 필요)
        self.setTabsClosable(False) # 기본 닫기 버튼 숨김 (미들 클릭 사용)
        self.setMovable(True) # 탭 이동 가능
        # "+" 탭 추가 (새 탭 생성용)
        self.addTab("+")

    def mousePressEvent(self, event: QMouseEvent):
        """Handles left mouse button press for adding new tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            # "+" 탭 클릭 시 새 탭 추가 동작 연결
            if index >= 0 and self.tabText(index) == "+":
                # MainWindow의 메서드를 호출하여 새 탭 추가
                if hasattr(self.main_window, 'add_new_custom_tab'):
                    self.main_window.add_new_custom_tab()
                return # 이벤트 처리 완료
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handles middle mouse button release for closing tabs."""
        if event.button() == Qt.MouseButton.MiddleButton: # Qt.MiddleButton -> Qt.MouseButton.MiddleButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                if tab_text != "+" and is_tab_deletable(tab_text):
                    self.parentWidget().removeTab(index)
                elif tab_text != "+":
                    QMessageBox.warning(self.parentWidget(), "경고", f"'{tab_text}' 탭은 제거할 수 없습니다.")
                # "+" 탭은 아무 동작 안 함
        super().mouseReleaseEvent(event)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """Handles left mouse button double-click for renaming tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                # 보호된 탭 또는 "+" 탭은 이름 변경 불가
                if tab_text != "+" and is_tab_deletable(tab_text):
                    new_name, ok = QInputDialog.getText(self.parentWidget(), "탭 이름 변경",
                                                        "새 탭 이름을 입력하세요:", text=tab_text)
                    if ok and new_name and new_name.strip():
                        new_name_stripped = new_name.strip()
                        # 보호된 이름으로 변경 불가 처리
                        if not is_tab_deletable(new_name_stripped):
                             QMessageBox.warning(self.parentWidget(), "경고", f"'{new_name_stripped}'(으)로는 변경할 수 없습니다.")
                             return
                        # 중복 탭 이름 검사
                        for i in range(self.count()):
                            if i != index and self.tabText(i) == new_name_stripped:
                                QMessageBox.warning(self.parentWidget(), "경고", f"'{new_name_stripped}' 탭이 이미 존재합니다.")
                                return
                        # 이름 변경 적용
                        self.setTabText(index, new_name_stripped)
                    elif ok:
                         QMessageBox.warning(self.parentWidget(), "경고", "탭 이름은 비워둘 수 없습니다.")
        super().mouseDoubleClickEvent(event)




======== src\ui\widgets\custom_text_edit.py ========

from PyQt6.QtWidgets import QTextEdit # PyQt5 -> PyQt6
from PyQt6.QtCore import QMimeData # PyQt5 -> PyQt6

class CustomTextEdit(QTextEdit):
    """
    Custom QTextEdit that only allows plain text pasting.
    """
    def __init__(self, parent=None):
        super().__init__(parent)

    def insertFromMimeData(self, source: QMimeData):
        """Overrides insertFromMimeData to paste only plain text."""
        if source.hasText():
            self.insertPlainText(source.text())



======== src\ui\widgets\file_tree_view.py ========
from PyQt6.QtWidgets import QTreeView, QApplication
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QMouseEvent

class FileTreeView(QTreeView):
    """
    마우스 드래그로 여러 파일 선택 시 핸들링하여
    선택된 모든 파일의 체크 상태를 토글합니다.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._drag_start_pos = None
        self._dragging = False

    def mousePressEvent(self, event):
        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            self._drag_start_pos = event.pos()
            self._dragging = False
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._drag_start_pos:
            distance = (event.pos() - self._drag_start_pos).manhattanLength()
            if distance > QApplication.startDragDistance():
                self._dragging = True
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton and self._dragging:
            # 드래그로 선택된 후 마우스 릴리즈 시 선택된 모든 파일 토글
            super().mouseReleaseEvent(event)
            indexes = self.selectionModel().selectedIndexes()
            # 0번 컬럼만 필터링
            col0_indexes = []
            rows = set()
            for idx in indexes:
                if idx.column() == 0 and idx.row() not in rows:
                    col0_indexes.append(idx)
                    rows.add(idx.row())
            if col0_indexes:
                first_state = self.model().data(col0_indexes[0], Qt.ItemDataRole.CheckStateRole)
                if isinstance(first_state, Qt.CheckState):
                    current_state = first_state
                elif isinstance(first_state, int):
                    current_state = Qt.CheckState(first_state)
                else:
                    return
                target_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked
                for idx in col0_indexes:
                    self.model().setData(idx, target_state, Qt.ItemDataRole.CheckStateRole)
            self._drag_start_pos = None
            self._dragging = False
        else:
            super().mouseReleaseEvent(event) 


======== src\ui\widgets\tab_manager.py ========
PROTECTED_TABS = {
    # 기본 UI 탭
    "시스템", "사용자", "파일 트리", "프롬프트 출력", "XML 입력",
    "메타 프롬프트 템플릿", "메타 사용자 입력", "메타 프롬프트 출력",
    "메타 프롬프트", "사용자 프롬프트", "최종 프롬프트", 
    # 기능성 탭
    "+", # 새 탭 추가 버튼
    "   |   ", 

}

def is_tab_deletable(tab_name: str) -> bool:
    """Checks if a tab with the given name can be deleted or renamed by the user."""
    # 보호 목록에 없으면 삭제/이름 변경 가능
    return tab_name not in PROTECTED_TABS


======== src\ui\__init__.py ========
# This file makes Python treat the directory ui as a package.



======== src\ui\main_window.py ========
import os
import io
import logging
import datetime
from typing import Optional, List, Dict, Any
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox,
    QAbstractItemView, QMenuBar, QSplitter, QStyleFactory, QApplication, QMenu,
    QTreeWidget, QTreeWidgetItem, QComboBox, QFileDialog, QInputDialog, QMessageBox,
    QFrame, QLineEdit, QDialog, QListWidget, QListWidgetItem, QStyle
)
from PyQt6.QtGui import QKeySequence, QIcon, QCursor, QMouseEvent, QFont, QDesktopServices, QPixmap, QImage, QAction, QKeyEvent # PyQt5 -> PyQt6, QAction, QKeyEvent 추가
from PyQt6.QtCore import Qt, QSize, QStandardPaths, QModelIndex, QItemSelection, QUrl, QThread, pyqtSignal, QObject, QBuffer, QIODevice, QTimer, QEvent # PyQt5 -> PyQt6, QEvent 추가

# 서비스 및 모델 import
from core.pydantic_models.app_state import AppState
from core.services.db_service import DbService
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.services.gemini_service import build_gemini_graph
from core.services.directory_cache_service import DirectoryCacheService, CacheNode # Added
from core.langgraph_state import GeminiGraphState

# UI 관련 import
# from ui.models.file_system_models import FilteredFileSystemModel, CheckableProxyModel # Removed QFileSystemModel based
from ui.models.file_system_models import CachedFileSystemModel, CheckableProxyModel # Use new models
from ui.controllers.main_controller import MainController # MainController import 수정
from ui.controllers.resource_controller import ResourceController
from ui.controllers.prompt_controller import PromptController
from ui.controllers.xml_controller import XmlController
from ui.controllers.file_tree_controller import FileTreeController
from ui.controllers.system_prompt_controller import apply_default_system_prompt

from .main_window_setup_ui import create_menu_bar, create_widgets, create_layout, create_status_bar
from .main_window_setup_signals import connect_signals
from .settings_dialog import SettingsDialog
from ui.widgets.custom_text_edit import CustomTextEdit
from ui.widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from utils.notifications import show_notification # 알림 기능 임포트

# Pillow import 시도
try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False

# 로거 설정
logger = logging.getLogger(__name__)

# --- Gemini API 호출을 위한 Worker 클래스 ---
class GeminiWorker(QObject):
    finished = pyqtSignal(str, str) # XML, Summary 결과 전달
    error = pyqtSignal(str)         # 오류 메시지 전달

    def __init__(self, graph_app, initial_state: GeminiGraphState): # 초기 상태 직접 받기
        super().__init__()
        self.graph_app = graph_app
        self.initial_state = initial_state # 전달받은 초기 상태 저장

    def run(self):
        """LangGraph 워크플로우를 실행합니다."""
        try:
            logger.info("Starting Gemini worker thread.")
            # LangGraph 실행 (.invoke 사용, 저장된 초기 상태 전달)
            final_state = self.graph_app.invoke(self.initial_state)
            logger.info(f"Gemini worker finished. Final state error: {final_state.get('error_message')}")

            if final_state.get("error_message"):
                self.error.emit(final_state["error_message"])
            else:
                xml_result = final_state.get("xml_output", "")
                summary_result = final_state.get("summary_output", "")
                self.finished.emit(xml_result, summary_result)
        except Exception as e:
            logger.exception("Error during LangGraph execution in worker thread.")
            self.error.emit(f"LangGraph 실행 오류: {str(e)}")


class MainWindow(QMainWindow):
    # 자동 저장 타이머 시그널 (상태 변경 시 타이머 재시작용)
    state_changed_signal = pyqtSignal()

    def __init__(self, mode="Code Enhancer Prompt Builder"):
        super().__init__()
        self._initialized = False
        self.mode = mode
        self.base_title = "DuckPrompt"
        self.update_window_title()

        QApplication.setStyle(QStyleFactory.create("Fusion"))

        # --- 상태 변수 ---
        self.current_project_folder: Optional[str] = None
        self.last_generated_prompt: str = ""
        self.selected_files_data: List[tuple] = [] # Still used by PromptController? Maybe remove.
        self.tree_generated: bool = False # Still used by PromptController? Maybe remove.
        self._is_saving_gemini_settings = False # Still needed to prevent signal loops
        self.attached_items: List[Dict[str, Any]] = []
        self.api_call_start_time: Optional[datetime.datetime] = None # API 호출 시작 시간 저장
        self.api_timer = QTimer(self) # API 경과 시간 업데이트용 타이머 추가
        self.api_timer.timeout.connect(self._update_api_elapsed_time) # 타이머 시그널 연결

        # --- 자동 저장 타이머 ---
        self.auto_save_timer = QTimer(self)
        self.auto_save_timer.setInterval(30000) # 30초 간격으로 변경
        self.auto_save_timer.setSingleShot(True) # 한 번만 실행 (상태 변경 시 재시작)

        # --- 서비스 인스턴스 생성 ---
        try:
            self.db_service = DbService() # Initialize DbService first
            self.config_service = ConfigService(self.db_service) # Inject DbService
        except ConnectionError as e:
             QMessageBox.critical(self, "Database Error", f"데이터베이스 연결 실패: {e}\n프로그램을 종료합니다.")
             # Exit the application gracefully
             # QApplication.instance().quit() # This might not work before app.exec()
             # Instead, prevent further initialization and let the app close
             raise SystemExit(f"Database connection failed: {e}") # Exit if DB fails
        except ValueError as e:
             QMessageBox.critical(self, "Configuration Error", f"설정 로드 실패: {e}\n프로그램을 종료합니다.")
             raise SystemExit(f"Configuration load failed: {e}") # Exit if config load fails

        self.state_service = StateService()
        self.template_service = TemplateService()
        self.prompt_service = PromptService()
        self.xml_service = XmlService()
        self.fs_service = FilesystemService(self.config_service) # Pass DB-backed config
        self.token_service = TokenCalculationService(self.config_service) # Pass DB-backed config
        self.cache_service = DirectoryCacheService(self.fs_service) # Added Cache Service
        self.gemini_graph = build_gemini_graph(self.config_service) # Pass DB-backed config
        self.gemini_thread: Optional[QThread] = None
        self.gemini_worker: Optional[GeminiWorker] = None

        # --- UI 구성 요소 생성 ---
        create_menu_bar(self)
        create_widgets(self) # This now creates CachedFileSystemModel and CheckableProxyModel
        create_layout(self)
        create_status_bar(self)

        # --- 컨트롤러 생성 및 연결 ---
        self.main_controller = MainController(self)
        self.resource_controller = ResourceController(self, self.template_service, self.state_service)
        self.prompt_controller = PromptController(self, self.prompt_service)
        self.xml_controller = XmlController(self, self.xml_service)
        # Pass cache_service to FileTreeController
        self.file_tree_controller = FileTreeController(self, self.fs_service, self.config_service, self.cache_service)

        # --- 시그널 연결 ---
        connect_signals(self)
        # 자동 저장 타이머 시그널 연결
        self.auto_save_timer.timeout.connect(self.resource_controller.save_state_to_default)
        self.state_changed_signal.connect(self.restart_auto_save_timer) # 상태 변경 시 타이머 재시작
        # Connect cache update signal to model population slot
        self.cache_service.cache_updated.connect(self.cached_model.update_model_from_cache_change)
        # Connect check state changes in proxy model to state changed signal
        self.checkable_proxy.check_state_changed.connect(self.state_changed_signal.emit)


        # --- 초기화 작업 ---
        self.resource_controller.load_templates_list()
        self._apply_initial_settings() # 기본 설정 적용 (DB 로드 등)

        self.status_bar.showMessage("Ready (DB Connected)")
        initial_width = 1200; initial_height = 800
        self.resize(initial_width, initial_height)
        left_width = int(initial_width * 0.35)
        right_width = initial_width - left_width
        self.center_splitter.setSizes([left_width, right_width])
        self.build_tabs.setCurrentIndex(1) # 사용자 탭을 기본으로
        self.file_tree_controller.reset_file_tree() # 파일 트리 초기화

        # --- 사용자 탭에 이벤트 필터 설치 ---
        if hasattr(self, 'user_tab'):
            self.user_tab.installEventFilter(self)
            logger.info("Event filter installed on user_tab.")
        # ---------------------------------

        self._initialized = True
        # 프로그램 시작 시 기본 상태 로드 제거 -> 사용자가 버튼 클릭 시 로드
        # self.resource_controller.load_state_from_default()
        self.restart_auto_save_timer() # 초기 로드 후 자동 저장 시작

    def _apply_initial_settings(self):
        """Applies initial settings loaded from ConfigService."""
        logger.info("Applying initial settings from ConfigService...")
        # 1. 기본 시스템 프롬프트 적용
        apply_default_system_prompt(self)

        # 2. Meta 모드일 경우 기본 메타 프롬프트 로드
        if self.mode == "Meta Prompt Builder":
            meta_prompt_path_relative = os.path.join("prompts", "system", "META_Prompt.md")
            try:
                meta_prompt_path = get_resource_path(meta_prompt_path_relative)
                if os.path.exists(meta_prompt_path):
                    with open(meta_prompt_path, "r", encoding="utf-8") as f:
                        self.system_tab.setText(f.read())
            except Exception as e: logger.error(f"Error loading default META prompt: {e}")

        # 3. LLM 및 모델 콤보박스 설정 (기본값 선택)
        self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini")) # 기본 LLM 설정
        self.main_controller.on_llm_selected() # 모델 목록 로드 및 기본 모델 선택

        # 4. Gemini 파라미터 UI 업데이트
        self.load_gemini_settings_to_ui()

        # 5. 파일 필터링/gitignore 설정 로드 (Controller가 CacheService 업데이트)
        self.file_tree_controller.load_gitignore_settings()

        # 6. 리소스 관리 버튼 레이블 업데이트
        self.resource_controller.update_buttons_label()
        logger.info("Initial settings applied.")


    def _restart_with_mode(self, new_mode: str):
        """Restarts the application with the specified mode."""
        self._initialized = False
        self.auto_save_timer.stop() # 타이머 중지
        self.cache_service.stop_monitoring() # Stop monitoring
        self.cache_service.stop_scan() # Stop scan
        self.db_service.disconnect() # Disconnect DB before closing
        self.close()
        # Note: Restarting might re-trigger DB connection errors if they persist
        new_window = MainWindow(mode=new_mode)
        new_window.show()

    def _toggle_mode(self):
        """Toggles between application modes."""
        new_mode = "Meta Prompt Builder" if self.mode == "Code Enhancer Prompt Builder" else "Code Enhancer Prompt Builder"
        self._restart_with_mode(new_mode)

    def _open_readme(self):
        """Opens the README.md file."""
        readme_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'README.md'))
        if os.path.exists(readme_path):
            url = QUrl.fromLocalFile(readme_path)
            if not QDesktopServices.openUrl(url):
                QMessageBox.warning(self, "오류", "README.md 파일을 여는 데 실패했습니다.")
        else:
            QMessageBox.warning(self, "오류", "README.md 파일을 찾을 수 없습니다.")

    def open_settings_dialog(self):
        """Opens the settings dialog."""
        dialog = SettingsDialog(self, self)
        # Dialog is now mostly read-only for config settings
        # It only saves .gitignore changes now
        dialog.exec() # exec_() -> exec()
        # SettingsDialog에서 설정을 저장하면 MainWindow의 UI도 업데이트해야 함
        # (SettingsDialog.save_config_settings 에서 MainWindow 업데이트 로직 호출)
        logger.info("Settings dialog closed.")


    # --- Public Methods ---

    def reset_state(self):
        """Resets internal state variables."""
        logger.info("Resetting application state...")
        was_initialized = self._initialized
        self._initialized = False
        self.auto_save_timer.stop() # 리셋 시 타이머 중지
        self.cache_service.stop_scan() # Stop scan on reset
        self.cache_service.stop_monitoring() # Stop monitoring on reset

        self.current_project_folder = None
        self.last_generated_prompt = ""
        self.selected_files_data = []
        self.tree_generated = False
        self.attached_items = []
        self.api_call_start_time = None # API 시작 시간 초기화
        self.api_timer.stop() # API 타이머 중지

        # 체크 상태 딕셔너리 초기화
        if hasattr(self, 'checkable_proxy'):
            logger.debug("Clearing checked_files_dict in reset_state.")
            self.checkable_proxy.checked_files_dict.clear()

        if hasattr(self, 'attachment_list_widget'): self.attachment_list_widget.clear()
        self.update_window_title()

        # 파일 트리 리셋 (모델 클리어)
        if hasattr(self, 'file_tree_controller'):
            self.file_tree_controller.reset_file_tree()

        # LLM 및 토큰 상태 리셋
        if hasattr(self, 'main_controller'):
            self.main_controller.on_llm_selected() # 기본 LLM/모델 설정
            self.main_controller._stop_token_calculation_thread() # 토큰 계산 스레드 중지
            self.main_controller.reset_token_label() # 토큰 라벨 리셋

        # 탭 내용 클리어
        if hasattr(self, 'system_tab'): self.system_tab.clear()
        if hasattr(self, 'user_tab'): self.user_tab.clear()
        if hasattr(self, 'dir_structure_tab'): self.dir_structure_tab.clear()
        if hasattr(self, 'xml_input_tab'): self.xml_input_tab.clear()
        if hasattr(self, 'prompt_output_tab'): self.prompt_output_tab.clear()
        if hasattr(self, 'summary_tab'): self.summary_tab.clear()
        # Meta 모드 탭 클리어 (존재 시)
        if hasattr(self, 'meta_prompt_tab'): self.meta_prompt_tab.clear()
        if hasattr(self, 'user_prompt_tab'):
            user_prompt_tab_widget = getattr(self, 'user_prompt_tab', None)
            if user_prompt_tab_widget: user_prompt_tab_widget.clear()
        if hasattr(self, 'final_prompt_tab'):
            final_prompt_tab_widget = getattr(self, 'final_prompt_tab', None)
            if final_prompt_tab_widget: final_prompt_tab_widget.clear()

        # 기타 UI 초기화
        if hasattr(self, 'project_folder_label'): self.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API 시간: -") # API 시간 라벨 초기화

        # 기본 설정 다시 적용 (시스템 프롬프트 등)
        self._apply_initial_settings()

        self._initialized = was_initialized # 원래 초기화 상태 복원
        self.restart_auto_save_timer() # 리셋 후 자동 저장 재시작
        logger.info("Application state reset complete.")


    def update_window_title(self, folder_name: Optional[str] = None):
        """Updates the window title."""
        title = f"{folder_name} - {self.base_title}" if folder_name else self.base_title
        self.setWindowTitle(title)

    def get_current_state(self) -> AppState:
        """Gathers the current UI state for saving (full or partial)."""
        checked_paths = self.checkable_proxy.get_all_checked_paths() if hasattr(self, 'checkable_proxy') else []
        selected_llm = self.llm_combo.currentText() if hasattr(self, 'llm_combo') else "Gemini"
        selected_model_name = self.model_name_combo.currentText().strip() if hasattr(self, 'model_name_combo') else ""

        # 첨부 파일 메타데이터만 직렬화
        serializable_attachments = []
        for item in self.attached_items:
            s_item = item.copy()
            s_item.pop('data', None) # 데이터 제외
            serializable_attachments.append(s_item)

        # AppState 모델 생성 (모든 필드 포함)
        state_data = {
            "mode": self.mode,
            "project_folder": self.current_project_folder,
            "system_prompt": self.system_tab.toPlainText(),
            "user_prompt": self.user_tab.toPlainText(),
            "checked_files": checked_paths, # checked_files_dict의 키 리스트 저장
            "selected_llm": selected_llm,
            "selected_model_name": selected_model_name,
            "attached_items": serializable_attachments,
        }
        try:
            app_state = AppState(**state_data)
            return app_state
        except Exception as e:
             logger.error(f"Error creating AppState model: {e}")
             # 오류 발생 시 최소한의 정보로 기본 상태 반환
             return AppState(
                 mode=self.mode,
                 project_folder=self.current_project_folder,
                 user_prompt=self.user_tab.toPlainText(),
                 checked_files=checked_paths,
                 attached_items=serializable_attachments,
                 selected_llm=selected_llm,
                 selected_model_name=selected_model_name
             )

    def set_current_state(self, state: AppState, partial_load: bool = False):
        """
        Sets the UI state based on the provided AppState model.
        If partial_load is True, only loads project folder, checked files, user prompt, and attachments.
        Triggers background scan if project folder changes.
        """
        logger.info(f"Setting current state. Partial load: {partial_load}")
        # UI 업데이트 중 시그널/타이머 방지
        was_initialized = self._initialized
        self._initialized = False
        self.auto_save_timer.stop()

        folder_changed = False
        new_folder = state.project_folder
        old_folder = self.current_project_folder

        # Determine if folder needs update and trigger scan if necessary
        if new_folder and os.path.isdir(new_folder):
            if old_folder != new_folder:
                logger.info(f"Project folder changed: {old_folder} -> {new_folder}")
                folder_changed = True
                self.current_project_folder = new_folder
                folder_name = os.path.basename(new_folder)
                self.project_folder_label.setText(f"현재 프로젝트 폴더: {new_folder}")
                self.update_window_title(folder_name)
                # Clear check state dict immediately on folder change
                if hasattr(self, 'checkable_proxy'):
                    self.checkable_proxy.checked_files_dict.clear()
                    logger.debug("Cleared checked_files_dict due to project folder change.")
                # Load gitignore and start scan
                ignore_patterns = self.file_tree_controller.load_gitignore_settings()
                self.cache_service.start_scan(new_folder, ignore_patterns)
            else:
                # Folder is the same, no need to rescan unless forced
                folder_name = os.path.basename(new_folder)
        elif not new_folder and old_folder:
            # Folder removed in state
            folder_changed = True
            self.current_project_folder = None
            self.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
            self.update_window_title()
            self.file_tree_controller.reset_file_tree() # Clear model
            self.cache_service.stop_scan()
            self.cache_service.stop_monitoring()
            if hasattr(self, 'checkable_proxy'): self.checkable_proxy.checked_files_dict.clear()
        # else: new_folder is None and old_folder is None - no change

        # --- Load common fields (partial and full) ---
        self.user_tab.setText(state.user_prompt)
        self.attached_items = state.attached_items or []
        self._update_attachment_list_ui()

        # --- Full Load Specific Fields ---
        if not partial_load:
            if self.mode != state.mode:
                logger.info(f"Mode mismatch. Restarting...")
                self._restart_with_mode(state.mode)
                return # Restart handles everything

            self.system_tab.setText(state.system_prompt)

            llm_index = self.llm_combo.findText(state.selected_llm)
            if llm_index != -1:
                self.llm_combo.setCurrentIndex(llm_index)
                # on_llm_selected updates model list and selects default/saved
                self.main_controller.on_llm_selected() # Call this first
                # Now try to select the specific model from the state
                model_index = self.model_name_combo.findText(state.selected_model_name)
                if model_index != -1:
                    self.model_name_combo.setCurrentIndex(model_index)
                else:
                    logger.warning(f"Saved model '{state.selected_model_name}' not found for {state.selected_llm} after loading state.")
            else:
                # Saved LLM not found, default to Gemini
                self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini"))
                self.main_controller.on_llm_selected()

            # Load Gemini settings if needed (already done by on_llm_selected if Gemini)
            # self.load_gemini_settings_to_ui()
            self.resource_controller.update_buttons_label()

        # --- Restore Check States (Common for partial and full, AFTER scan potentially finishes) ---
        # Check states should be restored *after* the model is populated by the scan.
        # We store the desired check states and apply them once the scan finishes.
        self._pending_check_states = set(state.checked_files or [])
        if folder_changed:
            # Connect to scan_finished signal to apply checks
            logger.info(f"Scan triggered for folder change. Will apply {len(self._pending_check_states)} check states upon completion.")
            # Ensure only one connection
            try: self.cache_service.scan_finished.disconnect(self._apply_pending_check_states)
            except TypeError: pass # Ignore if not connected
            self.cache_service.scan_finished.connect(self._apply_pending_check_states)
        elif self.current_project_folder:
            # If folder didn't change, apply checks immediately (assuming model is already populated)
            logger.info("Folder unchanged. Applying check states immediately.")
            self._apply_pending_check_states()
        else:
            # No folder, clear pending checks
            self._pending_check_states = set()


        # --- Final UI Updates ---
        status_msg = "마지막 작업 상태 로드 완료." if partial_load else "상태 로드 완료."
        self.status_bar.showMessage(status_msg)
        self._initialized = was_initialized
        self.main_controller.update_char_count_for_active_tab()
        self.token_count_label.setText("토큰 계산: -")
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API 시간: -")
        self.restart_auto_save_timer()

    def _apply_pending_check_states(self):
        """Applies check states stored in self._pending_check_states to the current model."""
        logger.info(f"Applying {len(self._pending_check_states)} pending check states...")
        if not hasattr(self, 'checkable_proxy') or not hasattr(self, 'cached_model'):
            logger.warning("Cannot apply check states: Models not available.")
            self._pending_check_states = set()
            return

        # Disconnect the signal after applying
        try: self.cache_service.scan_finished.disconnect(self._apply_pending_check_states)
        except TypeError: pass

        # Clear current checks before applying pending ones
        self.checkable_proxy.checked_files_dict.clear()
        items_to_check_indices = []

        for path in self._pending_check_states:
            item = self.cached_model.find_item_by_path(path)
            if item:
                source_index = self.cached_model.indexFromItem(item)
                proxy_index = self.checkable_proxy.mapFromSource(source_index)
                if proxy_index.isValid():
                    items_to_check_indices.append(proxy_index)
                else:
                    logger.warning(f"Could not map source index to proxy for pending check: {path}")
            else:
                logger.warning(f"Item not found in model for pending check state: {path}")

        # Apply checks using setData (will handle dictionary update and recursion)
        logger.info(f"Applying check state for {len(items_to_check_indices)} restored items using setData.")
        # Set data in batches or individually? Individual seems safer with recursion flag.
        for proxy_index in items_to_check_indices:
            self.checkable_proxy.setData(proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole)
            # logger.debug(f"  Called setData(Checked) for pending state: {self.checkable_proxy.get_file_path_from_index(proxy_index)}")

        self._pending_check_states = set() # Clear pending states
        logger.info("Finished applying pending check states.")
        # Emit state changed signal after applying checks
        self.state_changed_signal.emit()


    def uncheck_all_files(self):
        """Unchecks all items in the file tree view by clearing the dictionary."""
        if not hasattr(self, 'checkable_proxy'): return
        if not self.checkable_proxy.checked_files_dict: return # Nothing to uncheck

        logger.info("Unchecking all files.")
        # Clear the dictionary
        self.checkable_proxy.checked_files_dict.clear()
        # Signal the proxy model to update the UI based on the cleared dictionary
        self.checkable_proxy.update_check_states_from_dict()
        # Emit state changed signal
        self.state_changed_signal.emit()

    def create_tree_item(self, text, parent=None) -> QTreeWidgetItem:
        """Helper method to create items in the template/state tree."""
        item = QTreeWidgetItem([text])
        if parent is None: self.template_tree.addTopLevelItem(item)
        else: parent.addChild(item)
        return item

    def add_new_custom_tab(self):
        """Adds a new custom tab."""
        new_tab_name, ok = QInputDialog.getText(self, "새 탭 추가", "새 탭의 이름을 입력하세요:")
        if ok and new_tab_name and new_tab_name.strip():
            new_name = new_tab_name.strip()
            from ui.widgets.tab_manager import is_tab_deletable
            if not is_tab_deletable(new_name):
                 QMessageBox.warning(self, "경고", f"'{new_name}'은(는) 사용할 수 없는 탭 이름입니다.")
                 return
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == new_name:
                    QMessageBox.warning(self, "경고", f"'{new_name}' 탭이 이미 존재합니다.")
                    return
            new_tab = CustomTextEdit(); new_tab.setPlaceholderText(f"{new_name} 내용 입력...")
            plus_tab_index = -1
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == "+": plus_tab_index = i; break
            if plus_tab_index != -1:
                 self.build_tabs.insertTab(plus_tab_index, new_tab, new_name)
                 self.build_tabs.setCurrentIndex(plus_tab_index)
            else:
                 self.build_tabs.addTab(new_tab, new_name)
                 self.build_tabs.setCurrentIndex(self.build_tabs.count() - 1)
            # 새 탭의 textChanged 시그널 연결
            new_tab.textChanged.connect(self.main_controller.handle_text_changed)
            self.state_changed_signal.emit() # 상태 변경 시그널 발생
        elif ok: QMessageBox.warning(self, "경고", "탭 이름은 비워둘 수 없습니다.")

    # --- Attachment UI Update ---
    def _update_attachment_list_ui(self):
        """Updates the attachment list widget based on self.attached_items."""
        if not hasattr(self, 'attachment_list_widget'): return
        self.attachment_list_widget.clear()
        for item in self.attached_items:
            item_name = item.get('name', 'Unknown')
            item_type = item.get('type', 'unknown')
            display_text = f"[{item_type.upper()}] {item_name}"
            list_item = QListWidgetItem(display_text)
            icon = QIcon()
            if item_type == 'image':
                img_data = item.get('data')
                if not img_data and item.get('path') and os.path.exists(item['path']):
                    try:
                        with open(item['path'], 'rb') as f: img_data = f.read()
                    except Exception: pass

                if img_data:
                    try:
                        pixmap = QPixmap()
                        pixmap.loadFromData(img_data)
                        if not pixmap.isNull():
                            icon = QIcon(pixmap.scaled(QSize(32, 32), Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)) # Qt.KeepAspectRatio -> Qt.AspectRatioMode.KeepAspectRatio, Qt.SmoothTransformation -> Qt.TransformationMode.SmoothTransformation
                        else:
                           icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
                    except Exception as e:
                        logger.error(f"Error creating thumbnail for {item_name}: {e}")
                        icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
                else:
                    icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon

            elif item_type == 'file':
                icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
            else:
                icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon) # QStyle.SP_FileIcon -> QStyle.StandardPixmap.SP_FileIcon
            list_item.setIcon(icon)
            self.attachment_list_widget.addItem(list_item)
        # 첨부 목록 변경 시 상태 변경 시그널 발생 (자동 저장용)
        # self.state_changed_signal.emit() # 여기서 호출하면 너무 빈번할 수 있음. attach/paste/remove 함수에서 호출.

    # --- LangGraph 관련 메서드 ---
    def send_prompt_to_gemini(self):
        """ Sends the prompt and attachments to Gemini via LangGraph worker thread. """
        if self.mode == "Meta Prompt Builder":
            QMessageBox.information(self, "정보", "Meta Prompt Builder 모드에서는 Gemini 전송 기능을 사용할 수 없습니다.")
            return
        if not hasattr(self, 'prompt_output_tab'):
            QMessageBox.warning(self, "오류", "프롬프트 출력 탭을 찾을 수 없습니다.")
            return

        prompt_text = self.prompt_output_tab.toPlainText()
        loaded_attachments = []
        for item in self.attached_items:
            if not item.get('data') and item.get('path') and os.path.exists(item['path']):
                try:
                    with open(item['path'], 'rb') as f:
                        item['data'] = f.read()
                    logger.info(f"Loaded data for attachment: {item['name']}")
                except Exception as e:
                    QMessageBox.warning(self, "첨부 파일 오류", f"첨부 파일 '{item['name']}' 로드 실패: {e}")
            loaded_attachments.append(item)


        if not prompt_text.strip() and not loaded_attachments:
            QMessageBox.warning(self, "경고", "Gemini에 전송할 프롬프트 내용이나 첨부 파일이 없습니다.")
            return

        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(False)
        self.status_bar.showMessage("Gemini API 호출 중...")
        # API 호출 시작 시간 기록 및 표시
        self.api_call_start_time = datetime.datetime.now()
        start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
        if hasattr(self, 'api_time_label'):
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: 0:00:00") # 초기 경과 시간 표시
        self.api_timer.start(1000) # 1초마다 업데이트 타이머 시작
        QApplication.processEvents()

        if self.gemini_thread and self.gemini_thread.isRunning():
            logger.warning("Terminating previous Gemini thread...")
            self.gemini_thread.quit(); self.gemini_thread.wait()

        selected_model_name = self.model_name_combo.currentText().strip()
        initial_state: GeminiGraphState = {
            "input_prompt": prompt_text,
            "input_attachments": loaded_attachments,
            "selected_model_name": selected_model_name,
            "gemini_response": "",
            "xml_output": "",
            "summary_output": "",
            "error_message": None,
            "log_id": None # log_id 추가
        }

        self.gemini_thread = QThread()
        self.gemini_worker = GeminiWorker(self.gemini_graph, initial_state)
        self.gemini_worker.moveToThread(self.gemini_thread)

        self.gemini_thread.started.connect(self.gemini_worker.run)
        self.gemini_worker.finished.connect(self.handle_gemini_response)
        self.gemini_worker.error.connect(self.handle_gemini_error)
        self.gemini_worker.finished.connect(self.gemini_thread.quit)
        self.gemini_worker.finished.connect(self.gemini_worker.deleteLater)
        self.gemini_thread.finished.connect(self.gemini_thread.deleteLater)
        self.gemini_worker.error.connect(self.gemini_thread.quit)
        self.gemini_worker.error.connect(self.gemini_worker.deleteLater)
        self.gemini_thread.finished.connect(self.cleanup_gemini_thread)

        self.gemini_thread.start()

    def _update_api_elapsed_time(self):
        """ Updates the API elapsed time label. """
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            elapsed_time = datetime.datetime.now() - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS 형식
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str}")
        else:
            # Stop timer if start time is somehow lost
            self.api_timer.stop()

    def handle_gemini_response(self, xml_result: str, summary_result: str):
        """ Handles Gemini response. """
        logger.info("--- Handling Gemini Response ---")
        self.api_timer.stop() # 타이머 중지
        if hasattr(self, 'xml_input_tab'):
            self.xml_input_tab.setPlainText(xml_result)
            logger.info(f"XML Output Length: {len(xml_result)}")
        if hasattr(self, 'summary_tab'):
            self.summary_tab.setPlainText(summary_result)
            logger.info(f"Summary Output Length: {len(summary_result)}")
            self.build_tabs.setCurrentWidget(self.summary_tab)

        # API 경과 시간 계산 및 표시 (최종)
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now()
            elapsed_time = end_time - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS 형식
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str} (완료)")

        self.status_bar.showMessage("Gemini 응답 처리 완료.")
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)

        # --- 작업 완료 알림 ---
        show_notification("Gemini 응답 완료", "Gemini API 응답 처리가 완료되었습니다.")

    def handle_gemini_error(self, error_msg: str):
        """ Handles Gemini error, showing user-friendly message for specific API response issues. """
        logger.error(f"--- Handling Gemini Error: {error_msg} ---")
        self.api_timer.stop() # 타이머 중지

        # API 경과 시간 계산 및 표시 (오류 시에도)
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now()
            elapsed_time = end_time - self.api_call_start_time
            elapsed_str = str(elapsed_time).split('.')[0] # HH:MM:SS 형식
            start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str} (오류)")

        user_display_error = error_msg
        if "Gemini API 응답 처리 오류" in error_msg or "Gemini API 응답 문제 발생" in error_msg:
             user_display_error = "Gemini API 응답 문제입니다. 자세한 내용은 Summary 탭을 확인하세요."
             if hasattr(self, 'summary_tab'):
                 self.summary_tab.setPlainText(f"Gemini 오류 상세:\n{error_msg}")

        QMessageBox.critical(self, "Gemini API 오류", user_display_error)
        self.status_bar.showMessage("Gemini API 호출 오류.")
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)

        # --- 작업 오류 알림 ---
        # 오류 메시지가 너무 길 수 있으므로 일부만 표시
        notification_msg = f"Gemini API 호출 중 오류 발생: {error_msg[:100]}"
        if len(error_msg) > 100: notification_msg += "..."
        show_notification("Gemini 오류", notification_msg)


    def cleanup_gemini_thread(self):
        """ Cleans up Gemini thread and worker objects. """
        logger.info("--- Cleaning up Gemini thread and worker ---")
        self.api_timer.stop() # 스레드 정리 시 타이머 중지
        self.gemini_thread = None
        self.gemini_worker = None
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)


    # --- Gemini 파라미터 관리 메서드 ---
    def load_gemini_settings_to_ui(self):
        """Loads Gemini parameters from DB (via config_service) to UI."""
        # _initialized 체크 제거: 초기화 중에도 호출될 수 있음
        # if not self._initialized: return
        try:
            settings = self.config_service.get_settings()
            if not settings:
                logger.warning("Cannot load Gemini settings to UI: Config settings not available.")
                return

            logger.info("Loading Gemini settings to UI...")
            # 시그널 차단
            self.gemini_temp_edit.blockSignals(True); self.gemini_thinking_checkbox.blockSignals(True)
            self.gemini_budget_edit.blockSignals(True); self.gemini_search_checkbox.blockSignals(True)

            # UI 업데이트
            self.gemini_temp_edit.setText(str(settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(settings.gemini_enable_search)
            logger.info(f"  Temp: {settings.gemini_temperature}, Thinking: {settings.gemini_enable_thinking}, Budget: {settings.gemini_thinking_budget}, Search: {settings.gemini_enable_search}")

            # 시그널 복구
            self.gemini_temp_edit.blockSignals(False); self.gemini_thinking_checkbox.blockSignals(False)
            self.gemini_budget_edit.blockSignals(False); self.gemini_search_checkbox.blockSignals(False)

            # 위젯 가시성 설정
            is_gemini_selected = (self.llm_combo.currentText() == "Gemini")
            if hasattr(self, 'gemini_param_widget'): self.gemini_param_widget.setVisible(is_gemini_selected)
            logger.info("Gemini settings loaded to UI successfully.")

        except Exception as e:
            logger.error(f"Error loading Gemini settings to UI: {e}", exc_info=True)
            QMessageBox.warning(self, "오류", f"Gemini 설정을 UI에 로드하는 중 오류 발생: {e}")


    def save_gemini_settings(self):
        """Saves Gemini parameters from UI to DB (Not Implemented)."""
        # This function is now disabled because saving config back to DB is not implemented.
        # We keep the method to avoid breaking signal connections, but it does nothing.
        if not self._initialized or self._is_saving_gemini_settings: return
        # logger.warning("Saving Gemini parameters to database is currently disabled.")

        # --- Keep the logic to prevent signal loops ---
        self._is_saving_gemini_settings = True
        # Read UI values (optional, could be removed if truly disabled)
        try:
            temp_str = self.gemini_temp_edit.text().strip(); temperature = float(temp_str) if temp_str else 0.0
            enable_thinking = self.gemini_thinking_checkbox.isChecked()
            budget_str = self.gemini_budget_edit.text().strip(); thinking_budget = int(budget_str) if budget_str else 0
            enable_search = self.gemini_search_checkbox.isChecked()
            # print(f"Gemini UI Params: T={temperature}, Think={enable_thinking}, Bud={thinking_budget}, Srch={enable_search}")
        except ValueError:
            pass # Ignore errors if UI has invalid temp values temporarily
        finally:
            self._is_saving_gemini_settings = False
        # --- End of signal loop prevention ---

        # --- Actual saving logic is removed ---
        # try:
        #     # ... (read UI values) ...
        #     update_data = { ... }
        #     # self.config_service.update_settings(**update_data) # This line is removed/commented
        #     print(f"Gemini settings UI changed, but saving to DB is disabled.")
        # except Exception as e:
        #     print(f"Error preparing Gemini settings (saving disabled): {e}")
        # finally: self._is_saving_gemini_settings = False


    # --- Event Handlers ---
    def on_copy_shortcut(self):
        """Handles Ctrl+C shortcut."""
        current_widget = self.build_tabs.currentWidget()
        if isinstance(current_widget, CustomTextEdit):
            if current_widget.textCursor().hasSelection(): current_widget.copy()
            elif current_widget == self.prompt_output_tab or \
                 (hasattr(self, 'final_prompt_tab') and current_widget == self.final_prompt_tab):
                self.prompt_controller.copy_to_clipboard()

    def on_tree_view_context_menu(self, position):
        """Handles context menu requests on the file tree view."""
        index = self.tree_view.indexAt(position)
        if not index.isValid(): return
        # Get path from proxy model using the new method
        file_path = self.checkable_proxy.get_file_path_from_index(index)
        if not file_path: return
        menu = QMenu()
        rename_action = QAction("이름 변경", self) # PyQt6: QAction(text, parent)
        delete_action = QAction("삭제", self) # PyQt6: QAction(text, parent)
        refresh_action = QAction("새로고침", self) # Add refresh action
        menu.addAction(rename_action)
        menu.addAction(delete_action)
        menu.addSeparator()
        menu.addAction(refresh_action)
        action = menu.exec(self.tree_view.viewport().mapToGlobal(position)) # exec_() -> exec()
        if action == rename_action: self.file_tree_controller.rename_item(file_path)
        elif action == delete_action: self.file_tree_controller.delete_item(file_path)
        elif action == refresh_action: self.file_tree_controller.refresh_tree() # Call refresh

    def on_tree_view_item_clicked(self, index: QModelIndex):
        """
        Handles item clicks in the tree view to toggle check state for selected items.
        Applies the toggled state of the clicked item to all currently selected items.
        Uses the CheckableProxyModel's setData.
        """
        if not index.isValid() or index.column() != 0:
            return

        # Get the target state based on the *clicked* item's current state
        current_state_value = self.checkable_proxy.data(index, Qt.ItemDataRole.CheckStateRole)
        if isinstance(current_state_value, Qt.CheckState):
            current_check_state = current_state_value
        elif isinstance(current_state_value, int):
            current_check_state = Qt.CheckState(current_state_value)
        else:
            logger.warning(f"on_tree_view_item_clicked: Unexpected data type for CheckStateRole: {type(current_state_value)}")
            return

        # Determine the state to apply to all selected items (toggle of the clicked item)
        target_check_state = Qt.CheckState.Unchecked if current_check_state == Qt.CheckState.Checked else Qt.CheckState.Checked

        # Get all currently selected proxy indices
        selection_model = self.tree_view.selectionModel()
        selected_proxy_indices = selection_model.selectedIndexes()

        # Filter for unique column 0 indices
        unique_col0_indices = {idx for idx in selected_proxy_indices if idx.column() == 0}

        logger.debug(f"Clicked item: {self.checkable_proxy.get_file_path_from_index(index)}, Target state: {target_check_state}, Selected count: {len(unique_col0_indices)}")

        # Apply the target state to all unique selected items using setData
        # setData will handle the dictionary update and recursive logic
        for proxy_idx in unique_col0_indices:
            if proxy_idx.isValid():
                # logger.debug(f"  Calling setData for selected index: {self.checkable_proxy.get_file_path_from_index(proxy_idx)} with state {target_check_state}")
                # Let setData handle the logic, including checking if state actually needs changing
                self.checkable_proxy.setData(proxy_idx, target_check_state, Qt.ItemDataRole.CheckStateRole)

        # No need to emit state_changed_signal here, it's connected to checkable_proxy.check_state_changed


    def restart_auto_save_timer(self):
        """Restarts the auto-save timer."""
        if self._initialized:
            # logger.debug("Restarting auto-save timer.")
            self.auto_save_timer.start(30000) # 30초 후 저장으로 변경

    def eventFilter(self, source: QObject, event: QEvent) -> bool:
        """
        Filters events for specific widgets, handling Ctrl+Enter in the user tab.
        Modified to run "Generate All" then "Send to Gemini".
        Checks if prompt was generated before sending.
        """
        # 사용자 탭(user_tab)에서 발생하는 키 입력 이벤트인지 확인
        if source == self.user_tab and event.type() == QEvent.Type.KeyPress:
            # QKeyEvent 타입으로 캐스팅 (PyQt6에서는 필요 없을 수 있으나 명시적)
            key_event = event
            if isinstance(key_event, QKeyEvent):
                # Ctrl 키와 Enter 키가 함께 눌렸는지 확인
                is_control_pressed = bool(key_event.modifiers() & Qt.KeyboardModifier.ControlModifier) # Qt.ControlModifier -> Qt.KeyboardModifier.ControlModifier
                is_enter_key = key_event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter)

                if is_control_pressed and is_enter_key:
                    logger.info("Ctrl+Enter detected in user_tab. Triggering 'Generate All' then 'Send to Gemini'.")

                    # Code Enhancer 모드에서만 동작
                    if self.mode == "Code Enhancer Prompt Builder":
                        logger.info("Running 'Generate All'...")
                        # generate_all_and_copy는 프롬프트 생성 성공 시 True 반환
                        success_generate_all = self.prompt_controller.generate_all_and_copy()

                        # 프롬프트가 실제로 생성되었는지 확인 (last_generated_prompt 사용)
                        prompt_generated = bool(self.last_generated_prompt and self.last_generated_prompt.strip())

                        if prompt_generated:
                            logger.info("Prompt generated. Proceeding to 'Send to Gemini'.")
                            if not success_generate_all:
                                # 프롬프트는 생성되었지만, 트리 생성 또는 복사 실패 시 정보 메시지
                                logger.warning("'Generate All' returned False, but prompt was generated. Sending to Gemini anyway.")
                                # 사용자에게 알릴 필요는 없을 수 있음 (상태바 메시지로 대체 가능)
                                # QMessageBox.information(self, "정보", "일부 작업(트리 생성 또는 복사)에 실패했지만 Gemini 전송을 시도합니다.")
                                self.status_bar.showMessage("일부 작업 실패, Gemini 전송 시도...")
                            # Gemini 전송 실행
                            self.send_prompt_to_gemini()
                        else:
                            # 프롬프트 생성 자체가 실패한 경우
                            logger.error("'Generate All' failed to generate a prompt. Skipping 'Send to Gemini'.")
                            QMessageBox.warning(self, "실패", "'한번에 실행' 작업 중 프롬프트 생성에 실패하여 Gemini로 전송하지 못했습니다.")
                    else:
                        # Meta 모드에서는 다른 동작 또는 비활성화
                        logger.info("Ctrl+Enter ignored in Meta Prompt Builder mode.")

                    return True # 이벤트 처리 완료 (기본 동작 방지)

        # 다른 위젯이나 이벤트는 기본 처리
        return super().eventFilter(source, event)


    def closeEvent(self, event):
        """Ensure database connection is closed and threads are stopped when the window closes."""
        logger.info("Closing MainWindow. Stopping threads and disconnecting database.")
        self.auto_save_timer.stop() # 윈도우 닫을 때 자동 저장 타이머 중지
        self.api_timer.stop() # 윈도우 닫을 때 API 타이머 중지
        self.cache_service.stop_monitoring() # Stop monitoring
        self.cache_service.stop_scan() # Stop scan
        # 진행 중인 스레드 중지 시도
        if hasattr(self, 'main_controller'):
            self.main_controller._stop_token_calculation_thread()
        if self.gemini_thread and self.gemini_thread.isRunning():
            logger.warning("Terminating Gemini thread on close...")
            self.gemini_thread.quit()
            self.gemini_thread.wait(1000) # Wait up to 1 second
            if self.gemini_thread and self.gemini_thread.isRunning():
                self.gemini_thread.terminate()
                self.gemini_thread.wait()
            self.cleanup_gemini_thread()

        # 마지막 상태 저장 시도 (선택적)
        try:
            logger.info("Attempting to save final state before closing...")
            self.resource_controller.save_state_to_default()
        except Exception as e:
            logger.error(f"Error saving final state: {e}")

        if hasattr(self, 'db_service'):
            self.db_service.disconnect()
        super().closeEvent(event)




======== src\ui\main_window_setup_signals.py ========
from PyQt6.QtGui import QKeySequence, QAction # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow 타입 힌트
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# 컨트롤러 import (함수 호출용)
def connect_signals(mw: 'MainWindow'):
    """Connects widget signals to controller slots."""
    # 상단 버튼
    mw.mode_toggle_btn.clicked.connect(mw._toggle_mode)
    mw.reset_program_btn.clicked.connect(mw.main_controller.reset_program) # MainController
    mw.load_previous_work_btn.clicked.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.save_current_work_btn.clicked.connect(mw.resource_controller.save_state_to_default) # ResourceController (save default)
    mw.select_project_btn.clicked.connect(mw.file_tree_controller.select_project_folder) # FileTreeController

    # 파일 트리
    mw.tree_view.customContextMenuRequested.connect(mw.on_tree_view_context_menu) # MainWindow (컨트롤러 호출)
    mw.tree_view.clicked.connect(mw.on_tree_view_item_clicked) # 아이템 클릭 시 체크 상태 토글 (연결 복원)
    # Connect proxy model's check_state_changed signal to FileTreeController's handler
    mw.checkable_proxy.check_state_changed.connect(mw.file_tree_controller.on_data_changed)
    # Connect proxy model's check_state_changed signal to MainWindow's state_changed_signal
    mw.checkable_proxy.check_state_changed.connect(mw.state_changed_signal.emit)


    # 실행 버튼
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn.clicked.connect(mw.file_tree_controller.generate_directory_tree_structure) # FileTreeController
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_prompt) # PromptController (Calculates tokens)
        mw.send_to_gemini_btn.clicked.connect(mw.send_prompt_to_gemini) # MainWindow (LangGraph 호출)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        mw.run_xml_parser_btn.clicked.connect(mw.xml_controller.run_xml_parser) # XmlController
        mw.generate_all_btn.clicked.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens via generate_prompt)
    else:
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        if hasattr(mw, "generate_final_prompt_btn"):
            mw.generate_final_prompt_btn.clicked.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)

    # 리소스 관리
    mw.resource_mode_combo.currentIndexChanged.connect(mw.resource_controller.load_templates_list) # ResourceController
    mw.load_selected_template_btn.clicked.connect(mw.resource_controller.load_selected_item) # ResourceController
    mw.save_as_template_btn.clicked.connect(mw.resource_controller.save_current_as_item) # ResourceController
    mw.delete_template_btn.clicked.connect(mw.resource_controller.delete_selected_item) # ResourceController
    mw.update_template_btn.clicked.connect(mw.resource_controller.update_current_item) # ResourceController
    # 백업/복원 버튼 시그널 연결 제거
    # mw.backup_button.clicked.connect(mw.resource_controller.backup_all_states_action)
    # mw.restore_button.clicked.connect(mw.resource_controller.restore_states_from_backup_action)
    mw.template_tree.itemDoubleClicked.connect(mw.resource_controller.load_selected_item) # ResourceController

    # 첨부 파일 관리 버튼 (추가)
    if hasattr(mw, 'attach_file_btn'):
        mw.attach_file_btn.clicked.connect(mw.main_controller.attach_files) # MainController
    if hasattr(mw, 'paste_clipboard_btn'):
        mw.paste_clipboard_btn.clicked.connect(mw.main_controller.paste_from_clipboard) # MainController
    if hasattr(mw, 'remove_attachment_btn'):
        mw.remove_attachment_btn.clicked.connect(mw.main_controller.remove_selected_attachment) # MainController

    # 상태바 & 모델 선택
    mw.llm_combo.currentIndexChanged.connect(mw.main_controller.on_llm_selected) # MainController (Resets token label)
    # 모델명 변경 시 상태 변경 시그널 발생
    mw.model_name_combo.currentIndexChanged.connect(lambda: mw.state_changed_signal.emit())
    mw.model_name_combo.lineEdit().editingFinished.connect(lambda: mw.state_changed_signal.emit())


    # --- Gemini 파라미터 변경 시그널 연결 제거 (DB 저장 비활성화) ---
    # mw.gemini_temp_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_thinking_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # mw.gemini_budget_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_search_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # -----------------------------------------------------------

    # 텍스트 변경 시 문자 수 업데이트 및 토큰 레이블 리셋 (현재 활성 탭 기준)
    mw.build_tabs.currentChanged.connect(mw.main_controller.update_char_count_for_active_tab) # Update char counts when tab changes
    # Connect textChanged for all relevant text edit widgets to the new handler
    mw.system_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.user_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.prompt_output_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'dir_structure_tab'):
        mw.dir_structure_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'xml_input_tab'):
        mw.xml_input_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'summary_tab'): # Summary 탭 연결 추가
        mw.summary_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'meta_prompt_tab'):
        mw.meta_prompt_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'user_prompt_tab'):
        user_prompt_tab_widget = getattr(mw, 'user_prompt_tab', None)
        if user_prompt_tab_widget:
            user_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'final_prompt_tab'):
        final_prompt_tab_widget = getattr(mw, 'final_prompt_tab', None)
        if final_prompt_tab_widget:
            final_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    # Custom tabs added later will have their signals connected in add_new_custom_tab

    # 메뉴 액션
    mw.settings_action.triggered.connect(mw.open_settings_dialog) # 설정 메뉴 연결
    mw.save_state_action.triggered.connect(mw.resource_controller.save_state_to_default) # ResourceController
    mw.load_state_action.triggered.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.export_state_action.triggered.connect(mw.resource_controller.export_state_to_file) # ResourceController
    mw.import_state_action.triggered.connect(mw.resource_controller.import_state_from_file) # ResourceController

    # 단축키
    # Ctrl+Enter 단축키는 MainWindow의 eventFilter에서 처리하므로 여기서 제거
    # shortcut_generate = QAction(mw) # PyQt6: QAction(parent)
    # shortcut_generate.setShortcut(QKeySequence(Qt.Modifier.CTRL | Qt.Key.Key_Return)) # PyQt6: Use Qt.Modifier and Qt.Key
    # if mw.mode == "Meta Prompt Builder":
    #      if hasattr(mw, "generate_final_prompt_btn"):
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)
    #      else:
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
    # else:
    #      shortcut_generate.triggered.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens)
    # mw.addAction(shortcut_generate)

    shortcut_copy = QAction(mw) # PyQt6: QAction(parent)
    shortcut_copy.setShortcut(QKeySequence(QKeySequence.StandardKey.Copy)) # PyQt6: Use StandardKey enum
    shortcut_copy.triggered.connect(mw.on_copy_shortcut) # MainWindow
    mw.addAction(shortcut_copy)

    # 사용자 탭에 이벤트 필터 설치 (MainWindow 생성자에서 수행)
    # if hasattr(mw, 'user_tab'):
    #     mw.user_tab.installEventFilter(mw)



======== src\ui\main_window_setup_ui.py ========
import os
import sys
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QWidget, QVBoxLayout, QHBoxLayout, QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox, QAbstractItemView, QMenuBar,
    QSplitter, QStyleFactory, QApplication, QMenu, QTreeWidget, QComboBox,
    QFrame, QLineEdit, QGroupBox, QSpacerItem, QSizePolicy, QListWidget,
    QGridLayout
)
from PyQt6.QtGui import QFont, QFontDatabase, QAction # PyQt5 -> PyQt6, QAction 추가
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow 타입 힌트
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# 모델 및 위젯 import
# from .models.file_system_models import FilteredFileSystemModel, CheckableProxyModel # Removed QFileSystemModel based
from .models.file_system_models import CachedFileSystemModel, CheckableProxyModel # Use new models
from .widgets.custom_text_edit import CustomTextEdit
from .widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from .widgets.check_box_delegate import CheckBoxDelegate
from .widgets.file_tree_view import FileTreeView

def create_menu_bar(mw: 'MainWindow'):
    """Creates the main menu bar."""
    mw.menubar = QMenuBar(mw)
    mw.setMenuBar(mw.menubar)

    # "파일" 메뉴 제거, "환경 설정" 메뉴를 첫 번째로 추가
    settings_menu = mw.menubar.addMenu("환경 설정") # "파일" 대신 "환경 설정" 메뉴 추가
    mw.settings_action = QAction("환경 설정 열기...", mw) # PyQt6: QAction(text, parent)
    settings_menu.addAction(mw.settings_action)
    settings_menu.addSeparator() # 필요 시 구분선 추가

    # 나머지 메뉴들
    mode_menu = mw.menubar.addMenu("모드")
    switch_to_code_action = QAction("코드 강화 빌더로 전환", mw) # PyQt6: QAction(text, parent)
    switch_to_meta_action = QAction("메타 프롬프트 빌더로 전환", mw) # PyQt6: QAction(text, parent)
    switch_to_code_action.triggered.connect(lambda: mw._restart_with_mode("Code Enhancer Prompt Builder"))
    switch_to_meta_action.triggered.connect(lambda: mw._restart_with_mode("Meta Prompt Builder"))
    mode_menu.addAction(switch_to_code_action)
    mode_menu.addAction(switch_to_meta_action)

    state_menu = mw.menubar.addMenu("상태")
    mw.save_state_action = QAction("상태 저장(기본)", mw) # PyQt6: QAction(text, parent)
    mw.load_state_action = QAction("상태 불러오기(기본)", mw) # PyQt6: QAction(text, parent)
    mw.export_state_action = QAction("상태 내보내기", mw) # PyQt6: QAction(text, parent)
    mw.import_state_action = QAction("상태 가져오기", mw) # PyQt6: QAction(text, parent)
    state_menu.addAction(mw.save_state_action)
    state_menu.addAction(mw.load_state_action)
    state_menu.addAction(mw.export_state_action)
    state_menu.addAction(mw.import_state_action)

    help_menu = mw.menubar.addMenu("도움말")
    open_readme_action = QAction("README 열기", mw) # PyQt6: QAction(text, parent)
    open_readme_action.triggered.connect(mw._open_readme)
    help_menu.addAction(open_readme_action)


def create_widgets(mw: 'MainWindow'):
    """Creates the main widgets used in the window."""
    # --- OS별 기본 폰트 설정 ---
    default_font = QFont()
    font_family_name = ""
    if sys.platform == "win32":
        try:
            font_path = get_resource_path("fonts/malgun.ttf")
            font_id = QFontDatabase.addApplicationFont(font_path)
            if font_id != -1:
                family = QFontDatabase.applicationFontFamilies(font_id)[0]
                print(f"Loaded custom font: {family} from {font_path}")
                default_font = QFont(family, 10)
                font_family_name = family
            else:
                print(f"Failed to load custom font from {font_path}. Using system default.")
                default_font.setFamily("Malgun Gothic")
                default_font.setPointSize(10)
                font_family_name = "Malgun Gothic (Fallback)"
        except Exception as e:
            print(f"Error loading custom font: {e}. Using system default.")
            default_font.setFamily("Malgun Gothic")
            default_font.setPointSize(10)
            font_family_name = "Malgun Gothic (Exception Fallback)"
    elif sys.platform == "darwin":
        default_font.setFamily("Apple SD Gothic Neo")
        default_font.setPointSize(11)
        font_family_name = "Apple SD Gothic Neo"
    else:
        default_font.setStyleHint(QFont.StyleHint.SansSerif) # QFont.SansSerif -> QFont.StyleHint.SansSerif
        default_font.setPointSize(10)
        font_family_name = "System Default Sans-Serif"
    print(f"Applying default font: {font_family_name}, Size: {default_font.pointSize()}")

    # --- 상단 버튼 및 레이블 ---
    mw.mode_toggle_btn = QPushButton("🔄 모드 전환")
    mw.reset_program_btn = QPushButton("🗑️ 전체 프로그램 리셋")
    mw.load_previous_work_btn = QPushButton("⏪ 마지막 작업 불러오기") # 버튼 텍스트 변경
    mw.save_current_work_btn = QPushButton("💾 현재 작업 저장") # 작업 저장 버튼 추가
    mw.select_project_btn = QPushButton("📁 프로젝트 폴더 선택")
    for btn in [mw.mode_toggle_btn, mw.reset_program_btn, mw.load_previous_work_btn, mw.save_current_work_btn, mw.select_project_btn]: # 새 버튼 포함
        btn.setFixedHeight(30)
    mw.project_folder_label = QLabel("현재 프로젝트 폴더: (선택 안 됨)")
    font_lbl = mw.project_folder_label.font()
    font_lbl.setPointSize(10); font_lbl.setBold(True)
    mw.project_folder_label.setFont(font_lbl)

    # --- 파일 탐색기 (왼쪽) ---
    # Use CachedFileSystemModel and CheckableProxyModel
    mw.cached_model = CachedFileSystemModel() # Source model
    mw.tree_view = FileTreeView() # Custom view
    project_folder_getter = lambda: mw.current_project_folder
    # Pass fs_service for potential fallback checks (though ideally not needed)
    mw.checkable_proxy = CheckableProxyModel(project_folder_getter, mw.fs_service, mw.tree_view)
    mw.checkable_proxy.setSourceModel(mw.cached_model) # Set source model
    mw.checkable_proxy.setFilterKeyColumn(0) # Filter based on column 0 data (name/node)
    mw.checkable_proxy.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive) # Qt.CaseInsensitive -> Qt.CaseSensitivity.CaseInsensitive

    mw.tree_view.setModel(mw.checkable_proxy) # Set proxy model to the view
    mw.tree_view.setColumnWidth(0, 250)
    # No need to hide columns as CachedFileSystemModel only has one
    # mw.tree_view.hideColumn(1); mw.tree_view.hideColumn(2); mw.tree_view.hideColumn(3)
    mw.tree_view.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    mw.tree_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu) # Qt.CustomContextMenu -> Qt.ContextMenuPolicy.CustomContextMenu
    mw.tree_view.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers) # QAbstractItemView.NoEditTriggers -> QAbstractItemView.EditTrigger.NoEditTriggers
    mw.tree_view.setItemDelegateForColumn(0, CheckBoxDelegate(mw.tree_view))
    mw.tree_view.setHeaderHidden(True) # Hide header for single column model
    mw.tree_view.setSortingEnabled(False) # Disable sorting for now


    # --- 리소스 관리 (오른쪽 하단) ---
    mw.resource_manager_group = QGroupBox("리소스 관리")
    resource_manager_layout = QGridLayout() # QVBoxLayout 대신 QGridLayout 사용
    resource_manager_layout.setContentsMargins(5, 5, 5, 5); resource_manager_layout.setSpacing(5)

    # 위젯 생성 (기존 코드 재사용)
    mw.resource_mode_combo = QComboBox(); mw.resource_mode_combo.addItems(["프롬프트", "상태"])
    mw.template_tree = QTreeWidget(); mw.template_tree.setHeaderHidden(True)
    mw.load_selected_template_btn = QPushButton("📥 선택 불러오기")
    mw.save_as_template_btn = QPushButton("💾 현재 내용으로 저장")
    mw.template_type_label = QLabel("저장 타입:")
    mw.template_type_combo = QComboBox(); mw.template_type_combo.addItems(["시스템", "사용자"])
    mw.delete_template_btn = QPushButton("❌ 선택 삭제")
    mw.update_template_btn = QPushButton("🔄 현재 내용 업데이트")

    # --- 레이아웃 재구성 (2열 그리드) ---
    # 왼쪽 열 (Column 0)
    resource_manager_layout.addWidget(QLabel("아래에서 로드/저장할 리소스 선택:"), 0, 0, 1, 2) # 라벨은 2열에 걸쳐 표시
    resource_manager_layout.addWidget(mw.template_tree, 1, 0, 6, 1) # 트리는 1행부터 6개 행에 걸쳐 표시

    # 오른쪽 열 (Column 1) - 위젯 배치 순서 조정
    resource_manager_layout.addWidget(mw.load_selected_template_btn, 1, 1) # 행 1

    # 저장 타입 레이아웃 (HBox)
    save_type_layout = QHBoxLayout()
    save_type_layout.addWidget(mw.template_type_label)
    save_type_layout.addWidget(mw.template_type_combo)
    save_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(save_type_layout, 2, 1) # 행 2

    # 리소스 타입 선택 레이아웃 (HBox)
    resource_type_layout = QHBoxLayout()
    resource_type_layout.addWidget(QLabel("리소스 타입 선택:"))
    resource_type_layout.addWidget(mw.resource_mode_combo)
    resource_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(resource_type_layout, 3, 1) # 행 3

    resource_manager_layout.addWidget(mw.save_as_template_btn, 4, 1) # 행 4
    resource_manager_layout.addWidget(mw.update_template_btn, 5, 1) # 행 5
    resource_manager_layout.addWidget(mw.delete_template_btn, 6, 1) # 행 6

    # 오른쪽 열 하단에 빈 공간 추가 (선택적)
    resource_manager_layout.addItem(QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding), 7, 1) # QSizePolicy.Minimum -> QSizePolicy.Policy.Minimum, QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding

    # 열 너비 비율 설정 (선택적)
    resource_manager_layout.setColumnStretch(0, 1) # 왼쪽 열(트리)이 남는 공간 차지
    resource_manager_layout.setColumnStretch(1, 0) # 오른쪽 열(버튼)은 필요한 만큼만

    mw.resource_manager_group.setLayout(resource_manager_layout) # 최종 레이아웃 설정

    # --- 첨부 파일 관리 (왼쪽 하단으로 이동) ---
    mw.attachment_group = QGroupBox("첨부 파일")
    attachment_layout = QVBoxLayout()
    attachment_layout.setContentsMargins(5, 5, 5, 5); attachment_layout.setSpacing(5)
    attachment_button_layout = QHBoxLayout()
    mw.attach_file_btn = QPushButton("📎 파일 첨부")
    mw.paste_clipboard_btn = QPushButton("📋 클립보드 붙여넣기")
    mw.remove_attachment_btn = QPushButton("➖ 선택 제거")
    attachment_button_layout.addWidget(mw.attach_file_btn)
    attachment_button_layout.addWidget(mw.paste_clipboard_btn)
    attachment_button_layout.addWidget(mw.remove_attachment_btn)
    attachment_button_layout.addStretch()
    mw.attachment_list_widget = QListWidget() # 리스트 위젯 생성
    mw.attachment_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    attachment_layout.addLayout(attachment_button_layout)
    attachment_layout.addWidget(mw.attachment_list_widget, 1) # 리스트 위젯이 공간 차지
    mw.attachment_group.setLayout(attachment_layout)
    # Code Enhancer 모드에서만 보이도록 설정 (초기 상태)
    mw.attachment_group.setVisible(mw.mode == "Code Enhancer Prompt Builder")


    # --- 탭 위젯 (오른쪽 상단) ---
    mw.build_tabs = QTabWidget()
    custom_tab_bar = CustomTabBar(mw.build_tabs, mw)
    mw.build_tabs.setTabBar(custom_tab_bar)
    system_tab_label = "메타 프롬프트 템플릿" if mw.mode == "Meta Prompt Builder" else "시스템"
    user_tab_label = "메타 사용자 입력" if mw.mode == "Meta Prompt Builder" else "사용자"
    prompt_output_label = "메타 프롬프트 출력" if mw.mode == "Meta Prompt Builder" else "프롬프트 출력"
    mw.system_tab = CustomTextEdit(); mw.system_tab.setPlaceholderText(f"{system_tab_label} 내용 입력..."); mw.system_tab.setFont(default_font); mw.build_tabs.addTab(mw.system_tab, system_tab_label)
    mw.user_tab = CustomTextEdit(); mw.user_tab.setPlaceholderText(f"{user_tab_label} 내용 입력..."); mw.user_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_tab, user_tab_label)
    if mw.mode != "Meta Prompt Builder":
        mw.dir_structure_tab = CustomTextEdit(); mw.dir_structure_tab.setReadOnly(True); mw.dir_structure_tab.setFont(default_font); mw.build_tabs.addTab(mw.dir_structure_tab, "파일 트리")
    mw.prompt_output_tab = CustomTextEdit()
    output_font = QFont("Consolas", 10) if sys.platform == "win32" else QFont("Monaco", 11) if sys.platform == "darwin" else QFont("Monospace", 10); output_font.setStyleHint(QFont.StyleHint.Monospace) # QFont.Monospace -> QFont.StyleHint.Monospace
    mw.prompt_output_tab.setFont(output_font); mw.prompt_output_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.prompt_output_tab, prompt_output_label)
    if mw.mode != "Meta Prompt Builder":
        mw.xml_input_tab = CustomTextEdit(); mw.xml_input_tab.setPlaceholderText("XML 내용 입력..."); mw.xml_input_tab.setFont(default_font); mw.build_tabs.addTab(mw.xml_input_tab, "XML 입력")
        mw.summary_tab = CustomTextEdit(); mw.summary_tab.setPlaceholderText("Gemini 응답 요약..."); mw.summary_tab.setReadOnly(True); mw.summary_tab.setFont(default_font); mw.build_tabs.addTab(mw.summary_tab, "Summary")
    if mw.mode == "Meta Prompt Builder":
        mw.meta_prompt_tab = CustomTextEdit(); mw.meta_prompt_tab.setPlaceholderText("메타 프롬프트 내용..."); mw.meta_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.meta_prompt_tab, "메타 프롬프트")
        mw.user_prompt_tab = CustomTextEdit(); mw.user_prompt_tab.setPlaceholderText("사용자 프롬프트 내용 입력..."); mw.user_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_prompt_tab, "사용자 프롬프트")
        mw.final_prompt_tab = CustomTextEdit(); mw.final_prompt_tab.setFont(output_font); mw.final_prompt_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.final_prompt_tab, "최종 프롬프트")

    # --- 실행 버튼 (오른쪽 상단) ---
    copy_btn_label = "📋 메타 프롬프트 복사" if mw.mode == "Meta Prompt Builder" else "📋 클립보드에 복사"
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn = QPushButton("🌳 트리 생성")
        mw.generate_btn = QPushButton("✨ 프롬프트 생성")
        mw.send_to_gemini_btn = QPushButton("♊ Gemini로 전송")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.run_xml_parser_btn = QPushButton("▶️ XML 파서 실행")
        mw.generate_all_btn = QPushButton("⚡️ 한번에 실행")
        mw.run_buttons = [mw.generate_tree_btn, mw.generate_btn, mw.send_to_gemini_btn, mw.copy_btn, mw.run_xml_parser_btn, mw.generate_all_btn]
    else:
        mw.generate_btn = QPushButton("🚀 메타 프롬프트 생성")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.generate_final_prompt_btn = QPushButton("🚀 최종 프롬프트 생성")
        mw.run_buttons = [mw.generate_btn, mw.copy_btn, mw.generate_final_prompt_btn]

    # --- 상태 표시줄 위젯 ---
    mw.char_count_label = QLabel("Chars: 0")
    mw.token_count_label = QLabel("토큰 계산: -")
    mw.api_time_label = QLabel("API 시간: -") # API 시간 표시 라벨 추가

    # --- LLM 관련 위젯 (상단) ---
    mw.llm_combo = QComboBox(); mw.llm_combo.addItems(["Gemini", "Claude", "GPT"])
    mw.model_name_combo = QComboBox(); mw.model_name_combo.setEditable(True); mw.model_name_combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert) # QComboBox.NoInsert -> QComboBox.InsertPolicy.NoInsert
    mw.gemini_temp_label = QLabel("Temp:")
    mw.gemini_temp_edit = QLineEdit(); mw.gemini_temp_edit.setFixedWidth(40); mw.gemini_temp_edit.setPlaceholderText("0.0")
    mw.gemini_thinking_label = QLabel("Thinking:")
    mw.gemini_thinking_checkbox = QCheckBox()
    mw.gemini_budget_label = QLabel("Budget:")
    mw.gemini_budget_edit = QLineEdit(); mw.gemini_budget_edit.setFixedWidth(60); mw.gemini_budget_edit.setPlaceholderText("24576")
    mw.gemini_search_label = QLabel("Search:")
    mw.gemini_search_checkbox = QCheckBox()
    # Gemini 파라미터 위젯 그룹화 (상단 이동용)
    mw.gemini_param_widget = QWidget()
    gemini_param_layout = QHBoxLayout(mw.gemini_param_widget)
    gemini_param_layout.setContentsMargins(0, 0, 0, 0); gemini_param_layout.setSpacing(5)
    # 위젯 추가 순서 변경: Temp -> Search -> Thinking -> Budget
    gemini_param_layout.addWidget(mw.gemini_temp_label); gemini_param_layout.addWidget(mw.gemini_temp_edit)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_search_label); gemini_param_layout.addWidget(mw.gemini_search_checkbox) # Search 이동
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_thinking_label); gemini_param_layout.addWidget(mw.gemini_thinking_checkbox)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_budget_label); gemini_param_layout.addWidget(mw.gemini_budget_edit)
    mw.gemini_param_widget.setVisible(mw.llm_combo.currentText() == "Gemini") # 초기 가시성 설정


def create_layout(mw: 'MainWindow'):
    """Creates the main layout and arranges widgets."""
    central_widget = QWidget()
    mw.setCentralWidget(central_widget)
    main_layout = QVBoxLayout(central_widget)
    main_layout.setContentsMargins(5, 5, 5, 5)
    main_layout.setSpacing(5)

    # --- Row 1: Top Buttons ---
    top_buttons_layout = QHBoxLayout()
    top_buttons_layout.addWidget(mw.mode_toggle_btn)
    top_buttons_layout.addWidget(mw.reset_program_btn)
    top_buttons_layout.addWidget(mw.load_previous_work_btn)
    top_buttons_layout.addWidget(mw.save_current_work_btn)
    top_buttons_layout.addWidget(mw.select_project_btn)
    top_buttons_layout.addStretch(1)
    main_layout.addLayout(top_buttons_layout)

    # --- Row 2: Project Folder Label ---
    main_layout.addWidget(mw.project_folder_label)

    # --- Row 3: LLM Selection and Parameters ---
    llm_params_layout = QHBoxLayout()
    llm_params_layout.addWidget(QLabel("Model:"))
    llm_params_layout.addWidget(mw.llm_combo)
    llm_params_layout.addWidget(mw.model_name_combo)
    llm_params_layout.addWidget(mw.gemini_param_widget)
    llm_params_layout.addStretch(1)
    main_layout.addLayout(llm_params_layout)

    # --- Center Splitter (Left: File Tree/Attachments, Right: Tabs/Resources) ---
    mw.center_splitter = QSplitter(Qt.Orientation.Horizontal)

    # --- Left Panel ---
    left_panel = QWidget()
    left_layout = QVBoxLayout(left_panel)
    left_layout.setContentsMargins(0, 0, 0, 0)
    left_splitter = QSplitter(Qt.Orientation.Vertical)
    left_splitter.addWidget(mw.tree_view)
    left_splitter.addWidget(mw.attachment_group)
    # Set initial sizes for the left vertical splitter
    left_splitter.setSizes([400, 150])
    left_layout.addWidget(left_splitter)
    mw.center_splitter.addWidget(left_panel)

    # --- Right Panel ---
    right_panel = QWidget()
    right_layout = QVBoxLayout(right_panel)
    right_layout.setContentsMargins(0, 0, 0, 0)
    right_splitter = QSplitter(Qt.Orientation.Vertical)

    # Top part of the right panel (run buttons and tabs)
    right_top_widget = QWidget()
    right_top_layout = QVBoxLayout(right_top_widget)
    right_top_layout.setContentsMargins(0, 0, 0, 0)
    right_top_layout.setSpacing(5)

    run_buttons_layout = QHBoxLayout()
    for btn in mw.run_buttons:
        run_buttons_layout.addWidget(btn)
    run_buttons_layout.addStretch()
    right_top_layout.addLayout(run_buttons_layout)
    right_top_layout.addWidget(mw.build_tabs, 1)

    right_splitter.addWidget(right_top_widget)
    right_splitter.addWidget(mw.resource_manager_group)
    # Set initial sizes for the right vertical splitter
    right_splitter.setSizes([500, 250])
    right_layout.addWidget(right_splitter)
    mw.center_splitter.addWidget(right_panel)

    main_layout.addWidget(mw.center_splitter, 1)

def create_status_bar(mw: 'MainWindow'):
    """Creates and configures the status bar."""
    mw.status_bar = QStatusBar()
    mw.setStatusBar(mw.status_bar)
    # Add permanent widgets from right to left
    mw.status_bar.addPermanentWidget(mw.api_time_label)
    mw.status_bar.addPermanentWidget(mw.token_count_label)
    mw.status_bar.addPermanentWidget(mw.char_count_label)



======== src\ui\settings_dialog.py ========
import os
import datetime # datetime 추가
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QPlainTextEdit, QFileDialog, QMessageBox, QGroupBox, QHBoxLayout, QComboBox,
    QCheckBox, QApplication, QListWidget, QListWidgetItem, QAbstractItemView, QInputDialog, QWidget,
    QSplitter, QSizePolicy
)
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from PyQt6.QtGui import QColor, QIcon, QIntValidator, QBrush # PyQt5 -> PyQt6, QIntValidator 추가, QBrush 추가
from typing import Optional, Set, List, Dict, Any, Tuple # Dict, Any, Tuple 추가
from pydantic import ValidationError
import logging # 로깅 추가

# 서비스 및 컨트롤러 함수 import
from core.services.config_service import ConfigService
from core.pydantic_models.config_settings import ConfigSettings
from ui.controllers.system_prompt_controller import select_default_system_prompt
# MainWindow 타입 힌트 (순환 참조 방지)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow
    from core.services.db_service import DbService # DbService 타입 힌트

logger = logging.getLogger(__name__) # 로거 설정

# 파스텔 그린 색상 정의
PASTEL_GREEN = QColor(152, 251, 152) # 연한 녹색 (RGB)
# 파스텔 블루 색상 정의 (사용자 선택 강조용)
PASTEL_BLUE = QColor(173, 216, 230) # 연한 파란색 (Light Blue)
# 파스텔 퍼플 색상 정의 (자동 선택 예정 강조용)
PASTEL_PURPLE = QColor(221, 160, 221) # 연보라색 (Plum)

# --- 모델 추가 다이얼로그 ---
class AddModelDialog(QDialog):
    """모델 이름, RPM, Daily Limit을 입력받는 다이얼로그."""
    def __init__(self, model_type: str, existing_models: List[str], parent=None):
        super().__init__(parent)
        self.model_type = model_type
        self.existing_models = existing_models
        self.setWindowTitle(f"{model_type} 모델 추가")

        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.model_name_edit = QLineEdit()
        self.rpm_limit_edit = QLineEdit()
        self.daily_limit_edit = QLineEdit()

        # 숫자만 입력 가능하도록 Validator 설정
        self.rpm_limit_edit.setValidator(QIntValidator(0, 999999)) # 0 이상 정수
        self.daily_limit_edit.setValidator(QIntValidator(0, 9999999)) # 0 이상 정수

        form_layout.addRow("모델 이름:", self.model_name_edit)
        form_layout.addRow("RPM Limit (분당 요청 수):", self.rpm_limit_edit)
        form_layout.addRow("Daily Limit (하루 요청 수):", self.daily_limit_edit)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)

    def validate_and_accept(self):
        """입력값 유효성 검사 후 accept."""
        model_name = self.model_name_edit.text().strip()
        rpm_limit_str = self.rpm_limit_edit.text().strip()
        daily_limit_str = self.daily_limit_edit.text().strip()

        if not model_name:
            QMessageBox.warning(self, "입력 오류", "모델 이름을 입력해야 합니다.")
            return
        if model_name in self.existing_models:
            QMessageBox.warning(self, "입력 오류", f"'{model_name}' 모델이 이미 목록에 존재합니다.")
            return
        if not rpm_limit_str:
            QMessageBox.warning(self, "입력 오류", "RPM Limit을 입력해야 합니다.")
            return
        if not daily_limit_str:
            QMessageBox.warning(self, "입력 오류", "Daily Limit을 입력해야 합니다.")
            return

        try:
            int(rpm_limit_str)
            int(daily_limit_str)
        except ValueError:
            QMessageBox.warning(self, "입력 오류", "RPM 및 Daily Limit은 숫자로 입력해야 합니다.")
            return

        self.accept() # 유효성 검사 통과 시 accept

    def get_model_data(self) -> Optional[Tuple[str, int, int]]:
        """입력된 모델 데이터 반환."""
        if self.result() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_name = self.model_name_edit.text().strip()
            rpm_limit = int(self.rpm_limit_edit.text().strip())
            daily_limit = int(self.daily_limit_edit.text().strip())
            return model_name, rpm_limit, daily_limit
        return None

# --- SettingsDialog ---
class SettingsDialog(QDialog):
    """
    환경 설정을 표시하고 수정하는 다이얼로그 창.
    DB에서 로드된 설정을 보여주고, 수정 후 DB에 저장합니다.
    .gitignore 파일 편집/저장 기능도 유지합니다.
    API 키 필드는 일반 텍스트로 표시됩니다. (저장 로직은 별도 관리)
    사용 가능 LLM 모델 목록 및 API 키를 관리하는 기능이 추가되었습니다.
    API 키 목록에 잔여 사용량 정보를 표시하고, 사용자가 사용할 키를 선택할 수 있습니다.
    사용 가능 LLM 모델 목록에서 클릭하여 기본 모델을 지정할 수 있습니다.
    사용자가 키를 선택하지 않았을 때 자동으로 선택될 키를 표시합니다.
    """
    PASTEL_GREEN = PASTEL_GREEN # 클래스 변수로도 정의
    PASTEL_BLUE = PASTEL_BLUE # 클래스 변수로도 정의
    PASTEL_PURPLE = PASTEL_PURPLE # 클래스 변수로도 정의

    def __init__(self, main_window: 'MainWindow', parent=None):
        super().__init__(parent)
        self.mw = main_window # MainWindow 참조
        self.config_service = main_window.config_service
        self.db_service: 'DbService' = main_window.db_service # DbService 참조 추가
        self.settings: Optional[ConfigSettings] = None # Load in load_config_settings

        self.setWindowTitle("환경 설정") # Title updated
        self.setMinimumWidth(800) # 너비 증가
        self.setMinimumHeight(750) # 높이 증가 (내용 표시 공간 확보)

        # --- UI 요소 생성 ---
        # 기본 시스템 프롬프트
        self.default_prompt_group = QGroupBox("기본 시스템 프롬프트")
        prompt_layout = QHBoxLayout()
        self.default_prompt_path_edit = QLineEdit()
        self.default_prompt_path_edit.setPlaceholderText("프로젝트 루트 기준 상대 경로 또는 절대 경로")
        self.browse_prompt_button = QPushButton("찾아보기...") # Button text changed
        prompt_layout.addWidget(self.default_prompt_path_edit)
        prompt_layout.addWidget(self.browse_prompt_button)
        self.default_prompt_group.setLayout(prompt_layout)

        # --- API 키 관리 (개선) ---
        self.api_key_management_group = QGroupBox("API 키 관리")
        api_key_management_layout = QVBoxLayout()

        # API 키 목록 표시 및 새로고침 버튼
        api_list_layout = QHBoxLayout()
        self.api_keys_list = QListWidget()
        self.api_keys_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.api_keys_list.setMinimumHeight(100) # 최소 높이 증가
        self.api_keys_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        self.refresh_api_usage_btn = QPushButton("🔄") # 새로고침 버튼 추가
        self.refresh_api_usage_btn.setToolTip("API 키 사용량 새로고침")
        self.refresh_api_usage_btn.setFixedWidth(30) # 버튼 크기 고정
        api_list_layout.addWidget(self.api_keys_list)
        api_list_layout.addWidget(self.refresh_api_usage_btn)

        # 라벨 업데이트: 아이콘 설명 추가 (✨ 추가)
        self.api_key_label = QLabel(
            "등록된 API 키 (🔵: 사용자 선택됨, 🟢: 마지막 사용, ✨: 자동 선택 예정, 🟡: 활성, 🔴: 비활성 / 잔여량은 기본 Gemini 모델 기준):"
        )
        api_key_management_layout.addWidget(self.api_key_label)
        api_key_management_layout.addLayout(api_list_layout) # 목록과 새로고침 버튼 레이아웃 추가

        # API 키 추가/제거/선택 버튼
        api_key_buttons_layout = QHBoxLayout()
        self.add_api_key_btn = QPushButton("➕ 새 API 키 추가")
        self.remove_api_key_btn = QPushButton("➖ 선택한 키 제거")
        self.set_selected_key_btn = QPushButton("✅ 선택한 키 사용") # 사용 키 선택 버튼 추가
        api_key_buttons_layout.addWidget(self.add_api_key_btn)
        api_key_buttons_layout.addWidget(self.remove_api_key_btn)
        api_key_buttons_layout.addWidget(self.set_selected_key_btn) # 버튼 레이아웃에 추가
        api_key_buttons_layout.addStretch()
        api_key_management_layout.addLayout(api_key_buttons_layout)

        self.api_key_management_group.setLayout(api_key_management_layout)


        # 사용 가능 LLM 모델 관리 (위치 이동됨)
        self.available_models_group = QGroupBox("사용 가능 LLM 모델 목록 관리 (클릭하여 기본 모델 지정)") # 그룹 제목 수정
        available_models_main_layout = QHBoxLayout()

        # Gemini 모델 목록
        gemini_model_widget = QWidget()
        gemini_model_layout = QVBoxLayout(gemini_model_widget)
        gemini_model_layout.addWidget(QLabel("Gemini 모델:"))
        self.gemini_models_list = QListWidget()
        self.gemini_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.gemini_models_list.setMinimumHeight(100) # 최소 높이 증가
        self.gemini_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gemini_model_buttons = QHBoxLayout()
        self.add_gemini_model_btn = QPushButton("추가")
        self.remove_gemini_model_btn = QPushButton("제거")
        gemini_model_buttons.addWidget(self.add_gemini_model_btn)
        gemini_model_buttons.addWidget(self.remove_gemini_model_btn)
        gemini_model_layout.addWidget(self.gemini_models_list)
        gemini_model_layout.addLayout(gemini_model_buttons)

        # Claude 모델 목록
        claude_model_widget = QWidget()
        claude_model_layout = QVBoxLayout(claude_model_widget)
        claude_model_layout.addWidget(QLabel("Claude 모델:"))
        self.claude_models_list = QListWidget()
        self.claude_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.claude_models_list.setMinimumHeight(100) # 최소 높이 증가
        self.claude_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        claude_model_buttons = QHBoxLayout()
        self.add_claude_model_btn = QPushButton("추가")
        self.remove_claude_model_btn = QPushButton("제거")
        claude_model_buttons.addWidget(self.add_claude_model_btn)
        claude_model_buttons.addWidget(self.remove_claude_model_btn)
        claude_model_layout.addWidget(self.claude_models_list)
        claude_model_layout.addLayout(claude_model_buttons)

        # GPT 모델 목록
        gpt_model_widget = QWidget()
        gpt_model_layout = QVBoxLayout(gpt_model_widget)
        gpt_model_layout.addWidget(QLabel("GPT 모델:"))
        self.gpt_models_list = QListWidget()
        self.gpt_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.gpt_models_list.setMinimumHeight(100) # 최소 높이 증가
        self.gpt_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gpt_model_buttons = QHBoxLayout()
        self.add_gpt_model_btn = QPushButton("추가")
        self.remove_gpt_model_btn = QPushButton("제거")
        gpt_model_buttons.addWidget(self.add_gpt_model_btn)
        gpt_model_buttons.addWidget(self.remove_gpt_model_btn)
        gpt_model_layout.addWidget(self.gpt_models_list)
        gpt_model_layout.addLayout(gpt_model_buttons)

        available_models_main_layout.addWidget(gemini_model_widget)
        available_models_main_layout.addWidget(claude_model_widget)
        available_models_main_layout.addWidget(gpt_model_widget)
        self.available_models_group.setLayout(available_models_main_layout)


        # 파일 필터링
        self.filtering_group = QGroupBox("파일 필터링")
        filtering_layout = QFormLayout()
        self.allowed_extensions_edit = QLineEdit()
        self.allowed_extensions_edit.setPlaceholderText("쉼표(,) 또는 공백으로 구분 (예: .py, .js .html)")
        self.excluded_dirs_edit = QPlainTextEdit()
        self.excluded_dirs_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: node_modules/, *.log)")
        self.excluded_dirs_edit.setMinimumHeight(80) # 최소 높이 설정
        self.excluded_dirs_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        self.default_ignore_list_edit = QPlainTextEdit()
        self.default_ignore_list_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: .git/, __pycache__/)")
        self.default_ignore_list_edit.setMinimumHeight(80) # 최소 높이 설정
        self.default_ignore_list_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        filtering_layout.addRow("허용 확장자:", self.allowed_extensions_edit)
        filtering_layout.addRow("제외 폴더/파일:", self.excluded_dirs_edit)
        filtering_layout.addRow("기본 무시 목록:", self.default_ignore_list_edit)
        self.filtering_group.setLayout(filtering_layout)

        # Gemini 파라미터
        self.gemini_group = QGroupBox("Gemini 파라미터")
        gemini_layout = QFormLayout()
        self.gemini_temp_edit = QLineEdit()
        self.gemini_thinking_checkbox = QCheckBox()
        self.gemini_budget_edit = QLineEdit()
        self.gemini_search_checkbox = QCheckBox()
        # 위젯 추가 순서 변경: Temp -> Search -> Thinking -> Budget
        gemini_layout.addRow("Temperature (0.0 ~ 2.0):", self.gemini_temp_edit)
        gemini_layout.addRow("Enable Search:", self.gemini_search_checkbox) # Search 이동
        gemini_layout.addRow("Enable Thinking:", self.gemini_thinking_checkbox)
        gemini_layout.addRow("Thinking Budget:", self.gemini_budget_edit)
        self.gemini_group.setLayout(gemini_layout)

        # .gitignore 편집
        self.gitignore_group = QGroupBox(".gitignore 편집 (현재 프로젝트)")
        gitignore_layout = QVBoxLayout()
        gitignore_button_layout = QHBoxLayout()
        self.load_gitignore_button = QPushButton("불러오기")
        self.save_gitignore_button = QPushButton("저장하기") # This save is for .gitignore only
        gitignore_button_layout.addWidget(self.load_gitignore_button)
        gitignore_button_layout.addWidget(self.save_gitignore_button)
        gitignore_button_layout.addStretch()
        self.gitignore_edit = QPlainTextEdit()
        self.gitignore_edit.setPlaceholderText("프로젝트 폴더 선택 후 '.gitignore' 내용을 불러오거나 편집/저장하세요.")
        self.gitignore_edit.setMinimumHeight(120) # 최소 높이 설정
        self.gitignore_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding) # QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding
        gitignore_layout.addLayout(gitignore_button_layout)
        gitignore_layout.addWidget(self.gitignore_edit)
        self.gitignore_group.setLayout(gitignore_layout)
        self.gitignore_group.setEnabled(bool(self.mw.current_project_folder))

        # 버튼 박스 (Save and Close)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Close) # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Save).setText("설정 저장") # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Close).setText("닫기") # QDialogButtonBox.Close -> QDialogButtonBox.StandardButton.Close

        # --- 레이아웃 설정 (2단 컬럼 스플리터 사용) ---
        main_layout = QVBoxLayout(self)

        # 메인 수평 스플리터 생성
        main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal) # Qt.Horizontal -> Qt.Orientation.Horizontal

        # 왼쪽 컬럼 위젯 및 레이아웃 생성
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(5, 5, 5, 5)
        left_layout.setSpacing(10)

        # 왼쪽 컬럼에 그룹 추가 (순서 변경)
        left_layout.addWidget(self.default_prompt_group)
        left_layout.addWidget(self.available_models_group) # 사용 가능 모델 목록 그룹을 왼쪽으로 이동
        left_layout.addWidget(self.api_key_management_group)
        left_layout.addWidget(self.gemini_group) # Gemini 파라미터 왼쪽으로 이동
        left_layout.addStretch(1) # 위젯들을 위로 밀기

        # 오른쪽 컬럼 위젯 및 레이아웃 생성
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(5, 5, 5, 5)
        right_layout.setSpacing(10)

        # 오른쪽 컬럼에 그룹 추가
        right_layout.addWidget(self.filtering_group)
        right_layout.addWidget(self.gitignore_group) # gitignore 오른쪽으로 이동
        right_layout.addStretch(1) # 위젯들을 위로 밀기

        # 수평 스플리터에 왼쪽/오른쪽 컬럼 위젯 추가
        main_horizontal_splitter.addWidget(left_widget)
        main_horizontal_splitter.addWidget(right_widget)

        # 수평 스플리터 초기 크기 설정 (예: 1:1 비율)
        initial_width = self.width() # 현재 다이얼로그 너비 사용
        main_horizontal_splitter.setSizes([initial_width // 2, initial_width // 2])

        # 메인 레이아웃에 수평 스플리터와 버튼 박스 추가
        main_layout.addWidget(main_horizontal_splitter, 1) # 스플리터가 남는 공간 차지
        main_layout.addWidget(self.button_box)

        # --- 시그널 연결 ---
        self.browse_prompt_button.clicked.connect(self.browse_default_prompt)
        self.load_gitignore_button.clicked.connect(self.load_gitignore)
        self.save_gitignore_button.clicked.connect(self.save_gitignore)
        self.button_box.accepted.connect(self.save_config_settings)
        self.button_box.rejected.connect(self.reject)

        # API 키 관리 버튼 시그널
        self.add_api_key_btn.clicked.connect(self.add_api_key)
        self.remove_api_key_btn.clicked.connect(self.remove_api_key)
        self.refresh_api_usage_btn.clicked.connect(self.load_api_keys_list) # 새로고침 버튼 연결
        self.api_keys_list.itemDoubleClicked.connect(self.show_api_key_value) # 더블클릭 시그널 연결
        self.set_selected_key_btn.clicked.connect(self.set_selected_api_key) # 키 선택 버튼 연결

        # 사용 가능 모델 추가/제거 버튼 시그널 연결
        self.add_gemini_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gemini_models_list, "google")) # Provider 이름 전달
        self.remove_gemini_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gemini_models_list))
        self.add_claude_model_btn.clicked.connect(lambda: self.add_model_to_list(self.claude_models_list, "anthropic")) # Provider 이름 전달
        self.remove_claude_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.claude_models_list))
        self.add_gpt_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gpt_models_list, "openai")) # Provider 이름 전달
        self.remove_gpt_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gpt_models_list))

        # 사용 가능 모델 리스트 클릭 시그널 연결 (기본 모델 지정용)
        self.gemini_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gemini_models_list, 'gemini'))
        self.claude_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.claude_models_list, 'claude'))
        self.gpt_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gpt_models_list, 'gpt'))

        # --- 초기 설정값 로드 ---
        self.load_config_settings()
        self.load_api_keys_list() # API 키 목록 로드
        if self.mw.current_project_folder:
            self.load_gitignore()

    def load_config_settings(self):
        """UI 위젯에 현재 DB 설정값을 로드하고 기본 모델을 하이라이트합니다."""
        try:
            # ConfigService를 통해 최신 설정 로드
            self.settings = self.config_service.get_settings()
            if not self.settings:
                 QMessageBox.critical(self, "오류", "DB에서 설정을 로드하지 못했습니다.")
                 return

            logger.info("Loading config settings into SettingsDialog UI...")

            # UI 위젯 업데이트 (시그널 차단 불필요, 로드 시점에는 사용자 입력 없음)
            self.default_prompt_path_edit.setText(self.settings.default_system_prompt or "")

            # 사용 가능 모델 목록 로드 및 기본 모델 하이라이트
            self._populate_and_highlight_model_list(self.gemini_models_list, self.settings.gemini_available_models, self.settings.gemini_default_model)
            self._populate_and_highlight_model_list(self.claude_models_list, self.settings.claude_available_models, self.settings.claude_default_model)
            self._populate_and_highlight_model_list(self.gpt_models_list, self.settings.gpt_available_models, self.settings.gpt_default_model)

            self.allowed_extensions_edit.setText(", ".join(sorted(list(self.settings.allowed_extensions or set()))))
            self.excluded_dirs_edit.setPlainText("\n".join(sorted(self.settings.excluded_dirs or [])))
            self.default_ignore_list_edit.setPlainText("\n".join(sorted(self.settings.default_ignore_list or [])))

            self.gemini_temp_edit.setText(str(self.settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(self.settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(self.settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(self.settings.gemini_enable_search)

            logger.info("SettingsDialog UI updated with loaded config.")

        except Exception as e:
            QMessageBox.critical(self, "로드 오류", f"설정을 로드하는 중 오류 발생:\n{e}")
            logger.exception("Error loading config settings into SettingsDialog UI")

    def _populate_and_highlight_model_list(self, list_widget: QListWidget, models: List[str], default_model: str):
        """Helper function to populate a model list and highlight the default."""
        list_widget.clear()
        list_widget.addItems(models or [])
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() == default_model:
                item.setBackground(self.PASTEL_GREEN) # 기본 모델 하이라이트
            else:
                # 명시적으로 기본 배경색 설정 (이전 하이라이트 제거)
                # 기본 배경색을 투명하게 설정하여 시스템 테마 따르도록 수정
                item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent

    def handle_model_click(self, clicked_item: QListWidgetItem, list_widget: QListWidget, model_type: str):
        """Handles clicks on model list items to set the default model."""
        if not self.settings: return
        new_default_model = clicked_item.text()
        old_default_model = ""

        # Update the settings object and get the old default model
        if model_type == 'gemini':
            old_default_model = self.settings.gemini_default_model
            self.settings.gemini_default_model = new_default_model
        elif model_type == 'claude':
            old_default_model = self.settings.claude_default_model
            self.settings.claude_default_model = new_default_model
        elif model_type == 'gpt':
            old_default_model = self.settings.gpt_default_model
            self.settings.gpt_default_model = new_default_model
        else:
            return

        logger.info(f"Set default {model_type} model to: {new_default_model}")

        # Update highlighting in the list widget
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            # 이전 기본 모델 하이라이트 제거
            if item.text() == old_default_model:
                 item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent
            # 새 기본 모델 하이라이트 적용
            if item.text() == new_default_model:
                item.setBackground(self.PASTEL_GREEN)

    def load_api_keys_list(self):
        """DB에서 API 키 목록을 로드하여 리스트 위젯에 표시하고 상태(사용자 선택, 마지막 사용, 자동 선택 예정 등)를 강조합니다."""
        self.api_keys_list.clear()
        try:
            all_keys = self.db_service.list_api_keys() # 모든 키 정보 가져오기 (사용량 포함)
            if not all_keys:
                self.api_keys_list.addItem("등록된 API 키가 없습니다.")
                self.api_keys_list.setEnabled(False)
                return

            self.api_keys_list.setEnabled(True)

            user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
            last_used_key_id = self.config_service.get_last_used_gemini_key_id()
            logger.info(f"Current User Selected Key ID: {user_selected_key_id}, Last Used Key ID: {last_used_key_id}")

            default_gemini_model = self.config_service.get_default_model_name('Gemini')
            # Rate limit info is fetched inside the loop now if needed

            # --- 자동 선택 예정 키 식별 (개선) ---
            auto_select_candidate_id: Optional[int] = None
            if user_selected_key_id is None:
                logger.info("Identifying auto-select candidate key...")
                candidate_keys = []
                # 활성 Google 키 필터링
                active_google_keys_info = [k for k in all_keys if k.get('provider') == 'google' and k.get('is_active')]

                for key_info in active_google_keys_info:
                    key_id = key_info['id']
                    # Rate Limit 체크
                    is_limited, reason = self.db_service.is_key_rate_limited(key_id, default_gemini_model)
                    if not is_limited:
                        # Rate Limit 안 걸린 키만 후보로 추가
                        # 유효 일일 사용량 계산 (기존 로직 유지)
                        now = datetime.datetime.now(datetime.timezone.utc)
                        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
                        raw_calls_day = key_info.get('calls_this_day', 0)
                        day_start = key_info.get('day_start_timestamp')
                        if day_start and day_start.tzinfo is None: # 타임존 정보 없으면 UTC로 간주
                             day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                        effective_daily_calls = raw_calls_day if day_start and day_start >= current_day_start else 0
                        candidate_keys.append({'id': key_id, 'effective_calls': effective_daily_calls})
                        logger.debug(f"  Candidate Key ID: {key_id} (Not Rate Limited, Effective Daily Calls: {effective_daily_calls})")
                    else:
                        logger.debug(f"  Skipping Key ID: {key_id} (Rate Limited: {reason})")

                # 유효 일일 사용량 기준 정렬
                candidate_keys.sort(key=lambda x: x['effective_calls'])

                # 가장 사용량 적은 키가 자동 선택 후보
                if candidate_keys:
                    auto_select_candidate_id = candidate_keys[0]['id']
                    logger.info(f"Auto-select candidate key ID identified: {auto_select_candidate_id} (Effective Daily Calls: {candidate_keys[0]['effective_calls']})")
                else:
                    logger.warning("No suitable auto-select candidate key found (all active keys might be rate-limited).")
            # -----------------------------

            # --- 키 목록 UI 업데이트 ---
            rate_limit_info = self.db_service.get_model_rate_limit(default_gemini_model) # Get rate limit info once
            rpm_limit = rate_limit_info.get('rpm_limit') if rate_limit_info else None
            daily_limit = rate_limit_info.get('daily_limit') if rate_limit_info else None
            now = datetime.datetime.now(datetime.timezone.utc) # Get current time once

            for key_info in all_keys:
                key_id = key_info['id']
                provider = key_info.get('provider', 'N/A')
                description = key_info.get('description', '')
                api_key_value = key_info.get('api_key', '')
                api_key_display = api_key_value[:4] + "..." + api_key_value[-4:] if len(api_key_value) > 8 else api_key_value[:4] + "..."
                is_active = key_info.get('is_active', False)

                status_icon = ""
                item_color = QBrush(Qt.GlobalColor.transparent) # 기본 배경 투명
                display_text = f"[{provider.upper()}] {description or api_key_display}"
                extra_info = "" # 상태 표시용 추가 텍스트
                tooltip_status = "" # 툴팁용 상태 문자열

                # 상태 결정 (우선순위: 사용자 선택 > 자동 선택 예정 > 마지막 사용 > 활성 > 비활성)
                if provider == 'google' and key_id == user_selected_key_id:
                    status_icon = "🔵" # 사용자 선택
                    item_color = QBrush(self.PASTEL_BLUE) # 연한 파란색 배경
                    extra_info = " (사용자 선택)"
                    tooltip_status = "User Selected"
                elif provider == 'google' and key_id == auto_select_candidate_id:
                    status_icon = "✨" # 자동 선택 예정
                    item_color = QBrush(self.PASTEL_PURPLE) # 연보라색 배경
                    extra_info = " (자동 선택 예정)"
                    tooltip_status = "Auto-Select Candidate"
                elif provider == 'google' and key_id == last_used_key_id:
                    status_icon = "🟢" # 마지막 사용
                    item_color = QBrush(self.PASTEL_GREEN) # 연한 녹색 배경
                    extra_info = " (마지막 사용)"
                    tooltip_status = "Last Used"
                elif is_active:
                    status_icon = "🟡" # 활성
                    item_color = QBrush(QColor("lightyellow")) # 연한 노란색 배경
                    tooltip_status = "Active"
                else:
                    status_icon = "🔴" # 비활성
                    item_color = QBrush(QColor("lightcoral")) # 연한 산호색 배경
                    tooltip_status = "Inactive"

                display_text = f"{status_icon}{display_text}{extra_info}"

                # 잔여 사용량 계산 (Gemini 키)
                remaining_rpm_str, remaining_daily_str = "N/A", "N/A"
                tooltip_rpm, tooltip_daily = "N/A", "N/A"
                if provider == 'google' and rpm_limit is not None and daily_limit is not None:
                    calls_this_minute = key_info.get('calls_this_minute', 0)
                    minute_start = key_info.get('minute_start_timestamp')
                    calls_this_day = key_info.get('calls_this_day', 0)
                    day_start = key_info.get('day_start_timestamp')
                    if minute_start and minute_start.tzinfo is None: minute_start = minute_start.replace(tzinfo=datetime.timezone.utc)
                    if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc)

                    current_minute_calls = calls_this_minute
                    # 분 시작 시간이 있고, 현재 시간이 분 시작 시간 + 1분보다 크거나 같으면 0으로 리셋
                    if minute_start and now >= minute_start + datetime.timedelta(minutes=1):
                        current_minute_calls = 0
                    remaining_rpm = max(0, rpm_limit - current_minute_calls)
                    remaining_rpm_str = f"{remaining_rpm}/{rpm_limit}"
                    tooltip_rpm = f"{remaining_rpm} / {rpm_limit} (Used: {current_minute_calls})"

                    current_day_calls = calls_this_day
                    # 일 시작 시간이 있고, 현재 시간이 일 시작 시간 + 1일보다 크거나 같으면 0으로 리셋
                    if day_start and now >= day_start + datetime.timedelta(days=1):
                        current_day_calls = 0
                    remaining_daily = max(0, daily_limit - current_day_calls)
                    remaining_daily_str = f"{remaining_daily}/{daily_limit}"
                    tooltip_daily = f"{remaining_daily} / {daily_limit} (Used: {current_day_calls})"

                    display_text += f" (RPM: {remaining_rpm_str}, Daily: {remaining_daily_str})"
                elif provider == 'google':
                    logger.warning(f"Rate limit info not found for model '{default_gemini_model}'. Cannot calculate remaining usage for key ID {key_id}.")

                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, key_id) # 키 ID 저장
                item.setData(Qt.ItemDataRole.UserRole + 1, api_key_value) # 실제 키 값 저장
                item.setData(Qt.ItemDataRole.UserRole + 2, provider) # 프로바이더 저장
                item.setBackground(item_color) # 배경색 설정 (QBrush 사용)

                # 툴팁 업데이트
                tooltip_text = (
                    f"ID: {key_id}\nProvider: {provider}\nKey: {api_key_display}\nStatus: {tooltip_status}"
                )
                if provider == 'google':
                     tooltip_text += f"\nRemaining RPM (vs {default_gemini_model}): {tooltip_rpm}\nRemaining Daily (vs {default_gemini_model}): {tooltip_daily}"
                item.setToolTip(tooltip_text)

                self.api_keys_list.addItem(item)

        except Exception as e:
            QMessageBox.critical(self, "API 키 로드 오류", f"API 키 목록을 불러오는 중 오류 발생:\n{e}")
            logger.exception("Error loading API keys list")
            self.api_keys_list.addItem("API 키 로드 오류")
            self.api_keys_list.setEnabled(False)


    def add_api_key(self):
        """새 API 키를 추가하는 다이얼로그를 띄우고 DB에 저장합니다."""
        provider, ok1 = QInputDialog.getItem(self, "API 키 추가", "Provider 선택:", ["google", "anthropic", "openai"], 0, False)
        if not ok1: return
        # QLineEdit.Password 대신 QLineEdit.Normal 사용
        api_key, ok2 = QInputDialog.getText(self, "API 키 추가", f"{provider} API 키 입력:", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok2 or not api_key.strip(): return
        description, ok3 = QInputDialog.getText(self, "API 키 추가", "설명 (선택 사항):", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok3: description = ""

        try:
            key_id = self.db_service.add_api_key(provider, api_key.strip(), description.strip())
            if key_id is not None:
                QMessageBox.information(self, "성공", "API 키가 성공적으로 추가되었습니다.")
                self.load_api_keys_list() # 목록 새로고침
            else:
                QMessageBox.warning(self, "실패", "API 키 추가 중 오류가 발생했습니다.")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"API 키 추가 중 예외 발생:\n{e}")

    def remove_api_key(self):
        """선택된 API 키를 DB에서 제거합니다."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "제거할 API 키를 목록에서 선택하세요.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        display_text = item.text()

        # 사용자 선택 키는 제거 불가
        user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
        if key_id == user_selected_key_id:
            QMessageBox.warning(self, "제거 불가", "현재 사용하도록 선택된 API 키는 제거할 수 없습니다.\n다른 키를 선택하거나 선택을 해제한 후 시도하세요.")
            return

        reply = QMessageBox.question(self, "삭제 확인", f"정말로 API 키를 삭제하시겠습니까?\n({display_text})",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        try:
            success = self.db_service.delete_api_key(key_id)
            if success:
                QMessageBox.information(self, "성공", "API 키가 성공적으로 제거되었습니다.")
                self.load_api_keys_list() # 목록 새로고침
            else:
                QMessageBox.warning(self, "실패", "API 키 제거 중 오류가 발생했습니다.")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"API 키 제거 중 예외 발생:\n{e}")

    def show_api_key_value(self, item: QListWidgetItem):
        """더블클릭된 API 키의 실제 값을 메시지 박스로 보여줍니다."""
        api_key_value = item.data(Qt.ItemDataRole.UserRole + 1) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        if api_key_value:
            QMessageBox.information(self, "API 키 값 확인",
                                    f"선택한 API 키 값:\n\n{api_key_value}\n\n"
                                    "주의: 이 키는 민감한 정보이므로 안전하게 관리하세요.",
                                    QMessageBox.StandardButton.Ok) # QMessageBox.Ok -> QMessageBox.StandardButton.Ok
        else:
            QMessageBox.warning(self, "오류", "API 키 값을 가져올 수 없습니다.")

    def set_selected_api_key(self):
        """선택된 API 키를 사용자가 사용할 키로 설정합니다 (Gemini 키만 해당)."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "사용할 API 키를 목록에서 선택하세요.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole)
        provider = item.data(Qt.ItemDataRole.UserRole + 2)

        if provider != 'google':
            QMessageBox.information(self, "정보", "Google (Gemini) API 키만 사용하도록 선택할 수 있습니다.")
            return

        # 비활성 키는 선택 불가
        if "🔴" in item.text():
             QMessageBox.warning(self, "선택 불가", "비활성화된 API 키는 사용할 수 없습니다.")
             return

        current_selected_id = self.config_service.get_user_selected_gemini_key_id()

        if key_id == current_selected_id:
            # 이미 선택된 키를 다시 선택하면 선택 해제
            self.config_service.set_user_selected_gemini_key(None)
            QMessageBox.information(self, "선택 해제", "API 키 선택이 해제되었습니다.\n이제 사용량이 가장 적은 키부터 자동으로 사용됩니다.")
        else:
            # 새 키 선택
            self.config_service.set_user_selected_gemini_key(key_id)
            QMessageBox.information(self, "키 선택 완료", f"API 키 ID {key_id}가 사용되도록 선택되었습니다.")

        # UI 업데이트를 위해 목록 다시 로드
        self.load_api_keys_list()


    def browse_default_prompt(self):
        """Opens a file dialog to select the default system prompt and updates the line edit."""
        selected_path = select_default_system_prompt(self.config_service, self)
        if selected_path is not None:
            self.default_prompt_path_edit.setText(selected_path)

    def add_model_to_list(self, list_widget: QListWidget, provider: str):
        """리스트 위젯에 새 모델 이름과 Rate Limit을 추가하고 DB에 저장합니다."""
        existing_models = [list_widget.item(i).text() for i in range(list_widget.count())]
        dialog = AddModelDialog(provider.capitalize(), existing_models, self)
        if dialog.exec() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_data = dialog.get_model_data()
            if model_data:
                model_name, rpm_limit, daily_limit = model_data
                try:
                    # DB에 Rate Limit 정보 저장
                    self.db_service.insert_or_update_rate_limit(
                        model_name=model_name,
                        provider=provider,
                        rpm_limit=rpm_limit,
                        daily_limit=daily_limit
                    )
                    # UI 리스트 위젯에 모델 이름 추가
                    list_widget.addItem(model_name)
                    QMessageBox.information(self, "성공", f"모델 '{model_name}' 및 Rate Limit 정보가 추가되었습니다.")
                except Exception as e:
                    QMessageBox.critical(self, "DB 오류", f"모델 Rate Limit 정보 저장 중 오류 발생:\n{e}")
                    logger.exception(f"Error saving rate limit for model {model_name}")

    def remove_model_from_list(self, list_widget: QListWidget):
        """리스트 위젯에서 선택된 모델 이름을 제거하고 DB에서도 Rate Limit 정보를 제거합니다."""
        selected_items = list_widget.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "제거할 모델을 목록에서 선택하세요.")
            return

        model_to_remove = selected_items[0].text()
        is_default = False
        if list_widget == self.gemini_models_list and self.settings and model_to_remove == self.settings.gemini_default_model: is_default = True
        elif list_widget == self.claude_models_list and self.settings and model_to_remove == self.settings.claude_default_model: is_default = True
        elif list_widget == self.gpt_models_list and self.settings and model_to_remove == self.settings.gpt_default_model: is_default = True


        if is_default:
            QMessageBox.warning(self, "제거 불가", f"'{model_to_remove}' 모델은 현재 기본 모델로 지정되어 있어 제거할 수 없습니다.\n다른 모델을 기본으로 지정한 후 다시 시도하세요.")
            return

        # 기본 모델이 아니면 제거 진행
        reply = QMessageBox.question(self, "모델 제거 확인",
                                     f"정말로 '{model_to_remove}' 모델을 목록과 DB에서 제거하시겠습니까?\n(Rate Limit 정보도 함께 제거됩니다)",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            # DB에서 Rate Limit 정보 제거 시도
            success_db = self.db_service.delete_rate_limit(model_name=model_to_remove)
            if success_db:
                logger.info(f"Successfully removed rate limit info for model '{model_to_remove}' from DB.")
                # DB 제거 성공 시 UI 목록에서도 제거
                for item in selected_items:
                    list_widget.takeItem(list_widget.row(item))
                QMessageBox.information(self, "성공", f"모델 '{model_to_remove}'이(가) 목록과 DB에서 제거되었습니다.")
            else:
                # DB 제거 실패 또는 해당 모델 정보 없음
                logger.warning(f"Failed to remove rate limit info for model '{model_to_remove}' from DB (or not found).")
                # UI 목록에서만 제거할지 여부 결정 (여기서는 DB 실패 시 UI도 유지)
                QMessageBox.warning(self, "DB 오류", f"DB에서 '{model_to_remove}' 모델의 Rate Limit 정보를 제거하는 데 실패했습니다.")

        except Exception as e:
            QMessageBox.critical(self, "오류", f"모델 제거 중 예외 발생:\n{e}")
            logger.exception(f"Error removing model {model_to_remove}")


    def save_config_settings(self):
        """UI에서 설정값을 읽어 ConfigSettings 모델을 업데이트하고 DB에 저장합니다."""
        if not self.settings:
            QMessageBox.critical(self, "오류", "설정 객체가 로드되지 않아 저장할 수 없습니다.")
            return

        try:
            # --- UI에서 값 읽기 (기본 모델은 self.settings에서 직접 읽음) ---
            default_prompt = self.default_prompt_path_edit.text().strip()
            gemini_model = self.settings.gemini_default_model # 클릭 핸들러가 업데이트한 값 사용
            claude_model = self.settings.claude_default_model # 클릭 핸들러가 업데이트한 값 사용
            gpt_model = self.settings.gpt_default_model     # 클릭 핸들러가 업데이트한 값 사용

            gemini_available = [self.gemini_models_list.item(i).text() for i in range(self.gemini_models_list.count())]
            claude_available = [self.claude_models_list.item(i).text() for i in range(self.claude_models_list.count())]
            gpt_available = [self.gpt_models_list.item(i).text() for i in range(self.gpt_models_list.count())]

            # 기본 모델이 사용 가능 목록에 있는지 확인
            if gemini_model not in gemini_available and gemini_available:
                 QMessageBox.warning(self, "설정 오류", f"Gemini 기본 모델 '{gemini_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return
            if claude_model not in claude_available and claude_available:
                 QMessageBox.warning(self, "설정 오류", f"Claude 기본 모델 '{claude_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return
            if gpt_model not in gpt_available and gpt_available:
                 QMessageBox.warning(self, "설정 오류", f"GPT 기본 모델 '{gpt_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return

            allowed_ext_str = self.allowed_extensions_edit.text().strip()
            allowed_extensions = {ext.strip() for ext in allowed_ext_str.replace(',', ' ').split() if ext.strip()}

            excluded_dirs = [line.strip() for line in self.excluded_dirs_edit.toPlainText().splitlines() if line.strip()]
            default_ignore = [line.strip() for line in self.default_ignore_list_edit.toPlainText().splitlines() if line.strip()]

            temp_str = self.gemini_temp_edit.text().strip()
            gemini_temp = float(temp_str) if temp_str else 0.0
            gemini_thinking = self.gemini_thinking_checkbox.isChecked()
            budget_str = self.gemini_budget_edit.text().strip()
            gemini_budget = int(budget_str) if budget_str else 0
            gemini_search = self.gemini_search_checkbox.isChecked()

            # --- 업데이트할 데이터 준비 ---
            # self.settings 객체는 이미 클릭 핸들러에 의해 기본 모델이 업데이트되었으므로,
            # 나머지 필드만 업데이트합니다.
            update_data = self.settings.model_copy(deep=True)
            update_data.default_system_prompt = default_prompt if default_prompt else None
            # 기본 모델은 이미 self.settings에 반영됨
            update_data.allowed_extensions = allowed_extensions
            update_data.excluded_dirs = set(excluded_dirs)
            update_data.default_ignore_list = default_ignore
            update_data.gemini_available_models = gemini_available
            update_data.claude_available_models = claude_available
            update_data.gpt_available_models = gpt_available
            update_data.gemini_temperature = gemini_temp
            update_data.gemini_enable_thinking = gemini_thinking
            update_data.gemini_thinking_budget = gemini_budget
            update_data.gemini_enable_search = gemini_search

            # --- Pydantic 유효성 검사 ---
            validated_settings = ConfigSettings(**update_data.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})) # API 키는 검증/저장 제외

            # --- 로깅 추가: 저장될 최종 설정 데이터 확인 ---
            logger.info("Validated settings data before saving to DB:")
            logger.info(f"{validated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})}")
            # ---------------------------------------------

            # --- DB 저장 ---
            if self.config_service.update_settings(validated_settings):
                # QMessageBox.information(self, "성공", "애플리케이션 설정이 성공적으로 저장되었습니다.") # 확인 메시지 제거
                logger.info("Application settings saved successfully.")
                # MainWindow의 관련 UI 업데이트 트리거
                self.mw.main_controller.on_llm_selected() # LLM/모델 콤보박스 업데이트
                self.mw.load_gemini_settings_to_ui() # 메인 윈도우의 Gemini 파라미터 UI 업데이트
                self.mw.file_tree_controller.load_gitignore_settings() # 필터링 규칙 업데이트
                self.accept() # 다이얼로그 닫기
            else:
                QMessageBox.critical(self, "저장 실패", "설정을 데이터베이스에 저장하는 중 오류가 발생했습니다.")

        except ValidationError as e:
            QMessageBox.warning(self, "입력 오류", f"설정 값 유효성 검사 실패:\n{e}")
        except ValueError as e:
             QMessageBox.warning(self, "입력 오류", f"숫자 필드(온도, 예산)에 유효한 숫자를 입력하세요.\n{e}")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"설정 저장 중 예기치 않은 오류 발생:\n{e}")


    def load_gitignore(self):
        """현재 프로젝트 폴더의 .gitignore 파일을 로드하여 편집기에 표시합니다."""
        if not self.mw.current_project_folder:
            self.gitignore_edit.setPlainText("")
            self.gitignore_edit.setEnabled(False)
            return

        self.gitignore_edit.setEnabled(True)
        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = ""
        try:
            if os.path.isfile(gitignore_path):
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.gitignore_edit.setPlainText(content)
            else:
                self.gitignore_edit.setPlainText("# .gitignore 파일 없음")
        except Exception as e:
            QMessageBox.critical(self, "오류", f".gitignore 파일을 불러오는 중 오류 발생:\n{e}")
            self.gitignore_edit.setPlainText(f"# 오류: {e}")

    def save_gitignore(self):
        """편집기 내용을 현재 프로젝트 폴더의 .gitignore 파일에 저장합니다."""
        if not self.mw.current_project_folder:
            QMessageBox.warning(self, "오류", "프로젝트 폴더가 선택되지 않았습니다.")
            return

        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = self.gitignore_edit.toPlainText()

        try:
            with open(gitignore_path, 'w', encoding='utf-8') as f:
                f.write(content)
            QMessageBox.information(self, "성공", f".gitignore 파일이 저장되었습니다:\n{gitignore_path}")
            if hasattr(self.mw, 'file_tree_controller'):
                self.mw.file_tree_controller.load_gitignore_settings()
        except Exception as e:
            QMessageBox.critical(self, "오류", f".gitignore 파일을 저장하는 중 오류 발생:\n{e}")



======== src\utils\__init__.py ========

# This file makes Python treat the directory utils as a package.

from .helpers import get_project_root, get_resource_path, calculate_char_count
from .notifications import show_notification

__all__ = [
    "get_project_root",
    "get_resource_path",
    "calculate_char_count",
    "show_notification",
]



======== src\utils\db_migration_script.py ========

import psycopg2
import logging
from typing import Dict, Any, Optional, List

# --- Database Connection Details (from db_service.py or environment) ---
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389" # Warning: Hardcoded password

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def run_migration():
    """Performs the database migration: adds usage columns to api_keys, migrates data, drops api_key_usage."""
    conn = None
    try:
        # 1. Connect to the database
        logger.info(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )
        conn.autocommit = False # Start transaction
        logger.info("Database connection successful.")
        cur = conn.cursor()

        # 2. Add new columns to api_keys table if they don't exist
        logger.info("Adding usage tracking columns to api_keys table (if they don't exist)...")
        columns_to_add = [
            ("last_api_call_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_minute", "INTEGER", "NOT NULL DEFAULT 0"),
            ("minute_start_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_day", "INTEGER", "NOT NULL DEFAULT 0"),
            ("day_start_timestamp", "TIMESTAMPTZ", "NULL")
        ]
        for col_name, col_type, col_constraint in columns_to_add:
            try:
                alter_sql = f"ALTER TABLE api_keys ADD COLUMN IF NOT EXISTS {col_name} {col_type} {col_constraint};"
                logger.debug(f"Executing: {alter_sql}")
                cur.execute(alter_sql)
                logger.info(f"Column '{col_name}' added or already exists in api_keys.")
            except psycopg2.Error as e:
                logger.error(f"Error adding column '{col_name}' to api_keys: {e}")
                raise # Stop migration if altering fails

        # 3. Check if api_key_usage table exists before attempting migration
        cur.execute("SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'api_key_usage');")
        usage_table_exists = cur.fetchone()[0]

        if usage_table_exists:
            logger.info("api_key_usage table exists. Migrating data...")

            # 4. Fetch data from api_key_usage
            logger.info("Fetching data from api_key_usage table...")
            try:
                cur.execute("""
                    SELECT api_key_id, last_api_call_timestamp, calls_this_minute,
                           minute_start_timestamp, calls_this_day, day_start_timestamp
                    FROM api_key_usage;
                """)
                usage_data = cur.fetchall()
                logger.info(f"Fetched {len(usage_data)} rows from api_key_usage.")
            except psycopg2.Error as e:
                logger.error(f"Error fetching data from api_key_usage: {e}")
                raise

            # 5. Update api_keys table with migrated data
            logger.info("Updating api_keys table with migrated usage data...")
            update_count = 0
            for row in usage_data:
                key_id, last_call, calls_min, min_start, calls_day, day_start = row
                try:
                    update_sql = """
                        UPDATE api_keys
                        SET last_api_call_timestamp = %s,
                            calls_this_minute = %s,
                            minute_start_timestamp = %s,
                            calls_this_day = %s,
                            day_start_timestamp = %s,
                            updated_at = NOW()
                        WHERE id = %s;
                    """
                    cur.execute(update_sql, (last_call, calls_min, min_start, calls_day, day_start, key_id))
                    if cur.rowcount == 1:
                        update_count += 1
                    else:
                        logger.warning(f"API key ID {key_id} not found in api_keys table during migration update.")
                except psycopg2.Error as e:
                    logger.error(f"Error updating api_keys for key_id {key_id}: {e}")
                    # Decide whether to continue or stop on error
                    # raise # Uncomment to stop on first error
            logger.info(f"Successfully updated {update_count} rows in api_keys with usage data.")

            # 6. Drop the api_key_usage table
            logger.info("Dropping api_key_usage table...")
            try:
                cur.execute("DROP TABLE IF EXISTS api_key_usage;")
                logger.info("api_key_usage table dropped successfully.")
            except psycopg2.Error as e:
                logger.error(f"Error dropping api_key_usage table: {e}")
                raise
        else:
            logger.info("api_key_usage table does not exist. Skipping data migration and table drop.")

        # 7. Commit transaction
        conn.commit()
        logger.info("Database migration completed successfully.")

    except (Exception, psycopg2.Error) as error:
        logger.error(f"Database migration failed: {error}", exc_info=True)
        if conn:
            conn.rollback()
            logger.info("Transaction rolled back.")
    finally:
        if conn:
            cur.close()
            conn.close()
            logger.info("Database connection closed.")

if __name__ == "__main__":
    run_migration()



======== src\utils\helpers.py ========
import os
import sys
# import tiktoken # No longer directly used here, moved to TokenCalculationService
from typing import Union, Optional
# import threading # No longer needed for preloading here
from pathlib import Path # pathlib 사용

# --- 경로 관련 ---
def get_project_root() -> Path:
    """Gets the project root directory reliably."""
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # PyInstaller 번들 환경
        return Path(sys._MEIPASS)
    else:
        # 개발 환경 (main.py 또는 src/app.py에서 실행 가정)

        src_dir = Path(__file__).parent.parent.resolve()
        # 프로젝트 루트는 src 폴더의 부모
        return src_dir.parent

def get_resource_path(relative_path: str) -> str:
    """
    Gets the absolute path to a resource file/directory.
    Assumes the 'resources' directory is at the project root.
    """
    project_root = get_project_root()
    resource_path = project_root / "resources" / relative_path
    return str(resource_path)

# --- 텍스트 계산 관련 ---
def calculate_char_count(text: str) -> int:
    """Calculates the number of characters in the text."""
    return len(text)

# calculate_token_count is now handled by TokenCalculationService
# def calculate_token_count(text: str) -> Optional[int]:
#     """
#     Calculates the number of tokens using the preloaded tiktoken encoding.
#     Returns None if encoding is not available or an error occurs.
#     """
#     # ... (old implementation removed) ...

# init_utils and preload_encoding are removed as tiktoken loading is now
# handled within TokenCalculationService when needed.
# def preload_encoding():
#     """Preloads the tiktoken encoding in a separate thread."""
#     # ... (old implementation removed) ...

# def init_utils():
#     """Initializes utility functions, including preloading encoding."""
#     # ... (old implementation removed) ...

# def get_encoding() -> Optional[tiktoken.Encoding]:
#     """Returns the preloaded tiktoken encoding, loading if necessary."""
#     # ... (old implementation removed) ...



======== src\utils\notifications.py ========
import logging
import os
from typing import Optional

# 애플리케이션 이름 전역 변수
_APP_NAME = "DuckPrompt"

# winotify import 시도
try:
    from winotify import Notification
    # winotify는 기본적으로 Windows에서만 작동합니다.
    _WINOTIFY_AVAILABLE = os.name == 'nt'
except ImportError:
    _WINOTIFY_AVAILABLE = False
    logging.warning("winotify library not found or OS is not Windows. Desktop notifications will be disabled.")

# helpers에서 아이콘 경로 함수 가져오기
from .helpers import get_resource_path

logger = logging.getLogger(__name__)

def show_notification(title: str, message: str, app_name: str = None, timeout: Optional[int] = None):
    """
    Displays a desktop notification using winotify (Windows only).

    Args:
        title: The title of the notification.
        message: The main message content of the notification.
        app_name: The name of the application sending the notification.
        timeout: Duration in seconds (winotify doesn't directly support timeout, Windows setting applies).
    """
    if not _WINOTIFY_AVAILABLE:
        logger.warning(f"Notification not shown (winotify unavailable or not Windows): Title='{title}', Message='{message[:50]}...'")
        return

    try:
        logger.info(f"Showing notification via winotify: Title='{title}', Message='{message[:50]}...'")

        # 아이콘 경로 가져오기
        icon_path = ""
        try:
            icon_path = get_resource_path("icons/rubber_duck.ico")
            if not os.path.exists(icon_path):
                logger.warning(f"Notification icon not found at: {icon_path}")
                icon_path = "" # 아이콘 경로 없으면 빈 문자열로 설정
        except Exception as e:
            logger.error(f"Error getting notification icon path: {e}")
            icon_path = ""

        # 애플리케이션 이름 설정
        notification_app_name = app_name if app_name else _APP_NAME

        # winotify Notification 객체 생성
        toast = Notification(
            app_id=notification_app_name,
            title=title,
            msg=message,
            icon=icon_path if icon_path else None  # 아이콘 경로 설정 (없으면 None)
        )

        # 알림 표시
        toast.show()
        logger.info("winotify notification shown successfully.")

    except Exception as e:
        logger.error(f"Failed to show winotify notification: {e}", exc_info=True)

# Example usage (for testing):
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    print("Testing winotify notification...")
    if _WINOTIFY_AVAILABLE:
        show_notification("Test Notification", "This is a test message from notifications.py using winotify.")
        print("Notification test finished.")
    else:
        print("winotify is not available on this system (requires Windows and winotify library).")




======== src\utils\postgres_db_initializer.py ========

import psycopg2
import os
import yaml # YAML 파싱을 위해 추가
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, List # 타입 힌트 추가

# --- Database Connection Details ---
# 환경 변수나 보안 관리 도구를 사용하는 것이 좋습니다.
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389" # 경고: 실제 비밀번호

# --- Project Root and Config File Path ---
# helpers.py의 get_project_root()를 사용하여 프로젝트 루트를 찾습니다.
# 이 파일이 src/utils/ 에 있으므로, 프로젝트 루트는 두 단계 위입니다.
try:
    PROJECT_ROOT = Path(__file__).parent.parent.parent.resolve()
except NameError:
    # __file__이 정의되지 않은 경우 (예: 인터프리터에서 직접 실행)
    PROJECT_ROOT = Path('.').resolve()

CONFIG_FILE_PATH = PROJECT_ROOT / "src" / "config.yml"


# --- SQL Schema Definition ---
# api_key_usage 테이블 제거, api_keys 테이블에 사용량 컬럼 추가
SCHEMA_SQL = """
-- 타임스탬프 자동 업데이트를 위한 함수 생성 (존재하지 않을 경우)
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 기존 테이블 삭제 (스크립트를 여러 번 실행할 경우) - 주의: 데이터 손실 발생
-- DROP TABLE IF EXISTS application_config CASCADE;
-- DROP TABLE IF EXISTS model_rate_limits CASCADE;
-- DROP TABLE IF EXISTS api_keys CASCADE;
-- DROP TABLE IF EXISTS gemini_api_logs CASCADE;

-- ==== API 키 테이블 (사용량 컬럼 추가) ====
-- 테이블이 존재하지 않을 경우에만 생성 (IF NOT EXISTS 추가)
CREATE TABLE IF NOT EXISTS api_keys (
    id SERIAL PRIMARY KEY,
    api_key TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    description TEXT,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    -- Usage tracking columns added
    last_api_call_timestamp TIMESTAMPTZ,
    calls_this_minute INTEGER NOT NULL DEFAULT 0,
    minute_start_timestamp TIMESTAMPTZ,
    calls_this_day INTEGER NOT NULL DEFAULT 0,
    day_start_timestamp TIMESTAMPTZ,
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 트리거가 존재하지 않을 경우에만 생성
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_api_keys_timestamp') THEN
        CREATE TRIGGER set_api_keys_timestamp
        BEFORE UPDATE ON api_keys
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE api_keys IS 'Stores individual API keys, their metadata, and usage tracking.';
COMMENT ON COLUMN api_keys.api_key IS 'The actual API key string. Sensitive data.';
COMMENT ON COLUMN api_keys.provider IS 'The provider of the API key (e.g., google, anthropic).';
COMMENT ON COLUMN api_keys.description IS 'User-friendly description for the key.';
COMMENT ON COLUMN api_keys.is_active IS 'Flag to enable/disable the key for use.';
COMMENT ON COLUMN api_keys.last_api_call_timestamp IS 'Timestamp of the last successful API call using this key.';
COMMENT ON COLUMN api_keys.calls_this_minute IS 'Counter for calls made within the current minute window.';
COMMENT ON COLUMN api_keys.minute_start_timestamp IS 'Timestamp marking the beginning of the current minute window for rate limiting.';
COMMENT ON COLUMN api_keys.calls_this_day IS 'Counter for calls made within the current day window.';
COMMENT ON COLUMN api_keys.day_start_timestamp IS 'Timestamp marking the beginning of the current day window for rate limiting.';


-- ==== 모델별 기본 Rate Limit 테이블 ====
-- 테이블이 존재하지 않을 경우에만 생성
CREATE TABLE IF NOT EXISTS model_rate_limits (
    id SERIAL PRIMARY KEY,
    model_name TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    rpm_limit INTEGER NOT NULL,
    daily_limit INTEGER NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 트리거가 존재하지 않을 경우에만 생성
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_model_rate_limits_timestamp') THEN
        CREATE TRIGGER set_model_rate_limits_timestamp
        BEFORE UPDATE ON model_rate_limits
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE model_rate_limits IS 'Stores default rate limit information per model.';
COMMENT ON COLUMN model_rate_limits.model_name IS 'Identifier for the language model.';
COMMENT ON COLUMN model_rate_limits.rpm_limit IS 'Default Requests Per Minute limit for the model.';
COMMENT ON COLUMN model_rate_limits.daily_limit IS 'Default Requests Per Day limit for the model.';


-- ==== API 키 사용량 추적 테이블 (제거됨) ====
-- DROP TABLE IF EXISTS api_key_usage CASCADE;


-- ==== 애플리케이션 설정 테이블 ====
-- 테이블이 존재하지 않을 경우에만 생성
CREATE TABLE IF NOT EXISTS application_config (
    id SERIAL PRIMARY KEY,
    profile_name TEXT NOT NULL UNIQUE DEFAULT 'default',
    default_system_prompt TEXT,
    allowed_extensions TEXT[],
    excluded_dirs TEXT[],
    default_ignore_list TEXT[],
    gemini_default_model TEXT,
    claude_default_model TEXT,
    gpt_default_model TEXT,
    gemini_available_models TEXT[],
    claude_available_models TEXT[],
    gpt_available_models TEXT[],
    gemini_temperature NUMERIC(3, 2) DEFAULT 0.0,
    gemini_enable_thinking BOOLEAN DEFAULT TRUE,
    gemini_thinking_budget INTEGER DEFAULT 24576,
    gemini_enable_search BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 트리거가 존재하지 않을 경우에만 생성
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_application_config_timestamp') THEN
        CREATE TRIGGER set_application_config_timestamp
        BEFORE UPDATE ON application_config
        FOR EACH ROW
        EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;

COMMENT ON TABLE application_config IS 'Stores application-wide configuration settings, replacing config.yml.';
COMMENT ON COLUMN application_config.profile_name IS 'Identifier for the configuration profile (e.g., default, development).';
COMMENT ON COLUMN application_config.allowed_extensions IS 'Array of allowed file extensions.';
COMMENT ON COLUMN application_config.excluded_dirs IS 'Array of directory/file patterns to exclude.';
COMMENT ON COLUMN application_config.default_ignore_list IS 'Array of default patterns to ignore.';
COMMENT ON COLUMN application_config.gemini_available_models IS 'Array of available Gemini model names.';
COMMENT ON COLUMN application_config.claude_available_models IS 'Array of available Claude model names.';
COMMENT ON COLUMN application_config.gpt_available_models IS 'Array of available GPT model names.';
COMMENT ON COLUMN application_config.gemini_temperature IS 'Generation temperature for Gemini models.';

-- ==== Gemini API 로그 테이블 ====
-- 테이블이 존재하지 않을 경우에만 생성
CREATE TABLE IF NOT EXISTS gemini_api_logs (
    id SERIAL PRIMARY KEY,
    request_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    response_timestamp TIMESTAMPTZ,
    model_name TEXT,
    request_prompt TEXT,
    request_attachments JSONB,
    response_text TEXT,
    response_xml TEXT,
    response_summary TEXT,
    error_message TEXT,
    elapsed_time_ms INTEGER,
    token_count INTEGER,
    api_key_id INTEGER REFERENCES api_keys(id) ON DELETE SET NULL -- FK 유지
);

-- 인덱스가 존재하지 않을 경우에만 생성
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_request_timestamp' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_request_timestamp ON gemini_api_logs(request_timestamp);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_api_key_id' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_api_key_id ON gemini_api_logs(api_key_id);
    END IF;
END $$;

COMMENT ON TABLE gemini_api_logs IS 'Stores logs of requests and responses to the Gemini API.';
COMMENT ON COLUMN gemini_api_logs.request_timestamp IS 'Timestamp when the request was initiated.';
COMMENT ON COLUMN gemini_api_logs.response_timestamp IS 'Timestamp when the response was received.';
COMMENT ON COLUMN gemini_api_logs.model_name IS 'The specific Gemini model used for the request.';
COMMENT ON COLUMN gemini_api_logs.request_prompt IS 'The text prompt sent to the API.';
COMMENT ON COLUMN gemini_api_logs.request_attachments IS 'JSONB data containing metadata about attached files/images (e.g., name, type, path).';
COMMENT ON COLUMN gemini_api_logs.response_text IS 'The raw text response from the Gemini API.';
COMMENT ON COLUMN gemini_api_logs.response_xml IS 'The parsed XML part of the response, if applicable.';
COMMENT ON COLUMN gemini_api_logs.response_summary IS 'The parsed summary part of the response, if applicable.';
COMMENT ON COLUMN gemini_api_logs.error_message IS 'Error message if the API call failed.';
COMMENT ON COLUMN gemini_api_logs.elapsed_time_ms IS 'Total time taken for the API call in milliseconds.';
COMMENT ON COLUMN gemini_api_logs.token_count IS 'Calculated token count for the request/response.';
COMMENT ON COLUMN gemini_api_logs.api_key_id IS 'Foreign key referencing the api_key used for the request.';

"""

def create_tables(conn):
    """Creates database tables based on the SCHEMA_SQL."""
    print("Attempting to create/update database tables...")
    try:
        with conn.cursor() as cur:
            cur.execute(SCHEMA_SQL)
        conn.commit()
        print("Tables created/updated (or already exist) successfully.")
    except psycopg2.Error as e:
        print(f"Error creating/updating tables: {e}")
        conn.rollback() # Roll back changes on error
        raise # Re-raise the exception to stop the script

def load_yaml_config(file_path: Path) -> Optional[Dict[str, Any]]:
    """Loads configuration from a YAML file."""
    if not file_path.exists():
        print(f"Error: Configuration file not found at {file_path}")
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        print(f"Configuration loaded successfully from {file_path}")
        return config
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading configuration file {file_path}: {e}")
        return None

def insert_or_update_config(conn, config_data: Dict[str, Any]):
    """Inserts or updates the 'default' profile in the application_config table."""
    print("Attempting to insert/update application configuration...")
    profile_name = 'default' # Assuming we always update the default profile

    # Prepare data for insertion/update, handling potential missing keys and types
    # Convert sets from YAML (!!set) to lists for PostgreSQL TEXT[]
    allowed_extensions = list(config_data.get('allowed_extensions', set()))
    excluded_dirs = list(config_data.get('excluded_dirs', set()))
    default_ignore_list = list(config_data.get('default_ignore_list', []))
    gemini_available_models = list(config_data.get('gemini_available_models', []))
    claude_available_models = list(config_data.get('claude_available_models', []))
    gpt_available_models = list(config_data.get('gpt_available_models', []))

    # Ensure boolean values are correctly interpreted
    gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
    gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

    # Ensure numeric values are correctly interpreted, providing defaults
    try:
        gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
    except (ValueError, TypeError):
        gemini_temperature = 0.0
    try:
        gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
    except (ValueError, TypeError):
        gemini_thinking_budget = 24576

    # SQL query using ON CONFLICT for upsert
    sql = """
        INSERT INTO application_config (
            profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
            default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
            gemini_available_models, claude_available_models, gpt_available_models,
            gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
        ) VALUES (
            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
        )
        ON CONFLICT (profile_name) DO UPDATE SET
            default_system_prompt = EXCLUDED.default_system_prompt,
            allowed_extensions = EXCLUDED.allowed_extensions,
            excluded_dirs = EXCLUDED.excluded_dirs,
            default_ignore_list = EXCLUDED.default_ignore_list,
            gemini_default_model = EXCLUDED.gemini_default_model,
            claude_default_model = EXCLUDED.claude_default_model,
            gpt_default_model = EXCLUDED.gpt_default_model,
            gemini_available_models = EXCLUDED.gemini_available_models,
            claude_available_models = EXCLUDED.claude_available_models,
            gpt_available_models = EXCLUDED.gpt_available_models,
            gemini_temperature = EXCLUDED.gemini_temperature,
            gemini_enable_thinking = EXCLUDED.gemini_enable_thinking,
            gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
            gemini_enable_search = EXCLUDED.gemini_enable_search,
            updated_at = NOW();
    """
    params = (
        profile_name,
        config_data.get('default_system_prompt'),
        allowed_extensions,
        excluded_dirs,
        default_ignore_list,
        config_data.get('gemini_default_model'),
        config_data.get('claude_default_model'),
        config_data.get('gpt_default_model'),
        gemini_available_models,
        claude_available_models,
        gpt_available_models,
        gemini_temperature,
        gemini_enable_thinking,
        gemini_thinking_budget,
        gemini_enable_search
    )

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"Application configuration for profile '{profile_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating application configuration: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during config update: {e}")
        conn.rollback()

def insert_or_update_api_key(conn, api_key: str, provider: str):
    """Inserts or updates an API key in the api_keys table."""
    if not api_key:
        print(f"Skipping API key insertion/update for {provider}: Key is empty.")
        return

    print(f"Attempting to insert/update API key for provider: {provider}...")
    # Add default NULL/0 values for new usage columns on insert
    sql = """
        INSERT INTO api_keys (api_key, provider, is_active,
                              last_api_call_timestamp, calls_this_minute, minute_start_timestamp,
                              calls_this_day, day_start_timestamp)
        VALUES (%s, %s, %s, NULL, 0, NULL, 0, NULL)
        ON CONFLICT (api_key) DO UPDATE SET
            provider = EXCLUDED.provider,
            is_active = EXCLUDED.is_active,
            -- Do not reset usage columns on conflict update here
            updated_at = NOW();
    """
    params = (api_key, provider, True) # Always set as active when loading from config

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"API key for provider '{provider}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating API key for {provider}: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during API key update for {provider}: {e}")
        conn.rollback()

def insert_or_update_rate_limit(conn, model_name: str, provider: str, rpm_limit: int, daily_limit: int, notes: Optional[str] = None):
    """Inserts or updates a model's rate limit in the model_rate_limits table."""
    print(f"Attempting to insert/update rate limit for model: {model_name}...")
    sql = """
        INSERT INTO model_rate_limits (model_name, provider, rpm_limit, daily_limit, notes)
        VALUES (%s, %s, %s, %s, %s)
        ON CONFLICT (model_name) DO UPDATE SET
            provider = EXCLUDED.provider,
            rpm_limit = EXCLUDED.rpm_limit,
            daily_limit = EXCLUDED.daily_limit,
            notes = EXCLUDED.notes,
            updated_at = NOW();
    """
    params = (model_name, provider, rpm_limit, daily_limit, notes)

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        print(f"Rate limit for model '{model_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        print(f"Error inserting/updating rate limit for {model_name}: {e}")
        conn.rollback()
    except Exception as e:
        print(f"An unexpected error occurred during rate limit update for {model_name}: {e}")
        conn.rollback()

def main():
    """Main function to connect, setup/update DB schema, and load config."""
    conn = None
    try:
        # 1. Connect to the database
        print(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )
        print("Database connection successful.")

        # 2. Create/Update tables based on SCHEMA_SQL
        create_tables(conn)
        print("Database schema setup/update complete.")

        # 3. Load configuration from config.yml
        print(f"Loading configuration from: {CONFIG_FILE_PATH}")
        config = load_yaml_config(CONFIG_FILE_PATH)

        if config:
            # 4. Insert/Update application_config table
            insert_or_update_config(conn, config)

            # 5. Insert/Update api_keys table
            gemini_key = config.get('gemini_api_key')
            anthropic_key = config.get('anthropic_api_key')
            # openai_key = config.get('openai_api_key') # If needed in the future

            if gemini_key:
                insert_or_update_api_key(conn, gemini_key, 'google')
            if anthropic_key:
                insert_or_update_api_key(conn, anthropic_key, 'anthropic')
            # if openai_key:
            #     insert_or_update_api_key(conn, openai_key, 'openai')

            print("Configuration data loaded into database.")

            # 6. Insert/Update model_rate_limits table (based on user request)
            print("Inserting/Updating specific model rate limits...")
            insert_or_update_rate_limit(conn, 'gemini-2.5-pro-preview-03-25', 'google', 5, 25, 'Gemini Pro Preview Rate Limit')
            insert_or_update_rate_limit(conn, 'gemini-2.5-flash-preview-04-17', 'google', 10, 500, 'Gemini Flash Preview Rate Limit')
            print("Model rate limits updated.")

        else:
            print("Skipping database update due to configuration loading failure.")

    except psycopg2.OperationalError as e:
        print(f"Database connection failed: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        if conn:
            conn.close()
            print("Database connection closed.")

if __name__ == "__main__":
    main()




======== src\__init__.py ========
# This file makes Python treat the directory src as a package.



======== src\app.py ========

import sys
import os
import ctypes
import logging # 로깅 추가
from PyQt6.QtWidgets import QApplication, QMessageBox # PyQt5 -> PyQt6
from PyQt6.QtGui import QIcon # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from ui.main_window import MainWindow
from utils.helpers import get_resource_path
from core.services.db_service import DbService # DbService 임포트

def setup_logging():
    """Sets up basic logging configuration."""
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_format)
    # Optionally add file handler later if needed
    # handler = logging.FileHandler('app.log', encoding='utf-8')
    # handler.setFormatter(logging.Formatter(log_format))
    # logging.getLogger().addHandler(handler)
    logging.info("Logging setup complete.")

def cleanup_logs(db_service: DbService):
    """Calls the log cleanup function."""
    try:
        logging.info("Attempting to clean up old Gemini logs...")
        db_service.cleanup_old_gemini_logs(days_to_keep=7) # 7일 이상된 로그 삭제
        logging.info("Log cleanup process finished.")
    except Exception as e:
        logging.error(f"Error during log cleanup: {e}", exc_info=True)

def main():
    setup_logging() # 로깅 설정 호출

    if sys.platform.startswith("win"):
        try:
            # DPI 인식 설정 (Windows)
            ctypes.windll.shcore.SetProcessDpiAwareness(1)
            logging.info("Set DPI awareness for Windows.")
        except AttributeError:
            logging.warning("ctypes.windll.shcore not available, DPI awareness not set (might be older Windows).")
        except Exception as e:
            logging.warning(f"Error setting DPI awareness: {e}") # 로깅 사용

    # Qt High DPI 설정 (PyQt6에서는 기본 활성화)
    logging.info("PyQt6에서는 High DPI 스케일링이 기본으로 활성화됨")

    app = QApplication(sys.argv)

    # 애플리케이션 아이콘 설정
    try:
        # 아이콘 경로를 get_resource_path를 사용하여 올바르게 가져옵니다.
        icon_path = get_resource_path("icons/rubber_duck.ico")
        logging.info(f"Attempting to load icon from: {icon_path}") # 경로 로깅 추가
        if os.path.exists(icon_path):
            app_icon = QIcon(icon_path)
            app.setWindowIcon(app_icon)
            logging.info(f"Application icon set successfully from: {icon_path}")
        else:
            # 아이콘 파일이 없을 경우 경고 로깅
            logging.warning(f"Icon file not found at resolved path: {icon_path}. Check if the file exists at 'project_root/resources/icons/rubber_duck.ico'.")
    except Exception as e:
        logging.error(f"Error loading application icon: {e}", exc_info=True) # 로깅 사용

    db_service_instance = None # DB 서비스 인스턴스 변수
    try:
        # MainWindow 생성 전에 DB 서비스 초기화 및 로그 정리 시도
        # MainWindow 내부에서도 DBService를 초기화하므로, 여기서 생성된 인스턴스를
        # MainWindow에 전달하거나, MainWindow 내부에서 로그 정리를 호출해야 함.
        # 여기서는 로그 정리만 시도하고, MainWindow는 자체적으로 DBService를 생성하도록 둠.
        try:
            db_service_instance = DbService()
            cleanup_logs(db_service_instance)
        except (ConnectionError, ValueError) as db_init_err:
             # DB 연결 또는 설정 오류 시에도 일단 앱 실행 시도 (MainWindow에서 다시 처리)
             logging.error(f"Initial DB connection/cleanup failed: {db_init_err}. MainWindow will attempt connection.")
        except Exception as cleanup_err:
             logging.error(f"Error during initial log cleanup: {cleanup_err}")
        finally:
            # 로그 정리 후 연결 닫기 (MainWindow에서 새로 연결)
            if db_service_instance:
                db_service_instance.disconnect()
                logging.info("Initial DB connection for cleanup closed.")


        # MainWindow 생성 및 실행
        window = MainWindow(mode="Code Enhancer Prompt Builder")
        window.show()
        sys.exit(app.exec()) # exec_() -> exec()

    except (ConnectionError, ValueError) as e:
         # Catch DB connection or config load errors from MainWindow init
         logging.critical(f"Application initialization failed: {e}", exc_info=True)
         # GUI가 부분적으로 사용 가능할 때 간단한 메시지 박스 표시 (선택 사항)
         QMessageBox.critical(None, "치명적 오류", f"애플리케이션 시작 실패:\n{e}")
         sys.exit(1) # 오류 코드로 종료
    except SystemExit as e:
         # MainWindow 내부에서 DB/Config 오류로 SystemExit 호출 시
         logging.info(f"Application exited with code {e.code}")
         sys.exit(e.code)
    except Exception as e:
         logging.critical(f"An unexpected error occurred during application startup: {e}", exc_info=True)
         QMessageBox.critical(None, "예상치 못한 오류", f"애플리케이션 시작 중 오류 발생:\n{e}")
         sys.exit(1)

if __name__ == "__main__":
    main()



======== src\config.yml ========
default_system_prompt: resources\prompts\system\unified-diff_en.md
allowed_extensions: !!set {}
excluded_dirs: !!set
  __pycache__/: null
  .gitignore: null
  dist/: null
  node_modules/: null
  .vscode/: null
  .DS_Store: null
  .idea/: null
  .git/: null
  "*.log": null
  build/: null
  .venv/: null
default_ignore_list:
  - "*.egg-info/"
  - "*.pyc"
  - .cursorrules
  - .git/
  - .gitignore
  - .idea/
  - .vscode/
  - .windsurfrules
  - __pycache__/
  - build/
  - dist/
gemini_default_model: gemini-2.5-pro-preview-03-25
claude_default_model: claude-3-7-sonnet-20250219
gpt_default_model: gpt-4o
gemini_available_models:
  - gemini-2.5-pro-preview-03-25
  - gemini-2.5-flash-preview-04-17
claude_available_models:
  - claude-3-7-sonnet-20250219
gpt_available_models:
  - gpt-4o
  - gpt-4-turbo
  - gpt-3.5-turbo
anthropic_api_key: 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
gemini_api_key: AIzaSyC5uUtef7uQnLiP2ioBM7OqIF9EaxAnGQE
gemini_temperature: 0.0
gemini_enable_thinking: false
gemini_thinking_budget: 0
gemini_enable_search: false



======== pyproject.toml ========
[project]
name = "duck-prompt"
version = "0.2.1" # Version bump
description = "DuckPrompt: Code Enhancer & Meta Prompt Builder"
requires-python = ">=3.12"
dependencies = [
    "PyQt6>=6.7.0",
    "PyQt6-Qt6>=6.7.0",
    "google-generativeai>=0.5.4", # Gemini API
    "langgraph>=0.0.69", # LangGraph for workflow
    "tiktoken>=0.7.0", # Token calculation (GPT/fallback)
    "anthropic>=0.28.0", # Anthropic API (Claude)
    "psycopg2-binary>=2.9.9", # PostgreSQL driver
    "PyYAML>=6.0.1", # YAML parsing (config)
    "pydantic>=2.7.1", # Data validation and settings
    "pillow>=10.3.0", # Image handling
    "winotify>=1.1.0", # Windows notifications
    "pyinstaller>=6.13.0",
    "watchdog>=4.0.0", # Added for filesystem monitoring
]

[tool.black]
line-length = 88

[tool.isort]
profile = "black"

[tool.uv.sources]
# Optional: Specify custom package sources if needed

# Optional: Define project scripts or entry points
# [project.scripts]
# duckprompt = "src.app:main"

# Optional: Project URLs
# [project.urls]
# homepage = "https://example.com"
# documentation = "https://readthedocs.org"
# repository = "https://github.com/user/duck-prompt.git"
# changelog = "https://github.com/user/duck-prompt/blob/main/CHANGELOG.md"

# Optional: Author and maintainer information
# authors = [
#   { name="Your Name", email="your.email@example.com" },
# ]
# maintainers = [
#   { name="Your Name", email="your.email@example.com" },
# ]

# Optional: License information
# license = { text = "MIT License" }

# Optional: Keywords for PyPI
# keywords = ["llm", "prompt", "gui", "pyqt"]

# Optional: Classifiers for PyPI
# classifiers = [
#     "Development Status :: 3 - Alpha",
#     "Intended Audience :: Developers",
#     "License :: OSI Approved :: MIT License",
#     "Programming Language :: Python :: 3",
#     "Programming Language :: Python :: 3.12",
#     "Operating System :: OS Independent",
#     "Topic :: Software Development :: User Interfaces",
# ]



======== main.py ========
import sys
import os

# src 디렉토리를 sys.path에 추가
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.join(current_dir, "src")
if src_dir not in sys.path:
    sys.path.insert(0, src_dir)

# src/app.py의 메인 함수 실행
if __name__ == '__main__':
    # app 모듈을 여기서 임포트하여 순환 참조 방지 가능성 고려
    from app import main
    main()



======== qt.conf ========
[Platforms]
WindowsArguments = dpiawareness=3 


File Tree:
 📁 duck-prompt/
   📁 src/
     📁 core/
       📁 pydantic_models/
         📄 __init__.py
         📄 app_state.py
         📄 config_settings.py
       📁 services/
         📄 __init__.py
         📄 config_service.py
         📄 db_service.py
         📄 directory_cache_service.py
         📄 filesystem_service.py
         📄 gemini_service.py
         📄 prompt_service.py
         📄 state_service.py
         📄 template_service.py
         📄 token_service.py
         📄 xml_service.py
       📁 utils/
       📁 workers/
       📄 __init__.py
       📄 langgraph_state.py
     📁 ui/
       📁 controllers/
         📄 __init__.py
         📄 file_tree_controller.py
         📄 main_controller.py
         📄 prompt_controller.py
         📄 resource_controller.py
         📄 system_prompt_controller.py
         📄 xml_controller.py
       📁 models/
         📄 __init__.py
         📄 file_system_models.py
       📁 widgets/
         📄 __init__.py
         📄 check_box_delegate.py
         📄 custom_tab_bar.py
         📄 custom_text_edit.py
         📄 file_tree_view.py
         📄 tab_manager.py
       📄 __init__.py
       📄 main_window.py
       📄 main_window_setup_signals.py
       📄 main_window_setup_ui.py
       📄 settings_dialog.py
     📁 utils/
       📄 __init__.py
       📄 db_migration_script.py
       📄 helpers.py
       📄 notifications.py
       📄 postgres_db_initializer.py
     📄 __init__.py
     📄 app.py
     📄 config.yml
   📄 main.py
   📄 pyproject.toml
   📄 qt.conf