===SYSTEM===
# System Instruction Prompt

## 1. Role Assignment

You are a '**Code Patching Only** LLM'.
Your primary mission is:

1. Analyze existing Python code to identify the **bug location** down to the token level,
2. Write a **minimally invasive** patch, add and pass regression tests, and
3. Return the results as a **single XML document** (`<code_patch>`).

## 2. Execution Steps

### 2-1. Bug Diagnosis

- Analyze stack traces, logs, and failed tests to identify the **root cause** and scope of impact.
- Keep the identified cause in internal memory only (do not output).

### 2-2. Develop Correction Strategy

- Adhere to all clauses of the "Integrated Development Guide".
- Follow the **TDD procedure** (Test-First): Write a new failing test case ➜ Implement code to make it pass.
- Target **zero** warnings from **static analysis** (ruff/flake8).
- Feature improvement is _secondary_; the primary goal is bug fixing.

### 2-3. Implement Patch

- Use **functional programming** (+ classes when necessary), type hints, and Pydantic models.
- Split files exceeding 15,000 tokens by functionality.
- When handling exceptions, log the full stack trace using `logger.exception()`.
- Always use `encoding="utf-8"` for encoding.

### 2-5. XML Output Rules (!!!)

```xml
<code_patch> <!-- Single Root Element -->
<code_changes>
<changed_files>
<file>
<file_summary>...</file_summary>
<file_operation>CREATE|UPDATE|DELETE</file_operation>
<file_path>...</file_path>
<file_code><![CDATA[

# Full source code (Omit if DELETE)

        ]]></file_code>
      </file>
      <!-- Repeat for each modified file -->
    </changed_files>

</code_changes>

  <summary>
    <!-- ① Overall change summary ≤150 chars
         ② Reason for change/deletion per file (1 sentence each)
         ③ Git commit message (Korean, feat/fix/docs…) -->
  </summary>
</code_patch>
```

- Inside `<code_patch>`, the order **must be** `<code_changes>` → `<summary>`.
- Do not include unmodified files in the XML.
- Escape reserved characters (`&amp; &lt; &gt; &apos; &quot;`) or wrap them in CDATA. CDATA sections cannot contain `]]>`.

### 2-6. Summary Writing Guidelines

- Korean, maximum **1000 tokens**.
- Separate the three blocks (Overview / Per-File / Commit) with blank lines.

## 3. Output Example (For format reference only)

```xml
<code_patch>
<code_changes>
<changed_files>
<file>
<file_summary>Root main.py: Integrated common logging/config loader, improved FastAPIApp execution logic</file_summary>
<file_operation>UPDATE</file_operation>
<file_path>main.py</file_path>
<file_code><![CDATA[

# Modified full code …

        ]]></file_code>
      </file>
      <!-- …other files… -->
    </changed_files>

</code_changes>

  <summary>
Overall change: Introduced logging/config utils and fixed bugs, achieving 100% test pass rate.

- main.py: Integrated logging/config and exception handling (UPDATE)
- src/utils/log_manager.py: Created common logging module (CREATE)
- tests/stage_01_core/test_root.py: Added new regression test (CREATE)

fix: 공통 로깅·설정 적용 및 xxx 버그 해결 (Applied common logging/config and resolved xxx bug)

  </summary>
</code_patch>
```

---


===USER===
테스트 코드를 실행하였으며, pytest tests\ui -v > pytest_results.txt 2>&1 실행 결과는 pytest_results.txt 에 있음. 오류 수정해줘.

===FILES CONTENTS===

======== docs\Database Schema Definitions.md ========
## Database Schema Definitions

### `api_keys`

| Column                  | Type                     | Comment                                                                         | PK  | Nullable | Default        |
| :---------------------- | :----------------------- | :------------------------------------------------------------------------------ | :-- | :------- | :------------- |
| id                      | integer                  |                                                                                 | YES | NO       |                |
| api_key                 | text                     | The actual API key string. Sensitive data.                                      |     | NO       |                |
| provider                | text                     | The provider of the API key (e.g., google, anthropic).                          |     | NO       | 'google'::text |
| description             | text                     | User-friendly description for the key.                                          |     | YES      |                |
| is_active               | boolean                  | Flag to enable/disable the key for use.                                         |     | NO       | true           |
| created_at              | timestamp with time zone |                                                                                 |     | NO       | now()          |
| updated_at              | timestamp with time zone |                                                                                 |     | NO       | now()          |
| last_api_call_timestamp | timestamp with time zone | Timestamp of the last successful API call using this key.                       |     | YES      |                |
| calls_this_minute       | integer                  | Counter for calls made within the current minute window.                        |     | NO       | 0              |
| minute_start_timestamp  | timestamp with time zone | Timestamp marking the beginning of the current minute window for rate limiting. |     | YES      |                |
| calls_this_day          | integer                  | Counter for calls made within the current day window.                           |     | NO       | 0              |
| day_start_timestamp     | timestamp with time zone | Timestamp marking the beginning of the current day window for rate limiting.    |     | YES      |                |

### `application_config`

| Column                  | Type                     | Comment                                                                | PK  | Nullable | Default         |
| :---------------------- | :----------------------- | :--------------------------------------------------------------------- | :-- | :------- | :-------------- |
| id                      | integer                  |                                                                        | YES | NO       |                 |
| profile_name            | text                     | Identifier for the configuration profile (e.g., default, development). |     | NO       | 'default'::text |
| default_system_prompt   | text                     |                                                                        |     | YES      |                 |
| allowed_extensions      | text[]                   | Array of allowed file extensions.                                      |     | YES      |                 |
| excluded_dirs           | text[]                   | Array of directory/file patterns to exclude.                           |     | YES      |                 |
| default_ignore_list     | text[]                   | Array of default patterns to ignore.                                   |     | YES      |                 |
| gemini_default_model    | text                     |                                                                        |     | YES      |                 |
| claude_default_model    | text                     |                                                                        |     | YES      |                 |
| gpt_default_model       | text                     |                                                                        |     | YES      |                 |
| gemini_available_models | text[]                   | Array of available Gemini model names.                                 |     | YES      |                 |
| claude_available_models | text[]                   | Array of available Claude model names.                                 |     | YES      |                 |
| gpt_available_models    | text[]                   | Array of available GPT model names.                                    |     | YES      |                 |
| gemini_temperature      | numeric(3,2)             | Generation temperature for Gemini models.                              |     | YES      | 0.0             |
| gemini_enable_thinking  | boolean                  |                                                                        |     | YES      | true            |
| gemini_thinking_budget  | integer                  |                                                                        |     | YES      | 24576           |
| gemini_enable_search    | boolean                  |                                                                        |     | YES      | true            |
| created_at              | timestamp with time zone |                                                                        |     | NO       | now()           |
| updated_at              | timestamp with time zone |                                                                        |     | NO       | now()           |

### `gemini_api_logs`

| Column              | Type                     | Comment                                                                              | PK  | Nullable | Default |
| :------------------ | :----------------------- | :----------------------------------------------------------------------------------- | :-- | :------- | :------ |
| id                  | integer                  |                                                                                      | YES | NO       |         |
| request_timestamp   | timestamp with time zone | Timestamp when the request was initiated.                                            |     | NO       | now()   |
| response_timestamp  | timestamp with time zone | Timestamp when the response was received.                                            |     | YES      |         |
| model_name          | text                     | The specific Gemini model used for the request.                                      |     | YES      |         |
| request_prompt      | text                     | The text prompt sent to the API.                                                     |     | YES      |         |
| request_attachments | jsonb                    | JSONB data containing metadata about attached files/images (e.g., name, type, path). |     | YES      |         |
| response_text       | text                     | The raw text response from the Gemini API.                                           |     | YES      |         |
| response_xml        | text                     | The parsed XML part of the response, if applicable.                                  |     | YES      |         |
| response_summary    | text                     | The parsed summary part of the response, if applicable.                              |     | YES      |         |
| error_message       | text                     | Error message if the API call failed.                                                |     | YES      |         |
| elapsed_time_ms     | integer                  | Total time taken for the API call in milliseconds.                                   |     | YES      |         |
| token_count         | integer                  | Calculated token count for the request/response.                                     |     | YES      |         |
| api_key_id          | integer                  | Foreign key referencing the api_key used for the request.                            |     | YES      |         |

### `model_rate_limits`

| Column      | Type                     | Comment                                          | PK  | Nullable | Default        |
| :---------- | :----------------------- | :----------------------------------------------- | :-- | :------- | :------------- |
| id          | integer                  |                                                  | YES | NO       |                |
| model_name  | text                     | Identifier for the language model.               |     | NO       |                |
| provider    | text                     |                                                  |     | NO       | 'google'::text |
| rpm_limit   | integer                  | Default Requests Per Minute limit for the model. |     | NO       |                |
| daily_limit | integer                  | Default Requests Per Day limit for the model.    |     | NO       |                |
| notes       | text                     |                                                  |     | YES      |                |
| created_at  | timestamp with time zone |                                                  |     | NO       | now()          |
| updated_at  | timestamp with time zone |                                                  |     | NO       | now()          |

### `ssh_connections`

| Column     | Type                     | Comment                                                      | PK  | Nullable | Default |
| :--------- | :----------------------- | :----------------------------------------------------------- | :-- | :------- | :------ |
| id         | integer                  |                                                              | YES | NO       |         |
| alias      | text                     | User-defined unique alias for the connection.                |     | NO       |         |
| host       | text                     | Hostname or IP address of the SSH server.                    |     | NO       |         |
| port       | integer                  | Port number for the SSH connection.                          |     | NO       | 22      |
| username   | text                     | Username for SSH authentication.                             |     | NO       |         |
| auth_type  | text                     | Authentication method: password or key.                      |     | NO       |         |
| password   | text                     | password.                                                    |     | YES      |         |
| key_path   | text                     | Path to the private key file. Only used if auth_type is key. |     | YES      |         |
| created_at | timestamp with time zone |                                                              |     | YES      | now()   |
| updated_at | timestamp with time zone |                                                              |     | YES      | now()   |



======== docs\ssh_docs.md ========
# SSH 접속 기능 설명서

이 문서는 기존 DuckPrompt 애플리케이션에서 SSH 접속 관련 기능만 분리하여 독립적인 프로그램으로 구성했을 경우를 가정하고, 해당 프로그램의 구조, 기능, 프로세스, UI/UX에 대해 설명합니다.

## 1. 개요

SSH 접속 프로그램은 사용자가 원격 서버에 안전하게 접속하고, GUI 환경에서 원격 파일 시스템을 탐색하며 파일을 관리할 수 있도록 돕는 데스크톱 애플리케이션입니다. 사용자는 여러 SSH 연결 설정을 저장하고 관리할 수 있으며, 필요에 따라 원하는 서버에 쉽게 접속할 수 있습니다.

## 2. 프로그램 구조

프로그램은 PyQt6를 사용한 GUI와 백엔드 로직으로 구성되며, 주요 모듈 및 역할은 다음과 같습니다.

- **UI (User Interface)**:
  - `MainWindow`: 메인 애플리케이션 창. SSH 연결 선택 드롭다운, 연결/해제 버튼, 연결 상태 표시 레이블, 원격 파일 시스템을 보여주는 파일 트리 뷰 등을 포함합니다.
  - `SettingsDialog`: 환경 설정 창. SSH 연결 설정을 관리(추가/수정/삭제/테스트)하는 탭을 포함합니다.
  - `SshConfigDialog`: SSH 연결 설정을 추가하거나 수정하기 위한 별도의 다이얼로그입니다.
- **Controllers**:
  - `SshController`: SSH 연결 및 해제 로직, 연결 상태 관리, Keep-alive 처리 등을 담당합니다. 백그라운드 스레드(`SshWorker`)를 사용하여 UI 블로킹 없이 연결을 시도합니다.
  - `SshConfigService`: SSH 연결 설정 정보에 대한 CRUD(Create, Read, Update, Delete) 로직을 처리합니다. `DbService`를 통해 데이터베이스와 상호작용합니다.
  - `FileTreeController`: 파일 트리 뷰의 동작(폴더 확장, 아이템 선택 등)과 원격 파일 시스템 관련 작업(이름 변경, 삭제 등) 요청을 처리합니다. `FilesystemService`를 사용합니다.
  - `MainController`: (필요시) 애플리케이션 전반의 흐름 제어 및 컨트롤러 간 조정 역할을 수행합니다.
- **Core Services**:
  - `FilesystemService`: 로컬 및 원격(SFTP) 파일 시스템 작업을 추상화하여 제공합니다. `SshController`로부터 SFTP 클라이언트를 받아 원격 파일 목록 조회, 읽기, 쓰기, 삭제 등의 작업을 수행합니다.
  - `DbService`: PostgreSQL 데이터베이스와의 연결 및 쿼리 실행을 담당합니다. SSH 설정 정보 등을 저장하고 조회합니다.
  - `paramiko`: SSH 연결 및 SFTP 통신을 위한 핵심 라이브러리입니다.
- **Data Models**:
  - `SshConnectionConfig` (Pydantic): SSH 연결 설정 정보(별칭, 호스트, 포트, 사용자명, 인증 방식, 비밀번호/키 경로 등)의 데이터 구조를 정의하고 유효성을 검증합니다.
- **Utils**:
  - `postgres_db_initializer.py`: 데이터베이스 스키마(테이블 생성 등)를 초기화하는 스크립트입니다. `ssh_connections` 테이블 정의를 포함합니다.

## 3. 핵심 기능

### 3.1. SSH 설정 관리

- **설정 추가/수정/삭제**: 사용자는 환경 설정 다이얼로그를 통해 SSH 연결 설정을 추가, 수정, 삭제할 수 있습니다.
  - **입력 정보**: 별칭, 호스트 주소(IP 또는 도메인), 포트 번호, 사용자명, 인증 방식(비밀번호 또는 키 파일), 비밀번호 또는 개인 키 파일 경로.
  - **저장**: 입력된 정보는 `SshConnectionConfig` 모델로 유효성 검사를 거쳐 데이터베이스(`ssh_connections` 테이블)에 저장됩니다. 비밀번호는 암호화되어 저장될 수 있습니다 (구현에 따라 다름).
- **설정 목록 조회**: 저장된 SSH 연결 설정 목록을 환경 설정 다이얼로그의 테이블 뷰에 표시합니다. 메인 화면의 연결 선택 콤보박스에도 로드됩니다.
- **연결 테스트**: 환경 설정 다이얼로그에서 선택한 설정 정보로 실제 SSH 서버에 연결을 시도하고 성공/실패 여부를 사용자에게 피드백합니다. UI 블로킹을 방지하기 위해 백그라운드 스레드(`SshConnectionTester`)에서 실행됩니다.

### 3.2. SSH 연결 및 해제

- **연결 시도**: 메인 화면 상단의 콤보박스에서 저장된 연결 설정을 선택하고 '연결' 버튼을 클릭하여 SSH 연결을 시도합니다.
  - 비밀번호 인증 시, 필요에 따라 연결 시점에 비밀번호를 다시 입력받을 수 있습니다.
  - 연결 과정은 백그라운드 스레드(`SshWorker`)에서 처리되어 UI 응답성을 유지합니다.
- **연결 상태 표시**: 메인 화면 상단 레이블에 현재 연결 상태("미연결", "연결 중...", "연결됨: [별칭]")를 표시합니다.
- **연결 성공**:
  - `paramiko.SSHClient` 및 `paramiko.SFTPClient` 인스턴스가 생성 및 유지됩니다.
  - 연결 버튼 텍스트가 "연결 해제"로 변경됩니다.
  - 파일 트리 뷰가 원격 파일 시스템을 표시하도록 전환됩니다.
  - 로컬 프로젝트 폴더 선택 기능이 비활성화됩니다.
  - 연결 유지를 위한 Keep-alive 메시지가 주기적으로 전송될 수 있습니다.
- **연결 실패**: 사용자에게 오류 메시지(인증 실패, 타임아웃 등)를 표시하고 연결 상태를 "미연결"로 복원합니다.
- **연결 해제**: "연결 해제" 버튼을 클릭하거나 애플리케이션 종료 시 SSH 및 SFTP 연결을 안전하게 종료하고 관련 리소스를 정리합니다. 파일 트리 뷰는 로컬 모드로 복원되고 로컬 폴더 선택 기능이 활성화됩니다.

### 3.3. 원격 파일 시스템 탐색 및 조작

- **원격 디렉토리 탐색**: SSH 연결 성공 후, 파일 트리 뷰는 `FilesystemService`와 SFTP 클라이언트를 사용하여 원격 서버의 디렉토리 구조를 표시합니다. 폴더를 확장하면 해당 폴더의 내용을 동적으로 로드합니다.
- **파일/폴더 정보 표시**: 파일 트리 뷰에 파일/폴더 이름, 아이콘, 크기 등을 표시합니다.
- **파일 작업**: 파일 트리 뷰의 컨텍스트 메뉴 또는 단축키를 통해 다음 작업을 수행할 수 있습니다.
  - **이름 변경**: 원격 파일 또는 폴더의 이름을 변경합니다. (`SFTPClient.rename`)
  - **삭제**: 원격 파일 또는 폴더를 삭제합니다. (`SFTPClient.remove`, `SFTPClient.rmdir`)
  - **(구현 시)** 파일 생성, 폴더 생성, 파일 다운로드/업로드 등.
- **파일 내용 읽기/쓰기**: (구현 시) 원격 파일을 열어 내용을 읽거나 수정하여 저장하는 기능을 제공할 수 있습니다. (`SFTPClient.open`)

## 4. 주요 프로세스

1. **최초 실행**: 데이터베이스 스키마 확인 및 초기화. 저장된 SSH 설정 로드하여 메인 화면 콤보박스 채우기.
2. **설정 추가/수정**: 사용자가 환경 설정 다이얼로그를 열어 SSH 설정 추가/수정. 입력값 유효성 검사 후 DB 저장. 연결 테스트 수행.
3. **연결 시도**: 사용자가 메인 화면에서 연결 설정 선택 후 '연결' 버튼 클릭.
4. **백그라운드 연결**: `SshController`가 `SshWorker` 스레드 시작. Worker는 `paramiko`를 사용하여 SSH 연결 시도 (인증 포함).
5. **결과 처리**: Worker 스레드가 연결 성공/실패 결과를 `SshController`에 시그널로 전달.
6. **UI 업데이트 (성공 시)**: `SshController`가 연결 상태 업데이트, SFTP 클라이언트 열기, 파일 트리 원격 모드 전환 요청.
7. **원격 파일 탐색**: 사용자가 파일 트리에서 폴더 확장 시, `FileTreeController`가 `FilesystemService`를 통해 SFTP로 해당 디렉토리 목록 조회 후 트리 뷰 업데이트.
8. **파일 조작**: 사용자가 파일 트리에서 이름 변경/삭제 등 작업 요청 시, `FileTreeController`가 `FilesystemService`를 통해 SFTP 명령 수행 후 트리 뷰 새로고침.
9. **연결 해제**: 사용자가 '연결 해제' 버튼 클릭 시, `SshController`가 SFTP/SSH 연결 종료, 파일 트리 로컬 모드 복원.

## 5. UI/UX (사용자 인터페이스 / 사용자 경험)

- **메인 화면 (`MainWindow`)**:
  - **상단**:
    - SSH 연결 선택 `QComboBox`: 저장된 연결 설정 목록 표시.
    - 연결/해제 `QPushButton`: 현재 상태에 따라 텍스트 변경 ("연결" 또는 "연결 해제").
    - 연결 상태 `QLabel`: "미연결", "연결 중...", "연결됨: [별칭]" 등 상태 표시.
  - **왼쪽**:
    - 파일 트리 `QTreeView`: 로컬 또는 원격 파일 시스템 표시. 폴더 확장/축소 가능. 컨텍스트 메뉴 제공 (이름 변경, 삭제 등).
  - **오른쪽**: (기존 DuckPrompt UI 요소는 제외)
- **환경 설정 (`SettingsDialog`)**:
  - **SSH 설정 탭**:
    - `QTableWidget`: 저장된 SSH 연결 목록 표시 (ID, 별칭, 호스트, 포트, 사용자명).
    - `QPushButton` (추가, 수정, 삭제): 테이블 아래에 위치하여 목록 관리 기능 제공.
    - `QPushButton` (연결 테스트): 선택된 설정으로 연결 테스트 수행.
  - **SSH 설정 추가/수정 다이얼로그 (`SshConfigDialog`)**:
    - `QLineEdit` (별칭, 호스트, 포트, 사용자명, 비밀번호, 키 경로): 설정 정보 입력 필드.
    - `QComboBox` (인증 방식): 'password' 또는 'key' 선택.
    - `QPushButton` (찾아보기): 키 파일 선택 다이얼로그 열기.
    - 인증 방식 선택에 따라 비밀번호 또는 키 경로 필드만 활성화/표시.
- **사용성**:
  - 연결/테스트 등 시간이 걸리는 작업은 백그라운드 스레드에서 처리하여 UI 멈춤 현상 방지.
  - 연결 상태 및 오류 발생 시 명확한 피드백 제공 (상태 레이블, 메시지 박스).
  - 자주 사용하는 연결 설정을 저장하여 재입력 없이 빠르게 접속 가능.



======== conftest.py ========
import sys
import os
import pytest
from dotenv import load_dotenv
import logging

logger = logging.getLogger(__name__)

# --- .env 파일 로드 및 sys.path 설정 ---
# pytest_configure 훅을 사용하여 테스트 세션 시작 시 .env 로드 및 src 경로 추가
def pytest_configure(config):
    """Loads environment variables from .env file and adds src to sys.path."""
    # --- QT_API 환경 변수 설정 (다시 시도, conftest에서) ---
    # pytest.ini 설정이 적용되지 않는 경우를 대비하여 여기서도 설정 시도.
    if 'QT_API' not in os.environ:
        os.environ['QT_API'] = 'pyqt6'
        logger.info(f"Set environment variable QT_API=pyqt6 in pytest_configure as it was not set.")
    else:
        # 이미 설정된 경우 (예: pytest.ini 또는 외부 환경 변수) 로그만 남김
        logger.info(f"Environment variable QT_API already set to: {os.environ['QT_API']}")
    # ----------------------------------------------------

    project_root = config.rootpath # Get project root from pytest config
    logger.info(f"Project root determined by pytest: {project_root}")

    # .env 파일 로드
    env_path = os.path.join(project_root, '.env')
    if os.path.exists(env_path):
        logger.info(f"Loading environment variables from: {env_path}")
        load_dotenv(dotenv_path=env_path, override=True) # override=True 로 기존 환경 변수 덮어쓰기 허용
    else:
        logger.warning(f".env file not found at: {env_path}. Skipping environment variable loading.")

    # --- src 디렉토리를 sys.path에 추가 ---
    src_dir = os.path.join(project_root, "src")
    if os.path.isdir(src_dir):
        if src_dir not in sys.path:
            sys.path.insert(0, src_dir)
            logger.info(f"Added '{src_dir}' to sys.path for testing.")
        else:
            logger.debug(f"src directory '{src_dir}' already in sys.path.")
    else:
         logger.warning(f"src directory '{src_dir}' not found. Module imports might fail.")


# pytest 픽스처나 다른 설정이 필요하면 여기에 추가할 수 있습니다.





======== main.py ========
import sys
import os

# src 디렉토리를 sys.path에 추가
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.join(current_dir, "src")
if src_dir not in sys.path:
    sys.path.insert(0, src_dir)

# src/app.py의 메인 함수 실행
if __name__ == '__main__':
    # app 모듈을 여기서 임포트하여 순환 참조 방지 가능성 고려
    from app import main
    main()



======== pyproject.toml ========
[project]
name = "duck-prompt"
version = "0.2.1" # 버전 업데이트
description = "DuckPrompt: Code Enhancer & Meta Prompt Builder"
requires-python = ">=3.12,<3.13" # 수정: Python 3.13 제외
dependencies = [
    "PyQt6>=6.7.0",
    "PyQt6-Qt6>=6.7.0",
    "google-generativeai>=0.5.4", # Gemini API
    "langgraph>=0.0.69", # LangGraph for workflow
    "tiktoken>=0.7.0", # Token calculation (GPT/fallback)
    "anthropic>=0.28.0", # Anthropic API (Claude)
    "psycopg2-binary>=2.9.9", # PostgreSQL driver
    "PyYAML>=6.0.1", # YAML parsing (config)
    "pydantic>=2.7.1", # Data validation and settings
    "pillow>=10.3.0", # Image handling
    "winotify>=1.1.0", # Windows notifications
    "pyinstaller>=6.13.0",
    "asyncssh>=2.14.2", # Added: Async SSH library
    "pytest>=8.3.5",
    "pytest-qt>=4.4.0", # Added for Qt testing utilities
    "pytest-asyncio>=0.23.7", # Added for testing async code
    "qasync>=0.26.1", # Added for integrating asyncio with PyQt (Optional but recommended)
    "python-dotenv>=1.0.1", # Added for loading .env files in tests
    "pytest-qasync>=0.0.1",
]

[tool.black]
line-length = 88

[tool.isort]
profile = "black"

[tool.uv.sources]
# Optional: Specify custom package sources if needed

# Optional: Define project scripts or entry points
# [project.scripts]
# duckprompt = "src.app:main"

# Optional: Project URLs
# [project.urls]
# homepage = "https://example.com"
# documentation = "https://readthedocs.org"
# repository = "https://github.com/user/duck-prompt.git"
# changelog = "https://github.com/user/duck-prompt/blob/main/CHANGELOG.md"

# Optional: Author and maintainer information
# authors = [
#   { name="Your Name", email="your.email@example.com" },
# ]
# maintainers = [
#   { name="Your Name", email="your.email@example.com" },
# ]

# Optional: License information
# license = { text = "MIT License" }

# Optional: Keywords for PyPI
# keywords = ["llm", "prompt", "gui", "pyqt"]

# Optional: Classifiers for PyPI
# classifiers = [
#     "Development Status :: 3 - Alpha",
#     "Intended Audience :: Developers",
#     "License :: OSI Approved :: MIT License",
#     "Programming Language :: Python :: 3",
#     "Programming Language :: Python :: 3.12",
#     "Operating System :: OS Independent",
#     "Topic :: Software Development :: User Interfaces",
# ]





======== pytest.ini ========
[pytest]
markers =
    network: marks tests as requiring network access (deselect with '-m "not network"')
    integration: marks integration tests (deselect with '-m "not integration"')
    asyncio: marks asyncio tests

asyncio_mode = auto
asyncio_default_fixture_loop_scope = function

# pytest-qasync가 PyQt6를 인식하도록 환경 변수 설정
env =
    QT_API=pyqt6




======== qt.conf ========
[Platforms]
WindowsArguments = dpiawareness=3 


======== src\core\pydantic_models\__init__.py ========
# This file makes Python treat the directory pydantic_models as a package.

from .app_state import AppState
from .config_settings import ConfigSettings
from .ssh_connection_config import SshConnectionConfig # Added

__all__ = [
    "AppState",
    "ConfigSettings",
    "SshConnectionConfig", # Added
]



======== src\core\pydantic_models\app_state.py ========
from pydantic import BaseModel, Field, ConfigDict # ConfigDict 추가
from typing import List, Optional, Dict, Any # Dict, Any 추가

class AppState(BaseModel):
    """
    Represents the application state.
    저장/로드 시 특정 필드만 사용될 수 있음 (예: 이전 작업 불러오기).
    """
    # --- 이전 작업 저장/로드 대상 필드 ---
    project_folder: Optional[str] = None # 프로젝트 폴더 경로
    checked_files: List[str] = Field(default_factory=list) # 체크된 파일/폴더 경로 목록
    user_prompt: str = "" # 사용자 탭 내용
    attached_items: List[Dict[str, Any]] = Field(default_factory=list) # 첨부 파일/이미지 메타데이터 목록

    # --- 기타 상태 필드 (전체 상태 저장/로드 시 사용) ---
    mode: str = "Code Enhancer Prompt Builder"
    system_prompt: str = "" # 시스템 탭 내용 (기본값 로드 로직 있음)
    selected_llm: str = "Gemini" # 선택된 LLM
    selected_model_name: str = "" # 선택된 모델명

    # Gemini 파라미터는 config.yml에서 관리하므로 AppState에서 제거
    # gemini_temperature: float = 0.0
    # gemini_enable_thinking: bool = True
    # gemini_thinking_budget: int = 24576
    # gemini_enable_search: bool = True

    # Pydantic V2 스타일 ConfigDict 사용
    model_config = ConfigDict(
        validate_assignment=True
    )



======== src\core\pydantic_models\config_settings.py ========
from pydantic import BaseModel, Field, field_validator, ValidationInfo, ConfigDict # FieldValidationInfo -> ValidationInfo, ConfigDict 추가
from typing import List, Set, Any, Optional, Dict

class ConfigSettings(BaseModel):
    """
    Represents the application configuration settings loaded from the database.
    """
    # --- Fields loaded from application_config table ---
    profile_name: str = 'default' # Included for completeness, usually 'default'
    default_system_prompt: Optional[str] = None
    allowed_extensions: Set[str] = Field(default_factory=set)
    excluded_dirs: Set[str] = Field(default_factory=set)
    default_ignore_list: List[str] = Field(default_factory=list)
    gemini_default_model: str = "gemini-1.5-pro-latest" # Default if DB is missing
    claude_default_model: str = "claude-3-sonnet-20240229"
    gpt_default_model: str = "gpt-4o"
    gemini_available_models: List[str] = Field(default_factory=list)
    claude_available_models: List[str] = Field(default_factory=list)
    gpt_available_models: List[str] = Field(default_factory=list)
    gemini_temperature: float = Field(0.0, ge=0.0, le=2.0)
    gemini_enable_thinking: bool = Field(True)
    gemini_thinking_budget: int = Field(24576, ge=0)
    gemini_enable_search: bool = Field(True)
    # created_at, updated_at are in DB but not needed in the model for app logic

    # --- Fields loaded separately from api_keys table ---
    gemini_api_key: Optional[str] = None
    anthropic_api_key: Optional[str] = None
    # openai_api_key: Optional[str] = None # If needed

    @field_validator('allowed_extensions', 'excluded_dirs', mode='before')
    @classmethod
    def ensure_set_from_list_or_none(cls, v: Any, info: ValidationInfo): # FieldValidationInfo -> ValidationInfo
        """Converts list (from DB array) or None to a set of strings."""
        if v is None:
            return set()
        if isinstance(v, (list, tuple, set)):
            # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return set(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        # Allow comma or space separated string as fallback (though DB should provide list)
        if isinstance(v, str):
             items = {item.strip() for item in v.replace(',', ' ').split() if item.strip()}
             return items
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    @field_validator('default_ignore_list', 'gemini_available_models', 'claude_available_models', 'gpt_available_models', mode='before')
    @classmethod
    def ensure_list_from_list_or_none(cls, v: Any, info: ValidationInfo): # FieldValidationInfo -> ValidationInfo
        """Ensures the value is a list of strings, accepting None."""
        if v is None:
            return []
        if isinstance(v, (list, tuple, set)):
             # Ensure all items are strings
            if all(isinstance(item, str) for item in v):
                return list(v)
            else:
                raise TypeError(f"{info.field_name} must be a list/set of strings")
        raise TypeError(f"{info.field_name} must be a list, set, or None (received {type(v)})")

    # Pydantic V2 스타일 ConfigDict 사용
    model_config = ConfigDict(
        validate_assignment=True,
        # If loading directly from DB dict, extra fields might exist (id, created_at etc.)
        extra='ignore' # Ignore extra fields from DB query result
    )



======== src\core\pydantic_models\ssh_connection_config.py ========
from pydantic import BaseModel, Field, field_validator, ValidationInfo, ConfigDict # ConfigDict 추가
from typing import Literal, Optional

class SshConnectionConfig(BaseModel):
    """
    Represents the configuration for an SSH connection.
    Password will be stored as plain text in the DB.
    """
    id: Optional[int] = None  # DB에서 자동 생성되는 ID
    alias: str = Field(..., min_length=1, max_length=100) # Unique alias for the connection
    host: str = Field(..., min_length=1) # Hostname or IP address
    port: int = Field(22, ge=1, le=65535) # Port number
    username: str = Field(..., min_length=1) # Username for SSH authentication
    auth_type: Literal['password', 'key'] = Field(...) # Authentication method
    password: Optional[str] = Field(None) # Plain password (stored as text)
    # password_enc: Optional[str] = Field(None) # Removed: No longer storing encrypted password
    key_path: Optional[str] = Field(None) # Path to the private key file

    @field_validator('auth_type')
    @classmethod
    def validate_auth_details(cls, v, info: ValidationInfo):
        """Validate that required fields are present based on auth_type."""
        auth_type = v
        password = info.data.get('password')
        key_path = info.data.get('key_path')

        # When creating/updating interactively (not loading from DB where password might be null):
        # If auth_type is password, a password must be provided.
        # This validator runs *after* individual field validation, so password could be None
        # if it wasn't provided in the input dict.
        # The logic in the service layer (add/update) should handle password requirement more robustly
        # based on user input context (e.g., empty password field during edit might mean "don't change").
        # For loading from DB, password can be None, so we don't raise error here if it's missing.
        # We only check for key_path requirement here.
        # if auth_type == 'password' and not password:
        #     raise ValueError("Password is required for password authentication.")

        # Key path required IF auth_type is key
        if auth_type == 'key' and not key_path:
            raise ValueError("Key path is required for key authentication.")

        return v


    @field_validator('key_path')
    @classmethod
    def validate_key_path_if_needed(cls, v, info: ValidationInfo):
        """Optional: Validate key path existence if auth_type is 'key'."""
        auth_type = info.data.get('auth_type')
        if auth_type == 'key' and v:
            # Basic validation, actual existence check might be better elsewhere
            if not isinstance(v, str) or not v.strip():
                raise ValueError("Key path must be a non-empty string.")
        return v

    # Pydantic V2 스타일 ConfigDict 사용
    model_config = ConfigDict(
        validate_assignment=True,
        extra='ignore', # Ignore extra fields like created_at, updated_at from DB
        # Remove arbitrary_types_allowed if SecretStr is no longer used
        # arbitrary_types_allowed = True
    )



======== src\core\services\__init__.py ========
# This file makes Python treat the directory services as a package.
# It can also be used to expose specific classes or functions.

from .config_service import ConfigService
from .db_service import DbService # Added
from .filesystem_service import FilesystemService
from .prompt_service import PromptService
from .state_service import StateService
from .template_service import TemplateService
from .token_service import TokenCalculationService
from .xml_service import XmlService
from .ssh_config_service import SshConfigService # Added
# from .gemini_service import build_gemini_graph # 함수 직접 임포트 대신 모듈 사용

__all__ = [
    "ConfigService",
    "DbService", # Added
    "FilesystemService",
    "PromptService",
    "StateService",
    "TemplateService",
    "TokenCalculationService",
    "XmlService",
    "SshConfigService", # Added
    # "build_gemini_graph", # 함수 직접 노출 대신 서비스 모듈 사용
]



======== src\core\services\config_service.py ========
import os
import logging
import random # 랜덤 선택을 위해 추가
from pydantic import ValidationError
from typing import Optional, List, Set, Dict, Any # Set, Dict, Any 추가

# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로)
from ..pydantic_models.config_settings import ConfigSettings
from .db_service import DbService # DbService import

logger = logging.getLogger(__name__)

class ConfigService:
    def __init__(self, db_service: DbService, profile_name: str = 'default'):
        """
        Initializes ConfigService using a DbService instance.

        Args:
            db_service: An instance of DbService to interact with the database.
            profile_name: The configuration profile to load (default: 'default').
        """
        self.db_service = db_service
        self.profile_name = profile_name
        self._settings: ConfigSettings = self._load_config()
        self._user_selected_gemini_key_id: Optional[int] = None # 사용자가 명시적으로 선택한 키 ID (메모리 관리)
        self._last_used_gemini_key: Optional[str] = None # 마지막으로 성공적으로 사용된 키 문자열 (메모리 관리)

    def _load_config(self) -> ConfigSettings:
        """
        Loads configuration from the database.
        Initial active Gemini key is NOT selected here. Selection happens in gemini_service.
        """
        logger.info(f"Loading configuration from database for profile '{self.profile_name}'...")
        try:
            # 1. Fetch application config from DB
            config_data = self.db_service.get_application_config(self.profile_name)

            if not config_data:
                logger.critical(f"Failed to load configuration from database for profile '{self.profile_name}'. Application cannot proceed.")
                raise ValueError(f"Configuration profile '{self.profile_name}' not found in database.")

            # --- 로깅 추가: DB에서 로드된 설정 데이터 확인 ---
            logger.info(f"Raw config data loaded from DB for profile '{self.profile_name}':")
            # 중요 설정값만 로깅 (API 키 제외)
            logged_data = {k: v for k, v in config_data.items() if 'api_key' not in k}
            logger.info(f"{logged_data}")
            # ---------------------------------------------

            # 2. Fetch *active* API keys from DB (just to check availability, not select)
            # This check is mainly for logging warnings if no keys are available initially.
            active_gemini_keys = self.db_service.get_active_api_keys('google')
            active_anthropic_keys = self.db_service.get_active_api_keys('anthropic')

            # --- Initial Gemini Key Selection REMOVED ---
            if not active_gemini_keys:
                logger.warning("No active Gemini API key found in DB. API calls will likely fail until a key is added/activated.")
            else:
                logger.info(f"Found {len(active_gemini_keys)} active Gemini keys. Key selection will occur during API call.")

            # Use the first active Anthropic key if available
            anthropic_key = active_anthropic_keys[0]['api_key'] if active_anthropic_keys else None
            if not anthropic_key: logger.warning("No active Anthropic API key found in DB.")

            # 3. Add the API keys (set to None initially) to the config data dictionary
            config_data['gemini_api_key'] = None # Placeholder, always None initially
            config_data['anthropic_api_key'] = anthropic_key

            # 4. Validate and create ConfigSettings model
            settings = ConfigSettings(**config_data)
            logger.info(f"Configuration loaded successfully from database for profile '{self.profile_name}'.")
            # --- 로깅 추가: Pydantic 모델 생성 후 설정 값 확인 ---
            logger.info("Validated ConfigSettings object created:")
            logger.info(f"  gemini_temperature: {settings.gemini_temperature}")
            # ... other relevant settings ...
            logger.info(f"  Initial gemini_api_key in settings object: {settings.gemini_api_key}") # Should log None
            # -------------------------------------------------
            return settings

        except ValidationError as e:
            logger.critical(f"Database configuration validation error: {e}. Using default settings (or failing).", exc_info=True)
            raise ValueError(f"Configuration validation failed: {e}")
        except Exception as e:
            logger.critical(f"Unexpected error loading config from database: {e}", exc_info=True)
            raise ValueError(f"Failed to load configuration from database: {e}")

    def update_settings(self, updated_settings: ConfigSettings) -> bool:
        """
        Updates the application configuration in the database and in memory.
        API keys are NOT saved via this method. User-selected key preference is not saved to DB.

        Args:
            updated_settings: A ConfigSettings object with the updated values.

        Returns:
            True if the update was successful, False otherwise.
        """
        logger.info(f"Attempting to update configuration in database for profile '{self.profile_name}'...")
        try:
            # Convert Pydantic model to dictionary for DB service
            # Exclude API keys as they are managed separately
            config_dict_to_save = updated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})

            # --- 로깅 추가: DB에 저장될 설정 데이터 확인 ---
            logger.info(f"Data being saved to DB for profile '{self.profile_name}':")
            logger.info(f"{config_dict_to_save}")
            # ---------------------------------------------

            # Call DbService to save the configuration (excluding API keys)
            success = self.db_service.save_application_config(self.profile_name, config_dict_to_save)

            if success:
                # Update in-memory settings only if DB save was successful
                # Keep the currently loaded API keys AND the user selection in the in-memory object
                current_anthropic_key = self._settings.anthropic_api_key # Keep potentially updated Anthropic key
                # Create a fresh copy from the validated input, then restore keys/selection
                self._settings = updated_settings.model_copy(deep=True)
                self._settings.gemini_api_key = self._last_used_gemini_key # Restore last used key string
                self._settings.anthropic_api_key = current_anthropic_key
                # User selection (_user_selected_gemini_key_id) remains as it is in memory.
                logger.info(f"Configuration updated successfully in database and memory for profile '{self.profile_name}'.")
                return True
            else:
                logger.error(f"Failed to save configuration update to database for profile '{self.profile_name}'.")
                return False

        except ValidationError as e:
            logger.error(f"Configuration update validation error: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"Unexpected error updating configuration: {e}", exc_info=True)
            return False

    def get_settings(self) -> ConfigSettings:
        """Returns the current configuration settings."""
        if not self._settings:
             logger.error("Configuration settings are not loaded.")
             self._settings = self._load_config() # Attempt to reload
        return self._settings

    def get_default_model_name(self, llm_type: str) -> str:
        """Gets the default model name for a given LLM type from settings."""
        settings = self.get_settings()
        if llm_type == "Gemini": return settings.gemini_default_model
        elif llm_type == "Claude": return settings.claude_default_model
        elif llm_type == "GPT": return settings.gpt_default_model
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for default model."); return ""

    def get_available_models(self, llm_type: str) -> List[str]:
        """Gets the list of available model names for a given LLM type from settings."""
        settings = self.get_settings()
        models = []
        if llm_type == "Gemini": models = settings.gemini_available_models
        elif llm_type == "Claude": models = settings.claude_available_models
        elif llm_type == "GPT": models = settings.gpt_available_models
        else: logger.warning(f"Unknown LLM type '{llm_type}' requested for available models.")
        return models if models is not None else []

    # --- User Selected Key Management ---
    def set_user_selected_gemini_key(self, key_id: Optional[int]):
        """Sets the user's preferred Gemini API key ID (managed in memory)."""
        if self._user_selected_gemini_key_id != key_id:
            logger.info(f"Setting user-selected Gemini Key ID to: {key_id}")
            self._user_selected_gemini_key_id = key_id
            # Optionally clear the last used key if a new preference is set? No, keep last used.
        else:
             logger.debug(f"User selected Gemini key ID is already {key_id}.")

    def get_user_selected_gemini_key_id(self) -> Optional[int]:
        """Gets the user's preferred Gemini API key ID."""
        return self._user_selected_gemini_key_id

    # --- Last Used Key Management ---
    def update_last_used_gemini_key(self, key_string: str):
        """
        Updates the last successfully used Gemini API key string in memory
        and updates the placeholder in the settings object.
        Called by gemini_service after a successful API call.
        """
        if self._last_used_gemini_key != key_string:
            logger.info(f"Updating last successfully used Gemini API key string.")
            self._last_used_gemini_key = key_string
            if self._settings:
                # Update the placeholder in the settings object for consistency/display if needed
                self._settings.gemini_api_key = key_string
        else:
            logger.debug("Attempted to update last used Gemini key, but it's the same.")

    def get_last_used_gemini_key_id(self) -> Optional[int]:
        """Gets the database ID of the last successfully used Gemini API key."""
        if self._last_used_gemini_key:
            try:
                # Fetch the ID from the database using the key string
                key_id = self.db_service.get_api_key_id(self._last_used_gemini_key)
                logger.debug(f"Retrieved ID for last used Gemini key: {key_id}")
                return key_id
            except Exception as e:
                logger.error(f"Error getting ID for last used Gemini key '{self._last_used_gemini_key[:4]}...': {e}")
                return None
        else:
            # Log if no key has been successfully used yet
            logger.debug("Cannot get last used Gemini key ID: No key has been successfully used yet.")
            return None

    # Renamed for clarity (was get_current_gemini_key_id)
    # def get_current_gemini_key_id(self) -> Optional[int]:
    #     """Gets the database ID of the currently configured Gemini API key."""
    #     # ... (old logic based on settings.gemini_api_key) ...
    #     # Now replaced by get_last_used_gemini_key_id and get_user_selected_gemini_key_id

    # Renamed for clarity (was update_current_gemini_key)
    # def update_current_gemini_key(self, new_key: str):
    #      # Now replaced by update_last_used_gemini_key



======== src\core\services\db_service.py ========
import psycopg2
import logging
from typing import Optional, Dict, Any, List, Tuple
import json
import datetime
from decimal import Decimal

# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로)
from ..pydantic_models.ssh_connection_config import SshConnectionConfig

logger = logging.getLogger(__name__)

# 데이터베이스 접속 정보 (WARNING: Hardcoded credentials are not recommended)
# 환경 변수나 보안 관리 도구를 사용하는 것이 좋습니다.
DB_CONFIG = {
    "host": "postgresdb.lab.miraker.me",
    "user": "shacea",
    "password": "alfkzj9389", # 경고: 실제 비밀번호
    "port": 5333,
    "database": "duck_agent"
}

class DbService:
    """Handles database connection and queries for application configuration and logging."""

    def __init__(self, db_config: Dict[str, Any] = DB_CONFIG):
        self.db_config = db_config
        self.connection = None
        self.connect()

    def connect(self):
        """Establishes a connection to the PostgreSQL database."""
        if self.connection and not self.connection.closed:
            logger.debug("Database connection already active.")
            return # Already connected

        try:
            logger.info(f"Connecting to database '{self.db_config['database']}' on {self.db_config['host']}...")
            self.connection = psycopg2.connect(**self.db_config)
            logger.info("Database connection successful.")
        except psycopg2.Error as e:
            logger.critical(f"Database connection failed: {e}", exc_info=True)
            self.connection = None
            raise ConnectionError(f"Failed to connect to the database: {e}")

    def disconnect(self):
        """Closes the database connection."""
        if self.connection and not self.connection.closed:
            try:
                self.connection.close()
                logger.info("Database connection closed.")
            except psycopg2.Error as e:
                 logger.error(f"Error closing database connection: {e}", exc_info=True)
            finally:
                 self.connection = None
        elif self.connection and self.connection.closed:
             logger.debug("Database connection already closed.")
             self.connection = None # Ensure reference is cleared
        else:
            logger.debug("No active database connection to close.")


    def _execute_query(self, query: str, params: Optional[tuple] = None, fetch_one: bool = False, fetch_all: bool = False, return_id: bool = False) -> Optional[Any]:
        """Executes a SQL query and returns the result."""
        if not self.connection or self.connection.closed:
            logger.error("Cannot execute query: Database connection is not active.")
            logger.info("Attempting to reconnect to the database...")
            try:
                self.connect()
            except ConnectionError as ce:
                 logger.critical(f"Failed to reconnect to the database: {ce}")
                 raise # Re-raise the connection error after attempting reconnect
            if not self.connection or self.connection.closed: # Check again after reconnect attempt
                 raise ConnectionError("Database connection lost and could not be re-established.")

        cursor = None
        try:
            # Use 'with' statement for cursor management
            with self.connection.cursor() as cursor:
                logger.debug(f"Executing query: {cursor.mogrify(query, params).decode('utf-8', errors='ignore')}") # Log query with params (be careful with sensitive data)
                cursor.execute(query, params)

                if return_id:
                    result = cursor.fetchone()
                    self.connection.commit()
                    logger.debug(f"Query returned ID: {result[0] if result else None}")
                    return result[0] if result else None
                elif fetch_one:
                    result = cursor.fetchone()
                    if result and cursor.description:
                        colnames = [desc[0] for desc in cursor.description]
                        row_dict = dict(zip(colnames, result))
                        # logger.debug(f"Query fetched one row: {row_dict}") # Potentially logs sensitive data
                        logger.debug(f"Query fetched one row (keys: {list(row_dict.keys())}).")
                        return row_dict
                    elif result:
                        logger.debug(f"Query fetched one value: {result[0]}")
                        return result[0]
                    else:
                        logger.debug("Query fetched no results (fetch_one).")
                        return None
                elif fetch_all:
                    if cursor.description:
                        colnames = [desc[0] for desc in cursor.description]
                        rows = cursor.fetchall()
                        results_list = [dict(zip(colnames, row)) for row in rows]
                        logger.debug(f"Query fetched {len(results_list)} rows.")
                        return results_list
                    else:
                        rows = cursor.fetchall()
                        if rows and len(rows) > 0 and len(rows[0]) == 1:
                             results_list = [row[0] for row in rows]
                             logger.debug(f"Query fetched {len(results_list)} single values.")
                             return results_list
                        elif rows:
                             logger.debug(f"Query fetched {len(rows)} rows (no column description).")
                             return rows
                        else:
                             logger.debug("Query fetched no results (fetch_all).")
                             return []
                else:
                    affected_rows = cursor.rowcount
                    self.connection.commit()
                    logger.debug(f"Query executed successfully. Rows affected: {affected_rows}")
                    return affected_rows
        except psycopg2.Error as e:
            logger.error(f"Database query failed: {e}\nQuery: {query}\nParams: {params}", exc_info=True)
            if self.connection and not self.connection.closed:
                try:
                    self.connection.rollback()
                    logger.info("Transaction rolled back due to query error.")
                except psycopg2.Error as rb_err:
                     logger.error(f"Error during rollback: {rb_err}", exc_info=True)
            raise e
        except Exception as e:
             logger.error(f"Unexpected error during query execution: {e}\nQuery: {query}\nParams: {params}", exc_info=True)
             if self.connection and not self.connection.closed:
                 try:
                     self.connection.rollback()
                     logger.info("Transaction rolled back due to unexpected error.")
                 except psycopg2.Error as rb_err:
                      logger.error(f"Error during rollback: {rb_err}", exc_info=True)
             raise e
        # 'finally' block for cursor closing is removed as 'with' statement handles it

    def get_application_config(self, profile_name: str = 'default') -> Optional[Dict[str, Any]]:
        """Fetches application configuration for a given profile."""
        query = "SELECT * FROM application_config WHERE profile_name = %s;"
        try:
            result = self._execute_query(query, (profile_name,), fetch_one=True)
            if result and isinstance(result, dict):
                logger.info(f"Application config loaded for profile '{profile_name}'.")
                config_data = result
                if 'gemini_temperature' in config_data and isinstance(config_data['gemini_temperature'], Decimal):
                    config_data['gemini_temperature'] = float(config_data['gemini_temperature'])
                # Log loaded config excluding potentially sensitive defaults if any
                loggable_config = {k: v for k, v in config_data.items() if 'key' not in k.lower()}
                logger.debug(f"Loaded config data: {loggable_config}")
                return config_data
            else:
                logger.warning(f"Application config not found for profile '{profile_name}'.")
                return None
        except psycopg2.Error as e:
             logger.error(f"Failed to get application config for profile '{profile_name}': {e}", exc_info=True)
             return None
        except Exception as e:
             logger.error(f"Unexpected error getting application config for '{profile_name}': {e}", exc_info=True)
             return None

    def save_application_config(self, profile_name: str, config_data: Dict[str, Any]) -> bool:
        """
        Inserts or updates the application configuration for a given profile.
        Handles data type conversions for DB compatibility. Excludes API keys.
        """
        logger.info(f"Attempting to save application configuration for profile '{profile_name}'...")

        # Prepare data, ensuring correct types and handling potential None values
        def ensure_list(value): return list(value) if value is not None else []
        def ensure_bool(value, default): return bool(value) if value is not None else default
        def ensure_float(value, default):
            """Safely convert value to float, return default on error."""
            if value is None:
                return default
            try:
                return float(value)
            except (ValueError, TypeError):
                logger.warning(f"Could not convert '{value}' to float. Returning default: {default}")
                return default
        def ensure_int(value, default):
            """Safely convert value to int, return default on error."""
            if value is None:
                return default
            try:
                return int(value)
            except (ValueError, TypeError):
                 logger.warning(f"Could not convert '{value}' to int. Returning default: {default}")
                 return default

        allowed_extensions = ensure_list(config_data.get('allowed_extensions'))
        excluded_dirs = ensure_list(config_data.get('excluded_dirs'))
        default_ignore_list = ensure_list(config_data.get('default_ignore_list'))
        gemini_available_models = ensure_list(config_data.get('gemini_available_models'))
        claude_available_models = ensure_list(config_data.get('claude_available_models'))
        gpt_available_models = ensure_list(config_data.get('gpt_available_models'))

        gemini_enable_thinking = ensure_bool(config_data.get('gemini_enable_thinking'), True)
        gemini_enable_search = ensure_bool(config_data.get('gemini_enable_search'), True)
        gemini_temperature = ensure_float(config_data.get('gemini_temperature'), 0.0)
        gemini_thinking_budget = ensure_int(config_data.get('gemini_thinking_budget'), 24576)

        sql = """
            INSERT INTO application_config ( profile_name, default_system_prompt, allowed_extensions, excluded_dirs, default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model, gemini_available_models, claude_available_models, gpt_available_models, gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search )
            VALUES ( %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s )
            ON CONFLICT (profile_name) DO UPDATE SET default_system_prompt = EXCLUDED.default_system_prompt, allowed_extensions = EXCLUDED.allowed_extensions, excluded_dirs = EXCLUDED.excluded_dirs, default_ignore_list = EXCLUDED.default_ignore_list, gemini_default_model = EXCLUDED.gemini_default_model, claude_default_model = EXCLUDED.claude_default_model, gpt_default_model = EXCLUDED.gpt_default_model, gemini_available_models = EXCLUDED.gemini_available_models, claude_available_models = EXCLUDED.claude_available_models, gpt_available_models = EXCLUDED.gpt_available_models, gemini_temperature = EXCLUDED.gemini_temperature, gemini_enable_thinking = EXCLUDED.gemini_enable_thinking, gemini_thinking_budget = EXCLUDED.gemini_thinking_budget, gemini_enable_search = EXCLUDED.gemini_enable_search, updated_at = NOW();
        """
        params = ( profile_name, config_data.get('default_system_prompt'), allowed_extensions, excluded_dirs, default_ignore_list, config_data.get('gemini_default_model'), config_data.get('claude_default_model'), config_data.get('gpt_default_model'), gemini_available_models, claude_available_models, gpt_available_models, gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search )

        try:
            affected_rows = self._execute_query(sql, params)
            logger.info(f"Application configuration for profile '{profile_name}' saved successfully. Rows affected/action: {affected_rows}")
            return True
        except psycopg2.Error as e:
            logger.error(f"Error saving application configuration for profile '{profile_name}': {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during config save for profile '{profile_name}': {e}", exc_info=True)
            return False

    # --- API Key Management ---
    # get_active_api_key, get_active_api_keys, get_active_api_keys_with_usage, list_api_keys
    # add_api_key, update_api_key, delete_api_key, get_api_key_id: No significant changes needed beyond logging.

    def get_active_api_key(self, provider: str) -> Optional[str]:
        """Fetches the first active API key string for a given provider."""
        keys = self.get_active_api_keys(provider)
        return keys[0]['api_key'] if keys else None

    def get_active_api_keys(self, provider: str) -> List[Dict[str, Any]]:
        """Fetches all active API keys for a given provider, ordered by ID."""
        query = "SELECT id, api_key, description, is_active FROM api_keys WHERE provider = %s AND is_active = TRUE ORDER BY id;"
        try:
            result = self._execute_query(query, (provider,), fetch_all=True)
            if result: logger.info(f"Found {len(result)} active API key(s) for provider '{provider}'.")
            else: logger.warning(f"No active API keys found for provider '{provider}'.")
            return result if result else []
        except psycopg2.Error as e: logger.error(f"Failed to get active API keys for provider '{provider}': {e}"); return []
        except Exception as e: logger.error(f"Unexpected error getting active API keys for '{provider}': {e}", exc_info=True); return []


    def get_active_api_keys_with_usage(self, provider: str) -> List[Dict[str, Any]]:
        """ Fetches all active API keys for a given provider along with usage, ordered by ID. """
        query = """
            SELECT id, api_key, description, is_active, COALESCE(calls_this_day, 0) AS raw_calls_this_day, day_start_timestamp
            FROM api_keys WHERE provider = %s AND is_active = TRUE ORDER BY id;
        """
        try:
            results = self._execute_query(query, (provider,), fetch_all=True)
            if not results: logger.warning(f"No active API keys found for provider '{provider}'."); return []
            logger.info(f"Found {len(results)} active API key(s) with usage info for provider '{provider}'.")
            now = datetime.datetime.now(datetime.timezone.utc); current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            for key_info in results:
                raw_calls = key_info.get('raw_calls_this_day', 0); day_start = key_info.get('day_start_timestamp')
                if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc); key_info['day_start_timestamp'] = day_start
                if day_start and day_start < current_day_start: key_info['calls_this_day'] = 0; logger.debug(f"Key ID {key_info['id']}: Day window reset. Effective calls_this_day = 0")
                else: key_info['calls_this_day'] = raw_calls; logger.debug(f"Key ID {key_info['id']}: Within current day window. Effective calls_this_day = {raw_calls}")
            return results
        except psycopg2.Error as e: logger.error(f"Failed to get active API keys with usage for provider '{provider}': {e}", exc_info=True); return []
        except Exception as e: logger.error(f"Unexpected error getting active API keys with usage for '{provider}': {e}", exc_info=True); return []

    def list_api_keys(self, provider: Optional[str] = None) -> List[Dict[str, Any]]:
        """Lists all API keys, optionally filtered by provider."""
        select_cols = "id, api_key, provider, description, is_active, last_api_call_timestamp, calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp"
        if provider: query = f"SELECT {select_cols} FROM api_keys WHERE provider = %s ORDER BY provider, id;"; params = (provider,)
        else: query = f"SELECT {select_cols} FROM api_keys ORDER BY provider, id;"; params = None
        try:
            result = self._execute_query(query, params, fetch_all=True)
            logger.info(f"Listed {len(result)} API keys" + (f" for provider '{provider}'." if provider else "."))
            return result if result else []
        except psycopg2.Error as e: logger.error(f"Failed to list API keys: {e}", exc_info=True); return []
        except Exception as e: logger.error(f"Unexpected error listing API keys: {e}", exc_info=True); return []

    def add_api_key(self, provider: str, api_key: str, description: Optional[str] = None) -> Optional[int]:
        """Adds a new API key to the database."""
        if not provider or not api_key: logger.error("Cannot add API key: Provider and API key string are required."); return None
        query = """ INSERT INTO api_keys (provider, api_key, description, is_active, last_api_call_timestamp, calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp) VALUES (%s, %s, %s, %s, NULL, 0, NULL, 0, NULL) RETURNING id; """
        params = (provider, api_key, description, True)
        try:
            key_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new API key with ID: {key_id} for provider '{provider}'.")
            return key_id
        except psycopg2.IntegrityError as e: logger.error(f"Failed to add API key for '{provider}': Key likely already exists. {e}"); return None
        except psycopg2.Error as e: logger.error(f"Failed to add API key for '{provider}': {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error adding API key for '{provider}': {e}", exc_info=True); return None

    def update_api_key(self, key_id: int, description: Optional[str] = None, is_active: Optional[bool] = None) -> bool:
        """Updates the description or active status of an API key."""
        if description is None and is_active is None: logger.warning(f"No update provided for API key ID {key_id}."); return False
        set_clauses = []; params = []
        if description is not None: set_clauses.append("description = %s"); params.append(description)
        if is_active is not None: set_clauses.append("is_active = %s"); params.append(is_active)
        query = f"UPDATE api_keys SET {', '.join(set_clauses)}, updated_at = NOW() WHERE id = %s;"; params.append(key_id)
        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1: logger.info(f"API key ID {key_id} updated successfully."); return True
            else: logger.warning(f"API key ID {key_id} not found or no changes made."); return False
        except psycopg2.Error as e: logger.error(f"Failed to update API key ID {key_id}: {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error updating API key {key_id}: {e}", exc_info=True); return False

    def delete_api_key(self, key_id: int) -> bool:
        """Deletes an API key from the database."""
        query = "DELETE FROM api_keys WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (key_id,))
            if affected_rows == 1: logger.info(f"API key ID {key_id} deleted successfully."); return True
            else: logger.warning(f"API key ID {key_id} not found for deletion."); return False
        except psycopg2.Error as e: logger.error(f"Failed to delete API key ID {key_id}: {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error deleting API key {key_id}: {e}", exc_info=True); return False

    def get_api_key_id(self, api_key_string: str) -> Optional[int]:
        """Fetches the ID of a given API key string."""
        if not api_key_string: return None
        query = "SELECT id FROM api_keys WHERE api_key = %s;"
        try:
            result_dict = self._execute_query(query, (api_key_string,), fetch_one=True)
            key_id = result_dict['id'] if result_dict and 'id' in result_dict else None
            logger.debug(f"Fetched ID {key_id} for API key ending in '...{api_key_string[-4:]}'")
            return key_id
        except psycopg2.Error as e: logger.error(f"Failed to get API key ID: {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error getting API key ID: {e}", exc_info=True); return None

    # --- Gemini Log Management ---
    # log_gemini_request, update_gemini_log, cleanup_old_gemini_logs: No significant changes needed beyond logging.

    def log_gemini_request(self, model_name: str, request_prompt: str, request_attachments: Optional[List[Dict[str, Any]]], api_key_id: Optional[int]) -> Optional[int]:
        """Logs the initial Gemini API request details and returns the log ID."""
        query = "INSERT INTO gemini_api_logs (model_name, request_prompt, request_attachments, api_key_id, request_timestamp) VALUES (%s, %s, %s, %s, %s) RETURNING id;"
        attachments_json = None
        if request_attachments:
            metadata_attachments = [{k: v for k, v in att.items() if k != 'data'} for att in request_attachments]
            try: attachments_json = json.dumps(metadata_attachments)
            except TypeError as e: logger.error(f"Failed to serialize attachments to JSON: {e}"); attachments_json = json.dumps([{"error": "Serialization failed"}])
        request_timestamp = datetime.datetime.now(datetime.timezone.utc)
        params = (model_name, request_prompt, attachments_json, api_key_id, request_timestamp)
        try:
            log_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Logged Gemini request with ID: {log_id}")
            return log_id
        except psycopg2.Error as e: logger.error(f"Failed to log Gemini request: {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error logging Gemini request: {e}", exc_info=True); return None

    def update_gemini_log(self, log_id: int, response_text: Optional[str] = None, response_xml: Optional[str] = None, response_summary: Optional[str] = None, error_message: Optional[str] = None, elapsed_time_ms: Optional[int] = None, token_count: Optional[int] = None):
        """Updates the Gemini API log record with response details."""
        if log_id is None: logger.error("Cannot update Gemini log: Invalid log_id provided."); return
        update_fields = []; params = []
        if response_text is not None: update_fields.append("response_text = %s"); params.append(response_text)
        if response_xml is not None: update_fields.append("response_xml = %s"); params.append(response_xml)
        if response_summary is not None: update_fields.append("response_summary = %s"); params.append(response_summary)
        if error_message is not None: update_fields.append("error_message = %s"); params.append(error_message)
        if elapsed_time_ms is not None: update_fields.append("elapsed_time_ms = %s"); params.append(elapsed_time_ms)
        if token_count is not None: update_fields.append("token_count = %s"); params.append(token_count)
        # Always update response_timestamp
        update_fields.append("response_timestamp = %s"); params.append(datetime.datetime.now(datetime.timezone.utc)); params.append(log_id)
        if not update_fields: logger.debug(f"No specific fields to update for Gemini log ID {log_id}, updating timestamp only."); pass
        query = f"UPDATE gemini_api_logs SET {', '.join(update_fields)} WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1: logger.info(f"Updated Gemini log record ID: {log_id}")
            else: logger.warning(f"Attempted to update Gemini log ID: {log_id}, but {affected_rows} rows were affected.")
        except psycopg2.Error as e: logger.error(f"Failed to update Gemini log ID {log_id}: {e}", exc_info=True)
        except Exception as e: logger.error(f"Unexpected error updating Gemini log {log_id}: {e}", exc_info=True)

    def cleanup_old_gemini_logs(self, days_to_keep: int = 7):
        """Deletes Gemini API log records older than the specified number of days."""
        if days_to_keep <= 0: logger.warning("Log cleanup skipped: days_to_keep must be positive."); return
        cutoff_date = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=days_to_keep)
        query = "DELETE FROM gemini_api_logs WHERE request_timestamp < %s;"
        try:
            affected_rows = self._execute_query(query, (cutoff_date,))
            if affected_rows is not None and affected_rows > 0: logger.info(f"Cleaned up {affected_rows} old Gemini log records older than {cutoff_date.strftime('%Y-%m-%d')}.")
            else: logger.info("No old Gemini log records found to clean up.")
        except psycopg2.Error as e: logger.error(f"Failed to clean up old Gemini logs: {e}", exc_info=True)
        except Exception as e: logger.error(f"Unexpected error cleaning up Gemini logs: {e}", exc_info=True)


    # --- Rate Limit and Usage Tracking (Modified for api_keys table) ---
    # update_api_key_usage, get_model_rate_limit, get_api_key_usage, is_key_rate_limited
    # insert_or_update_rate_limit, delete_rate_limit: No significant changes needed beyond logging.

    def update_api_key_usage(self, api_key_id: int):
        """Updates usage statistics for a given API key ID in api_keys table."""
        if api_key_id is None: logger.warning("Cannot update API key usage: api_key_id is None."); return
        logger.info(f"Updating API key usage for key ID: {api_key_id}")
        now = datetime.datetime.now(datetime.timezone.utc); current_minute_start = now.replace(second=0, microsecond=0); current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        query = """
            UPDATE api_keys SET
                last_api_call_timestamp = %(now)s,
                calls_this_minute = CASE WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN 1 ELSE calls_this_minute + 1 END,
                minute_start_timestamp = CASE WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN %(minute_start)s ELSE minute_start_timestamp END,
                calls_this_day = CASE WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN 1 ELSE calls_this_day + 1 END,
                day_start_timestamp = CASE WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN %(day_start)s ELSE day_start_timestamp END,
                updated_at = NOW()
            WHERE id = %(key_id)s;
        """
        params = {'key_id': api_key_id, 'now': now, 'minute_start': current_minute_start, 'day_start': current_day_start }
        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1: logger.info(f"API key usage updated successfully for key ID: {api_key_id}.")
            elif affected_rows == 0: logger.warning(f"API key usage update failed for key ID {api_key_id}: Key not found.")
            else: logger.error(f"Unexpected number of rows affected ({affected_rows}) during API key usage update for key ID {api_key_id}.")
        except psycopg2.Error as e: logger.error(f"Failed to update API key usage for key ID {api_key_id}: {e}", exc_info=True)
        except Exception as e: logger.error(f"An unexpected error occurred during API key usage update for key ID {api_key_id}: {e}", exc_info=True)

    def get_model_rate_limit(self, model_name: str) -> Optional[Dict[str, Any]]:
        """Fetches the default rate limit information for a specific model."""
        query = "SELECT rpm_limit, daily_limit FROM model_rate_limits WHERE model_name = %s;"
        try:
            result = self._execute_query(query, (model_name,), fetch_one=True)
            if result: logger.info(f"Rate limit found for model '{model_name}': RPM={result.get('rpm_limit')}, Daily={result.get('daily_limit')}"); return result
            else: logger.warning(f"No rate limit information found for model '{model_name}'."); return None
        except psycopg2.Error as e: logger.error(f"Failed to get rate limit for model '{model_name}': {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error getting rate limit for '{model_name}': {e}", exc_info=True); return None

    def get_api_key_usage(self, api_key_id: int) -> Optional[Dict[str, Any]]:
        """Fetches current usage statistics for a specific API key ID."""
        if api_key_id is None: return None
        query = "SELECT calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp FROM api_keys WHERE id = %s;"
        try:
            result = self._execute_query(query, (api_key_id,), fetch_one=True)
            if result:
                logger.debug(f"Usage found for API key ID {api_key_id}.")
                if result.get('minute_start_timestamp') and result['minute_start_timestamp'].tzinfo is None: result['minute_start_timestamp'] = result['minute_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                if result.get('day_start_timestamp') and result['day_start_timestamp'].tzinfo is None: result['day_start_timestamp'] = result['day_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                return result
            else: logger.info(f"No usage record found for API key ID {api_key_id}. Assuming 0 usage."); return {'calls_this_minute': 0, 'minute_start_timestamp': None, 'calls_this_day': 0, 'day_start_timestamp': None}
        except psycopg2.Error as e: logger.error(f"Failed to get usage for API key ID {api_key_id}: {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error getting usage for key ID {api_key_id}: {e}", exc_info=True); return None

    def is_key_rate_limited(self, api_key_id: int, model_name: str) -> Tuple[bool, str]:
        """ Checks if the API key is currently rate-limited for the given model. """
        if api_key_id is None: return True, "API Key ID is missing."
        try:
            rate_limit_info = self.get_model_rate_limit(model_name)
            if not rate_limit_info: logger.warning(f"No rate limit info found for model '{model_name}'. Assuming not limited."); return False, "Rate limit info not found."
            rpm_limit = rate_limit_info.get('rpm_limit'); daily_limit = rate_limit_info.get('daily_limit')
            usage_info = self.get_api_key_usage(api_key_id)
            calls_this_minute = usage_info.get('calls_this_minute', 0); minute_start = usage_info.get('minute_start_timestamp'); calls_this_day = usage_info.get('calls_this_day', 0); day_start = usage_info.get('day_start_timestamp')
            now = datetime.datetime.now(datetime.timezone.utc); current_minute_start = now.replace(second=0, microsecond=0); current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            if rpm_limit is not None and rpm_limit > 0:
                current_minute_call_count = calls_this_minute
                if minute_start and now >= minute_start + datetime.timedelta(minutes=1): current_minute_call_count = 0; logger.debug(f"RPM Check: Minute window reset for key {api_key_id}.")
                if current_minute_call_count >= rpm_limit: reason = f"RPM limit ({rpm_limit}) reached or exceeded ({current_minute_call_count})."; logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}"); return True, reason
            if daily_limit is not None and daily_limit > 0:
                current_day_call_count = calls_this_day
                if day_start and now >= day_start + datetime.timedelta(days=1): current_day_call_count = 0; logger.debug(f"Daily Check: Day window reset for key {api_key_id}.")
                if current_day_call_count >= daily_limit: reason = f"Daily limit ({daily_limit}) reached or exceeded ({current_day_call_count})."; logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}"); return True, reason
            logger.debug(f"Rate limit check passed for key ID {api_key_id} and model '{model_name}'.")
            return False, "Rate limit OK."
        except Exception as e: logger.error(f"Error checking rate limit for key ID {api_key_id}: {e}", exc_info=True); return True, f"Error during rate limit check: {e}"

    def insert_or_update_rate_limit(self, model_name: str, provider: str, rpm_limit: int, daily_limit: int, notes: Optional[str] = None) -> bool:
        """Inserts or updates a model's rate limit information."""
        sql = """ INSERT INTO model_rate_limits (model_name, provider, rpm_limit, daily_limit, notes) VALUES (%s, %s, %s, %s, %s) ON CONFLICT (model_name) DO UPDATE SET provider = EXCLUDED.provider, rpm_limit = EXCLUDED.rpm_limit, daily_limit = EXCLUDED.daily_limit, notes = EXCLUDED.notes, updated_at = NOW(); """
        params = (model_name, provider, rpm_limit, daily_limit, notes)
        try:
            self._execute_query(sql, params)
            logger.info(f"Rate limit for model '{model_name}' saved successfully.")
            return True
        except psycopg2.Error as e: logger.error(f"Error saving rate limit for model '{model_name}': {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error saving rate limit for '{model_name}': {e}", exc_info=True); return False

    def delete_rate_limit(self, model_name: str) -> bool:
        """Deletes rate limit information for a specific model."""
        sql = "DELETE FROM model_rate_limits WHERE model_name = %s;"
        try:
            affected_rows = self._execute_query(sql, (model_name,))
            if affected_rows == 1: logger.info(f"Rate limit for model '{model_name}' deleted successfully."); return True
            else: logger.warning(f"Model '{model_name}' not found for rate limit deletion."); return False
        except psycopg2.Error as e: logger.error(f"Error deleting rate limit for model '{model_name}': {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error deleting rate limit for '{model_name}': {e}", exc_info=True); return False


    # --- SSH Connection Management ---
    # add_ssh_connection, get_ssh_connection, get_ssh_connection_by_id, list_ssh_connections
    # update_ssh_connection, delete_ssh_connection, delete_ssh_connection_by_alias: No significant changes needed beyond logging.

    def add_ssh_connection(self, config: SshConnectionConfig) -> Optional[int]:
        """Adds a new SSH connection configuration (plain text password)."""
        query = "INSERT INTO ssh_connections (alias, host, port, username, auth_type, password, key_path) VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING id;"
        password_to_store = config.password if config.auth_type == 'password' else None
        params = (config.alias, config.host, config.port, config.username, config.auth_type, password_to_store, config.key_path)
        try:
            connection_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new SSH connection with ID: {connection_id} (Alias: {config.alias})")
            return connection_id
        except psycopg2.IntegrityError as e: logger.error(f"Failed to add SSH connection '{config.alias}': Alias likely already exists. {e}"); return None
        except psycopg2.Error as e: logger.error(f"Failed to add SSH connection '{config.alias}': {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error adding SSH connection '{config.alias}': {e}", exc_info=True); return None

    def get_ssh_connection(self, alias: str) -> Optional[SshConnectionConfig]:
        """Fetches an SSH connection configuration by its alias."""
        query = "SELECT * FROM ssh_connections WHERE alias = %s;"
        try:
            result_dict = self._execute_query(query, (alias,), fetch_one=True)
            if result_dict: logger.debug(f"Found SSH connection for alias '{alias}'."); return SshConnectionConfig(**result_dict)
            else: logger.info(f"No SSH connection found with alias '{alias}'."); return None
        except psycopg2.Error as e: logger.error(f"Failed to get SSH connection '{alias}': {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error getting SSH connection '{alias}': {e}", exc_info=True); return None

    def get_ssh_connection_by_id(self, connection_id: int) -> Optional[SshConnectionConfig]:
        """Fetches an SSH connection configuration by its ID."""
        query = "SELECT * FROM ssh_connections WHERE id = %s;"
        try:
            result_dict = self._execute_query(query, (connection_id,), fetch_one=True)
            if result_dict: logger.debug(f"Found SSH connection for ID {connection_id}."); return SshConnectionConfig(**result_dict)
            else: logger.info(f"No SSH connection found with ID {connection_id}."); return None
        except psycopg2.Error as e: logger.error(f"Failed to get SSH connection by ID {connection_id}: {e}", exc_info=True); return None
        except Exception as e: logger.error(f"Unexpected error getting SSH connection by ID {connection_id}: {e}", exc_info=True); return None

    def list_ssh_connections(self) -> List[SshConnectionConfig]:
        """Lists all saved SSH connection configurations."""
        query = "SELECT * FROM ssh_connections ORDER BY alias;"
        try:
            results_list = self._execute_query(query, fetch_all=True)
            connections = [SshConnectionConfig(**row) for row in results_list] if results_list else []
            logger.info(f"Listed {len(connections)} SSH connections.")
            return connections
        except psycopg2.Error as e: logger.error(f"Failed to list SSH connections: {e}", exc_info=True); return []
        except Exception as e: logger.error(f"Unexpected error listing SSH connections: {e}", exc_info=True); return []

    def update_ssh_connection(self, connection_id: int, config: SshConnectionConfig) -> bool:
        """Updates an existing SSH connection configuration (plain text password)."""
        query = "UPDATE ssh_connections SET alias = %s, host = %s, port = %s, username = %s, auth_type = %s, password = %s, key_path = %s, updated_at = NOW() WHERE id = %s;"
        password_to_store = config.password if config.auth_type == 'password' else None
        params = (config.alias, config.host, config.port, config.username, config.auth_type, password_to_store, config.key_path, connection_id)
        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1: logger.info(f"SSH connection ID {connection_id} (Alias: {config.alias}) updated successfully."); return True
            else: logger.warning(f"SSH connection ID {connection_id} not found for update."); return False
        except psycopg2.IntegrityError as e: logger.error(f"Failed to update SSH connection ID {connection_id}: Alias '{config.alias}' likely already exists for another entry. {e}"); return False
        except psycopg2.Error as e: logger.error(f"Failed to update SSH connection ID {connection_id}: {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error updating SSH connection {connection_id}: {e}", exc_info=True); return False

    def delete_ssh_connection(self, connection_id: int) -> bool:
        """Deletes an SSH connection configuration by its ID."""
        query = "DELETE FROM ssh_connections WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (connection_id,))
            if affected_rows == 1: logger.info(f"SSH connection ID {connection_id} deleted successfully."); return True
            else: logger.warning(f"SSH connection ID {connection_id} not found for deletion."); return False
        except psycopg2.Error as e: logger.error(f"Failed to delete SSH connection ID {connection_id}: {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error deleting SSH connection {connection_id}: {e}", exc_info=True); return False

    def delete_ssh_connection_by_alias(self, alias: str) -> bool:
        """Deletes an SSH connection configuration by its alias."""
        query = "DELETE FROM ssh_connections WHERE alias = %s;"
        try:
            affected_rows = self._execute_query(query, (alias,))
            if affected_rows == 1: logger.info(f"SSH connection with alias '{alias}' deleted successfully."); return True
            else: logger.warning(f"SSH connection with alias '{alias}' not found for deletion."); return False
        except psycopg2.Error as e: logger.error(f"Failed to delete SSH connection with alias '{alias}': {e}", exc_info=True); return False
        except Exception as e: logger.error(f"Unexpected error deleting SSH connection by alias '{alias}': {e}", exc_info=True); return False

    def __del__(self):
        """Ensure disconnection when the service object is destroyed."""
        self.disconnect()



======== src\core\services\filesystem_service.py ========
import os
import fnmatch
from typing import Set, List

# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로)
from .config_service import ConfigService

class FilesystemService:
    def __init__(self, config_service: ConfigService): # ConfigService 주입
        self.config_service = config_service

    def load_gitignore_patterns(self, project_folder: str) -> Set[str]:
        """Loads .gitignore patterns from the project folder and combines with defaults."""
        gitignore_path = os.path.join(project_folder, ".gitignore")
        settings = self.config_service.get_settings()
        # 기본 무시 목록으로 시작
        patterns = set(settings.default_ignore_list)

        if os.path.isfile(gitignore_path):
            try:
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    lines = f.read().splitlines()
                # 주석과 빈 줄 제외하고 패턴 추가
                lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                patterns.update(lines)
            except Exception as e:
                print(f"Error loading .gitignore file {gitignore_path}: {e}")
                # 오류 발생 시 기본값만 사용

        # 설정에 직접 저장된 제외 목록도 추가 (config.yml)
        patterns.update(settings.excluded_dirs)
        return patterns

    def should_ignore(self, file_path: str, project_root: str, ignore_patterns: Set[str], is_dir: bool) -> bool:
        """Checks if a file/directory should be ignored based on patterns."""
        if not project_root or not file_path.startswith(project_root):
            return False # 프로젝트 루트 외부는 무시하지 않음

        if file_path == project_root:
            return False # 프로젝트 루트 자체는 무시하지 않음

        file_name = os.path.basename(file_path)
        try:
            relative_path = os.path.relpath(file_path, project_root).replace(os.sep, '/')
        except ValueError:
            # 다른 드라이브 등 상대 경로 계산 불가 시 무시하지 않음
            return False

        for pattern in ignore_patterns:
            # 패턴 정리 및 디렉토리 패턴 여부 확인
            is_dir_pattern = pattern.endswith('/')
            cleaned_pattern = pattern.rstrip('/')

            # 디렉토리 패턴인데 현재 항목이 파일이면 건너뜀
            if is_dir_pattern and not is_dir:
                continue

            # 1. 파일 이름 매칭 (e.g., *.log, __pycache__)
            if fnmatch.fnmatch(file_name, cleaned_pattern):
                # 디렉토리 패턴이면 디렉토리만 매칭
                if is_dir_pattern and is_dir:
                    return True
                # 파일 패턴이면 파일/디렉토리 모두 매칭 (gitignore 기본 동작)
                elif not is_dir_pattern:
                    return True

            # 2. 상대 경로 매칭 (e.g., build/, docs/temp.txt)
            # 디렉토리일 경우, 경로 끝에 '/' 추가하여 매칭
            match_path = relative_path + '/' if is_dir else relative_path
            if fnmatch.fnmatch(match_path, pattern):
                 return True
            # 패턴에 /가 포함되어 있고, 디렉토리 패턴이 아닐 때도 경로 매칭 시도
            # (e.g. 'some/dir/file.txt' 패턴)
            if '/' in pattern and not is_dir_pattern:
                 if fnmatch.fnmatch(relative_path, pattern):
                     return True

        return False # 어떤 패턴과도 매치되지 않으면 무시하지 않음

    def get_directory_tree(self, paths: List[str], project_root: str) -> str:
        """Builds a directory tree structure string from a list of paths."""
        if not paths or not project_root:
            return "No items selected or project root not set."

        tree = {}
        visible_paths = [] # 실제 존재하는 경로만 필터링 (필요시)
        for p in paths:
            if os.path.exists(p):
                 visible_paths.append(p)

        if not visible_paths:
            return "No valid items selected."

        for p in visible_paths:
            try:
                rel_path = os.path.relpath(p, project_root)
            except ValueError:
                continue # 다른 드라이브 등 relpath 계산 불가 시 건너뜀
            parts = rel_path.split(os.sep)
            current = tree
            for part in parts:
                if part not in current:
                    current[part] = {}
                current = current[part]

        def print_tree(subtree, current_path, indent=0):
            lines = []
            indent_str = "  " * indent
            entries = sorted(subtree.keys())
            dirs = []
            files = []

            for entry in entries:
                full_path = os.path.join(current_path, entry)
                if os.path.isdir(full_path):
                    dirs.append(entry)
                elif os.path.isfile(full_path):
                    files.append(entry)

            for d in dirs:
                lines.append(f"{indent_str} 📁 {d}/")
                lines.extend(print_tree(subtree[d], os.path.join(current_path, d), indent + 1))
            for f in files:
                size = 0
                full_file_path = os.path.join(current_path, f)
                try:
                    size = os.path.getsize(full_file_path)
                except OSError:
                    size = 0
                lines.append(f"{indent_str} 📄 {f} ({size:,} bytes)")
            return lines

        root_folder_name = os.path.basename(project_root)
        root_lines = [f"File Tree:", f" 📁 {root_folder_name}/"]
        root_lines.extend(print_tree(tree, project_root, 1))

        return "\n".join(root_lines)



======== src\core\services\gemini_service.py ========
import google.generativeai as genai
from langgraph.graph import StateGraph, END, START
from functools import partial
import logging
from typing import Optional, List, Dict, Any, Union, Tuple, Set
import base64
import mimetypes
import os
import datetime # datetime 모듈 임포트
import time # 시간 측정용

# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로)
from ..langgraph_state import GeminiGraphState
from .config_service import ConfigService
from .db_service import DbService # DbService 임포트
from google.generativeai import types
from google.api_core import exceptions as google_api_exceptions

logger = logging.getLogger(__name__)

# --- LangGraph 노드 함수 ---

def call_gemini(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """
    Gemini API를 호출하는 노드 (멀티모달 지원).
    키 선택 및 재시도 로직 포함.
    """
    logger.info("--- Starting Gemini API Call Node (Multimodal, Key Rotation) ---")
    start_time_mono = time.monotonic()
    request_timestamp = datetime.datetime.now(datetime.timezone.utc)
    logger.info(f"Gemini API call start time: {request_timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}")

    text_prompt = state['input_prompt']
    attachments = state.get('input_attachments', [])
    settings = config_service.get_settings()
    db_service: DbService = config_service.db_service

    model_name = state.get('selected_model_name', settings.gemini_default_model)
    temperature = settings.gemini_temperature
    enable_thinking = settings.gemini_enable_thinking
    thinking_budget = settings.gemini_thinking_budget
    enable_search = settings.gemini_enable_search

    default_return_state: GeminiGraphState = {
        "input_prompt": text_prompt, "input_attachments": attachments,
        "selected_model_name": model_name, "gemini_response": "",
        "xml_output": "", "summary_output": "", "error_message": None, "log_id": None
    }

    if not model_name:
        error_msg = "Gemini model name not provided or configured."; logger.error(error_msg)
        default_return_state["error_message"] = error_msg; return default_return_state

    logger.info(f"Target Model: {model_name}")
    logger.debug(f"Parameters - Temp: {temperature}, Thinking: {enable_thinking}, Budget: {thinking_budget}, Search: {enable_search}")

    tried_key_ids: Set[int] = set()
    api_key_id: Optional[int] = None
    log_id: Optional[int] = None
    final_error_message: Optional[str] = None
    api_call_successful = False
    successfully_used_key_string: Optional[str] = None
    successfully_used_key_id: Optional[int] = None

    # 1. 사용자 지정 키 시도
    user_selected_key_id = config_service.get_user_selected_gemini_key_id()
    user_key_info: Optional[Dict[str, Any]] = None
    if user_selected_key_id is not None:
        logger.info(f"Attempting user-selected Gemini Key ID: {user_selected_key_id}")
        try:
            temp_keys_usage = db_service.get_active_api_keys_with_usage('google')
            user_key_info = next((k for k in temp_keys_usage if k['id'] == user_selected_key_id), None)
            if user_key_info:
                is_limited, reason = db_service.is_key_rate_limited(user_selected_key_id, model_name)
                if is_limited:
                    logger.warning(f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}. Will try other keys.")
                    final_error_message = f"User-selected key ID {user_selected_key_id} is rate-limited: {reason}"
                    tried_key_ids.add(user_selected_key_id); user_key_info = None
                else: logger.info(f"User-selected key ID {user_selected_key_id} passed rate limit check.")
            else:
                logger.warning(f"User-selected key ID {user_selected_key_id} not found among active keys or failed to get usage. Will try other keys.")
                tried_key_ids.add(user_selected_key_id)
        except Exception as e:
            logger.error(f"Error retrieving/checking user-selected key ID {user_selected_key_id}: {e}", exc_info=True)
            tried_key_ids.add(user_selected_key_id); user_key_info = None

    # --- API 키 시도 루프 ---
    keys_to_attempt: List[Dict[str, Any]] = []
    if user_key_info: keys_to_attempt.append(user_key_info)
    if not user_key_info:
        logger.info("Fetching other active Gemini keys sorted by daily usage...")
        try:
            active_keys_usage = db_service.get_active_api_keys_with_usage('google')
            active_keys_usage.sort(key=lambda x: x['calls_this_day'])
            added_count = 0
            for key_info in active_keys_usage:
                if key_info['id'] not in tried_key_ids: keys_to_attempt.append(key_info); added_count += 1
            logger.info(f"Found {added_count} other active keys to try.")
        except Exception as e:
            error_msg = f"Failed to retrieve other active Gemini keys with usage from DB: {e}"
            logger.error(error_msg, exc_info=True)
            if not user_key_info: default_return_state["error_message"] = final_error_message or error_msg; return default_return_state
            elif user_selected_key_id in tried_key_ids: default_return_state["error_message"] = final_error_message or "Failed to find alternative keys."; return default_return_state

    if not keys_to_attempt:
        error_msg = final_error_message or "No usable Gemini API Keys found."
        logger.error(error_msg); default_return_state["error_message"] = error_msg; return default_return_state

    logger.info(f"Total keys to try in order: {[k['id'] for k in keys_to_attempt]}")

    for key_info in keys_to_attempt:
        api_key = key_info['api_key']; current_key_id = key_info['id']; daily_usage = key_info.get('calls_this_day', 'N/A')
        logger.info(f"--> Attempting Key ID: {current_key_id} (Daily Usage: {daily_usage})")

        if current_key_id in tried_key_ids: logger.debug(f"Skipping already tried key ID: {current_key_id}"); continue

        if current_key_id != user_selected_key_id: # Rate limit check for non-user-selected keys
            is_limited, reason = db_service.is_key_rate_limited(current_key_id, model_name)
            if is_limited:
                logger.warning(f"Pre-check failed: Rate limit reached for key ID {current_key_id}. Reason: {reason}. Skipping.")
                final_error_message = f"Rate limit exceeded for key ID {current_key_id}: {reason}"
                tried_key_ids.add(current_key_id); continue
            logger.info(f"Rate limit pre-check passed for key ID {current_key_id}.")

        # --- DB 로깅 준비 ---
        current_log_id = log_id
        if current_log_id is None:
            try:
                current_log_id = db_service.log_gemini_request(model_name=model_name, request_prompt=text_prompt, request_attachments=attachments, api_key_id=current_key_id)
                if current_log_id: log_id = current_log_id; default_return_state["log_id"] = log_id
                else: logger.error(f"Failed to create initial Gemini log entry for key ID {current_key_id}.")
            except Exception as db_err: logger.error(f"Failed to log Gemini request to DB for key ID {current_key_id}: {db_err}", exc_info=True)
        # --- DB 로깅 준비 완료 ---

        effective_model_name = ""; gemini_response_text = ""; api_error_message: Optional[str] = None

        try:
            genai.configure(api_key=api_key)
            effective_model_name = model_name.replace("models/", "")
            model = genai.GenerativeModel(effective_model_name)
            logger.info(f"Using Gemini model: {effective_model_name} with key ID: {current_key_id}")

            # GenerationConfig, ToolConfig, Tools 설정
            generation_config_params = {"temperature": temperature, "response_mime_type": "text/plain"}
            try: generation_config = types.GenerationConfig(**generation_config_params)
            except Exception as e: raise ValueError(f"Error creating GenerationConfig: {e}")

            tools_list: Optional[List[types.Tool]] = None
            if enable_search:
                try: tools_list = [types.Tool(google_search=types.GoogleSearch())]
                except Exception as e: logger.error(f"Error creating GoogleSearch tool: {e}")

            tool_config_obj: Optional[types.ToolConfig] = None
            if enable_thinking:
                try:
                    thinking_config_obj = types.ThinkingConfig(thinking_budget=thinking_budget); tool_config_obj = types.ToolConfig(thinking_config=thinking_config_obj)
                except Exception as e: logger.error(f"Error creating ThinkingConfig/ToolConfig: {e}")

            # Contents 구성
            contents_list: List[Union[str, Dict[str, Any]]] = []
            if text_prompt: contents_list.append(text_prompt)
            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type'); item_name = attachment.get('name', 'unknown'); item_data = attachment.get('data'); item_path = attachment.get('path')
                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e: logger.error(f"Failed to read attachment {item_path}: {e}"); continue
                    if not item_data: logger.warning(f"Skipping attachment '{item_name}': No data."); continue
                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name); mime_type = mime_type or 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list: raise ValueError("No content (text or attachments) to send.")

            # API 호출 (스트림)
            logger.info(f"Sending {len(contents_list)} parts to Gemini model: {effective_model_name} (using key ID: {current_key_id})")
            response = model.generate_content(contents=contents_list, generation_config=generation_config, tools=tools_list, tool_config=tool_config_obj, stream=True)

            specific_error_occurred = False; error_details = ""
            for chunk in response:
                try: gemini_response_text += chunk.text
                except ValueError as e:
                    if "response.text` quick accessor" in str(e) or "candidate.text`" in str(e):
                        func_calls = getattr(chunk, 'function_calls', None); finish_reason = getattr(getattr(chunk, 'candidates', [None])[0], 'finish_reason', 'unknown') if hasattr(chunk, 'candidates') else 'unknown'
                        msg = (f"Function Call ignored: {func_calls}" if func_calls else f"Chunk text access error (Finish Reason: {finish_reason}): {e}")
                        logger.warning(msg); error_details += f"\n- {msg}"; specific_error_occurred = True; continue
                    else: raise
                except Exception as e: logger.exception(f"Unexpected chunk error: {e}"); error_details += f"\n- Chunk error: {e}"; specific_error_occurred = True; continue

            if specific_error_occurred:
                api_error_message = f"Gemini API 응답 문제 발생 (Key ID: {current_key_id}). 일부 내용 누락 또는 Function Call 포함 가능.\n세부 정보:" + error_details
                logger.warning(f"Gemini stream processing issues for key ID {current_key_id}. Details: {error_details}")
                default_return_state["error_message"] = api_error_message; default_return_state["gemini_response"] = gemini_response_text
                api_call_successful = True # 부분 성공 간주
                successfully_used_key_string = api_key; successfully_used_key_id = current_key_id; break
            elif not gemini_response_text.strip():
                error_detail = "Unknown reason (empty response)";
                try: error_detail = f"Prompt Feedback: {response.prompt_feedback}"
                except Exception: pass
                api_error_message = f"Gemini API 호출 성공했으나 빈 응답 반환 (Key ID: {current_key_id}). 세부 정보: {error_detail}"
                logger.warning(api_error_message); default_return_state["gemini_response"] = ""; default_return_state["error_message"] = api_error_message
                api_call_successful = True # 빈 응답도 성공 간주
                successfully_used_key_string = api_key; successfully_used_key_id = current_key_id; break
            else:
                logger.info(f"--- Gemini Response Received Successfully using Key ID: {current_key_id} ---")
                api_call_successful = True; successfully_used_key_string = api_key; successfully_used_key_id = current_key_id
                default_return_state["gemini_response"] = gemini_response_text; default_return_state["error_message"] = None; break

        except google_api_exceptions.ResourceExhausted as e:
            api_error_message = f"Gemini API Rate Limit 초과 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다."; logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message; tried_key_ids.add(current_key_id)
            if db_service and log_id is not None: end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000); db_service.update_gemini_log(log_id=log_id, error_message=f"Rate Limit Error: {e}", elapsed_time_ms=elapsed_ms_err)
            continue
        except google_api_exceptions.PermissionDenied as e:
            api_error_message = f"Gemini API 권한 오류 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다."; logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message; tried_key_ids.add(current_key_id)
            if db_service and log_id is not None: end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000); db_service.update_gemini_log(log_id=log_id, error_message=f"Permission Denied: {e}", elapsed_time_ms=elapsed_ms_err)
            continue
        except google_api_exceptions.InvalidArgument as e:
            api_error_message = f"Gemini API 잘못된 인수 오류 (Key ID: {current_key_id}): {str(e)}. 다음 키로 재시도합니다."; logger.error(api_error_message, exc_info=False)
            final_error_message = api_error_message; tried_key_ids.add(current_key_id)
            if db_service and log_id is not None: end_time_mono_err = time.monotonic(); elapsed_ms_err = int((end_time_mono_err - start_time_mono) * 1000); db_service.update_gemini_log(log_id=log_id, error_message=f"Invalid Argument: {e}", elapsed_time_ms=elapsed_ms_err)
            continue
        except (AttributeError, ValueError) as e:
            error_type = type(e).__name__; api_error_message = f"Gemini API 오류 ({error_type} - Key ID: {current_key_id}): {str(e)}. 중단합니다."; logger.error(api_error_message, exc_info=True)
            default_return_state["error_message"] = api_error_message; api_call_successful = False; tried_key_ids.add(current_key_id); break
        except Exception as e:
            api_error_message = f"Gemini API 호출 중 예상치 못한 오류 (Key ID: {current_key_id}): {str(e)}. 중단합니다."; logger.exception(api_error_message)
            default_return_state["error_message"] = api_error_message; api_call_successful = False; tried_key_ids.add(current_key_id); break
        finally:
            if api_call_successful or (api_error_message and "다음 키로 재시도합니다" not in api_error_message):
                 if api_call_successful and db_service and current_key_id is not None:
                    try: db_service.update_api_key_usage(current_key_id)
                    except Exception as usage_err: logger.error(f"Failed to update usage for key ID {current_key_id}: {usage_err}", exc_info=True)
                 if db_service and log_id is not None:
                    end_time_mono = time.monotonic(); elapsed_ms = int((end_time_mono - start_time_mono) * 1000)
                    try: db_service.update_gemini_log(log_id=log_id, response_text=gemini_response_text, error_message=api_error_message, elapsed_time_ms=elapsed_ms)
                    except Exception as db_err: logger.error(f"Failed to update Gemini log ID {log_id}: {db_err}", exc_info=True)

    if api_call_successful and successfully_used_key_string and successfully_used_key_id is not None:
        if config_service:
            config_service.update_last_used_gemini_key(successfully_used_key_string)
            logger.info(f"Successfully used API key ID {successfully_used_key_id}. Updated in-memory config.")
            if user_selected_key_id is not None and user_selected_key_id != successfully_used_key_id:
                 logger.info(f"Clearing user selection as key ID {successfully_used_key_id} was used instead of selected {user_selected_key_id}.")
                 config_service.set_user_selected_gemini_key(None)
        else: logger.warning("ConfigService not available to update the last used key.")

    if not api_call_successful:
        error_msg = final_error_message or "모든 활성 Gemini API 키를 시도했지만 호출에 실패했습니다."
        logger.error(error_msg); default_return_state["error_message"] = error_msg

    total_elapsed_ms = int((time.monotonic() - start_time_mono) * 1000)
    response_timestamp = datetime.datetime.now(datetime.timezone.utc)
    elapsed_time_str = str(datetime.timedelta(milliseconds=total_elapsed_ms)).split('.')[0]
    logger.info(f"--- Finished Gemini API Call Node. Elapsed Time: {elapsed_time_str} ---")

    return default_return_state


def process_response(state: GeminiGraphState, config_service: ConfigService) -> GeminiGraphState:
    """Gemini 응답을 XML과 Summary로 파싱하는 노드."""
    logger.info("--- Starting Process Response Node ---")
    gemini_response = state.get('gemini_response', '')
    xml_output = ""; summary_output = ""; error_message = state.get('error_message'); log_id = state.get('log_id')
    db_service: Optional[DbService] = config_service.db_service if config_service else None
    new_state = state.copy()

    try:
        if error_message and "Gemini API 응답 문제 발생" not in error_message and "빈 응답 반환" not in error_message:
             logger.warning(f"Skipping response processing due to previous critical error: {error_message}")
             new_state["xml_output"] = ""; new_state["summary_output"] = ""; return new_state
        elif error_message: logger.warning(f"Processing potentially partial or empty response due to previous issue: {error_message}")

        if not gemini_response or not gemini_response.strip():
             logger.warning("Gemini response is empty, skipping processing.")
             if not error_message: error_message = "Gemini response was empty."; new_state["error_message"] = error_message
             new_state["xml_output"] = ""; new_state["summary_output"] = ""
             if db_service and log_id is not None: db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
             return new_state

        cleaned_response = gemini_response.strip()
        summary_start_tag = "<summary>"; summary_end_tag = "</summary>"
        summary_start_index = cleaned_response.rfind(summary_start_tag)
        summary_end_index = cleaned_response.rfind(summary_end_tag)
        is_valid_summary = (summary_start_index != -1 and summary_end_index != -1 and summary_start_index < summary_end_index and summary_end_index >= len(cleaned_response) - len(summary_end_tag) - 20)

        if is_valid_summary:
            xml_output = cleaned_response[:summary_start_index].strip()
            summary_output = cleaned_response[summary_start_index + len(summary_start_tag):summary_end_index].strip()
            logger.info("Successfully parsed XML and Summary parts.")
            if "빈 응답 반환" in (error_message or ""): new_state["error_message"] = None
        else:
            xml_output = cleaned_response; summary_output = "Summary tag not found or improperly placed."; logger.warning(summary_output)
            if not error_message: new_state["error_message"] = summary_output

        new_state["xml_output"] = xml_output; new_state["summary_output"] = summary_output

        if db_service and log_id is not None:
            try:
                logger.info(f"Updating DB log ID {log_id} with parsed XML and Summary.")
                db_service.update_gemini_log(log_id=log_id, response_xml=xml_output, response_summary=summary_output, error_message=new_state["error_message"])
            except Exception as db_err: logger.error(f"Failed to update Gemini log ID {log_id} with parsed results: {db_err}", exc_info=True)

        logger.info("--- Finished Process Response Node ---")
        return new_state

    except Exception as e:
        error_msg = f"Error processing response: {str(e)}"; logger.exception(error_msg)
        new_state["xml_output"] = gemini_response; new_state["summary_output"] = f"응답 처리 오류: {e}"
        new_state["error_message"] = (error_message + "\n" + error_msg) if error_message else error_msg
        if db_service and log_id is not None: db_service.update_gemini_log(log_id=log_id, error_message=new_state["error_message"])
        logger.info("--- Finished Process Response Node (with error) ---")
        return new_state


def build_gemini_graph(config_service: ConfigService) -> StateGraph:
    """LangGraph 빌드."""
    workflow = StateGraph(GeminiGraphState)
    bound_call_gemini = partial(call_gemini, config_service=config_service)
    bound_process_response = partial(process_response, config_service=config_service)
    workflow.add_node("call_gemini", bound_call_gemini)
    workflow.add_node("process_response", bound_process_response)
    workflow.add_edge(START, "call_gemini")
    workflow.add_edge("call_gemini", "process_response")
    workflow.add_edge("process_response", END)
    app = workflow.compile()
    logger.info("Gemini LangGraph compiled successfully.")
    return app



======== src\core\services\prompt_service.py ========

import os
from typing import List, Tuple, Dict, Any # Dict, Any 추가

class PromptService:
    def generate_code_enhancer_prompt(
        self,
        system_text: str,
        user_text: str,
        file_contents: List[Tuple[str, str]], # List of (path, content)
        root_dir: str,
        dir_structure_content: str = "",
        attached_items: List[Dict[str, Any]] = [] # 첨부 파일 목록 추가
    ) -> str:
        """
        Generates the final text prompt for the Code Enhancer mode.
        Includes markers for attached files/images.
        """
        final_prompt_parts = [
            "===SYSTEM===",
            system_text,
            "",
            "===USER===",
            user_text,
            "",
        ]

        # 첨부 파일/이미지 정보 추가 (마커 사용)
        if attached_items:
            final_prompt_parts.append("===ATTACHMENTS===")
            for i, item in enumerate(attached_items):
                item_type = item.get('type', 'unknown')
                item_name = item.get('name', f'attachment_{i+1}')
                if item_type == 'image':
                    final_prompt_parts.append(f"- Image: {item_name} (Data provided separately)")
                elif item_type == 'file':
                    # 파일 내용을 프롬프트에 포함할지 여부 결정 (여기서는 마커만 사용)
                    # file_data = item.get('data')
                    # content_preview = "(Content provided separately)"
                    # if file_data:
                    #     try:
                    #         # 간단한 텍스트 미리보기 (옵션)
                    #         preview = file_data[:100].decode('utf-8', errors='ignore') + ('...' if len(file_data) > 100 else '')
                    #         content_preview = f"(Content starts with: {preview})"
                    #     except: pass
                    final_prompt_parts.append(f"- File: {item_name} (Content provided separately)")
                else:
                    final_prompt_parts.append(f"- Unknown Attachment: {item_name}")
            final_prompt_parts.append("") # 구분선

        # 선택된 파일 내용 추가
        final_prompt_parts.append("===FILES CONTENTS===")
        if not root_dir:
             print("Warning: root_dir is not set for relative path calculation.")
             for path, content in file_contents:
                 final_prompt_parts.append(f"\n======== {path} ========\n{content}\n")
        else:
            for path, content in file_contents:
                try:
                    relative_path = os.path.relpath(path, root_dir)
                except ValueError:
                    relative_path = path
                final_prompt_parts.append(f"\n======== {relative_path} ========\n{content}\n")

        # 디렉토리 구조 추가
        if dir_structure_content and dir_structure_content.strip():
            final_prompt_parts.append("")
            final_prompt_parts.append(dir_structure_content)

        return "\n".join(final_prompt_parts)

    def generate_meta_prompt(
        self,
        meta_template: str,
        meta_user_input: str
    ) -> str:
        """Generates the prompt for the Meta Prompt Builder mode."""
        final_output = meta_template.replace("{{user-input}}", meta_user_input)
        return final_output

    def generate_final_meta_prompt(
        self,
        meta_prompt_content: str,
        user_prompt_content: str,
        variables: dict
    ) -> str:
        """Generates the final prompt by replacing variables in the meta prompt."""
        final_prompt = meta_prompt_content.replace("[[user-prompt]]", user_prompt_content)

        for k, v in variables.items():
            if k != "user-prompt":
                final_prompt = final_prompt.replace(f"[[{k}]]", v)

        return final_prompt



======== src\core\services\ssh_config_service.py ========
import logging
import os
import asyncio # asyncio 추가
from typing import List, Optional, Tuple
from pydantic import ValidationError

# AsyncSSH import
import asyncssh

from .db_service import DbService
from ..pydantic_models.ssh_connection_config import SshConnectionConfig

logger = logging.getLogger(__name__)

class SshConfigService:
    """
    Manages SSH connection configurations, including CRUD operations.
    Stores passwords as plain text.
    Uses AsyncSSH for connection testing.
    """

    def __init__(self, db_service: DbService):
        self.db_service = db_service

    def add_connection(self, config_data: dict) -> Optional[SshConnectionConfig]:
        """
        Adds a new SSH connection configuration after validation.

        Args:
            config_data: A dictionary containing the SSH connection details.
                         Password should be plain text.

        Returns:
            The created SshConnectionConfig object with ID, or None if failed.
        """
        try:
            config = SshConnectionConfig(**config_data)
            if config.auth_type == 'key':
                config.password = None
            connection_id = self.db_service.add_ssh_connection(config)
            if connection_id:
                config.id = connection_id
                logger.info(f"Successfully added SSH connection: {config.alias} (ID: {connection_id})")
                return config
            else:
                logger.error(f"Failed to add SSH connection '{config.alias}' to the database.")
                return None
        except ValidationError as e:
            logger.error(f"SSH connection configuration validation failed: {e}")
            return None
        except Exception as e:
            logger.exception(f"Unexpected error adding SSH connection: {e}")
            return None

    def get_connection(self, alias: str) -> Optional[SshConnectionConfig]:
        """Retrieves an SSH connection configuration by alias."""
        return self.db_service.get_ssh_connection(alias)

    def list_connections(self) -> List[SshConnectionConfig]:
        """Lists all saved SSH connection configurations."""
        return self.db_service.list_ssh_connections()

    def update_connection(self, connection_id: int, config_data: dict) -> Optional[SshConnectionConfig]:
        """
        Updates an existing SSH connection configuration.

        Args:
            connection_id: The ID of the connection to update.
            config_data: Dictionary with updated connection details.
                         Password should be plain text if provided.

        Returns:
            The updated SshConnectionConfig object, or None if failed.
        """
        try:
            existing_config = self.db_service.get_ssh_connection_by_id(connection_id)
            if not existing_config:
                logger.error(f"Cannot update SSH connection: ID {connection_id} not found.")
                return None
            config_data['id'] = connection_id
            config = SshConnectionConfig(**config_data)
            if config.auth_type == 'key':
                 config.password = None
            success = self.db_service.update_ssh_connection(connection_id, config)
            if success:
                logger.info(f"Successfully updated SSH connection: {config.alias} (ID: {connection_id})")
                return config
            else:
                logger.error(f"Failed to update SSH connection ID {connection_id} in the database.")
                return None
        except ValidationError as e:
            logger.error(f"SSH connection configuration validation failed during update: {e}")
            return None
        except Exception as e:
            logger.exception(f"Unexpected error updating SSH connection ID {connection_id}: {e}")
            return None

    def delete_connection(self, connection_id: int) -> bool:
        """Deletes an SSH connection configuration by its ID."""
        logger.info(f"Attempting to delete SSH connection with ID: {connection_id}")
        success = self.db_service.delete_ssh_connection(connection_id)
        if success:
            logger.info(f"Successfully deleted SSH connection ID {connection_id}.")
        else:
            logger.error(f"Failed to delete SSH connection ID {connection_id}.")
        return success

    def delete_connection_by_alias(self, alias: str) -> bool:
        """Deletes an SSH connection configuration by its alias."""
        logger.info(f"Attempting to delete SSH connection with alias: {alias}")
        success = self.db_service.delete_ssh_connection_by_alias(alias)
        if success:
            logger.info(f"Successfully deleted SSH connection with alias '{alias}'.")
        else:
            logger.error(f"Failed to delete SSH connection with alias '{alias}'.")
        return success

    async def test_connection(self, alias: str) -> Tuple[bool, str]:
        """
        Tests the SSH connection for the given alias asynchronously using AsyncSSH.
        """
        logger.info(f"Attempting to test SSH connection for alias: {alias} using AsyncSSH...")
        config = self.get_connection(alias)
        if not config:
            return False, f"Configuration for alias '{alias}' not found."

        connect_options = {
            "host": config.host,
            "port": config.port,
            "username": config.username,
            "known_hosts": None # Disable known_hosts checking for test connection
        }

        try:
            if config.auth_type == 'password':
                if not config.password:
                    return False, "Password authentication selected, but password is not set."
                connect_options["password"] = config.password
            elif config.auth_type == 'key':
                if not config.key_path:
                    return False, "Key authentication selected, but key path is not set."
                key_filepath = os.path.expanduser(config.key_path)
                if not os.path.exists(key_filepath):
                    return False, f"Private key file not found: {key_filepath}"
                # AsyncSSH handles key loading internally via client_keys
                connect_options["client_keys"] = [key_filepath]
                # TODO: Add passphrase support if needed via connect_options["passphrase"]
            else:
                return False, f"Invalid authentication type: {config.auth_type}"

            logger.debug(f"Attempting asyncssh.connect with options: { {k: v for k, v in connect_options.items() if k != 'password'} }") # Log options excluding password
            async with asyncssh.connect(**connect_options) as conn:
                # Connection successful if no exception is raised
                logger.info(f"AsyncSSH connection test successful for alias: {alias}")
                # Optionally run a simple command
                # result = await conn.run('echo hello', check=True)
                # logger.debug(f"Test command result: {result.stdout.strip()}")
                return True, "Connection successful!"

        except asyncssh.PermissionDenied as e:
            logger.warning(f"AsyncSSH Authentication failed for alias {alias}: {e}")
            return False, f"Authentication failed: {e}"
        except asyncssh.ConnectionLost as e:
            logger.error(f"AsyncSSH connection lost for alias {alias}: {e}")
            return False, f"Connection lost: {e}"
        except asyncssh.NoMatchingHostKey as e:
             logger.error(f"AsyncSSH host key validation failed for alias {alias}: {e} (Note: validation disabled for test)")
             # Should not happen with known_hosts=None, but handle defensively
             return False, f"Host key error (should be disabled): {e}"
        except ConnectionRefusedError:
            logger.error(f"AsyncSSH connection refused for alias {alias} (host:{config.host}, port:{config.port})")
            return False, "Connection refused by server."
        except OSError as e: # Catches socket errors like timeout, host not found
             logger.error(f"AsyncSSH OS error during connection for alias {alias}: {e}")
             return False, f"Connection OS error: {e}"
        except FileNotFoundError as e: # Already checked, but catch again
             logger.error(f"AsyncSSH key file not found error for alias {alias}: {e}")
             return False, str(e)
        except Exception as e:
            logger.exception(f"Unexpected error testing AsyncSSH connection {alias}: {e}")
            return False, f"Unexpected error: {e}"



======== src\core\services\state_service.py ========
import os
import json
import shutil
from datetime import datetime
from typing import Optional, List
from pydantic import ValidationError

# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로) -> 다시 절대경로로 수정
from ..pydantic_models.app_state import AppState
# from ..utils.helpers import get_resource_path # 리소스 경로 함수 사용 (상대경로 -> 절대경로)
from src.utils.helpers import get_resource_path # 리소스 경로 함수 사용

# 상태 파일 저장 디렉토리 (resources/status)
STATUS_DIR = get_resource_path("status")

class StateService:
    def __init__(self, status_dir: str = STATUS_DIR):
        self.status_dir = status_dir
        os.makedirs(self.status_dir, exist_ok=True)

    def _get_state_file_path(self, filename: str) -> str:
        """Constructs the full path for a state file."""
        # 파일 이름에 .json 확장자가 없으면 추가
        if not filename.lower().endswith(".json"):
            filename += ".json"
        return os.path.join(self.status_dir, filename)

    def save_state(self, state: AppState, filename: str) -> bool:
        """Saves the application state (Pydantic model) to a JSON file."""
        file_path = self._get_state_file_path(filename)
        try:
            # Pydantic 모델을 JSON 문자열로 직렬화 (indent 적용)
            state_json = state.model_dump_json(indent=4)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State saved successfully to {file_path}")
            return True
        except ValidationError as e:
            print(f"State validation error before saving: {e}")
            return False
        except Exception as e:
            print(f"Error saving state to {file_path}: {str(e)}")
            return False

    def load_state(self, filename: str) -> Optional[AppState]:
        """Loads application state from a JSON file into a Pydantic model."""
        file_path = self._get_state_file_path(filename)
        if not os.path.exists(file_path):
            print(f"State file not found: {file_path}. Returning default state.")
            return AppState() # 파일 없으면 기본 상태 반환

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            # JSON 데이터를 Pydantic 모델로 파싱 및 유효성 검사
            state = AppState.model_validate(state_data)
            print(f"State loaded successfully from {file_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from {file_path}: {e}. Returning default state.")
            return AppState()
        except ValidationError as e:
            print(f"State validation error loading from {file_path}: {e}. Returning default state.")
            # 유효성 검사 실패 시 기본값 반환 또는 더 엄격한 처리 가능
            return AppState()
        except Exception as e:
            print(f"Error loading state from {file_path}: {str(e)}. Returning default state.")
            return AppState()

    def import_state_from_file(self, import_path: str) -> Optional[AppState]:
        """Imports state from an external JSON file."""
        if not os.path.exists(import_path):
            print(f"Import file not found: {import_path}")
            return None # 가져올 파일 없으면 None 반환

        try:
            with open(import_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            state = AppState.model_validate(state_data)
            print(f"State imported successfully from {import_path}")
            return state
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON from import file {import_path}: {e}")
            return None
        except ValidationError as e:
            print(f"Imported state validation error: {e}")
            return None
        except Exception as e:
            print(f"Error importing state from {import_path}: {str(e)}")
            return None

    def export_state_to_file(self, state: AppState, export_path: str) -> bool:
        """Exports the current state to an external JSON file."""
        try:
            dir_path = os.path.dirname(export_path)
            if dir_path:
                os.makedirs(dir_path, exist_ok=True)
            state_json = state.model_dump_json(indent=4)
            with open(export_path, 'w', encoding='utf-8') as f:
                f.write(state_json)
            print(f"State exported successfully to {export_path}")
            return True
        except ValidationError as e:
             print(f"State validation error before exporting: {e}")
             return False
        except Exception as e:
            print(f"Error exporting state to {export_path}: {str(e)}")
            return False

    def list_states(self) -> List[str]:
        """Lists available state files (JSON) in the status directory."""
        if not os.path.exists(self.status_dir):
            return []
        try:
            files = os.listdir(self.status_dir)
            # .json 파일만 필터링
            return [f for f in files if f.lower().endswith(".json")]
        except Exception as e:
            print(f"Error listing states in {self.status_dir}: {e}")
            return []

    def delete_state(self, filename: str) -> bool:
        """Deletes a specific state file."""
        file_path = self._get_state_file_path(filename)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                print(f"Deleted state file: {file_path}")
                return True
            except Exception as e:
                print(f"Error deleting state file {file_path}: {e}")
                return False
        else:
            print(f"State file not found for deletion: {file_path}")
            return False

    def backup_all_states(self, backup_path: str) -> bool:
        """Backs up all state files into a zip archive."""
        if not os.path.isdir(self.status_dir):
            print("Status directory does not exist. Nothing to backup.")
            return False

        # Ensure backup path ends with .zip
        if not backup_path.lower().endswith(".zip"):
            backup_path += ".zip"

        base_dir = os.path.dirname(backup_path)
        if base_dir:
            os.makedirs(base_dir, exist_ok=True)

        # shutil.make_archive needs the archive name without extension
        archive_name = backup_path[:-4]

        try:
            shutil.make_archive(archive_name, 'zip', self.status_dir)
            print(f"All states successfully backed up to {backup_path}")
            return True
        except Exception as e:
            print(f"Error backing up states to {backup_path}: {str(e)}")
            return False

    def restore_states_from_backup(self, backup_path: str) -> bool:
        """Restores states from a zip archive, overwriting existing ones."""
        if not os.path.exists(backup_path):
            print(f"Backup file not found: {backup_path}")
            return False

        try:
            # Remove existing status directory before restoring if it exists
            if os.path.exists(self.status_dir):
                shutil.rmtree(self.status_dir)
            os.makedirs(self.status_dir, exist_ok=True) # Ensure directory exists

            # Unpack the archive into the status directory
            shutil.unpack_archive(backup_path, self.status_dir, 'zip')
            print(f"States successfully restored from {backup_path} to {self.status_dir}")
            return True
        except Exception as e:
            print(f"Error restoring states from {backup_path}: {str(e)}")
            return False



======== src\core\services\template_service.py ========
import os
from typing import List

# 내부 모듈 import 경로 수정 (상대경로 -> 절대경로)
# from ..utils.helpers import get_resource_path
from src.utils.helpers import get_resource_path

class TemplateService:
    def __init__(self, base_resource_path: str = "resources"):
        pass

    def _get_full_path(self, relative_path: str) -> str:
        """Constructs the full path using get_resource_path."""
        # 예: relative_path = "prompts/system/my_template.md"
        return get_resource_path(relative_path)

    def list_templates(self, directory: str) -> List[str]:
        """Lists Markdown templates in a given directory relative to resources."""
        # directory 예: "prompts/system"
        full_dir_path = self._get_full_path(directory)
        if not os.path.exists(full_dir_path) or not os.path.isdir(full_dir_path):
            print(f"Template directory not found: {full_dir_path}")
            return []
        try:
            files = os.listdir(full_dir_path)
            # .md 파일만 필터링
            return [f for f in files if f.lower().endswith(".md")]
        except Exception as e:
            print(f"Error listing templates in {full_dir_path}: {e}")
            return []

    def load_template(self, file_path: str) -> str:
        """Loads content from a template file relative to resources."""
        # file_path 예: "prompts/user/example.md"
        full_file_path = self._get_full_path(file_path)
        if not os.path.exists(full_file_path):
            print(f"Template file not found: {full_file_path}")
            return "" # 파일 없으면 빈 문자열 반환
        try:
            with open(full_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            print(f"Template loaded successfully from {full_file_path}")
            return content
        except Exception as e:
            print(f"Error loading template {full_file_path}: {str(e)}")
            return "" # 오류 시 빈 문자열 반환

    def save_template(self, file_path: str, content: str) -> bool:
        """Saves content to a template file relative to resources."""
        # file_path 예: "prompts/system/new_template.md"
        full_file_path = self._get_full_path(file_path)
        try:
            # 디렉토리 생성 (필요한 경우)
            os.makedirs(os.path.dirname(full_file_path), exist_ok=True)
            with open(full_file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"Template saved successfully to {full_file_path}")
            return True
        except Exception as e:
            print(f"Error saving template to {full_file_path}: {str(e)}")
            return False

    def delete_template(self, file_path: str) -> bool:
        """Deletes a template file relative to resources."""
        # file_path 예: "prompts/system/old_template.md"
        full_file_path = self._get_full_path(file_path)
        if os.path.exists(full_file_path):
            try:
                os.remove(full_file_path)
                print(f"Deleted template file: {full_file_path}")
                return True
            except Exception as e:
                print(f"Error deleting template file {full_file_path}: {e}")
                return False
        else:
            print(f"Template file not found for deletion: {full_file_path}")
            return False



======== src\core\services\token_service.py ========
import os
import threading
from typing import Optional, Dict, Any, List, Union
import tiktoken
import mimetypes
import base64
import logging

# --- Optional Imports for API Calls ---
try:
    import google.generativeai as genai
    from google.generativeai.types import ContentDict, PartDict
    from google.api_core import exceptions as google_api_exceptions
    _GOOGLE_GENAI_AVAILABLE = True
except ImportError:
    _GOOGLE_GENAI_AVAILABLE = False
    print("Warning: google-generativeai not installed. Gemini token calculation via API disabled.")

try:
    import anthropic
    _ANTHROPIC_AVAILABLE = True
except ImportError:
    _ANTHROPIC_AVAILABLE = False
    print("Warning: anthropic not installed. Claude token calculation via API disabled.")

# --- Service Dependencies ---
from typing import TYPE_CHECKING
# 내부 모듈 import 경로 수정 (절대경로 -> 상대경로)
if TYPE_CHECKING:
    from .config_service import ConfigService
    from ..pydantic_models.config_settings import ConfigSettings

# --- Tiktoken Encoding Cache ---
_enc_cache: Dict[str, tiktoken.Encoding] = {}
_enc_lock = threading.Lock()

# 로거 설정
logger = logging.getLogger(__name__)


def _get_encoding(encoding_name: str = "o200k_base") -> Optional[tiktoken.Encoding]:
    """Gets or loads a tiktoken encoding."""
    with _enc_lock:
        if encoding_name not in _enc_cache:
            try:
                print(f"Loading tiktoken encoding: {encoding_name}...")
                _enc_cache[encoding_name] = tiktoken.get_encoding(encoding_name)
                print(f"Tiktoken encoding '{encoding_name}' loaded.")
            except Exception as e:
                print(f"Error loading tiktoken encoding '{encoding_name}': {e}")
                _enc_cache[encoding_name] = None
        return _enc_cache[encoding_name]

# --- Token Calculation Service ---
class TokenCalculationService:
    """Handles token calculation for different LLM providers."""

    def __init__(self, config_service: 'ConfigService'):
        """Initializes the service."""
        self.config_service = config_service
        # Settings are now fetched when needed via config_service.get_settings()
        self.anthropic_client: Optional[anthropic.Anthropic] = None
        self.gemini_configured = False
        self._init_clients() # Combined initialization

    def _get_settings(self) -> 'ConfigSettings':
        """Helper to get current settings."""
        return self.config_service.get_settings()

    def _init_clients(self):
        """Initializes API clients based on keys found in config settings."""
        settings = self._get_settings()

        # Initialize Gemini
        if _GOOGLE_GENAI_AVAILABLE:
            api_key = settings.gemini_api_key
            if api_key:
                try:
                    genai.configure(api_key=api_key)
                    print("Google Generative AI SDK configured using API key from DB.")
                    self.gemini_configured = True
                except Exception as e:
                    print(f"Error configuring Google Generative AI SDK: {e}")
                    self.gemini_configured = False
            else:
                print("Warning: Gemini API key not found in DB config. Gemini token calculation might fail.")
                self.gemini_configured = False
        else:
             self.gemini_configured = False

        # Initialize Anthropic
        if _ANTHROPIC_AVAILABLE:
            api_key = settings.anthropic_api_key
            if api_key:
                try:
                    self.anthropic_client = anthropic.Anthropic(api_key=api_key)
                    print("Anthropic client initialized using API key from DB.")
                except Exception as e:
                    self.anthropic_client = None
                    print(f"Error initializing Anthropic client: {e}")
            else:
                self.anthropic_client = None
                print("Warning: Anthropic API key not found in DB config. Claude token calculation via API disabled.")
        else:
            self.anthropic_client = None


    def calculate_tokens(
        self,
        model_type: str,
        model_name: str,
        text: str,
        attachments: Optional[List[Dict[str, Any]]] = None
    ) -> Optional[int]:
        """
        Calculates the number of tokens for the given text and attachments
        based on the model type and name.

        Args:
            model_type: "GPT", "Claude", or "Gemini".
            model_name: The specific model identifier.
            text: The input text to tokenize.
            attachments: List of attached items (dicts with 'type', 'name', 'data'/'path').

        Returns:
            The calculated token count, or None if calculation fails.
        """
        print(f"Calculating tokens for Model Type: {model_type}, Model Name: {model_name}")
        attachments = attachments or []

        # Re-initialize clients in case API keys changed in DB (though config is loaded once now)
        # self._init_clients() # Might be redundant if config is loaded once

        if model_type == "GPT":
            if attachments:
                print("Warning: GPT token calculation currently only supports text. Attachments ignored.")
            return self._calculate_gpt_tokens(text)
        elif model_type == "Claude":
            if attachments:
                 print("Warning: Claude token calculation currently only supports text. Attachments ignored.")
            return self._calculate_claude_tokens(model_name, text)
        elif model_type == "Gemini":
            return self._calculate_gemini_tokens(model_name, text, attachments)
        else:
            print(f"Error: Unknown model type '{model_type}'")
            return None

    def _calculate_gpt_tokens(self, text: str) -> Optional[int]:
        """Calculates tokens using tiktoken (assuming o200k_base for newer models)."""
        enc = _get_encoding("o200k_base")
        if enc is None:
            print("Token calculation failed: Tiktoken encoding not available.")
            return None
        try:
            if not text: return 0
            return len(enc.encode(text))
        except Exception as e:
            print(f"Error calculating GPT tokens with tiktoken: {str(e)}")
            return None

    def _calculate_claude_tokens(self, model_name: str, text: str) -> Optional[int]:
        """Calculates tokens using the Anthropic API (currently text only)."""
        if not _ANTHROPIC_AVAILABLE or self.anthropic_client is None:
            print("Claude token calculation skipped: Anthropic SDK not available or API key missing/invalid.")
            return None
        if not model_name:
            print("Claude token calculation skipped: Model name is required.")
            return None
        if not text: return 0

        try:
            messages = [{"role": "user", "content": text}]
            count_response = self.anthropic_client.messages.count_tokens(
                model=model_name,
                messages=messages
            )
            token_count = count_response.input_tokens
            print(f"Claude API token count (text only): {token_count}")
            return token_count
        except anthropic.APIConnectionError as e:
             print(f"Claude API connection error during token count: {e}")
             return None
        except anthropic.AuthenticationError as e:
             print(f"Claude API authentication error (check API key): {e}")
             return None
        except anthropic.RateLimitError as e:
             print(f"Claude API rate limit exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Claude tokens via API: {str(e)}")
            return None

    def _calculate_gemini_tokens(
        self,
        model_name: str,
        text: str,
        attachments: List[Dict[str, Any]]
    ) -> Optional[int]:
        """Calculates tokens using the google-generativeai SDK (multimodal)."""
        if not _GOOGLE_GENAI_AVAILABLE:
            print("Gemini token calculation skipped: google-generativeai SDK not available.")
            return None
        if not self.gemini_configured:
             print("Gemini token calculation skipped: Gemini API key not configured or invalid.")
             return None
        if not model_name:
            print("Gemini token calculation skipped: Model name is required.")
            return None

        contents_list: List[Union[str, Dict[str, Any]]] = []
        effective_model_name = ""
        try:
            if text:
                contents_list.append(text)

            if attachments:
                for attachment in attachments:
                    item_type = attachment.get('type')
                    item_name = attachment.get('name', 'unknown')
                    item_data = attachment.get('data')
                    item_path = attachment.get('path')

                    if not item_data and item_path and os.path.exists(item_path):
                        try:
                            with open(item_path, 'rb') as f: item_data = f.read()
                        except Exception as e:
                            logger.error(f"Token Calc: Failed to read attachment {item_path}: {e}")
                            continue
                    if not item_data: continue

                    mime_type = None
                    if item_type == 'image':
                        if item_name.lower().endswith('.png'): mime_type = 'image/png'
                        elif item_name.lower().endswith(('.jpg', '.jpeg')): mime_type = 'image/jpeg'
                        elif item_name.lower().endswith('.webp'): mime_type = 'image/webp'
                        else: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})
                    elif item_type == 'file':
                        mime_type, _ = mimetypes.guess_type(item_name)
                        if not mime_type: mime_type = 'application/octet-stream'
                        contents_list.append({"mime_type": mime_type, "data": item_data})

            if not contents_list:
                print("Token calculation skipped: No content (text or attachments) provided.")
                return 0

            effective_model_name = model_name.replace("models/", "")
            print(f"Instantiating genai.GenerativeModel for token count: {effective_model_name}")
            model = genai.GenerativeModel(effective_model_name)

            print(f"Calling model.count_tokens for model: {effective_model_name} with {len(contents_list)} content parts")
            response = model.count_tokens(contents=contents_list)

            token_count = response.total_tokens
            print(f"Gemini API token count (multimodal): {token_count}")
            return token_count

        except AttributeError as e:
             log_message = (
                 f"AttributeError during Gemini token calculation: {e}. "
                 f"Check SDK version and content structure."
             )
             logger.error(log_message, exc_info=True)
             print(f"Gemini token calculation failed due to AttributeError: {e}")
             return None
        except google_api_exceptions.PermissionDenied as e:
             print(f"Gemini API permission error during token count (check API key): {e}")
             # Invalidate configuration if key is bad?
             # self.gemini_configured = False
             return None
        except google_api_exceptions.InvalidArgument as e:
             print(f"Gemini API invalid argument error during token count: {e}")
             print(f"Hint: Check if model '{effective_model_name}' supports multimodal count_tokens or the provided content types/structure.")
             return None
        except google_api_exceptions.ResourceExhausted as e:
             print(f"Gemini API rate limit likely exceeded during token count: {e}")
             return None
        except Exception as e:
            print(f"Error calculating Gemini tokens via API: {str(e)}")
            logger.error(f"Unexpected error calculating Gemini tokens: {e}", exc_info=True)
            return None

# Preload default encoding on module import
_get_encoding()



======== src\core\services\xml_service.py ========
import os
import xml.etree.ElementTree as ET
from typing import Dict, List
import logging # 로깅 추가

logger = logging.getLogger(__name__) # 로거 설정

class XmlService:
    def apply_changes_from_xml(self, xml_string: str, project_directory: str) -> Dict[str, List[str]]:
        """
        Parses XML string and applies file changes (CREATE, UPDATE, DELETE)
        within the specified project directory.
        Handles removing surrounding Markdown code block markers if present.
        Removes leading whitespace/newlines from file content before writing.
        Handles trailing Markdown code block markers (like ```)

        Returns a dictionary summarizing the results:
        {
            "created": [list of created file paths],
            "updated": [list of updated file paths],
            "deleted": [list of deleted file paths],
            "errors": [list of error messages]
        }
        """
        result = {
            "created": [],
            "updated": [],
            "deleted": [],
            "errors": []
        }

        if not project_directory or not os.path.isdir(project_directory):
            result["errors"].append(f"Invalid project directory: {project_directory}")
            return result

        if not xml_string or not xml_string.strip():
            result["errors"].append("XML input string is empty.")
            return result

        # --- Add logic to strip Markdown code block markers ---
        cleaned_xml_string = xml_string.strip()
        # 다양한 마커 형태 고려 (예: ```xml, ```, ````xml, ```` 등)
        markdown_markers = ["```xml", "```", "````xml", "````", '"""', "'''"] # 종료 마커 추가

        # 시작 마커 제거
        for marker in markdown_markers:
            if cleaned_xml_string.startswith(marker):
                # 마커 길이만큼 제거하고, 이후 공백/줄바꿈 제거
                cleaned_xml_string = cleaned_xml_string[len(marker):].lstrip()
                logger.debug(f"Removed starting marker: {marker}")
                break # 하나의 시작 마커만 처리

        # 끝 마커 제거 (수정: 여러 종류의 종료 마커 제거)
        temp_string = cleaned_xml_string.rstrip() # 끝 마커 확인 전 후행 공백/줄바꿈 제거
        marker_removed = False
        for marker in markdown_markers:
            if temp_string.endswith(marker):
                # 마커 길이만큼 제거하고, 이전 공백/줄바꿈 제거
                cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                logger.debug(f"Removed ending marker: {marker}")
                marker_removed = True
                break # 하나의 끝 마커만 처리
        # 만약 마커 제거 후에도 마커가 남아있을 수 있는 경우(예: """\n```) 추가 처리
        if marker_removed:
            temp_string = cleaned_xml_string.rstrip()
            for marker in markdown_markers:
                 if temp_string.endswith(marker):
                      cleaned_xml_string = temp_string[:-len(marker)].rstrip()
                      logger.debug(f"Removed secondary ending marker: {marker}")
                      break

        if not cleaned_xml_string:
             result["errors"].append("XML input string became empty after removing potential Markdown markers.")
             logger.warning("XML input is empty after cleaning.")
             return result
        # --- End of Markdown marker stripping logic ---

        try:
            # XML 파싱 (정리된 문자열 사용)
            logger.info("Attempting to parse cleaned XML string...")
            root = ET.fromstring(cleaned_xml_string)
            logger.info(f"XML parsed successfully. Root element: <{root.tag}>")
        except ET.ParseError as e:
            error_msg = f"Invalid XML format after cleaning: {str(e)}"
            result["errors"].append(error_msg)
            # 파싱 실패 시 문제 문자열 일부 로깅
            context_length = 100 # 오류 주변 문자열 길이
            error_line = getattr(e, 'lineno', '?')
            error_pos = getattr(e, 'offset', '?') # position 속성이 없을 수 있음 (offset 사용)
            start = max(0, e.position[1] - context_length//2) if hasattr(e, 'position') else 0
            end = start + context_length
            problematic_xml_snippet = cleaned_xml_string[start:end]
            logger.error(f"XML ParseError: {e}, Line: {error_line}, Pos: {error_pos}. Problematic snippet near error: ...{problematic_xml_snippet}...")
            return result
        except Exception as e:
             # Catch other potential errors during fromstring
             error_msg = f"Error parsing XML string: {str(e)}"
             result["errors"].append(error_msg)
             logger.exception(f"Unexpected error during XML parsing: {e}") # 스택 트레이스 로깅
             return result


        changed_files_node = root.find('changed_files')
        if changed_files_node is None:
            # If <changed_files> is missing but parsing was successful, it might be an empty XML response.
            # Treat as no changes rather than an error, unless it's entirely empty or unexpected structure.
            # Let's check if the root tag itself is also unexpected.
            if root.tag not in ['code_changes', 'root', 'response']: # Add common root tags
                 result["errors"].append(f"No <changed_files> node found and unexpected root tag '{root.tag}' in XML.")
                 logger.warning(f"XML parsing successful but no <changed_files> node found and unexpected root tag: {root.tag}")
            else:
                 # Successful parse, but no changed_files node. Assume no changes.
                 logger.info("XML parsed successfully but no <changed_files> node found. Assuming no changes.") # 로깅 사용
            return result # Return with errors if any added, or empty result

        for file_node in changed_files_node.findall('file'):
            file_op_node = file_node.find('file_operation')
            file_path_node = file_node.find('file_path')
            file_code_node = file_node.find('file_code') # CDATA 내용 포함

            if file_op_node is None or file_path_node is None:
                result["errors"].append("Skipping file entry: missing file_operation or file_path.")
                logger.warning("Skipping file entry in XML: missing file_operation or file_path.")
                continue

            operation = file_op_node.text.strip().upper() if file_op_node.text else "UNKNOWN"
            relative_path = file_path_node.text.strip() if file_path_node.text else None

            if not relative_path:
                result["errors"].append(f"Skipping file entry: file_path is empty for operation {operation}.")
                logger.warning(f"Skipping file entry in XML: file_path is empty for operation {operation}.")
                continue

            # 보안: 경로 조작 방지 (상대 경로가 프로젝트 디렉토리를 벗어나지 않도록 확인)
            # 정규화된 경로 사용
            try:
                 target_path = os.path.abspath(os.path.join(project_directory, relative_path.lstrip('/\\')))
                 if not target_path.startswith(os.path.abspath(project_directory)):
                    result["errors"].append(f"Skipping potentially unsafe path: {relative_path}")
                    logger.error(f"Security risk: Attempted path traversal detected! Path: '{relative_path}', Target: '{target_path}', Project Root: '{os.path.abspath(project_directory)}'")
                    continue
            except Exception as path_e:
                 result["errors"].append(f"Error processing path '{relative_path}': {path_e}")
                 logger.error(f"Error processing path '{relative_path}': {path_e}", exc_info=True)
                 continue

            # Ensure path separator consistency if needed, but os.path.join handles this locally.
            # For comparison against input, maybe normalize relative_path too? Not critical for security check here.

            file_code = file_code_node.text if file_code_node is not None and file_code_node.text is not None else None

            try:
                if operation in ["CREATE", "UPDATE"]:
                    # Allow empty file_code for creating/updating empty files
                    # if file_code is None: # Changed: Allow None/empty string for file_code
                    #     result["errors"].append(f"Skipping {operation} for '{relative_path}': file_code is missing.")
                    #     continue

                    # Ensure directory exists
                    os.makedirs(os.path.dirname(target_path), exist_ok=True)

                    # Write file, handle None/empty file_code as empty content
                    # *** 수정: 파일 내용 앞쪽 공백/개행 제거 ***
                    with open(target_path, 'w', encoding='utf-8') as f:
                        # file_code가 None이 아니고, 문자열일 경우 앞쪽 공백/개행 제거
                        content_to_write = file_code.lstrip() if file_code is not None and isinstance(file_code, str) else ""
                        f.write(content_to_write)
                        logger.debug(f"Writing content (leading whitespace stripped) to: {target_path}") # 로깅 추가

                    if operation == "CREATE":
                        result["created"].append(target_path)
                        logger.info(f"File CREATED: {target_path}") # 로깅 사용
                    else: # UPDATE
                        result["updated"].append(target_path)
                        logger.info(f"File UPDATED: {target_path}") # 로깅 사용

                elif operation == "DELETE":
                    if os.path.exists(target_path):
                        if os.path.isfile(target_path):
                            os.remove(target_path)
                            result["deleted"].append(target_path)
                            logger.info(f"File DELETED: {target_path}") # 로깅 사용
                        elif os.path.isdir(target_path):
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is a directory, not a file.")
                             logger.warning(f"Skipping DELETE for directory: {target_path}")
                        else:
                             result["errors"].append(f"Skipping DELETE for '{relative_path}': It is not a regular file.")
                             logger.warning(f"Skipping DELETE for non-file item: {target_path}")
                    else:
                        # 삭제할 파일이 없는 경우, 오류보다는 경고 또는 무시가 나을 수 있음
                        logger.warning(f"File not found for deletion (ignored): {target_path}") # 로깅 사용

                elif operation == "NONE":
                    # 수정 없음 처리 (로그 또는 아무 작업 안 함)
                    logger.debug(f"Operation NONE for: {target_path}") # Log level DEBUG
                    pass

                else:
                    result["errors"].append(f"Unknown file operation '{operation}' for file: {relative_path}")
                    logger.warning(f"Unknown file operation '{operation}' found in XML for path: {relative_path}")

            except OSError as e:
                 result["errors"].append(f"OS error during {operation} for '{relative_path}': {e}")
                 logger.error(f"OS error during {operation} for '{relative_path}': {e}", exc_info=True) # 로깅 추가
            except Exception as e:
                result["errors"].append(f"Unexpected error during {operation} for '{relative_path}': {str(e)}")
                logger.exception(f"Unexpected error during {operation} for '{relative_path}'") # 로깅 추가

        return result



======== src\core\utils\__init__.py ========
# This file makes Python treat the directory utils as a package within core.
# It's usually kept empty or contains specific sub-package imports if needed.

# Removed crypto imports as the module is deleted
# from .crypto import encrypt_password, decrypt_password, generate_key



======== src\core\__init__.py ========
# This file makes Python treat the directory core as a package.



======== src\core\langgraph_state.py ========

from typing import TypedDict, Optional, List, Dict, Any # List, Dict, Any 추가

class GeminiGraphState(TypedDict):
    """
    LangGraph 상태 정의: Gemini API 호출 및 결과 처리를 위한 상태 관리
    """
    input_prompt: str             # Gemini API에 전달될 최종 텍스트 프롬프트
    input_attachments: List[Dict[str, Any]] # 첨부된 파일/이미지 데이터 목록 (멀티모달용)
    selected_model_name: str      # LangGraph 실행 시 선택된 모델명 (추가)
    gemini_response: str          # Gemini API의 원시 응답
    xml_output: str               # 파싱된 XML 부분
    summary_output: str           # 파싱된 Summary 부분
    error_message: Optional[str] = None # 오류 발생 시 메시지 저장 (선택적)
    log_id: Optional[int] = None  # DB 로그 ID 저장 (추가)




======== src\ui\controllers\__init__.py ========
# This file makes Python treat the directory controllers as a package.



======== src\ui\controllers\file_tree_controller.py ========
import os
import shutil
from typing import Optional, List, Set
from PyQt6.QtCore import Qt, QModelIndex, QItemSelection # PyQt5 -> PyQt6
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox # PyQt5 -> PyQt6
import logging # 로깅 추가
import asyncssh # asyncssh import
import asyncio # asyncio 추가

# 서비스 및 모델 import
from src.core.services.filesystem_service import FilesystemService # src 절대 경로 사용
from src.core.services.config_service import ConfigService # src 절대 경로 사용
from src.ui.models.remote_file_system_model import RemoteFileSystemModel # 원격 모델 import (src 절대 경로 사용)

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from src.ui.main_window import MainWindow # src 절대 경로 사용

logger = logging.getLogger(__name__) # 로거 설정

class FileTreeController:
    """
    Handles logic related to the file tree view, including interactions,
    filesystem operations, and gitignore handling.
    Manages switching between local and remote file system models.
    """
    def __init__(self, main_window: 'MainWindow', fs_service: FilesystemService, config_service: ConfigService):
        self.mw = main_window
        self.fs_service = fs_service
        self.config_service = config_service
        self.gitignore_path: Optional[str] = None # .gitignore 파일 경로 저장
        self.local_root_path: Optional[str] = None # SSH 연결 전 로컬 루트 경로 저장
        self.remote_model: Optional[RemoteFileSystemModel] = None # 원격 모델 인스턴스 저장

    def select_project_folder(self):
        """Opens a dialog to select the project folder and updates the UI."""
        # SSH 연결 중이면 로컬 폴더 선택 비활성화
        if self.mw.ssh_client:
             QMessageBox.information(self.mw, "정보", "SSH 연결 중에는 로컬 프로젝트 폴더를 선택할 수 없습니다.")
             return
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 프로젝트 폴더 선택이 필요 없습니다.")
            return

        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        folder = QFileDialog.getExistingDirectory(self.mw, "프로젝트 폴더 선택", start_dir)

        if folder:
            # 폴더 선택 시 상태 초기화 (UI 및 내부 변수)
            self.mw.reset_state() # MainWindow 상태 초기화 (트리 리셋 포함)
            self.mw.current_project_folder = folder
            folder_name = os.path.basename(folder)
            self.mw.project_folder_label.setText(f"현재 프로젝트 폴더: {folder}")

            self.load_gitignore_settings() # gitignore 로드 및 필터 설정

            # 모델에 루트 경로 설정 및 트리뷰 업데이트 (로컬 모델 사용)
            if hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
                # 로컬 모델로 설정되어 있는지 확인
                if self.mw.tree_view.model() != self.mw.checkable_proxy:
                    self.mw.tree_view.setModel(self.mw.checkable_proxy)
                    logger.info("Switched tree view model to CheckableProxyModel (local).")

                idx = self.mw.dir_model.setRootPathFiltered(folder)
                root_proxy_index = self.mw.checkable_proxy.mapFromSource(idx)
                self.mw.tree_view.setRootIndex(root_proxy_index) # 유효한 루트 인덱스 설정
                self.mw.status_bar.showMessage(f"Project Folder: {folder}")

                # 루트 폴더 자동 체크 (선택적)
                if root_proxy_index.isValid():
                    # Check the root folder by default
                    self.mw.checkable_proxy.setData(root_proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole) # Qt.Checked -> Qt.CheckState.Checked, Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole

            self.mw.update_window_title(folder_name)
            # 프로젝트 폴더 변경 시 상태 변경 시그널 발생
            self.mw.state_changed_signal.emit()

    def load_gitignore_settings(self):
        """Loads .gitignore patterns and updates the filter model."""
        self.gitignore_path = None
        patterns: Set[str] = set()

        settings = self.config_service.get_settings()
        patterns.update(settings.default_ignore_list)

        if self.mw.current_project_folder:
            possible_path = os.path.join(self.mw.current_project_folder, ".gitignore")
            if os.path.isfile(possible_path):
                self.gitignore_path = possible_path
                try:
                    with open(self.gitignore_path, 'r', encoding='utf-8') as f:
                        lines = f.read().splitlines()
                    gitignore_lines = [ln.strip() for ln in lines if ln.strip() and not ln.strip().startswith('#')]
                    patterns.update(gitignore_lines)
                except Exception as e:
                    QMessageBox.warning(self.mw, "Error", f".gitignore 로드 중 오류: {str(e)}")

        # config.yml의 excluded_dirs 추가
        patterns.update(settings.excluded_dirs)

        # 필터 모델에 패턴 설정 (로컬 모델에만 적용)
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(patterns)
             # 필터가 변경되었으므로 트리 뷰를 새로 고쳐야 할 수 있음 (로컬 모드일 때만)
             if not self.mw.ssh_client:
                 self.refresh_tree() # 필터 적용 후 트리 새로고침

    def save_gitignore_settings(self):
        """Saves the content of the gitignore editor to the .gitignore file. (Moved to SettingsDialog)"""
        QMessageBox.information(self.mw, "정보", ".gitignore 저장은 환경 설정 메뉴에서 수행해주세요.")

    def reset_gitignore_and_filter(self):
        """Resets gitignore filter to defaults based on config.yml."""
        default_settings = self.config_service.get_settings()
        default_patterns = set(default_settings.default_ignore_list).union(default_settings.excluded_dirs)
        if hasattr(self.mw, 'checkable_proxy'):
             self.mw.checkable_proxy.set_ignore_patterns(default_patterns)
             if not self.mw.ssh_client:
                 self.refresh_tree() # 필터 리셋 후 트리 새로고침

    def reset_file_tree(self):
        """Resets the file tree view to an empty state, using the appropriate model."""
        if self.mw.ssh_client and self.remote_model:
            # SSH 연결 상태: 원격 모델 리셋 (루트 경로 재설정 등)
            logger.info("Resetting remote file tree model.")
            # RemoteFileSystemModel에 리셋 로직 추가 필요 (예: 캐시 클리어, 루트 재설정)
            self.remote_model.reset() # reset 메서드 호출
            self.mw.tree_view.setModel(self.remote_model) # 모델 재설정하여 리프레시 유도
            self.mw.tree_view.setRootIndex(self.remote_model.index(0, 0, QModelIndex())) # 루트 인덱스 설정
        elif hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
            # 로컬 상태: 로컬 모델 리셋
            logger.info("Resetting local file tree model.")
            # 현재 루트 경로 저장 (SSH 해제 시 복원용)
            if not self.mw.ssh_client:
                self.local_root_path = self.mw.dir_model.rootPath()

            # 트리 비우기
            self.mw.dir_model.setRootPath("")
            self.mw.tree_view.reset() # 뷰 강제 리셋 추가

            # 체크 상태 딕셔너리 초기화
            self.mw.checkable_proxy.checked_files_dict.clear()

            self.mw.tree_view.collapseAll()
        logger.info("File tree reset complete.")

    def update_tree_for_ssh_status(self, is_connected: bool, remote_root: Optional[str] = None):
        """
        Updates the file tree view based on SSH connection status.
        Switches between local CheckableProxyModel and RemoteFileSystemModel.
        Accepts asyncssh.SFTPClient.
        """
        if not hasattr(self.mw, 'tree_view'):
            logger.warning("File tree view not available for SSH status update.")
            return

        if is_connected:
            # SSH 연결 성공 시:
            if not self.mw.sftp_client:
                logger.error("SFTP client is not available for remote browsing.")
                QMessageBox.critical(self.mw, "오류", "SFTP 클라이언트 초기화 실패. 원격 탐색을 시작할 수 없습니다.")
                # self.mw._close_ssh_connection() # 연결 강제 종료 (async 필요)
                asyncio.create_task(self.mw._close_ssh_connection_async()) # 비동기 종료 호출
                return

            # 1. 현재 로컬 루트 경로 저장 (이미 연결된 상태가 아니라면)
            if not self.remote_model:
                self.local_root_path = self.mw.dir_model.rootPath() if hasattr(self.mw, 'dir_model') else None
                logger.info(f"Storing local root path: {self.local_root_path}")

            # 2. 로컬 폴더 선택 해제 및 UI 업데이트
            self.mw.current_project_folder = None
            self.mw.project_folder_label.setText(f"현재 경로: 원격 ({remote_root})")

            # 3. RemoteFileSystemModel 생성 또는 업데이트 (asyncssh.SFTPClient 사용)
            if not self.remote_model:
                logger.info("Creating new RemoteFileSystemModel instance.")
                # Pass asyncssh.SFTPClient instance
                self.remote_model = RemoteFileSystemModel(self.mw.sftp_client, remote_root or "/")
            else:
                logger.info("Updating existing RemoteFileSystemModel.")
                self.remote_model.update_sftp_client(self.mw.sftp_client) # update_sftp_client 구현 필요
                self.remote_model.set_root_path(remote_root or "/") # set_root_path 구현 필요

            # 4. 트리 뷰에 원격 모델 설정
            self.mw.tree_view.setModel(self.remote_model)
            self.mw.tree_view.setRootIndex(self.remote_model.index(0, 0, QModelIndex()))
            self.mw.tree_view.setEnabled(True)
            self.mw.tree_view.setColumnWidth(0, 300)
            logger.info(f"File tree switched to SSH mode (Alias: {remote_root}). Remote browsing enabled.")

        else:
            # SSH 연결 해제 시:
            # 1. 원격 모델 정리
            if self.remote_model:
                logger.info("Cleaning up RemoteFileSystemModel (calling cancel_all_fetches).")
                self.remote_model.cancel_all_fetches() # Use cancel_all_fetches instead of cleanup
                self.remote_model = None
                self.mw.tree_view.setModel(None)

            # 2. 트리 뷰 활성화
            self.mw.tree_view.setEnabled(True)

            # 3. 로컬 모델 복원 (CheckableProxyModel)
            if hasattr(self.mw, 'checkable_proxy'):
                self.mw.tree_view.setModel(self.mw.checkable_proxy)
                logger.info("Switched tree view model back to CheckableProxyModel (local).")

                # 4. 이전에 저장된 로컬 폴더 경로 복원
                if self.local_root_path and os.path.isdir(self.local_root_path):
                    self.mw.current_project_folder = self.local_root_path
                    self.mw.project_folder_label.setText(f"현재 프로젝트 폴더: {self.local_root_path}")
                    idx = self.mw.dir_model.setRootPathFiltered(self.local_root_path)
                    root_proxy_index = self.mw.checkable_proxy.mapFromSource(idx)
                    self.mw.tree_view.setRootIndex(root_proxy_index)
                    logger.info(f"File tree restored to local mode: {self.local_root_path}")
                else:
                    # 복원할 로컬 폴더 없으면 초기 상태로
                    self.mw.current_project_folder = None
                    self.mw.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
                    self.reset_file_tree() # 로컬 트리 및 체크 상태 초기화
                    logger.info("File tree switched back to local mode (no previous folder).")
            else:
                logger.error("CheckableProxyModel not found. Cannot restore local file tree.")


    def generate_directory_tree_structure(self):
        """Generates the directory tree structure based on checked items."""
        if self.mw.ssh_client:
             QMessageBox.information(self.mw, "정보", "SSH 연결 중에는 로컬 디렉토리 트리 생성이 불가능합니다.")
             return False
        if self.mw.mode == "Meta Prompt Builder":
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 디렉토리 트리 기능이 필요 없습니다.")
            return False

        if not self.mw.current_project_folder or not os.path.isdir(self.mw.current_project_folder):
            QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
            return False

        all_checked_paths = self.mw.checkable_proxy.get_all_checked_paths() if hasattr(self.mw, 'checkable_proxy') else []
        if not all_checked_paths:
            message = "선택된 파일이나 폴더가 없습니다."
            if hasattr(self.mw, "dir_structure_tab"):
                self.mw.dir_structure_tab.setText(message)
                self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
            self.mw.status_bar.showMessage("파일 트리를 생성할 항목이 없습니다!")
            return False

        try:
            tree_string = self.fs_service.get_directory_tree(all_checked_paths, self.mw.current_project_folder)
        except Exception as e:
             QMessageBox.critical(self.mw, "오류", f"디렉토리 트리 생성 중 오류 발생: {e}")
             return False

        if hasattr(self.mw, "dir_structure_tab"):
            self.mw.dir_structure_tab.setText(tree_string)
            self.mw.build_tabs.setCurrentWidget(self.mw.dir_structure_tab)
        self.mw.status_bar.showMessage("File tree generated!")
        self.mw.tree_generated = True # MainWindow 상태 업데이트
        return True

    def rename_item(self, file_path):
        """Renames a file or directory (Local only for now)."""
        # TODO: Implement remote rename using asyncssh SFTP client
        if self.mw.ssh_client:
             QMessageBox.information(self.mw, "정보", "원격 파일 이름 변경은 아직 지원되지 않습니다.")
             return
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "파일 또는 디렉토리가 존재하지 않습니다.")
            return

        base_dir = os.path.dirname(file_path)
        old_name = os.path.basename(file_path)
        new_name, ok = QInputDialog.getText(self.mw, "이름 변경", f"'{old_name}'의 새 이름을 입력하세요:", text=old_name)

        if ok and new_name and new_name.strip():
            new_name_stripped = new_name.strip()
            if new_name_stripped == old_name: return
            new_path = os.path.join(base_dir, new_name_stripped)
            if os.path.exists(new_path):
                 QMessageBox.warning(self.mw, "Error", f"'{new_name_stripped}' 이름이 이미 존재합니다.")
                 return

            try:
                os.rename(file_path, new_path)
                self.mw.status_bar.showMessage(f"'{old_name}' -> '{new_name_stripped}' 이름 변경 완료")
                if hasattr(self.mw, 'checkable_proxy'):
                    if file_path in self.mw.checkable_proxy.checked_files_dict:
                        is_checked = self.mw.checkable_proxy.checked_files_dict.pop(file_path)
                        self.mw.checkable_proxy.checked_files_dict[new_path] = is_checked
                self.refresh_tree()
                self.mw.state_changed_signal.emit() # 파일 구조 변경 시 상태 변경
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"이름 변경 중 오류 발생: {str(e)}")
        elif ok:
             QMessageBox.warning(self.mw, "Error", "새 이름은 비워둘 수 없습니다.")

    def delete_item(self, file_path):
        """Deletes a file or directory (Local only for now)."""
        # TODO: Implement remote delete using asyncssh SFTP client
        if self.mw.ssh_client:
             QMessageBox.information(self.mw, "정보", "원격 파일 삭제는 아직 지원되지 않습니다.")
             return
        if self.mw.mode == "Meta Prompt Builder": return
        if not os.path.exists(file_path):
            QMessageBox.warning(self.mw, "Error", "파일 또는 디렉토리가 존재하지 않습니다.")
            return

        item_name = os.path.basename(file_path)
        item_type = "폴더" if os.path.isdir(file_path) else "파일"
        reply = QMessageBox.question(self.mw, "삭제 확인",
                                     f"정말로 '{item_name}' {item_type}을(를) 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No

        if reply == QMessageBox.StandardButton.Yes: # QMessageBox.Yes -> QMessageBox.StandardButton.Yes
            try:
                if os.path.isdir(file_path):
                    shutil.rmtree(file_path)
                else:
                    os.remove(file_path)
                self.mw.status_bar.showMessage(f"'{item_name}' 삭제 완료")
                if hasattr(self.mw, 'checkable_proxy'):
                    paths_to_remove = [p for p in self.mw.checkable_proxy.checked_files_dict if p == file_path or p.startswith(file_path + os.sep)]
                    for p in paths_to_remove:
                        if p in self.mw.checkable_proxy.checked_files_dict:
                            del self.mw.checkable_proxy.checked_files_dict[p]
                self.refresh_tree()
                self.mw.state_changed_signal.emit() # 파일 구조 변경 시 상태 변경
            except Exception as e:
                QMessageBox.warning(self.mw, "Error", f"삭제 중 오류 발생: {str(e)}")

    def refresh_tree(self):
        """Refreshes the file explorer tree view."""
        if self.mw.ssh_client:
            # SSH 연결 상태: 원격 모델 새로고침
            if self.remote_model:
                logger.info("Refreshing remote file tree...")
                self.remote_model.refresh() # refresh 메서드 호출
                self.mw.status_bar.showMessage("원격 파일 트리 새로고침 완료.")
            else:
                logger.warning("Cannot refresh remote tree: Remote model not available.")
        else:
            # 로컬 상태: 로컬 모델 새로고침
            if self.mw.current_project_folder and hasattr(self.mw, 'dir_model') and hasattr(self.mw, 'checkable_proxy'):
                logger.info("Refreshing local file tree...")
                self.mw.checkable_proxy.invalidateFilter()
                idx = self.mw.dir_model.setRootPathFiltered(self.mw.current_project_folder)
                root_proxy_index = self.mw.checkable_proxy.mapFromSource(idx)
                self.mw.tree_view.setRootIndex(root_proxy_index)
                self._reapply_check_states(root_proxy_index)
                self.mw.status_bar.showMessage("로컬 파일 트리 새로고침 완료.")


    def _reapply_check_states(self, parent_proxy_index: QModelIndex):
         """Recursively reapply check states based on the dictionary after a refresh (Local only)."""
         if self.mw.ssh_client: return

         if not parent_proxy_index.isValid(): return

         parent_path = self.mw.checkable_proxy.get_file_path_from_index(parent_proxy_index)
         if parent_path:
             is_checked = self.mw.checkable_proxy.checked_files_dict.get(parent_path, False)
             current_state = self.mw.checkable_proxy.data(parent_proxy_index, Qt.ItemDataRole.CheckStateRole)
             target_state = Qt.CheckState.Checked if is_checked else Qt.CheckState.Unchecked
             if current_state != target_state:
                 # setData 호출 시 플래그 관리를 위해 내부적으로 처리
                 self.mw.checkable_proxy.setData(parent_proxy_index, target_state, Qt.ItemDataRole.CheckStateRole)

         row_count = self.mw.checkable_proxy.rowCount(parent_proxy_index)
         for row in range(row_count):
             child_proxy_index = self.mw.checkable_proxy.index(row, 0, parent_proxy_index)
             if child_proxy_index.isValid():
                 self._reapply_check_states(child_proxy_index)


    def on_data_changed(self, topLeft: QModelIndex, bottomRight: QModelIndex, roles: List[int]):
        """Handles updates when data in the CheckableProxyModel changes (e.g., check state)."""
        if self.mw.tree_view.model() == self.mw.checkable_proxy and Qt.ItemDataRole.CheckStateRole in roles:
            checked_files = self.mw.checkable_proxy.get_checked_files()
            self.mw.selected_files_data = []
            total_size = 0
            for fpath in checked_files:
                try:
                    size = os.path.getsize(fpath)
                    self.mw.selected_files_data.append((fpath, size))
                    total_size += size
                except Exception:
                    pass
            self.mw.status_bar.showMessage(f"{len(checked_files)} files selected, Total size: {total_size:,} bytes")





======== src\ui\controllers\main_controller.py ========
import os
import base64
import mimetypes
import logging
from typing import Optional, List, Dict, Any
from PyQt6.QtCore import Qt, QModelIndex, QMimeData, QObject, QThread, pyqtSignal, QBuffer, QIODevice
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QApplication, QListWidgetItem
from PyQt6.QtGui import QImage

# 서비스 및 모델 import
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.pydantic_models.app_state import AppState
from utils.helpers import calculate_char_count

# MainWindow는 타입 힌트용으로만 사용 (순환 참조 방지)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .resource_controller import ResourceController
    from .prompt_controller import PromptController
    from .xml_controller import XmlController
    from .file_tree_controller import FileTreeController

try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False
    print("Warning: Pillow library not installed. Image handling from clipboard might be limited.")

logger = logging.getLogger(__name__)

# --- 토큰 계산을 위한 Worker 클래스 ---
class TokenWorker(QObject):
    finished = pyqtSignal(int)
    error = pyqtSignal(str)

    def __init__(self, token_service: TokenCalculationService, model_type: str, model_name: str, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        super().__init__()
        self.token_service = token_service
        self.model_type = model_type
        self.model_name = model_name
        self.text = text
        self.attachments = attachments or []

    def run(self):
        """토큰 계산 로직을 실행합니다."""
        try:
            logger.info(f"Starting token calculation in worker thread for {self.model_type} - {self.model_name}")
            token_count = self.token_service.calculate_tokens(
                self.model_type, self.model_name, self.text, self.attachments
            )
            if token_count is not None:
                logger.info(f"Token calculation finished successfully: {token_count}")
                self.finished.emit(token_count)
            else:
                logger.warning(f"Token calculation returned None for {self.model_type} - {self.model_name}")
                self.error.emit(f"{self.model_type} 토큰 계산 실패 (None 반환)")
        except Exception as e:
            logger.exception(f"Error during token calculation in worker thread for {self.model_type} - {self.model_name}")
            self.error.emit(f"토큰 계산 오류: {str(e)}")


class MainController:
    """
    메인 컨트롤러는 애플리케이션의 전반적인 흐름과
    다른 컨트롤러 간의 조정 역할을 담당.
    """
    def __init__(self, main_window: 'MainWindow'):
        self.mw = main_window
        self.token_service: TokenCalculationService = self.mw.token_service
        self.config_service: ConfigService = self.mw.config_service
        self.last_token_count: Optional[int] = None
        self.token_thread: Optional[QThread] = None
        self.token_worker: Optional[TokenWorker] = None

    def reset_program(self):
        """Resets the application to its initial state."""
        logger.info("Reset program requested.")
        self._initialized = False # Temporarily disable signals/timers during reset
        self.mw.reset_state()
        self._initialized = False # Keep disabled until reset is fully complete

        self.mw.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
        # Clearing tabs - ensure attributes exist before clearing
        if hasattr(self.mw, "system_tab"): self.mw.system_tab.clear()
        if hasattr(self.mw, "user_tab"): self.mw.user_tab.clear()
        if hasattr(self.mw, "dir_structure_tab"): self.mw.dir_structure_tab.clear()
        if hasattr(self.mw, "xml_input_tab"): self.mw.xml_input_tab.clear()
        if hasattr(self.mw, "prompt_output_tab"): self.mw.prompt_output_tab.clear()
        if hasattr(self.mw, "summary_tab"): self.mw.summary_tab.clear()
        if hasattr(self.mw, "attachment_list_widget"): self.mw.attachment_list_widget.clear()
        if hasattr(self.mw, 'meta_prompt_tab'): self.mw.meta_prompt_tab.clear()
        if hasattr(self.mw, 'user_prompt_tab'): getattr(self.mw, 'user_prompt_tab', None).clear()
        if hasattr(self.mw, 'final_prompt_tab'): getattr(self.mw, 'final_prompt_tab', None).clear()


        self.mw.file_tree_controller.reset_gitignore_and_filter()
        # reset_file_tree is called within reset_state

        self.mw.llm_combo.setCurrentIndex(self.mw.llm_combo.findText("Gemini"))
        self.on_llm_selected() # This will also reset token label

        self.update_char_count_for_active_tab()
        # self.reset_token_label() # Called by on_llm_selected
        if hasattr(self.mw, 'api_time_label'): self.mw.api_time_label.setText("API 시간: -")

        self.mw.update_window_title()
        self.mw.status_bar.showMessage("프로그램 리셋 완료.")

        self._initialized = True # Re-enable signals/timers
        QMessageBox.information(self.mw, "Info", "프로그램이 초기 상태로 리셋되었습니다.")
        self.mw.state_changed_signal.emit() # Emit state changed after reset

    def update_char_count(self, text: str):
        """Updates character count in the status bar."""
        char_count = calculate_char_count(text)
        logger.debug(f"Updating char count: {char_count}")
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

    def update_char_count_for_active_tab(self):
        """Updates the character count based on the currently active text edit tab."""
        current_widget = self.mw.build_tabs.currentWidget()
        logger.debug(f"Active tab changed, updating char count. Widget: {type(current_widget).__name__}")
        if hasattr(current_widget, 'toPlainText'):
            self.update_char_count(current_widget.toPlainText())
        else:
            logger.debug("Active widget has no toPlainText method, resetting char count.")
            self.mw.char_count_label.setText("Chars: 0")

    def reset_token_label(self):
        """Resets the token count label."""
        if hasattr(self.mw, '_initialized') and self.mw._initialized:
            logger.debug("Resetting token label.")
            self.mw.token_count_label.setText("토큰 계산: -")
            self.last_token_count = None
            self._stop_token_calculation_thread()

    def handle_text_changed(self):
        """Handles text changes: updates char count, resets token label, signals state change."""
        if not hasattr(self.mw, '_initialized') or not self.mw._initialized:
            return # Avoid handling signals during initialization/reset
        logger.debug("Text changed in an editor.")
        self.update_char_count_for_active_tab()
        self.reset_token_label()
        self.mw.state_changed_signal.emit()


    def calculate_and_display_tokens(self, text: str, attachments: Optional[List[Dict[str, Any]]] = None):
        """ Starts the token calculation in a background thread. """
        if not hasattr(self.mw, '_initialized') or not self.mw._initialized:
            logger.warning("Token calculation skipped: MainWindow not initialized.")
            self.reset_token_label()
            return

        attachments = attachments or []
        char_count = calculate_char_count(text)
        self.mw.char_count_label.setText(f"Chars: {char_count:,}")

        self._stop_token_calculation_thread()

        if not text and not attachments:
            logger.info("Token calculation skipped: Text and attachments are empty.")
            self.mw.token_count_label.setText("토큰 계산: -")
            self.last_token_count = 0
            return

        selected_llm = self.mw.llm_combo.currentText()
        model_name = self.mw.model_name_combo.currentText().strip()

        if not model_name:
            token_text = f"{selected_llm} 모델명을 선택하거나 입력하세요."
            logger.warning("Token calculation skipped: Model name is empty.")
            self.mw.token_count_label.setText(token_text); self.last_token_count = None; return

        token_text = f"{selected_llm} 토큰 계산 중..."
        self.mw.token_count_label.setText(token_text); self.last_token_count = None
        QApplication.processEvents()

        logger.info(f"Starting token calculation worker for {selected_llm}, {model_name}...")
        self.token_thread = QThread()
        self.token_worker = TokenWorker(self.token_service, selected_llm, model_name, text, attachments)
        self.token_worker.moveToThread(self.token_thread)
        self.token_thread.started.connect(self.token_worker.run)
        self.token_worker.finished.connect(self._handle_token_result)
        self.token_worker.error.connect(self._handle_token_error)
        self.token_thread.finished.connect(self._cleanup_token_thread)
        self.token_worker.finished.connect(self.token_worker.deleteLater)
        self.token_worker.error.connect(self.token_worker.deleteLater)
        self.token_worker.finished.connect(self.token_thread.quit)
        self.token_worker.error.connect(self.token_thread.quit)
        self.token_thread.finished.connect(self.token_thread.deleteLater)
        self.token_thread.start()

    def _handle_token_result(self, token_count: int):
        """Handles the successful result from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText()
        token_text = f"Total Token ({selected_llm}): {token_count:,}"
        self.last_token_count = token_count
        logger.info(f"Token calculation successful. Updating label to: {token_text}")
        self.mw.token_count_label.setText(token_text)

    def _handle_token_error(self, error_msg: str):
        """Handles the error signal from the TokenWorker."""
        selected_llm = self.mw.llm_combo.currentText()
        token_text = f"{selected_llm} 토큰 계산 오류"
        self.last_token_count = None
        logger.error(f"Token calculation failed: {error_msg}")
        self.mw.token_count_label.setText(token_text)
        self.mw.status_bar.showMessage(f"토큰 계산 오류: {error_msg}", 5000)

    def _stop_token_calculation_thread(self):
        """Stops the currently running token calculation thread, if any."""
        if self.token_thread and self.token_thread.isRunning():
            logger.info("Stopping previous token calculation thread...")
            self.token_thread.quit()
            if not self.token_thread.wait(1000): logger.warning("Token calculation thread did not quit gracefully within 1 second.")
            else: logger.info("Previous token calculation thread finished gracefully.")

    def _cleanup_token_thread(self):
        """Cleans up the token thread and worker objects."""
        logger.debug("Cleaning up token thread and worker objects.")
        self.token_thread = None; self.token_worker = None

    def on_llm_selected(self):
        """Handles the selection change in the LLM dropdown."""
        logger.info("LLM selection changed.")
        selected_llm = self.mw.llm_combo.currentText()
        available_models = self.config_service.get_available_models(selected_llm)
        logger.debug(f"Selected LLM: {selected_llm}, Available Models: {available_models}")

        self.mw.model_name_combo.blockSignals(True)
        self.mw.model_name_combo.clear()
        self.mw.model_name_combo.addItems(available_models)
        self.mw.model_name_combo.blockSignals(False)

        default_model = self.config_service.get_default_model_name(selected_llm)
        default_index = self.mw.model_name_combo.findText(default_model)
        if default_index != -1: self.mw.model_name_combo.setCurrentIndex(default_index); logger.debug(f"Set default model to: {default_model}")
        elif available_models: self.mw.model_name_combo.setCurrentIndex(0); logger.warning(f"Default model '{default_model}' not found for {selected_llm}. Selecting first available: {available_models[0]}")
        else: logger.warning(f"No available models found for {selected_llm}.")

        self.reset_token_label()
        self.update_char_count_for_active_tab()

        is_gemini_selected = (selected_llm == "Gemini")
        if hasattr(self.mw, 'gemini_param_widget'): self.mw.gemini_param_widget.setVisible(is_gemini_selected)
        logger.debug(f"Gemini params visibility set to: {is_gemini_selected}")

        self.mw.state_changed_signal.emit() # Signal state change

    # --- Attachment Handling ---
    def attach_files(self):
        """Opens a file dialog to select multiple files for attachment."""
        if self.mw.mode == "Meta Prompt Builder": QMessageBox.information(self.mw, "정보", "Meta Prompt Builder 모드에서는 파일 첨부가 필요 없습니다."); return
        start_dir = self.mw.current_project_folder if self.mw.current_project_folder else os.path.expanduser("~")
        file_paths, _ = QFileDialog.getOpenFileNames(self.mw, "파일 첨부", start_dir, "모든 파일 (*.*);;이미지 파일 (*.png *.jpg *.jpeg *.webp);;텍스트 파일 (*.txt *.md *.py *.json *.yaml *.yml *.html *.css *.js)")
        if file_paths:
            added_count = 0
            for file_path in file_paths:
                if not os.path.exists(file_path): continue
                file_name = os.path.basename(file_path)
                if any(item.get('path') == file_path for item in self.mw.attached_items): logger.info(f"Skipping duplicate attachment: {file_name}"); continue
                mime_type, _ = mimetypes.guess_type(file_path); item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'
                attachment_info = {"type": item_type, "path": file_path, "name": file_name, "data": None}
                self.mw.attached_items.append(attachment_info); added_count += 1; logger.info(f"Attached file: {file_name} (Type: {item_type})")
            if added_count > 0: self.mw._update_attachment_list_ui(); self.mw.status_bar.showMessage(f"{added_count}개 파일 첨부 완료."); self.reset_token_label(); self.mw.state_changed_signal.emit()
            else: self.mw.status_bar.showMessage("선택한 파일이 이미 첨부되어 있거나 유효하지 않습니다.")

    def paste_from_clipboard(self):
        """Pastes image or file paths from the clipboard."""
        if self.mw.mode == "Meta Prompt Builder": QMessageBox.information(self, "정보", "Meta Prompt Builder 모드에서는 클립보드 첨부가 필요 없습니다."); return
        clipboard = QApplication.clipboard(); mime_data = clipboard.mimeData(); added_count = 0
        if mime_data.hasImage():
            qimage = clipboard.image();
            if not qimage.isNull():
                image_data = None; image_format = "PNG"
                if _PILLOW_AVAILABLE:
                    try:
                        pil_image = ImageQt(qimage).copy();
                        if pil_image.mode == 'RGBA': pil_image = pil_image.convert('RGB')
                        import io; buffer = io.BytesIO(); save_format = "JPEG" if pil_image.mode == 'RGB' else "PNG"; pil_image.save(buffer, format=save_format); image_data = buffer.getvalue(); image_format = save_format; logger.info(f"Pasted image converted to {save_format} bytes.")
                    except Exception as e: logger.error(f"Error converting QImage with Pillow: {e}", exc_info=True)
                else:
                    try:
                        import io; buffer = QBuffer(); buffer.open(QIODevice.OpenModeFlag.ReadWrite);
                        if qimage.save(buffer, "PNG"): image_data = bytes(buffer.data()); image_format = "PNG"; logger.info("Pasted image converted to PNG bytes using QBuffer.")
                        else: logger.warning("Failed to save QImage using QBuffer.")
                        buffer.close()
                    except Exception as e: logger.error(f"Error converting QImage with QBuffer: {e}", exc_info=True)
                if image_data:
                    import time; timestamp = time.strftime("%Y%m%d_%H%M%S"); image_name = f"clipboard_image_{timestamp}.{image_format.lower()}"; attachment_info = {"type": "image", "path": None, "name": image_name, "data": image_data}
                    self.mw.attached_items.append(attachment_info); added_count += 1; logger.info(f"Image pasted from clipboard: {image_name}")
        elif mime_data.hasUrls():
            urls = mime_data.urls()
            for url in urls:
                if url.isLocalFile():
                    file_path = url.toLocalFile()
                    if os.path.exists(file_path):
                        file_name = os.path.basename(file_path)
                        if any(item.get('path') == file_path for item in self.mw.attached_items): logger.info(f"Skipping duplicate attachment from clipboard: {file_name}"); continue
                        mime_type, _ = mimetypes.guess_type(file_path); item_type = 'image' if mime_type and mime_type.startswith('image/') else 'file'
                        attachment_info = {"type": item_type, "path": file_path, "name": file_name, "data": None}
                        self.mw.attached_items.append(attachment_info); added_count += 1; logger.info(f"File path pasted from clipboard: {file_name}")
                    else: logger.warning(f"Ignoring non-existent file path from clipboard: {file_path}")
                else: logger.warning(f"Ignoring non-local URL from clipboard: {url.toString()}")
        if added_count > 0: self.mw._update_attachment_list_ui(); self.mw.status_bar.showMessage(f"{added_count}개 항목 클립보드에서 첨부 완료."); self.reset_token_label(); self.mw.state_changed_signal.emit()
        else: self.mw.status_bar.showMessage("클립보드에 첨부할 수 있는 이미지나 파일 경로가 없습니다.")

    def remove_selected_attachment(self):
        """Removes the selected item from the attachment list."""
        if not hasattr(self.mw, 'attachment_list_widget'): return
        selected_items = self.mw.attachment_list_widget.selectedItems()
        if not selected_items: self.mw.status_bar.showMessage("제거할 첨부 파일을 선택하세요."); return
        removed_count = 0; selected_indices = sorted([self.mw.attachment_list_widget.row(item) for item in selected_items], reverse=True)
        for index in selected_indices:
            if 0 <= index < len(self.mw.attached_items):
                removed_item = self.mw.attached_items.pop(index); self.mw.attachment_list_widget.takeItem(index); logger.info(f"Removed attachment: {removed_item.get('name')}"); removed_count += 1
        if removed_count > 0: self.mw.status_bar.showMessage(f"{removed_count}개 첨부 파일 제거 완료."); self.reset_token_label(); self.mw.state_changed_signal.emit()
        else: self.mw.status_bar.showMessage("첨부 파일 제거 중 오류 발생.")



======== src\ui\controllers\prompt_controller.py ========
import os
import logging
from PyQt6.QtWidgets import QMessageBox, QApplication

# 서비스 및 모델 import
from core.services.prompt_service import PromptService

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

logger = logging.getLogger(__name__)

class PromptController:
    """
    Handles logic related to prompt generation and clipboard operations.
    """
    def __init__(self, main_window: 'MainWindow', prompt_service: PromptService):
        self.mw = main_window
        self.prompt_service = prompt_service

    def generate_prompt(self):
        """Generates the prompt for the Code Enhancer mode."""
        logger.info("Attempting to generate Code Enhancer prompt...")
        if self.mw.mode == "Meta Prompt Builder":
            logger.info("Mode is Meta Prompt Builder, calling generate_meta_prompt instead.")
            return self.generate_meta_prompt() # Meta 모드면 해당 함수 호출

        if not self.mw.current_project_folder:
             logger.warning("Project folder not selected.")
             QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
             return False

        checked_files = self.mw.checkable_proxy.get_checked_files() if hasattr(self.mw, 'checkable_proxy') else []
        if not checked_files:
            logger.warning("No files selected for prompt generation.")
            QMessageBox.warning(self.mw, "경고", "프롬프트에 포함할 파일을 하나 이상 선택해주세요.")
            return False

        logger.info(f"Generating prompt with {len(checked_files)} selected files.")
        file_contents = []
        self.mw.selected_files_data = []
        read_errors = []
        for fpath in checked_files:
            try:
                size = os.path.getsize(fpath)
                with open(fpath, 'r', encoding='utf-8', errors='ignore') as fp:
                    content = fp.read()
                file_contents.append((fpath, content))
                self.mw.selected_files_data.append((fpath, size))
            except Exception as e:
                error_msg = f"파일 읽기 오류 ({os.path.basename(fpath)}): {e}"
                logger.error(error_msg, exc_info=True) # Log traceback
                read_errors.append(error_msg)
                continue

        if read_errors:
             logger.warning(f"Encountered {len(read_errors)} file reading errors.")
             QMessageBox.warning(self.mw, "파일 로딩 오류", "일부 파일을 읽는 중 오류 발생:\n" + "\n".join(read_errors))

        system_text = self.mw.system_tab.toPlainText()
        user_text = self.mw.user_tab.toPlainText()
        dir_structure_content = ""
        if self.mw.tree_generated and hasattr(self.mw, "dir_structure_tab"):
            dir_structure_content = self.mw.dir_structure_tab.toPlainText()
        logger.debug(f"System prompt length: {len(system_text)}")
        logger.debug(f"User prompt length: {len(user_text)}")
        logger.debug(f"Directory structure included: {bool(dir_structure_content)}")

        attachments_metadata = []
        for item in self.mw.attached_items:
            meta_item = item.copy(); meta_item.pop('data', None)
            attachments_metadata.append(meta_item)
        logger.info(f"Including metadata for {len(attachments_metadata)} attachments.")

        final_prompt = self.prompt_service.generate_code_enhancer_prompt(
            system_text=system_text, user_text=user_text, file_contents=file_contents,
            root_dir=self.mw.current_project_folder, dir_structure_content=dir_structure_content,
            attached_items=attachments_metadata
        )

        self.mw.last_generated_prompt = final_prompt
        self.mw.prompt_output_tab.setText(final_prompt)
        logger.info(f"Final prompt generated (length: {len(final_prompt)}).")

        # Trigger token calculation
        self.mw.main_controller.calculate_and_display_tokens(final_prompt, self.mw.attached_items)

        self.mw.status_bar.showMessage(f"Prompt generated! Length: {len(final_prompt):,} chars. Token calculation started...")
        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        return True

    def generate_meta_prompt(self):
        """Generates the intermediate meta prompt."""
        logger.info("Generating intermediate Meta prompt...")
        system_text = self.mw.system_tab.toPlainText() # Meta template
        user_text = self.mw.user_tab.toPlainText() # Meta user input

        final_output = self.prompt_service.generate_meta_prompt(
            meta_template=system_text, meta_user_input=user_text
        )

        self.mw.prompt_output_tab.setText(final_output); self.mw.last_generated_prompt = final_output
        logger.info(f"Meta prompt generated (length: {len(final_output)}).")

        # Trigger token calculation
        self.mw.main_controller.calculate_and_display_tokens(final_output)

        self.mw.build_tabs.setCurrentWidget(self.mw.prompt_output_tab)
        self.mw.status_bar.showMessage("META Prompt generated! Token calculation started...")
        return True

    def generate_final_meta_prompt(self):
        """Generates the final prompt by replacing variables."""
        logger.info("Generating final Meta prompt...")
        meta_prompt_content = getattr(self.mw, 'meta_prompt_tab', None).toPlainText() if hasattr(self.mw, 'meta_prompt_tab') else ""
        user_prompt_content = getattr(self.mw, 'user_prompt_tab', None).toPlainText() if hasattr(self.mw, 'user_prompt_tab') else ""

        variables = {}
        if hasattr(self.mw, 'build_tabs'):
            for i in range(self.mw.build_tabs.count()):
                tab_name = self.mw.build_tabs.tabText(i)
                if tab_name.startswith("var-"):
                    var_name = tab_name[4:]
                    tab_widget = self.mw.build_tabs.widget(i)
                    if tab_widget and hasattr(tab_widget, 'toPlainText'):
                        variables[var_name] = tab_widget.toPlainText()
        logger.debug(f"Variables for final meta prompt: {list(variables.keys())}")

        final_prompt = self.prompt_service.generate_final_meta_prompt(
            meta_prompt_content=meta_prompt_content, user_prompt_content=user_prompt_content, variables=variables
        )

        if hasattr(self.mw, 'final_prompt_tab'):
            self.mw.final_prompt_tab.setText(final_prompt); self.mw.last_generated_prompt = final_prompt
            logger.info(f"Final meta prompt generated (length: {len(final_prompt)}).")
            # Trigger token calculation
            self.mw.main_controller.calculate_and_display_tokens(final_prompt)
            self.mw.build_tabs.setCurrentWidget(self.mw.final_prompt_tab)
            self.mw.status_bar.showMessage("Final Prompt generated! Token calculation started...")
        else:
             logger.error("Final prompt tab not found.")
             QMessageBox.warning(self.mw, "오류", "최종 프롬프트 탭을 찾을 수 없습니다.")

    def copy_to_clipboard(self):
        """Copies the content of the active prompt output tab to the clipboard."""
        current_widget = self.mw.build_tabs.currentWidget()
        prompt_to_copy = ""

        if current_widget == self.mw.prompt_output_tab and self.mw.mode != "Meta Prompt Builder": prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        elif current_widget == self.mw.prompt_output_tab and self.mw.mode == "Meta Prompt Builder": prompt_to_copy = self.mw.prompt_output_tab.toPlainText()
        elif hasattr(self.mw, 'final_prompt_tab') and current_widget == self.mw.final_prompt_tab: prompt_to_copy = self.mw.final_prompt_tab.toPlainText()
        elif hasattr(self.mw, 'dir_structure_tab') and current_widget == self.mw.dir_structure_tab: prompt_to_copy = self.mw.dir_structure_tab.toPlainText()

        if not prompt_to_copy: prompt_to_copy = self.mw.last_generated_prompt

        if prompt_to_copy:
            QApplication.clipboard().setText(prompt_to_copy)
            self.mw.status_bar.showMessage("Copied!")
            logger.info(f"Copied content (length: {len(prompt_to_copy)}) to clipboard.")
            return True
        else:
            self.mw.status_bar.showMessage("복사할 내용이 없습니다!")
            logger.warning("Attempted to copy, but no content available.")
            return False

    def generate_all_and_copy(self):
        """Generates tree, prompt, triggers tokens, and copies (Code Enhancer mode)."""
        logger.info("Generate All & Copy requested...")
        if self.mw.mode == "Meta Prompt Builder":
            logger.info("Generate All & Copy ignored in Meta Prompt Builder mode.")
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 이 기능을 사용할 수 없습니다.")
            return False

        tree_success = self.mw.file_tree_controller.generate_directory_tree_structure()
        if not tree_success:
            logger.warning("generate_all_and_copy: Directory tree generation failed or was skipped.")
            # Continue to prompt generation even if tree fails/is skipped

        prompt_success = self.generate_prompt()
        if not prompt_success:
            logger.error("generate_all_and_copy: Prompt generation failed.")
            return False

        copy_success = self.copy_to_clipboard()
        if not copy_success:
            logger.warning("generate_all_and_copy: Copy to clipboard failed, but prompt generation succeeded.")

        logger.info("Generate All & Copy finished (prompt generation successful).")
        return True



======== src\ui\controllers\resource_controller.py ========
import os
import logging # 로깅 추가
from PyQt6.QtWidgets import QFileDialog, QInputDialog, QMessageBox, QTreeWidgetItem
from PyQt6.QtCore import Qt

# 서비스 및 모델 import
from core.services.template_service import TemplateService
from core.services.state_service import StateService
from core.pydantic_models.app_state import AppState

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow

logger = logging.getLogger(__name__) # 로거 설정

class ResourceController:
    """
    Handles logic related to resource management (templates and states).
    """
    def __init__(self, main_window: 'MainWindow', template_service: TemplateService, state_service: StateService):
        self.mw = main_window
        self.template_service = template_service
        self.state_service = state_service

    def load_templates_list(self):
        """Loads the list of templates or states into the resource tree."""
        logger.info("Loading resource list...")
        self.mw.template_tree.clear()
        current_mode = self.mw.resource_mode_combo.currentText()
        logger.debug(f"Current resource mode: {current_mode}")

        if current_mode == "프롬프트":
            system_templates = self.template_service.list_templates("prompts/system")
            user_templates = self.template_service.list_templates("prompts/user")
            system_item = self.mw.create_tree_item("System"); user_item = self.mw.create_tree_item("User")
            for st in sorted(system_templates): self.mw.create_tree_item(st, system_item)
            for ut in sorted(user_templates): self.mw.create_tree_item(ut, user_item)
            system_item.setExpanded(True); user_item.setExpanded(True)
            logger.info(f"Loaded {len(system_templates)} system and {len(user_templates)} user prompt templates.")
        elif current_mode == "상태":
            states_list = self.state_service.list_states()
            states_item = self.mw.create_tree_item("States")
            for st_file in sorted(states_list): self.mw.create_tree_item(st_file, states_item)
            states_item.setExpanded(True)
            logger.info(f"Loaded {len(states_list)} saved states.")

        self.update_buttons_label()

    def load_selected_item(self):
        """Loads the selected template or state."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent():
            logger.warning(f"No {current_mode} item selected to load.")
            QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요.")
            return

        filename = item.text(0)
        logger.info(f"Attempting to load selected {current_mode}: {filename}")

        if current_mode == "프롬프트":
            parent_text = item.parent().text(0); relative_path = ""; target_tab = None
            if parent_text == "System": relative_path = os.path.join("prompts", "system", filename); target_tab = self.mw.system_tab
            elif parent_text == "User": relative_path = os.path.join("prompts", "user", filename); target_tab = self.mw.user_tab
            if relative_path and target_tab:
                content = self.template_service.load_template(relative_path)
                target_tab.setText(content)
                self.mw.status_bar.showMessage(f"Loaded {parent_text.lower()} template: {filename}")
                logger.info(f"Loaded {parent_text.lower()} template '{filename}' into the corresponding tab.")
        elif current_mode == "상태":
            fname_no_ext = os.path.splitext(filename)[0]
            loaded_state = self.state_service.load_state(fname_no_ext)
            if loaded_state:
                self.mw.set_current_state(loaded_state, partial_load=False)
                self.mw.status_bar.showMessage(f"State '{filename}' loaded successfully.")
                logger.info(f"Loaded state file '{filename}' successfully.")
            else:
                logger.error(f"Failed to load state file: {filename}")
                QMessageBox.warning(self.mw, "오류", "상태 파일을 불러오는 데 실패했습니다.")

    def save_current_as_item(self):
        """Saves the current prompt or state as a new item."""
        current_mode = self.mw.resource_mode_combo.currentText()
        logger.info(f"Attempting to save current content as new {current_mode}...")

        if current_mode == "프롬프트":
            template_type = self.mw.template_type_combo.currentText(); content = ""; target_dir_relative = ""; source_tab = None
            if template_type == "시스템": source_tab = self.mw.system_tab; target_dir_relative = os.path.join("prompts", "system")
            else: source_tab = self.mw.user_tab; target_dir_relative = os.path.join("prompts", "user")
            content = source_tab.toPlainText()
            if not content.strip(): logger.warning("No content to save."); QMessageBox.warning(self.mw, "경고", "저장할 내용이 없습니다."); return
            fname, ok = QInputDialog.getText(self.mw, "템플릿 저장", "템플릿 파일 이름(확장자 제외)을 입력하세요:")
            if not ok or not fname or not fname.strip(): logger.info("Save cancelled by user or empty name."); return
            fname_stripped = fname.strip(); fname_md = fname_stripped + ".md"; relative_path = os.path.join(target_dir_relative, fname_md)
            if self.template_service.save_template(relative_path, content):
                self.mw.status_bar.showMessage(f"Template saved: {fname_md}"); logger.info(f"Template '{fname_md}' saved successfully.")
                self.load_templates_list()
            else: logger.error(f"Failed to save template: {relative_path}"); QMessageBox.warning(self.mw, "오류", "템플릿 저장 중 오류가 발생했습니다.")
        elif current_mode == "상태":
            current_state = self.mw.get_current_state()
            fname, ok = QInputDialog.getText(self.mw, "상태 저장", "상태 파일 이름(확장자 제외)을 입력하세요:")
            if not ok or not fname or not fname.strip(): logger.info("Save cancelled by user or empty name."); return
            fname_stripped = fname.strip()
            if self.state_service.save_state(current_state, fname_stripped):
                self.mw.status_bar.showMessage(f"State saved: {fname_stripped}.json"); logger.info(f"State '{fname_stripped}.json' saved successfully.")
                self.load_templates_list()
            else: logger.error(f"Failed to save state: {fname_stripped}.json"); QMessageBox.warning(self.mw, "오류", "상태 저장 중 오류가 발생했습니다.")

    def delete_selected_item(self):
        """Deletes the selected template or state file."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent(): logger.warning(f"No {current_mode} item selected to delete."); QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요."); return
        filename = item.text(0); parent_text = item.parent().text(0)
        logger.warning(f"Delete requested for {current_mode}: {filename}")
        reply = QMessageBox.question(self.mw, "삭제 확인", f"정말로 '{filename}'을(를) 삭제하시겠습니까?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: logger.info("Delete cancelled by user."); return
        deleted = False
        if current_mode == "프롬프트":
            relative_path = ""
            if parent_text == "System": relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User": relative_path = os.path.join("prompts", "user", filename)
            if relative_path: deleted = self.template_service.delete_template(relative_path)
        elif current_mode == "상태":
            fname_no_ext = os.path.splitext(filename)[0]; deleted = self.state_service.delete_state(fname_no_ext)
        if deleted: self.mw.status_bar.showMessage(f"Deleted: {filename}"); logger.info(f"Deleted {current_mode}: {filename}"); self.load_templates_list()
        else: logger.error(f"Failed to delete {current_mode}: {filename}"); QMessageBox.warning(self.mw, "오류", f"'{filename}' 삭제 중 오류가 발생했습니다.")

    def update_current_item(self):
        """Updates the selected template or state file."""
        current_mode = self.mw.resource_mode_combo.currentText()
        item = self.mw.template_tree.currentItem()
        if not item or not item.parent(): logger.warning(f"No {current_mode} item selected to update."); QMessageBox.information(self.mw, "Info", f"{current_mode} 파일을 선택해주세요."); return
        filename = item.text(0); parent_text = item.parent().text(0)
        logger.info(f"Update requested for {current_mode}: {filename}")
        reply = QMessageBox.question(self.mw, "업데이트 확인", f"'{filename}'의 내용을 현재 편집 중인 내용으로 덮어쓰시겠습니까?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.Yes)
        if reply != QMessageBox.StandardButton.Yes: logger.info("Update cancelled by user."); return
        updated = False
        if current_mode == "프롬프트":
            content = ""; relative_path = ""; source_tab = None
            if parent_text == "System": source_tab = self.mw.system_tab; relative_path = os.path.join("prompts", "system", filename)
            elif parent_text == "User": source_tab = self.mw.user_tab; relative_path = os.path.join("prompts", "user", filename)
            if relative_path and source_tab: content = source_tab.toPlainText(); updated = self.template_service.save_template(relative_path, content)
        elif current_mode == "상태":
            current_state = self.mw.get_current_state(); fname_no_ext = os.path.splitext(filename)[0]; updated = self.state_service.save_state(current_state, fname_no_ext)
        if updated: self.mw.status_bar.showMessage(f"Updated: {filename}"); logger.info(f"Updated {current_mode}: {filename}")
        else: logger.error(f"Failed to update {current_mode}: {filename}"); QMessageBox.warning(self.mw, "오류", f"'{filename}' 업데이트 중 오류가 발생했습니다.")

    def save_state_to_default(self):
        """Saves the current state to 'default.json'."""
        logger.info("Auto-saving current state to default.json...")
        state = self.mw.get_current_state()
        if self.state_service.save_state(state, "default"):
            self.mw.status_bar.showMessage("현재 작업 자동 저장 완료!")
            logger.info("Auto-save successful.")
        else:
            logger.error("Failed to auto-save state to default.json")
            # Don't show message box for auto-save failure

    def load_state_from_default(self):
        """Loads state from 'default.json' (partial load)."""
        logger.info("Loading state from default.json (partial load)...")
        state = self.state_service.load_state("default")
        if state:
            self.mw.set_current_state(state, partial_load=True)
            logger.info("Partial state loaded successfully from default.json.")
        else:
            logger.info("Default state file not found or failed to load.")
            QMessageBox.information(self.mw, "정보", "저장된 이전 작업 상태 파일을 찾을 수 없습니다.")

    def export_state_to_file(self):
        """Exports the current state to a user-selected file."""
        logger.info("Export state requested.")
        path, _ = QFileDialog.getSaveFileName(self.mw, "상태 내보내기", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            logger.info(f"Exporting state to: {path}")
            state = self.mw.get_current_state()
            if self.state_service.export_state_to_file(state, path):
                self.mw.status_bar.showMessage("상태 내보내기 완료!")
                logger.info("State exported successfully.")
            else:
                logger.error(f"Failed to export state to {path}")
                QMessageBox.warning(self.mw, "오류", "상태 내보내기 중 오류가 발생했습니다.")
        else:
            logger.info("Export state cancelled by user.")

    def import_state_from_file(self):
        """Imports state from a user-selected file."""
        logger.info("Import state requested.")
        path, _ = QFileDialog.getOpenFileName(self.mw, "상태 가져오기", os.path.expanduser("~"), "JSON Files (*.json)")
        if path:
            logger.info(f"Importing state from: {path}")
            state = self.state_service.import_state_from_file(path)
            if state:
                self.mw.set_current_state(state, partial_load=False) # Full load on import
                logger.info("State imported successfully.")
            else:
                logger.error(f"Failed to import state from {path} or invalid content.")
                QMessageBox.warning(self.mw, "오류", "상태 가져오기 중 오류가 발생했거나 파일 내용이 유효하지 않습니다.")
        else:
            logger.info("Import state cancelled by user.")

    def update_buttons_label(self):
        """Updates button labels based on the resource mode."""
        current_mode = self.mw.resource_mode_combo.currentText()
        is_prompt_mode = (current_mode == "프롬프트")
        self.mw.load_selected_template_btn.setText(f"📥 선택한 {current_mode} 불러오기")
        self.mw.save_as_template_btn.setText(f"💾 현재 {current_mode}로 저장")
        self.mw.delete_template_btn.setText(f"❌ 선택한 {current_mode} 삭제")
        self.mw.update_template_btn.setText(f"🔄 현재 {current_mode} 업데이트")
        self.mw.template_type_combo.setVisible(is_prompt_mode)
        self.mw.template_type_label.setVisible(is_prompt_mode)
        logger.debug(f"Updated resource button labels for mode: {current_mode}")



======== src\ui\controllers\system_prompt_controller.py ========

import os
from PyQt6.QtWidgets import QFileDialog, QMessageBox, QWidget # PyQt5 -> PyQt6

# 변경된 경로에서 import
from utils.helpers import get_resource_path, get_project_root
from core.services.config_service import ConfigService # ConfigService import

# MainWindow 타입 힌트
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from ui.main_window import MainWindow

# 함수 형태로 유지 (MainWindow 또는 SettingsDialog에서 호출)
def apply_default_system_prompt(main_window: 'MainWindow'):
    """
    Loads the default system prompt specified in config.yml into the system_tab.
    Handles both relative (to project root) and absolute paths.
    """
    # MainWindow가 가지고 있는 ConfigService 사용
    if not hasattr(main_window, 'config_service'):
        print("Error: ConfigService not found in MainWindow.")
        return

    config_service: ConfigService = main_window.config_service
    settings = config_service.get_settings()
    default_system_prompt_path_str = settings.default_system_prompt
    prompt_source = ""
    prompt_path = "" # Initialize prompt_path

    if default_system_prompt_path_str:
        prompt_path_input = default_system_prompt_path_str
        # 설정 파일의 경로는 프로젝트 루트 기준 상대 경로 또는 절대 경로로 간주
        if not os.path.isabs(prompt_path_input):
             # 상대 경로일 경우 프로젝트 루트 기준으로 절대 경로 생성
             try:
                 project_root = get_project_root()
                 prompt_path = str(project_root / prompt_path_input)
                 prompt_source = f"config.yml (relative: {prompt_path_input})"
             except Exception as e:
                 print(f"Error resolving relative path '{prompt_path_input}': {e}")
                 main_window.status_bar.showMessage(f"기본 시스템 프롬프트 상대 경로 오류: {prompt_path_input}")
                 return
        else:
            # 절대 경로인 경우 그대로 사용
            prompt_path = prompt_path_input
            prompt_source = f"config.yml (absolute: {os.path.basename(prompt_path_input)})"
    else:
        # 설정값이 없으면 기본값(XML Guide) 사용 시도
        default_path_relative = os.path.join("prompts", "system", "XML_Prompt_Guide.md")
        try:
            prompt_path = get_resource_path(default_path_relative)
            prompt_source = f"Default ({os.path.basename(default_path_relative)})"
            print(f"default_system_prompt not set in config, attempting to load default: {default_path_relative}")
        except Exception as e:
             print(f"Error getting resource path for default prompt: {e}")
             main_window.status_bar.showMessage("기본 시스템 프롬프트 경로를 찾을 수 없습니다.")
             return

    # 파일 존재 여부 확인
    if not prompt_path or not os.path.exists(prompt_path):
        print(f"Default system prompt file not found at resolved path: {prompt_path}")
        main_window.status_bar.showMessage(
            f"기본 시스템 프롬프트 파일 없음: {os.path.basename(default_system_prompt_path_str or 'Default')}"
        )
        return

    # 파일 로드 및 UI 업데이트
    try:
        with open(prompt_path, "r", encoding="utf-8") as f:
            content = f.read()
        main_window.system_tab.setText(content)
        print(f"Default system prompt loaded from: {prompt_path}")
        main_window.status_bar.showMessage(f"기본 시스템 프롬프트 로드 완료: {prompt_source}")
    except Exception as e:
        print(f"Error loading default system prompt file '{prompt_path}': {e}")
        main_window.status_bar.showMessage(f"기본 시스템 프롬프트 로드 중 오류: {str(e)}")


def select_default_system_prompt(config_service: ConfigService, parent_widget: Optional[QWidget] = None) -> Optional[str]:
    """
    Opens a file dialog to select a default system prompt file (.md, .txt).
    Returns the path to be saved (relative to project root if possible, otherwise absolute).

    Args:
        config_service: The ConfigService instance.
        parent_widget: The parent widget for the file dialog.

    Returns:
        The path string to be saved in config.yml, or None if cancelled.
    """
    settings = config_service.get_settings()
    current_path_str = settings.default_system_prompt
    initial_dir = os.path.expanduser("~") # Default initial directory

    # Determine initial directory for file dialog
    try:
        project_root = get_project_root()
        # Try to resolve current path (relative or absolute)
        if current_path_str:
            resolved_path = current_path_str
            if not os.path.isabs(current_path_str):
                resolved_path = str(project_root / current_path_str)

            if os.path.exists(resolved_path):
                initial_dir = os.path.dirname(resolved_path)
            elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
                 initial_dir = str(project_root / "resources" / "prompts" / "system")
        elif os.path.isdir(str(project_root / "resources" / "prompts" / "system")):
             initial_dir = str(project_root / "resources" / "prompts" / "system")
    except Exception as e:
        print(f"Error determining initial directory: {e}")
        # Fallback to user home if error occurs

    path, _ = QFileDialog.getOpenFileName(
        parent_widget, # 부모 위젯 전달
        "기본 시스템 프롬프트 선택",
        initial_dir,
        "Text/Markdown Files (*.txt *.md);;All Files (*.*)"
    )

    if path:
        try:
            # 경로를 프로젝트 루트 기준 상대 경로로 변환 시도
            project_root_str = str(get_project_root())
            # Use os.path.normpath and os.path.abspath for reliable comparison
            abs_path = os.path.abspath(path)
            abs_project_root = os.path.abspath(project_root_str)

            if abs_path.startswith(abs_project_root):
                # Calculate relative path and normalize separators to forward slashes
                relative_path = os.path.relpath(abs_path, abs_project_root).replace(os.sep, '/')
                print(f"Default system prompt selected (relative path): {relative_path}")
                return relative_path
            else:
                # 프로젝트 외부는 정규화된 절대 경로 저장 (forward slashes)
                absolute_path_normalized = abs_path.replace(os.sep, '/')
                print(f"Default system prompt selected (absolute path): {absolute_path_normalized}")
                QMessageBox.information(parent_widget, "정보", "프로젝트 외부 경로는 절대 경로로 저장됩니다.")
                return absolute_path_normalized

        except Exception as e:
            print(f"Error processing selected path: {e}")
            QMessageBox.warning(
                parent_widget,
                "오류",
                f"경로 처리 중 오류 발생: {str(e)}"
            )
            return None
    return None # 사용자가 취소한 경우




======== src\ui\controllers\xml_controller.py ========
import os
import logging # 로깅 추가
from PyQt6.QtWidgets import QMessageBox # PyQt5 -> PyQt6

# 서비스 및 모델 import
from core.services.xml_service import XmlService

# MainWindow는 타입 힌트용으로만 사용
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ui.main_window import MainWindow
    from .file_tree_controller import FileTreeController # refresh_tree 호출용

logger = logging.getLogger(__name__) # 로거 설정

class XmlController:
    """
    Handles logic related to XML parsing and applying file changes.
    """
    def __init__(self, main_window: 'MainWindow', xml_service: XmlService):
        self.mw = main_window
        self.xml_service = xml_service

    def run_xml_parser(self):
        """Parses XML input and applies changes to the project files."""
        logger.info("Run XML Parser requested.")
        if self.mw.mode == "Meta Prompt Builder":
            logger.info("XML Parser ignored in Meta Prompt Builder mode.")
            QMessageBox.information(self.mw, "Info", "Meta Prompt Builder 모드에서는 XML 파서 기능이 필요 없습니다.")
            return

        xml_str = ""
        if hasattr(self.mw, "xml_input_tab"):
            xml_str = self.mw.xml_input_tab.toPlainText()
        if not xml_str.strip():
            logger.warning("XML input is empty.")
            self.mw.status_bar.showMessage("XML 내용이 비어 있습니다.")
            return

        project_dir = self.mw.current_project_folder
        if not project_dir or not os.path.isdir(project_dir):
            logger.warning("Project directory not selected.")
            QMessageBox.warning(self.mw, "경고", "프로젝트 폴더를 먼저 선택해주세요.")
            return

        logger.info(f"Applying XML changes to directory: {project_dir}")
        try:
            result = self.xml_service.apply_changes_from_xml(xml_str, project_dir)
        except Exception as e:
             logger.exception("Unexpected error during XML processing.") # Log traceback
             QMessageBox.critical(self.mw, "XML 파싱 오류", f"XML 처리 중 예외 발생: {e}")
             if hasattr(self.mw, 'file_tree_controller'):
                 logger.info("Refreshing file tree after XML processing error.")
                 self.mw.file_tree_controller.refresh_tree() # 오류 시에도 새로고침
             return

        messages = []
        if result["created"]: messages.append(f"생성된 파일 ({len(result['created'])}):\n" + "\n".join(result["created"]))
        if result["updated"]: messages.append(f"수정된 파일 ({len(result['updated'])}):\n" + "\n".join(result["updated"]))
        if result["deleted"]: messages.append(f"삭제된 파일 ({len(result['deleted'])}):\n" + "\n".join(result["deleted"]))
        if result["errors"]: messages.append(f"오류 ({len(result['errors'])}):\n" + "\n".join(result["errors"]))
        if not messages: messages.append("변경 사항 없음.")

        final_message = "\n\n".join(messages)

        if result["errors"]:
            logger.warning(f"XML parsing completed with errors: {result['errors']}")
            QMessageBox.warning(self.mw, "XML 파싱 결과 (오류 발생)", final_message)
        else:
            logger.info("XML parsing completed successfully.")
            QMessageBox.information(self.mw, "XML 파싱 결과", final_message)

        # 파일 변경 후 트리 새로고침
        if hasattr(self.mw, 'file_tree_controller'):
            logger.info("Refreshing file tree after XML processing.")
            self.mw.file_tree_controller.refresh_tree()
        self.mw.status_bar.showMessage("XML 파싱 완료!")



======== src\ui\models\__init__.py ========
# This file makes Python treat the directory models as a package.

from .file_system_models import FilteredFileSystemModel, CheckableProxyModel
from .remote_file_system_model import RemoteFileSystemModel

__all__ = [
    "FilteredFileSystemModel",
    "CheckableProxyModel",
    "RemoteFileSystemModel",
]




======== src\ui\models\file_system_models.py ========
import os
import fnmatch
from PyQt6.QtCore import QSortFilterProxyModel, Qt, QModelIndex
from PyQt6.QtGui import QFileSystemModel
from PyQt6.QtWidgets import QTreeView
from typing import Callable, Optional, Set, List, Dict, Any # List, Dict, Any 추가
from core.services.filesystem_service import FilesystemService
import logging

logger = logging.getLogger(__name__)

class FilteredFileSystemModel(QFileSystemModel):
    """ Custom file system model that fetches all children recursively. """
    def __init__(self, parent=None):
        super().__init__(parent)

    def setRootPathFiltered(self, path: str) -> QModelIndex:
        """Sets the root path and immediately fetches all children."""
        logger.debug(f"FilteredFileSystemModel: Setting root path to '{path}'")
        root_index = super().setRootPath(path)
        if root_index.isValid():
            logger.debug(f"FilteredFileSystemModel: Root index valid. Fetching children recursively...")
            self._fetch_all_recursively(root_index)
            logger.debug(f"FilteredFileSystemModel: Finished fetching children for '{path}'.")
        else:
             logger.warning(f"FilteredFileSystemModel: Root index is invalid for path '{path}'.")
        return root_index

    def _fetch_all_recursively(self, parent_index: QModelIndex) -> None:
        """Recursively fetches all items under the parent index."""
        if not parent_index.isValid():
            return

        # Fetch immediate children first
        if self.canFetchMore(parent_index):
             # logger.debug(f"Fetching more for index: {self.filePath(parent_index)}") # Can be very verbose
             self.fetchMore(parent_index)
             # Loop required because fetchMore might not fetch everything in one go
             while self.canFetchMore(parent_index):
                 QApplication.processEvents() # Process events to keep UI responsive during fetch
                 self.fetchMore(parent_index)


        # Recursively fetch for child directories
        row_count = self.rowCount(parent_index)
        for row in range(row_count):
            child_index = self.index(row, 0, parent_index)
            if child_index.isValid() and self.isDir(child_index):
                self._fetch_all_recursively(child_index)


class CheckableProxyModel(QSortFilterProxyModel):
    """ Proxy model providing checkable items and filtering based on ignore patterns. """
    def __init__(self, fs_model: FilteredFileSystemModel, project_folder_getter: Callable[[], Optional[str]], fs_service: FilesystemService, tree_view: QTreeView, parent=None):
        super().__init__(parent)
        self.fs_model = fs_model
        self.project_folder_getter = project_folder_getter
        self.fs_service = fs_service
        self.tree_view = tree_view
        self.checked_files_dict: Dict[str, bool] = {} # Stores {file_path: is_checked}
        self._ignore_patterns: Set[str] = set()
        self._is_setting_data = False # Flag to prevent recursive setData calls

    def set_ignore_patterns(self, patterns: Set[str]):
        """Sets the ignore patterns used for filtering."""
        if self._ignore_patterns != patterns:
            logger.info(f"Setting ignore patterns. Count: {len(patterns)}")
            logger.debug(f"Ignore patterns: {patterns}")
            self._ignore_patterns = patterns
            self.invalidateFilter() # Trigger filter update

    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool:
        """Determines if a row should be shown based on ignore patterns."""
        source_index = self.sourceModel().index(source_row, 0, source_parent)
        if not source_index.isValid(): return False

        file_path = self.sourceModel().filePath(source_index)
        project_root = self.project_folder_getter()

        if not project_root or not file_path.startswith(project_root): return True # Show if outside project
        if file_path == project_root: return True # Always show project root

        is_dir = self.sourceModel().isDir(source_index)
        should_ignore = self.fs_service.should_ignore(file_path, project_root, self._ignore_patterns, is_dir)

        if should_ignore:
            if file_path in self.checked_files_dict:
                logger.debug(f"Removing filtered item from checked_files_dict: {file_path}")
                del self.checked_files_dict[file_path]
            # logger.debug(f"Ignoring path: {file_path}") # Can be verbose
            return False

        return True

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """Returns data for the item, including check state and file size."""
        if not index.isValid(): return None

        if index.column() == 0:
            if role == Qt.ItemDataRole.CheckStateRole:
                file_path = self.get_file_path_from_index(index)
                is_checked = self.checked_files_dict.get(file_path, False)
                return Qt.CheckState.Checked if is_checked else Qt.CheckState.Unchecked
            elif role == Qt.ItemDataRole.DisplayRole:
                base_name = super().data(index, role); src_index = self.mapToSource(index)
                if src_index.isValid() and not self.fs_model.isDir(src_index):
                    file_path = self.fs_model.filePath(src_index)
                    try: size = os.path.getsize(file_path); return f"{base_name} ({size:,} bytes)"
                    except OSError: return f"{base_name} (size error)"
                return base_name

        return super().data(index, role)

    def flags(self, index: QModelIndex) -> Qt.ItemFlag:
        """Returns item flags, adding ItemIsUserCheckable."""
        flags = super().flags(index)
        if index.column() == 0: flags |= Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsSelectable
        return flags

    def setData(self, index: QModelIndex, value: Any, role: int = Qt.ItemDataRole.EditRole) -> bool:
        """Sets data for the item, handling check state changes."""
        if self._is_setting_data: return False # Prevent recursion
        if index.column() != 0 or role != Qt.ItemDataRole.CheckStateRole: return super().setData(index, value, role)

        file_path = self.get_file_path_from_index(index)
        if not file_path: logger.warning(f"setData failed: Could not get file path for index {index.row()},{index.column()}"); return False

        logger.debug(f"▶ setData called: path={os.path.basename(file_path)}, role={role}, value={value}")
        self._is_setting_data = True
        try:
            if isinstance(value, Qt.CheckState): new_check_state = value
            elif isinstance(value, int): new_check_state = Qt.CheckState(value)
            else: logger.warning(f"setData: Unexpected value type for CheckStateRole: {type(value)}"); self._is_setting_data = False; return False

            is_checked = (new_check_state == Qt.CheckState.Checked)
            # Use get() with default False for cleaner check
            current_state_in_dict = self.checked_files_dict.get(file_path, False)

            if is_checked == current_state_in_dict:
                logger.debug(f"setData: No state change needed for {os.path.basename(file_path)}. Current: {current_state_in_dict}, New: {is_checked}")
                self._is_setting_data = False; return True

            logger.debug(f"setData processing state change for: {os.path.basename(file_path)}, New state: {is_checked}")

            if is_checked: self.checked_files_dict[file_path] = True; logger.debug(f"  Checked and added to dict: {os.path.basename(file_path)}")
            elif file_path in self.checked_files_dict: del self.checked_files_dict[file_path]; logger.debug(f"  Unchecked and removed from dict: {os.path.basename(file_path)}")

            indices_to_signal = {index} # Start with the initially clicked/changed index

            src_index = self.mapToSource(index)
            if src_index.isValid() and self.fs_model.isDir(src_index):
                logger.debug(f"  {os.path.basename(file_path)} is a directory. Updating children...")
                self.ensure_loaded(src_index)
                changed_children_indices = self.update_children_state(src_index, is_checked)
                indices_to_signal.update(changed_children_indices)
                logger.debug(f"  Finished updating children for {os.path.basename(file_path)}. Signalling {len(indices_to_signal)} indices.")
                if is_checked: logger.debug(f"  Expanding checked folder: {os.path.basename(file_path)}"); self.expand_index_recursively(index)

            logger.debug(f"Emitting dataChanged for {len(indices_to_signal)} indices related to {os.path.basename(file_path)}.")
            # Emit dataChanged for all affected indices *after* processing is complete
            # Combine emission into fewer calls if possible, but individual signals ensure UI updates
            for idx_to_signal in indices_to_signal:
                if idx_to_signal.isValid():
                    # logger.debug(f"    Emitting dataChanged for: {os.path.basename(self.get_file_path_from_index(idx_to_signal) or 'Invalid')}")
                    self.dataChanged.emit(idx_to_signal, idx_to_signal, [Qt.ItemDataRole.CheckStateRole])

            logger.debug(f"setData returning True for path: {os.path.basename(file_path)}")
            return True
        except Exception as e: logger.exception(f"Error in setData for path {file_path}: {e}"); return False
        finally: self._is_setting_data = False; logger.debug("setData flag released.")

    def ensure_loaded(self, parent_src_index: QModelIndex):
        """Ensures all children under the parent source index are loaded."""
        if parent_src_index.isValid() and hasattr(self.fs_model, '_fetch_all_recursively'):
            # logger.debug(f"Ensuring children are loaded for: {self.fs_model.filePath(parent_src_index)}") # Can be verbose
            self.fs_model._fetch_all_recursively(parent_src_index)

    def update_children_state(self, parent_src_index: QModelIndex, checked: bool) -> Set[QModelIndex]:
        """ Recursively updates check state for all visible children. """
        changed_indices = set()
        row_count = self.fs_model.rowCount(parent_src_index)
        # parent_path = self.fs_model.filePath(parent_src_index) # For logging
        # logger.debug(f"    Updating children state for {os.path.basename(parent_path)}, checked={checked}, children={row_count}")

        for row in range(row_count):
            child_src_index = self.fs_model.index(row, 0, parent_src_index)
            if not child_src_index.isValid(): continue

            child_proxy_index = self.mapFromSource(child_src_index)
            if not child_proxy_index.isValid(): continue # Skip filtered items

            file_path = self.fs_model.filePath(child_src_index)
            current_state_in_dict = self.checked_files_dict.get(file_path, False)
            needs_update = (checked != current_state_in_dict)

            if needs_update:
                if checked: self.checked_files_dict[file_path] = True
                elif file_path in self.checked_files_dict: del self.checked_files_dict[file_path]
                changed_indices.add(child_proxy_index)
                # logger.debug(f"      Child state changed: {os.path.basename(file_path)}")

            if self.fs_model.isDir(child_src_index):
                self.ensure_loaded(child_src_index)
                grandchildren_indices = self.update_children_state(child_src_index, checked)
                changed_indices.update(grandchildren_indices)

        return changed_indices

    def expand_index_recursively(self, proxy_index: QModelIndex):
        """Recursively expands the given index and its children."""
        if not proxy_index.isValid(): return
        self.tree_view.expand(proxy_index)
        child_count = self.rowCount(proxy_index)
        for row in range(child_count):
            child_proxy_idx = self.index(row, 0, proxy_index)
            if child_proxy_idx.isValid():
                 child_src_idx = self.mapToSource(child_proxy_idx)
                 if self.fs_model.isDir(child_src_idx): self.expand_index_recursively(child_proxy_idx)

    def get_file_path_from_index(self, proxy_index: QModelIndex) -> Optional[str]:
        """Gets the file path from a proxy index."""
        src_index = self.mapToSource(proxy_index)
        return self.fs_model.filePath(src_index) if src_index.isValid() else None

    def get_all_checked_paths(self) -> List[str]:
        """Returns a list of all paths currently marked as checked."""
        paths = list(self.checked_files_dict.keys())
        logger.debug(f"get_all_checked_paths returning {len(paths)} paths.")
        return paths

    def get_checked_files(self) -> List[str]:
        """Returns a list of checked paths that correspond to actual files."""
        checked_files = [path for path in self.checked_files_dict if os.path.isfile(path)]
        logger.debug(f"get_checked_files returning {len(checked_files)} file paths.")
        return checked_files



======== src\ui\models\remote_file_system_model.py ========
import os
import stat
import datetime
import logging
import socket
import asyncio # asyncio 추가
from typing import Optional, List, Dict, Any, Set, Union, AsyncIterator # AsyncIterator 추가
from PyQt6.QtCore import (
    QAbstractItemModel, QModelIndex, Qt, QObject, pyqtSignal, QRunnable, QThreadPool, QMutex, QMutexLocker, QThread, QTimer # QTimer 추가
)
from PyQt6.QtGui import QIcon, QColor, QBrush
from PyQt6.QtWidgets import QApplication, QStyle
import asyncssh # paramiko 대신 asyncssh import

logger = logging.getLogger(__name__)

# --- SFTP Fetch Worker 제거 ---

# --- Remote File System Model ---
class RemoteFileSystemModel(QAbstractItemModel):
    """
    A QAbstractItemModel implementation for browsing remote filesystems via AsyncSSH SFTP.
    Loads directory contents asynchronously using scandir.
    """
    # --- Signals ---
    fetchCompleted = pyqtSignal(str, bool) # path, success

    # --- Internal Data Structure ---
    # _children: Dict[str, List[Dict[str, Any]]] - Parent path -> List of child SFTPName dicts
    # _fetched: Set[str] - Paths whose children have been successfully fetched
    # _fetching: Dict[str, asyncio.Task] - Paths currently being fetched -> associated asyncio Task
    # _errors: Dict[str, str] - Path-specific error messages

    def __init__(self, sftp_client: asyncssh.SFTPClient, root_path: str = "/", parent: Optional[QObject] = None):
        super().__init__(parent)
        self.sftp_client = sftp_client
        self.root_path = self._normalize_path(root_path)
        self._children: Dict[str, List[Dict[str, Any]]] = {}
        # Removed _path_map and _index_map, relying on internalPointer and parent logic
        self._fetched: Set[str] = set()
        self._fetching: Dict[str, asyncio.Task] = {} # path -> asyncio.Task
        self._errors: Dict[str, str] = {}
        self._mutex = QMutex()

        logger.info(f"RemoteFileSystemModel initialized with root: '{self.root_path}'")
        self._fetch_children_if_needed(self.root_path)

    def _normalize_path(self, path: str) -> str:
        """Normalizes SFTP paths (use forward slashes, remove trailing slash unless root)."""
        path = path.replace("\\", "/")
        if path != "/" and path.endswith("/"):
            path = path[:-1]
        return path if path else "/" # Ensure root path is "/" if empty

    def _get_path(self, index: QModelIndex) -> Optional[str]:
        """Retrieves the absolute path associated with a QModelIndex's internal pointer."""
        if not index.isValid():
            return self.root_path
        internal_ptr = index.internalPointer()
        # Ensure the internal pointer is a string (the path)
        return internal_ptr if isinstance(internal_ptr, str) else None

    def _get_child_data(self, path: str) -> Optional[Dict[str, Any]]:
        """Finds the cached data dictionary for a given path."""
        parent_path = self._get_parent_path(path)
        if parent_path is None: return None # Cannot get data for root this way
        with QMutexLocker(self._mutex):
            children = self._children.get(parent_path)
            if children:
                filename = os.path.basename(path)
                for child_data in children:
                    if child_data.get('filename') == filename:
                        return child_data
        return None

    def _get_attributes_from_data(self, data: Optional[Dict[str, Any]]) -> Optional[asyncssh.SFTPAttrs]:
         """Converts cached attribute dictionary back to SFTPAttrs (if needed, currently basic)."""
         if data and 'attrs' in data and isinstance(data['attrs'], dict):
             # Create SFTPAttrs from dict - needs proper reconstruction if complex
             # For basic use (like checking S_ISDIR), direct dict access might suffice
             try:
                 # Attempt basic reconstruction assuming simple types
                 return asyncssh.SFTPAttrs(data['attrs'])
             except Exception:
                 # Fallback: return the dict itself for direct access like data['attrs'].get('st_mode')
                 return data['attrs'] # Return the dict for simple access
         return None


    def _get_parent_path(self, path: str) -> Optional[str]:
        """Gets the parent path of a given path."""
        if path == self.root_path or not path:
            return None
        # Use os.path.dirname and normalize
        parent = self._normalize_path(os.path.dirname(path))
        # Handle cases like dirname('/') -> '/'
        return parent if parent != path else None

    # --- QAbstractItemModel Overrides ---

    def index(self, row: int, column: int, parent: QModelIndex = QModelIndex()) -> QModelIndex:
        """Creates a QModelIndex for the given row, column, and parent."""
        parent_path = self._get_path(parent)
        if parent_path is None:
             logger.warning(f"index(): Invalid parent path for parent index {parent.row()},{parent.column()}")
             return QModelIndex()

        with QMutexLocker(self._mutex):
            children_data = self._children.get(parent_path)
            if children_data is None or not (0 <= row < len(children_data)):
                return QModelIndex()

            child_data = children_data[row]
            child_filename = child_data.get('filename')
            if child_filename is None: return QModelIndex() # Should not happen

            # Construct child path correctly using forward slashes
            child_path = self._normalize_path(f"{parent_path.rstrip('/')}/{child_filename}")

            # Use the child_path itself as the internal pointer
            new_index = self.createIndex(row, column, child_path)
            return new_index

    def parent(self, child: QModelIndex) -> QModelIndex:
        """Returns the parent QModelIndex for the given child index."""
        if not child.isValid():
            return QModelIndex()

        child_path = self._get_path(child)
        if child_path is None or child_path == self.root_path:
            return QModelIndex()

        parent_path = self._get_parent_path(child_path)
        if parent_path is None: # Child is likely directly under root
             # Return an invalid QModelIndex representing the root
             return QModelIndex()

        # Find the parent's row within its parent (grandparent)
        grandparent_path = self._get_parent_path(parent_path)
        if grandparent_path is None: # Parent is directly under root
            grandparent_path = self.root_path # Use root path for lookup

        with QMutexLocker(self._mutex):
            grandparent_children_data = self._children.get(grandparent_path)
            if grandparent_children_data:
                parent_filename = os.path.basename(parent_path)
                for i, sibling_data in enumerate(grandparent_children_data):
                    if sibling_data.get('filename') == parent_filename:
                        # Create the parent index using its path as internal pointer
                        parent_index = self.createIndex(i, 0, parent_path)
                        return parent_index

        logger.warning(f"parent(): Could not find parent index for '{child_path}' (parent path: '{parent_path}')")
        return QModelIndex()


    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """Returns the number of children for the given parent index."""
        parent_path = self._get_path(parent)
        if parent_path is None:
            return 0
        with QMutexLocker(self._mutex):
            children = self._children.get(parent_path)
            count = len(children) if children is not None else 0
            # If not fetched and not fetching, canFetchMore will trigger fetchMore
            # If fetching, return 0 for now, UI will update when fetch finishes
            if children is None and parent_path not in self._fetching:
                 pass # canFetchMore will handle triggering
            elif children is None and parent_path in self._fetching:
                 return 0 # Still fetching
            return count

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """Returns the number of columns (always 1)."""
        return 1

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """Returns the data for the given index and role."""
        if not index.isValid():
            return None

        path = self._get_path(index)
        if path is None: return None

        # Get cached child data
        child_data = self._get_child_data(path)
        filename = os.path.basename(path) if child_data else (path if path == self.root_path else os.path.basename(path))
        attrs_dict = child_data.get('attrs') if child_data else None

        if role == Qt.ItemDataRole.DisplayRole:
            # Return filename as string (decoding if necessary)
            if isinstance(filename, bytes):
                try: return filename.decode('utf-8', errors='replace')
                except UnicodeDecodeError: return filename.decode('latin-1', errors='replace') # Fallback
            return str(filename) # Ensure it's a string
        elif role == Qt.ItemDataRole.DecorationRole:
            is_dir = False
            if attrs_dict and 'st_mode' in attrs_dict:
                 try:
                      is_dir = stat.S_ISDIR(attrs_dict['st_mode'])
                 except TypeError: pass # Handle potential non-integer st_mode if dict conversion was lossy
            elif path == self.root_path: # Assume root is a directory
                is_dir = True

            icon_name = "folder-remote" if is_dir else "text-x-generic"
            standard_icon = QStyle.StandardPixmap.SP_DirIcon if is_dir else QStyle.StandardPixmap.SP_FileIcon
            # Try theme icon first, fallback to standard Qt icon
            icon = QIcon.fromTheme(icon_name, QApplication.style().standardIcon(standard_icon))
            return icon
        elif role == Qt.ItemDataRole.ToolTipRole:
            if attrs_dict:
                try:
                    size_str = f"{attrs_dict.get('size', 'N/A'):,}" if attrs_dict.get('size') is not None else "N/A"
                    mtime_epoch = attrs_dict.get('mtime')
                    mtime_str = datetime.datetime.fromtimestamp(mtime_epoch).strftime('%Y-%m-%d %H:%M:%S') if mtime_epoch is not None else "N/A"
                    return f"Path: {path}\nSize: {size_str} bytes\nModified: {mtime_str}"
                except Exception as e:
                    logger.warning(f"Error formatting tooltip for {path}: {e}")
                    return path
            # Display error if exists
            with QMutexLocker(self._mutex):
                 if path in self._errors:
                     return f"Error: {self._errors[path]}"
            return path
        # Foreground role for errors
        elif role == Qt.ItemDataRole.ForegroundRole:
             with QMutexLocker(self._mutex):
                 if path in self._errors:
                     return QBrush(Qt.GlobalColor.red)
        return None

    def flags(self, index: QModelIndex) -> Qt.ItemFlag:
        """Returns the flags for the item."""
        # Basic flags: Enabled and Selectable. No editing, no checkboxes for remote.
        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable

    def hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool:
        """Returns true if the parent item is a directory."""
        path = self._get_path(parent)
        if path is None: return False

        # Root always potentially has children
        if path == self.root_path: return True

        child_data = self._get_child_data(path)
        attrs_dict = child_data.get('attrs') if child_data else None
        if attrs_dict and 'st_mode' in attrs_dict:
             try:
                  return stat.S_ISDIR(attrs_dict['st_mode'])
             except TypeError: return False # Error reading st_mode
        # If attributes not yet fetched, assume it *might* have children if it looks like a dir
        # This might need refinement based on how often attributes are missing initially
        return True # Optimistic default for directories without attributes yet

    def canFetchMore(self, parent: QModelIndex) -> bool:
        """Returns true if more children can be fetched for the parent."""
        path = self._get_path(parent)
        if path is None: return False

        is_dir = self.hasChildren(parent) # Use hasChildren to determine if it's likely a directory

        with QMutexLocker(self._mutex):
            can_fetch = is_dir and path not in self._fetched and path not in self._fetching
            return can_fetch

    def fetchMore(self, parent: QModelIndex):
        """Fetches children for the parent index asynchronously using asyncio.create_task."""
        path = self._get_path(parent)
        if path is None: return

        with QMutexLocker(self._mutex):
            if path in self._fetching or path in self._fetched:
                return # Already fetching or fetched
            # Store the asyncio task in _fetching
            task = None # Placeholder
            self._fetching[path] = task # Store placeholder initially
            logger.info(f"fetchMore(): Scheduling async fetch task for '{path}'")

        async def do_fetch():
            nonlocal task # Allow modification of outer scope task variable
            current_task = asyncio.current_task() # Get the current task
            with QMutexLocker(self._mutex):
                 # Update the placeholder with the actual task
                 if path in self._fetching and self._fetching[path] is None:
                     self._fetching[path] = current_task
                 task = self._fetching.get(path) # Get the stored task

            # Check if the task was cancelled immediately after scheduling
            if task and task.cancelled():
                 logger.info(f"Async fetch task for '{path}' cancelled before starting.")
                 with QMutexLocker(self._mutex):
                      self._fetching.pop(path, None) # Clean up fetching state
                 return

            logger.info(f"Async fetch task started for '{path}' (Task: {id(task)})")
            children_data = []
            error_msg = None
            try:
                # Check SFTP client state before proceeding
                # Removed sftp_client.is_closed() check as it doesn't exist
                if not self.sftp_client:
                     raise asyncssh.SFTPError(asyncssh.FX_NO_CONNECTION, "SFTP client is not available")

                start_time = datetime.datetime.now()
                async for item in self.sftp_client.scandir(path):
                    # Check for cancellation within the loop
                    if task and task.cancelled():
                         logger.info(f"Async fetch task for '{path}' cancelled during scandir.")
                         raise asyncio.CancelledError()

                    # Convert SFTPName to a serializable dictionary
                    attr_dict = {}
                    if item.attrs:
                        # Use getattr with default None for potentially missing attributes
                        for attr_name in ['filename', 'longname', 'type', 'size', 'alloc_size', 'uid', 'gid', 'owner', 'group', 'permissions', 'atime', 'atime_ns', 'crtime', 'crtime_ns', 'mtime', 'mtime_ns', 'ctime', 'ctime_ns', 'acl', 'attrib_bits', 'attrib_valid', 'text_hint', 'mime_type', 'nlink', 'untrans_name', 'extended']:
                            val = getattr(item.attrs, attr_name, None)
                            if val is not None: # Only add if attribute exists
                                if isinstance(val, datetime.datetime): val = val.isoformat() # Example serialization
                                elif isinstance(val, bytes) and attr_name != 'filename': # Avoid decoding filename if bytes
                                     try: val = val.decode('utf-8', errors='ignore') # Decode other bytes safely
                                     except UnicodeDecodeError: val = f"<bytes len={len(val)}>" # Fallback for non-utf8 bytes
                                # Add other type conversions if needed
                                attr_dict[attr_name] = val
                        if 'permissions' in attr_dict and attr_dict['permissions'] is not None:
                             attr_dict['st_mode'] = attr_dict['permissions']

                    children_data.append({
                        'filename': item.filename, # Keep filename as bytes/str as received
                        'longname': item.longname, # Keep longname as bytes/str
                        'attrs': attr_dict
                    })
                end_time = datetime.datetime.now()
                duration = (end_time - start_time).total_seconds()
                logger.info(f"Async fetch task: scandir successful for '{path}', {len(children_data)} items in {duration:.3f}s.")

            except asyncio.CancelledError:
                logger.info(f"Async fetch task for '{path}' was cancelled.")
                error_msg = "Operation cancelled" # Specific error for cancellation
            # Updated exception handling: Removed ChannelClosed, added ConnectionLost
            except (asyncssh.SFTPError, OSError, asyncssh.ConnectionLost) as e:
                code = getattr(e, 'code', 'Unknown')
                reason = getattr(e, 'reason', str(e)) if hasattr(e, 'reason') else str(e)
                error_msg = f"{code}: {reason}"
                logger.error(f"Async fetch task: SFTP/OS Error scanning '{path}': {error_msg}")
            except Exception as e:
                error_msg = f"Unexpected error: {e}"
                logger.exception(f"Async fetch task: Unexpected SFTP Error scanning '{path}'")
            finally:
                # Call the appropriate handler in the main Qt thread
                # Use QTimer.singleShot to ensure it runs in the Qt event loop
                if error_msg is not None:
                    QTimer.singleShot(0, lambda p=path, msg=error_msg: self._on_fetch_error(p, msg))
                else:
                    # Pass children_data directly
                    QTimer.singleShot(0, lambda p=path, data=children_data: self._on_fetch_finished(p, data))
                # Clean up the task reference from _fetching dict in the main thread
                QTimer.singleShot(0, lambda p=path: self._cleanup_fetching_task(p))

        # Schedule the async task using asyncio.create_task
        try:
            # This assumes the Qt event loop is integrated with asyncio (e.g., via qasync)
            task = asyncio.create_task(do_fetch())
            logger.debug(f"Async fetch task created for '{path}' (Task ID: {id(task)})")
            # Store the actual task object now
            with QMutexLocker(self._mutex):
                 if path in self._fetching: # Ensure the placeholder is updated
                     self._fetching[path] = task
                 else: # Should not happen if logic is correct, but handle defensively
                      logger.warning(f"Path '{path}' not found in _fetching dict when storing task.")
                      task.cancel() # Cancel if state is inconsistent
        except RuntimeError as e:
            # Handle case where event loop might not be running or available
            logger.error(f"Failed to create async fetch task for '{path}': {e}")
            # Fallback or error handling: call error handler immediately
            QTimer.singleShot(0, lambda p=path, msg=f"Failed to schedule task: {e}": self._on_fetch_error(p, msg))
            # Clean up fetching state
            with QMutexLocker(self._mutex):
                 self._fetching.pop(path, None)


    def _cleanup_fetching_task(self, path: str):
        """Removes the task reference from the _fetching dictionary."""
        with QMutexLocker(self._mutex):
            if path in self._fetching:
                del self._fetching[path]
            else:
                logger.warning(f"Tried to cleanup fetching task reference for path '{path}', but it was not found.")


    # --- Background Fetch Callbacks ---

    def _on_fetch_finished(self, path: str, children_data: List[Dict[str, Any]]):
        """Callback when SFTP fetch worker finishes successfully."""
        logger.info(f"_on_fetch_finished(): Received {len(children_data)} items for '{path}'")
        parent_index = self._find_index_for_path(path)
        if not parent_index.isValid() and path != self.root_path:
            logger.warning(f"_on_fetch_finished(): Could not find valid parent index for path '{path}'. Cannot insert rows.")
            with QMutexLocker(self._mutex):
                # self._fetching.discard(path) # Already removed in _cleanup_fetching_task
                self._fetched.add(path) # Assume fetched even if index not found
            self.fetchCompleted.emit(path, False) # Emit failure signal
            return

        with QMutexLocker(self._mutex):
            if path in self._fetched:
                 logger.warning(f"_on_fetch_finished(): Path '{path}' was already marked as fetched. Ignoring.")
                 # self._fetching.discard(path) # Already removed
                 return

            # Sort children data by filename BEFORE inserting
            # Sort directories first, then files, alphabetically within each group
            children_data.sort(key=lambda x: (
                not stat.S_ISDIR(x.get('attrs', {}).get('st_mode', 0)), # False for dirs (comes first)
                str(x.get('filename', '')).lower() # Case-insensitive filename sort
            ))


            row_count = len(children_data)
            logger.debug(f"_on_fetch_finished: Preparing to insert {row_count} rows for parent index of path '{path}'.") # Log before beginInsertRows
            if row_count > 0:
                self.beginInsertRows(parent_index, 0, row_count - 1)

            self._children[path] = children_data
            self._fetched.add(path)
            # self._fetching.discard(path) # Already removed
            self._errors.pop(path, None)

            if row_count > 0:
                self.endInsertRows()
                logger.debug(f"_on_fetch_finished: endInsertRows called for path '{path}'.") # Log after endInsertRows

            if path == self.root_path:
                 logger.info(f"Initial root directory ('{self.root_path}') listing complete.")

        # Emit success signal AFTER model updates are done
        self.fetchCompleted.emit(path, True)

    def _on_fetch_error(self, path: str, error_message: str):
        """Callback when SFTP fetch worker encounters an error."""
        logger.error(f"_on_fetch_error(): Error fetching children for '{path}': {error_message}")
        with QMutexLocker(self._mutex):
            # self._fetching.discard(path) # Already removed
            self._fetched.add(path) # Mark as fetched to avoid retry loops on error
            self._errors[path] = error_message

            error_index = self._find_index_for_path(path)
            if error_index.isValid() or path == self.root_path: # Handle root error display too
                 effective_index = error_index if error_index.isValid() else QModelIndex()
                 logger.debug(f"Emitting dataChanged for error node: {path}")
                 self.dataChanged.emit(effective_index, effective_index, [Qt.ItemDataRole.ToolTipRole, Qt.ItemDataRole.ForegroundRole])

        # Emit failure signal
        self.fetchCompleted.emit(path, False)

    def _find_index_for_path(self, path: str) -> QModelIndex:
         """Helper to find the QModelIndex corresponding to a path using internal pointers."""
         if path == self.root_path:
              return QModelIndex() # Root is represented by invalid index

         parent_path = self._get_parent_path(path)
         # If parent_path is None, it means 'path' is directly under root
         parent_index = QModelIndex() if parent_path is None else self._find_index_for_path(parent_path) # Recursive call

         # Determine the grandparent path for lookup
         lookup_path = self.root_path if parent_path is None else parent_path

         # Find the row of 'path' within its parent's children
         with QMutexLocker(self._mutex):
              children_data = self._children.get(lookup_path)
              if children_data:
                   filename = os.path.basename(path)
                   for row, child_data in enumerate(children_data):
                       # Handle filename possibly being bytes
                       child_filename = child_data.get('filename')
                       if isinstance(filename, bytes):
                           filename_str = filename.decode('utf-8', errors='replace')
                       else:
                           filename_str = filename

                       if isinstance(child_filename, bytes):
                           child_filename_str = child_filename.decode('utf-8', errors='replace')
                       else:
                           child_filename_str = str(child_filename) # Ensure string

                       if child_filename_str == filename_str:
                           # Create index with path as internal pointer
                           return self.createIndex(row, 0, path)
         return QModelIndex()


    # --- Public Methods ---

    def update_sftp_client(self, new_sftp_client: asyncssh.SFTPClient):
        """Updates the SFTP client instance."""
        logger.info("Updating SFTP client in RemoteFileSystemModel.")
        # Cancel any ongoing workers before changing the client
        self.cancel_all_fetches()
        self.sftp_client = new_sftp_client
        self.reset()

    def set_root_path(self, new_root_path: str):
        """Sets a new root path for the model."""
        normalized_path = self._normalize_path(new_root_path)
        if self.root_path != normalized_path:
            logger.info(f"Setting new root path in RemoteFileSystemModel: '{normalized_path}'")
            self.cancel_all_fetches() # Cancel fetches before resetting root
            self.root_path = normalized_path
            self.reset()

    def reset(self):
        """Resets the internal state of the model."""
        logger.info("Resetting RemoteFileSystemModel internal state.")
        # Cancel any ongoing workers
        self.cancel_all_fetches()
        self.beginResetModel()
        with QMutexLocker(self._mutex):
            self._children.clear()
            self._fetched.clear()
            self._fetching.clear() # Clear fetching dict as well
            self._errors.clear()
        self.endResetModel()
        # Only fetch root if sftp client is valid
        # Removed sftp_client.is_closed() check
        if self.sftp_client:
             self._fetch_children_if_needed(self.root_path)
        else:
             logger.warning("SFTP client not available during reset, skipping initial fetch.")


    def refresh(self, index: QModelIndex = QModelIndex()):
        """Refreshes the directory listing for the given index (or root)."""
        path = self._get_path(index)
        if path is None: return

        logger.info(f"Refreshing directory listing for: '{path}'")
        # Cancel existing fetch task for this path, if any
        self.cancel_fetch(path)

        # Clear cache and state for this path only, then refetch
        with QMutexLocker(self._mutex):
            existing_children = self._children.pop(path, None)
            self._fetched.discard(path)
            self._fetching.pop(path, None) # Remove from fetching dict
            self._errors.pop(path, None)

        if existing_children:
            parent_idx = self.parent(index) # Use the correct parent index
            logger.debug(f"Refreshing: Removing {len(existing_children)} rows for parent index of '{path}'")
            self.beginRemoveRows(parent_idx, 0, len(existing_children) - 1)
            self.endRemoveRows()
            logger.debug(f"Refreshing: Rows removed for '{path}'")


        # Trigger fetching again
        # Removed sftp_client.is_closed() check
        if self.sftp_client:
             self._fetch_children_if_needed(path)
        else:
             logger.warning(f"Cannot refresh '{path}': SFTP client not available.")


    def _fetch_children_if_needed(self, path: str):
         """Initiates fetching children if the path is a directory and not fetched/fetching."""
         parent_index = self._find_index_for_path(path)
         if not parent_index.isValid() and path != self.root_path:
              logger.warning(f"_fetch_children_if_needed: Could not find index for path '{path}'. Fetch aborted.")
              return

         # Check if it's potentially a directory before fetching
         child_data = self._get_child_data(path)
         attrs_dict = child_data.get('attrs') if child_data else None
         is_known_file = False
         if attrs_dict and 'st_mode' in attrs_dict:
             try:
                  if not stat.S_ISDIR(attrs_dict['st_mode']):
                      is_known_file = True
             except TypeError: pass # Ignore if st_mode is invalid

         if is_known_file:
              logger.debug(f"_fetch_children_if_needed: Path '{path}' is known to be a file. Skipping fetch.")
              return

         # Proceed with fetchMore if it's the root or not known to be a file
         self.fetchMore(parent_index)


    def cancel_fetch(self, path: str):
        """Cancels an ongoing fetch operation for a specific path."""
        with QMutexLocker(self._mutex):
            task = self._fetching.pop(path, None) # Remove and get task
        if task:
            logger.info(f"Cancelling fetch task for path '{path}' (Task ID: {id(task)})")
            if not task.done():
                task.cancel()
                logger.info(f"Fetch task for '{path}' cancelled.")
            else:
                logger.debug(f"Fetch task for '{path}' was already done.")
            # Note: The task itself will handle cleanup in its finally block
            # and call _on_fetch_error with a cancellation message.
        else:
            logger.debug(f"No active fetch task found to cancel for path '{path}'.")

    def cancel_all_fetches(self):
        """Cancels all ongoing fetch operations."""
        with QMutexLocker(self._mutex):
            paths_to_cancel = list(self._fetching.keys())
            logger.info(f"Cancelling all ({len(paths_to_cancel)}) ongoing fetch tasks...")
            for path in paths_to_cancel:
                task = self._fetching.pop(path, None)
                if task:
                    logger.debug(f"  Cancelling task for path '{path}' (Task ID: {id(task)})")
                    if not task.done():
                         task.cancel()
                         logger.info(f"  Fetch task for '{path}' cancelled.")
                    else:
                         logger.debug(f"  Fetch task for '{path}' was already done.")
        logger.info("All fetch tasks cancellation requests sent.")

  


======== src\ui\widgets\__init__.py ========
# This file makes Python treat the directory widgets as a package.



======== src\ui\widgets\check_box_delegate.py ========
# src/ui/widgets/check_box_delegate.py
from PyQt6.QtCore import Qt, QEvent, QRect, QModelIndex, QAbstractItemModel
from PyQt6.QtWidgets import QStyledItemDelegate, QApplication, QStyleOptionViewItem, QWidget, QStyle
from PyQt6.QtGui import QMouseEvent
import logging

logger = logging.getLogger(__name__)

class CheckBoxDelegate(QStyledItemDelegate):
    """
    Delegate to handle checkbox clicks only within the checkbox area.
    """
    def __init__(self, parent: QWidget = None):
        super().__init__(parent)

    def editorEvent(self, event: QEvent, model: QAbstractItemModel, option: QStyleOptionViewItem, index: QModelIndex) -> bool:
        """ Handles mouse clicks to toggle checkbox state. """
        if index.column() != 0:
            return super().editorEvent(event, model, option, index)

        if event.type() == QEvent.Type.MouseButtonRelease and isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            style = QApplication.style() if self.parent() is None else self.parent().style()
            # Ensure option is valid and has the CheckIndicator feature before getting the rect
            if not option or not (option.features & QStyleOptionViewItem.ViewItemFeature.HasCheckIndicator):
                 logger.debug("editorEvent: Index has no check indicator.")
                 return super().editorEvent(event, model, option, index) # No checkbox, default handling

            cb_rect = style.subElementRect(QStyle.SubElement.SE_ItemViewItemCheckIndicator, option, self.parent())

            if cb_rect.contains(event.position().toPoint()):
                current_value = model.data(index, Qt.ItemDataRole.CheckStateRole)
                logger.debug(f"Checkbox clicked at index {index.row()},{index.column()}. Current value: {current_value}")

                if isinstance(current_value, Qt.CheckState): current_state = current_value
                elif isinstance(current_value, int): current_state = Qt.CheckState(current_value)
                else: logger.warning(f"Unexpected data type for CheckStateRole: {type(current_value)}"); return False

                new_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked
                logger.debug(f"Attempting setData for index {index.row()},{index.column()} with state {new_state}")
                # Use model().setData to ensure proxy model logic (recursion check, etc.) is triggered
                success = model.setData(index, new_state, Qt.ItemDataRole.CheckStateRole)
                logger.debug(f"setData call result: {success}")
                if success: return True # Event handled
                else: logger.warning(f"setData failed for index {index.row()},{index.column()}"); return False

        # Handle other events (like key presses if needed) with default behavior
        return super().editorEvent(event, model, option, index)

    # paint method uses default QStyledItemDelegate behavior



======== src\ui\widgets\custom_tab_bar.py ========

from PyQt6.QtWidgets import QTabBar, QTabWidget, QInputDialog, QMessageBox, QMainWindow # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6
from PyQt6.QtGui import QMouseEvent # PyQt5 -> PyQt6
from .tab_manager import is_tab_deletable

class CustomTabBar(QTabBar):
    """
    Custom tab bar with features like adding new tabs, closing tabs with middle-click,
    and renaming tabs with double-click.
    """
    def __init__(self, parent: QTabWidget, main_window: QMainWindow):
        super().__init__(parent)
        self.main_window = main_window # MainWindow 참조 (새 탭 추가 시 필요)
        self.setTabsClosable(False) # 기본 닫기 버튼 숨김 (미들 클릭 사용)
        self.setMovable(True) # 탭 이동 가능
        # "+" 탭 추가 (새 탭 생성용)
        self.addTab("+")

    def mousePressEvent(self, event: QMouseEvent):
        """Handles left mouse button press for adding new tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            # "+" 탭 클릭 시 새 탭 추가 동작 연결
            if index >= 0 and self.tabText(index) == "+":
                # MainWindow의 메서드를 호출하여 새 탭 추가
                if hasattr(self.main_window, 'add_new_custom_tab'):
                    self.main_window.add_new_custom_tab()
                return # 이벤트 처리 완료
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handles middle mouse button release for closing tabs."""
        if event.button() == Qt.MouseButton.MiddleButton: # Qt.MiddleButton -> Qt.MouseButton.MiddleButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                if tab_text != "+" and is_tab_deletable(tab_text):
                    self.parentWidget().removeTab(index)
                elif tab_text != "+":
                    QMessageBox.warning(self.parentWidget(), "경고", f"'{tab_text}' 탭은 제거할 수 없습니다.")
                # "+" 탭은 아무 동작 안 함
        super().mouseReleaseEvent(event)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """Handles left mouse button double-click for renaming tabs."""
        if event.button() == Qt.MouseButton.LeftButton: # Qt.LeftButton -> Qt.MouseButton.LeftButton
            pos = event.position().toPoint() # PyQt6: event.pos() -> event.position().toPoint()
            index = self.tabAt(pos)
            if index >= 0:
                tab_text = self.tabText(index)
                # 보호된 탭 또는 "+" 탭은 이름 변경 불가
                if tab_text != "+" and is_tab_deletable(tab_text):
                    new_name, ok = QInputDialog.getText(self.parentWidget(), "탭 이름 변경",
                                                        "새 탭 이름을 입력하세요:", text=tab_text)
                    if ok and new_name and new_name.strip():
                        new_name_stripped = new_name.strip()
                        # 보호된 이름으로 변경 불가 처리
                        if not is_tab_deletable(new_name_stripped):
                             QMessageBox.warning(self.parentWidget(), "경고", f"'{new_name_stripped}'(으)로는 변경할 수 없습니다.")
                             return
                        # 중복 탭 이름 검사
                        for i in range(self.count()):
                            if i != index and self.tabText(i) == new_name_stripped:
                                QMessageBox.warning(self.parentWidget(), "경고", f"'{new_name_stripped}' 탭이 이미 존재합니다.")
                                return
                        # 이름 변경 적용
                        self.setTabText(index, new_name_stripped)
                    elif ok:
                         QMessageBox.warning(self.parentWidget(), "경고", "탭 이름은 비워둘 수 없습니다.")
        super().mouseDoubleClickEvent(event)




======== src\ui\widgets\custom_text_edit.py ========

from PyQt6.QtWidgets import QTextEdit # PyQt5 -> PyQt6
from PyQt6.QtCore import QMimeData # PyQt5 -> PyQt6

class CustomTextEdit(QTextEdit):
    """
    Custom QTextEdit that only allows plain text pasting.
    """
    def __init__(self, parent=None):
        super().__init__(parent)

    def insertFromMimeData(self, source: QMimeData):
        """Overrides insertFromMimeData to paste only plain text."""
        if source.hasText():
            self.insertPlainText(source.text())



======== src\ui\widgets\file_tree_view.py ========
from PyQt6.QtWidgets import QTreeView, QApplication
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QMouseEvent
from ui.models.remote_file_system_model import RemoteFileSystemModel # 원격 모델 import

class FileTreeView(QTreeView):
    """
    마우스 드래그로 여러 파일 선택 시 핸들링하여
    선택된 모든 파일의 체크 상태를 토글합니다.
    원격 파일 시스템 모델 사용 시에는 체크박스 관련 동작을 비활성화합니다.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._drag_start_pos = None
        self._dragging = False

    def _is_remote_model_active(self) -> bool:
        """현재 모델이 RemoteFileSystemModel인지 확인합니다."""
        return isinstance(self.model(), RemoteFileSystemModel)

    def mousePressEvent(self, event):
        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton:
            self._drag_start_pos = event.pos()
            self._dragging = False
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._drag_start_pos:
            distance = (event.pos() - self._drag_start_pos).manhattanLength()
            if distance > QApplication.startDragDistance():
                self._dragging = True
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        # 원격 모델 사용 시 드래그 토글 비활성화
        if self._is_remote_model_active():
            super().mouseReleaseEvent(event)
            self._drag_start_pos = None
            self._dragging = False
            return

        if isinstance(event, QMouseEvent) and event.button() == Qt.MouseButton.LeftButton and self._dragging:
            # 드래그로 선택된 후 마우스 릴리즈 시 선택된 모든 파일 토글
            super().mouseReleaseEvent(event)
            indexes = self.selectionModel().selectedIndexes()
            # 0번 컬럼만 필터링
            col0_indexes = []
            rows = set()
            for idx in indexes:
                if idx.column() == 0 and idx.row() not in rows:
                    col0_indexes.append(idx)
                    rows.add(idx.row())
            if col0_indexes:
                # 모델의 flags()를 확인하여 체크 가능한지 확인 (선택적)
                if not (self.model().flags(col0_indexes[0]) & Qt.ItemFlag.ItemIsUserCheckable):
                    self._drag_start_pos = None
                    self._dragging = False
                    return # 체크 불가능하면 아무것도 안 함

                first_state = self.model().data(col0_indexes[0], Qt.ItemDataRole.CheckStateRole)
                if isinstance(first_state, Qt.CheckState):
                    current_state = first_state
                elif isinstance(first_state, int):
                    current_state = Qt.CheckState(first_state)
                else:
                    self._drag_start_pos = None
                    self._dragging = False
                    return
                target_state = Qt.CheckState.Unchecked if current_state == Qt.CheckState.Checked else Qt.CheckState.Checked
                for idx in col0_indexes:
                    self.model().setData(idx, target_state, Qt.ItemDataRole.CheckStateRole)
            self._drag_start_pos = None
            self._dragging = False
        else:
            super().mouseReleaseEvent(event)




======== src\ui\widgets\ssh_config_dialog.py ========
import os
import logging # 로깅 추가
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QComboBox, QFileDialog, QMessageBox, QWidget, QHBoxLayout
)
from PyQt6.QtCore import Qt
from typing import Optional, Dict, Any
from pydantic import SecretStr, ValidationError # SecretStr 추가

from core.pydantic_models.ssh_connection_config import SshConnectionConfig

logger = logging.getLogger(__name__) # 로거 설정

class SshConfigDialog(QDialog):
    """
    Dialog for adding or editing SSH connection configurations.
    """
    def __init__(self, parent: QWidget = None, config: Optional[SshConnectionConfig] = None):
        super().__init__(parent)
        self.config = config
        self.is_edit_mode = config is not None
        logger.info(f"Initializing SshConfigDialog. Edit mode: {self.is_edit_mode}")

        self.setWindowTitle("SSH 연결 설정 편집" if self.is_edit_mode else "새 SSH 연결 설정 추가")
        self.setMinimumWidth(450)

        # UI Elements
        self.alias_edit = QLineEdit()
        self.host_edit = QLineEdit()
        self.port_edit = QLineEdit()
        self.port_edit.setPlaceholderText("22")
        self.username_edit = QLineEdit()
        self.auth_type_combo = QComboBox(); self.auth_type_combo.addItems(['password', 'key'])
        self.password_label = QLabel("비밀번호:"); self.password_edit = QLineEdit(); self.password_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.key_path_label = QLabel("개인 키 경로:"); self.key_path_edit = QLineEdit(); self.browse_key_button = QPushButton("찾아보기...")

        # Layouts
        main_layout = QVBoxLayout(self); form_layout = QFormLayout()
        form_layout.addRow("별칭 (Alias):*", self.alias_edit); form_layout.addRow("호스트 주소:*", self.host_edit)
        form_layout.addRow("포트:", self.port_edit); form_layout.addRow("사용자 이름:*", self.username_edit)
        form_layout.addRow("인증 방식:*", self.auth_type_combo)
        password_widget = QWidget(); password_layout = QHBoxLayout(password_widget); password_layout.setContentsMargins(0, 0, 0, 0); password_layout.addWidget(self.password_edit); form_layout.addRow(self.password_label, password_widget)
        key_path_widget = QWidget(); key_path_layout = QHBoxLayout(key_path_widget); key_path_layout.setContentsMargins(0, 0, 0, 0); key_path_layout.addWidget(self.key_path_edit); key_path_layout.addWidget(self.browse_key_button); form_layout.addRow(self.key_path_label, key_path_widget)
        main_layout.addLayout(form_layout)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        main_layout.addWidget(self.button_box)

        # Signals
        self.auth_type_combo.currentIndexChanged.connect(self.update_auth_fields_visibility)
        self.browse_key_button.clicked.connect(self.browse_for_key_file)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        # Initial State
        if self.is_edit_mode and self.config: self.load_config_data()
        else: self.port_edit.setText("22")
        self.update_auth_fields_visibility()

    def load_config_data(self):
        """Loads existing config data into the dialog fields."""
        if not self.config: return
        logger.info(f"Loading data for SSH connection: {self.config.alias}")
        self.alias_edit.setText(self.config.alias)
        self.host_edit.setText(self.config.host)
        self.port_edit.setText(str(self.config.port))
        self.username_edit.setText(self.config.username)
        self.auth_type_combo.setCurrentText(self.config.auth_type)
        self.password_edit.setPlaceholderText("변경하려면 새 비밀번호 입력") # Don't load password
        self.key_path_edit.setText(self.config.key_path or "")

    def update_auth_fields_visibility(self):
        """Shows/hides fields based on selected auth type."""
        auth_type = self.auth_type_combo.currentText()
        logger.debug(f"Auth type changed to: {auth_type}")
        is_password_auth = (auth_type == 'password')
        self.password_label.setVisible(is_password_auth); self.password_edit.setVisible(is_password_auth)
        self.key_path_label.setVisible(not is_password_auth); self.key_path_edit.setVisible(not is_password_auth); self.browse_key_button.setVisible(not is_password_auth)
        self.adjustSize()

    def browse_for_key_file(self):
        """Opens a file dialog to select a private key file."""
        logger.debug("Browse for key file clicked.")
        start_dir = os.path.expanduser("~/.ssh") if os.path.exists(os.path.expanduser("~/.ssh")) else os.path.expanduser("~")
        key_path, _ = QFileDialog.getOpenFileName(self, "개인 키 파일 선택", start_dir, "모든 파일 (*)")
        if key_path:
            logger.info(f"Key file selected: {key_path}")
            self.key_path_edit.setText(key_path)
        else:
            logger.debug("Key file selection cancelled.")

    def validate_and_accept(self):
        """Validates the input fields before accepting."""
        logger.info("Validating and accepting SSH config dialog.")
        data = self.get_data()
        if data:
            try:
                validation_data = data.copy()
                # Handle password validation based on mode
                if self.is_edit_mode and 'password' not in validation_data: pass # Editing, empty means no change
                elif validation_data.get('auth_type') == 'password' and not validation_data.get('password'):
                    if not self.is_edit_mode: raise ValueError("Password cannot be empty for password authentication when adding.")
                elif validation_data.get('auth_type') == 'key' and not validation_data.get('key_path'):
                    raise ValueError("Key path cannot be empty for key authentication.")

                # Perform Pydantic validation (temporarily convert SecretStr if present)
                if 'password' in validation_data and isinstance(validation_data['password'], SecretStr):
                    validation_data['password'] = validation_data['password'].get_secret_value()

                logger.debug("Performing Pydantic validation...")
                temp_config = SshConnectionConfig(**validation_data)
                logger.info("Pydantic validation successful.")
                self.accept()
            except (ValidationError, ValueError) as e:
                logger.warning(f"Input validation failed: {e}")
                QMessageBox.warning(self, "입력 오류", f"입력값을 확인해주세요:\n{e}")
            except Exception as e:
                 logger.exception(f"Unexpected error during validation: {e}")
                 QMessageBox.critical(self, "오류", f"검증 중 예기치 않은 오류 발생:\n{e}")
        else:
             logger.warning("Validation failed: Basic required fields missing (handled in get_data).")


    def get_data(self) -> Optional[Dict[str, Any]]:
        """Retrieves data from the dialog fields."""
        logger.debug("Retrieving data from SSH config dialog fields.")
        alias = self.alias_edit.text().strip()
        host = self.host_edit.text().strip()
        port_str = self.port_edit.text().strip()
        username = self.username_edit.text().strip()
        auth_type = self.auth_type_combo.currentText()
        password = self.password_edit.text() # Get plain text
        key_path = self.key_path_edit.text().strip()

        if not alias or not host or not username:
            logger.warning("Validation failed: Alias, Host, or Username is missing.")
            QMessageBox.warning(self, "입력 오류", "별칭, 호스트 주소, 사용자 이름은 필수입니다.")
            return None

        try:
            port = int(port_str) if port_str else 22
            if not 1 <= port <= 65535: raise ValueError("포트 번호는 1과 65535 사이여야 합니다.")
        except ValueError as e:
            logger.warning(f"Validation failed: Invalid port number '{port_str}'. Error: {e}")
            QMessageBox.warning(self, "입력 오류", f"유효하지 않은 포트 번호입니다: {e}")
            return None

        data = {
            "alias": alias, "host": host, "port": port, "username": username, "auth_type": auth_type,
            "key_path": key_path if auth_type == 'key' else None,
            # Include password only if it's password auth AND not empty OR if adding new config
            # If editing, empty password means "keep existing", so pass None
            "password": SecretStr(password) if auth_type == 'password' and password else None,
        }

        # Clean up None values explicitly if needed by Pydantic model later
        if data['key_path'] is None: data.pop('key_path', None) # Use pop to avoid KeyError
        if data['password'] is None: data.pop('password', None)

        logger.debug(f"Retrieved data (password excluded): { {k:v for k,v in data.items() if k != 'password'} }")
        return data



======== src\ui\widgets\tab_manager.py ========
PROTECTED_TABS = {
    # 기본 UI 탭
    "시스템", "사용자", "파일 트리", "프롬프트 출력", "XML 입력",
    "메타 프롬프트 템플릿", "메타 사용자 입력", "메타 프롬프트 출력",
    "메타 프롬프트", "사용자 프롬프트", "최종 프롬프트", 
    # 기능성 탭
    "+", # 새 탭 추가 버튼
    "   |   ", 

}

def is_tab_deletable(tab_name: str) -> bool:
    """Checks if a tab with the given name can be deleted or renamed by the user."""
    # 보호 목록에 없으면 삭제/이름 변경 가능
    return tab_name not in PROTECTED_TABS


======== src\ui\__init__.py ========
# This file makes Python treat the directory ui as a package.



======== src\ui\main_window.py ========
import os
import io
import logging
import datetime
import time # 시간 측정용 time 모듈 추가
import asyncio # asyncio 추가
from typing import Optional, List, Dict, Any
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox,
    QAbstractItemView, QMenuBar, QSplitter, QStyleFactory, QApplication, QMenu,
    QTreeWidget, QTreeWidgetItem, QComboBox, QFileDialog, QInputDialog, QMessageBox,
    QFrame, QLineEdit, QDialog, QListWidget, QListWidgetItem, QStyle
)
from PyQt6.QtGui import QKeySequence, QIcon, QCursor, QMouseEvent, QFont, QDesktopServices, QPixmap, QImage, QAction, QKeyEvent # PyQt5 -> PyQt6, QAction, QKeyEvent 추가
from PyQt6.QtCore import Qt, QSize, QStandardPaths, QModelIndex, QItemSelection, QUrl, QThread, pyqtSignal, QObject, QBuffer, QIODevice, QTimer, QEvent # PyQt5 -> PyQt6, QEvent 추가

# 서비스 및 모델 import
from core.pydantic_models.app_state import AppState
from core.services.db_service import DbService
from core.services.config_service import ConfigService
from core.services.state_service import StateService
from core.services.template_service import TemplateService
from core.services.prompt_service import PromptService
from core.services.xml_service import XmlService
from core.services.filesystem_service import FilesystemService
from core.services.token_service import TokenCalculationService
from core.services.gemini_service import build_gemini_graph
from core.langgraph_state import GeminiGraphState
from core.services.ssh_config_service import SshConfigService # Added for SSH
from core.pydantic_models.ssh_connection_config import SshConnectionConfig # Added for SSH config

# UI 관련 import
from ui.models.file_system_models import FilteredFileSystemModel, CheckableProxyModel
from ui.models.remote_file_system_model import RemoteFileSystemModel # 원격 모델 import
from ui.controllers.main_controller import MainController # MainController import 수정
from ui.controllers.resource_controller import ResourceController
from ui.controllers.prompt_controller import PromptController
from ui.controllers.xml_controller import XmlController
from ui.controllers.file_tree_controller import FileTreeController
from ui.controllers.system_prompt_controller import apply_default_system_prompt

from .main_window_setup_ui import create_menu_bar, create_widgets, create_layout, create_status_bar
from .main_window_setup_signals import connect_signals
from .settings_dialog import SettingsDialog
from ui.widgets.custom_text_edit import CustomTextEdit
from ui.widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from utils.notifications import show_notification # 알림 기능 임포트

# Pillow import 시도
try:
    from PIL import Image
    from PIL.ImageQt import ImageQt
    _PILLOW_AVAILABLE = True
except ImportError:
    _PILLOW_AVAILABLE = False

# SSH 라이브러리 import
try:
    import asyncssh # paramiko 대신 asyncssh import
    import socket # for socket.timeout
    _ASYNCSSH_AVAILABLE = True
except ImportError:
    _ASYNCSSH_AVAILABLE = False
    print("Warning: asyncssh library not installed. SSH functionality will be limited.")


# 로거 설정
logger = logging.getLogger(__name__)
# asyncssh 로거 설정 (DEBUG 레벨로 설정하여 상세 정보 확인)
# paramiko_logger -> asyncssh_logger 로 변경
asyncssh_logger = logging.getLogger("asyncssh")
asyncssh_logger.setLevel(logging.INFO) # 기본 INFO 레벨, 필요시 DEBUG로 변경
# asyncssh 로그를 콘솔에도 출력하도록 핸들러 추가 (필요 시)
# console_handler = logging.StreamHandler()
# console_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
# asyncssh_logger.addHandler(console_handler)


# --- Gemini API 호출을 위한 Worker 클래스 ---
class GeminiWorker(QObject):
    finished = pyqtSignal(str, str) # XML, Summary 결과 전달
    error = pyqtSignal(str)         # 오류 메시지 전달

    def __init__(self, graph_app, initial_state: GeminiGraphState): # 초기 상태 직접 받기
        super().__init__()
        self.graph_app = graph_app
        self.initial_state = initial_state # 전달받은 초기 상태 저장

    def run(self):
        """LangGraph 워크플로우를 실행합니다."""
        try:
            logger.info("Starting Gemini worker thread.")
            # LangGraph 실행 (.invoke 사용, 저장된 초기 상태 전달)
            final_state = self.graph_app.invoke(self.initial_state)
            logger.info(f"Gemini worker finished. Final state error: {final_state.get('error_message')}")

            if final_state.get("error_message"):
                self.error.emit(final_state["error_message"])
            else:
                xml_result = final_state.get("xml_output", "")
                summary_result = final_state.get("summary_output", "")
                self.finished.emit(xml_result, summary_result)
        except Exception as e:
            logger.exception("Error during LangGraph execution in worker thread.")
            self.error.emit(f"LangGraph 실행 오류: {str(e)}")

# --- SSH 연결을 위한 Worker 클래스 제거 ---


class MainWindow(QMainWindow):
    state_changed_signal = pyqtSignal()

    def __init__(self, mode="Code Enhancer Prompt Builder"):
        super().__init__()
        self._initialized = False
        self.mode = mode
        self.base_title = "DuckPrompt"
        self.update_window_title()

        QApplication.setStyle(QStyleFactory.create("Fusion"))

        # --- 상태 변수 ---
        self.current_project_folder: Optional[str] = None
        self.last_generated_prompt: str = ""
        self.selected_files_data: List[tuple] = []
        self.tree_generated: bool = False
        self._is_saving_gemini_settings = False
        self.attached_items: List[Dict[str, Any]] = []
        self.api_call_start_time: Optional[datetime.datetime] = None
        self.api_timer = QTimer(self)
        self.api_timer.timeout.connect(self._update_api_elapsed_time)
        self.ssh_client: Optional[asyncssh.SSHClientConnection] = None # paramiko -> asyncssh
        self.sftp_client: Optional[asyncssh.SFTPClient] = None      # paramiko -> asyncssh

        self.auto_save_timer = QTimer(self)
        self.auto_save_timer.setInterval(30000)
        self.auto_save_timer.setSingleShot(True)

        # --- 서비스 인스턴스 생성 ---
        try:
            self.db_service = DbService()
            self.config_service = ConfigService(self.db_service)
            self.ssh_config_service = SshConfigService(self.db_service)
        except ConnectionError as e:
             QMessageBox.critical(self, "Database Error", f"데이터베이스 연결 실패: {e}\n프로그램을 종료합니다.")
             raise SystemExit(f"Database connection failed: {e}")
        except ValueError as e:
             QMessageBox.critical(self, "Configuration Error", f"설정 로드 실패: {e}\n프로그램을 종료합니다.")
             raise SystemExit(f"Configuration load failed: {e}")

        self.state_service = StateService()
        self.template_service = TemplateService()
        self.prompt_service = PromptService()
        self.xml_service = XmlService()
        self.fs_service = FilesystemService(self.config_service)
        self.token_service = TokenCalculationService(self.config_service)
        self.gemini_graph = build_gemini_graph(self.config_service)
        self.gemini_thread: Optional[QThread] = None
        self.gemini_worker: Optional[GeminiWorker] = None

        # --- UI 구성 요소 생성 ---
        create_menu_bar(self)
        create_widgets(self)
        create_layout(self)
        create_status_bar(self)

        # --- 컨트롤러 생성 및 연결 ---
        self.main_controller = MainController(self)
        self.resource_controller = ResourceController(self, self.template_service, self.state_service)
        self.prompt_controller = PromptController(self, self.prompt_service)
        self.xml_controller = XmlController(self, self.xml_service)
        self.file_tree_controller = FileTreeController(self, self.fs_service, self.config_service)

        # --- 시그널 연결 ---
        connect_signals(self)
        self.auto_save_timer.timeout.connect(self.resource_controller.save_state_to_default)
        self.state_changed_signal.connect(self.restart_auto_save_timer)

        # --- 초기화 작업 ---
        self.resource_controller.load_templates_list()
        self._apply_initial_settings()
        self.load_ssh_connections_to_combo()

        self.status_bar.showMessage("Ready (DB Connected)")
        initial_width = 1200; initial_height = 800
        self.resize(initial_width, initial_height)
        left_width = int(initial_width * 0.35)
        right_width = initial_width - left_width
        self.center_splitter.setSizes([left_width, right_width])
        self.build_tabs.setCurrentIndex(1)
        self.file_tree_controller.reset_file_tree()

        if hasattr(self, 'user_tab'):
            self.user_tab.installEventFilter(self)
            logger.info("Event filter installed on user_tab.")

        self._initialized = True
        self.restart_auto_save_timer()

    # --- _apply_initial_settings, _restart_with_mode, _toggle_mode, _open_readme, open_settings_dialog 등 생략 ---
    def _apply_initial_settings(self):
        """Applies initial settings loaded from ConfigService."""
        logger.info("Applying initial settings from ConfigService...")
        apply_default_system_prompt(self)
        if self.mode == "Meta Prompt Builder":
            meta_prompt_path_relative = os.path.join("prompts", "system", "META_Prompt.md")
            try:
                meta_prompt_path = get_resource_path(meta_prompt_path_relative)
                if os.path.exists(meta_prompt_path):
                    with open(meta_prompt_path, "r", encoding="utf-8") as f: self.system_tab.setText(f.read())
            except Exception as e: logger.error(f"Error loading default META prompt: {e}")
        self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini"))
        self.main_controller.on_llm_selected()
        self.load_gemini_settings_to_ui()
        self.file_tree_controller.load_gitignore_settings()
        self.resource_controller.update_buttons_label()
        logger.info("Initial settings applied.")

    def _restart_with_mode(self, new_mode: str):
        """Restarts the application with the specified mode."""
        self._initialized = False
        self.auto_save_timer.stop()
        # Schedule async close if needed, but handle potential loop issues
        try:
             if self.ssh_client:
                 loop = asyncio.get_running_loop()
                 loop.create_task(self._close_ssh_connection_async())
                 # Allow some time for the task to start, but don't block indefinitely
                 # This part is tricky without full async GUI integration
                 time.sleep(0.2)
             # Close DB and main window synchronously after attempting async close
             self.db_service.disconnect()
             self.close()
             new_window = MainWindow(mode=new_mode)
             new_window.show()
        except RuntimeError: # No running loop
             logger.warning("No running event loop to schedule SSH close during restart. Closing synchronously (best effort).")
             self._close_ssh_connection_sync() # Add a synchronous fallback
             self.db_service.disconnect()
             self.close()
             new_window = MainWindow(mode=new_mode)
             new_window.show()
        except Exception as e:
             logger.error(f"Error during application restart: {e}", exc_info=True)
             # Attempt basic close anyway
             self.close()
             QApplication.quit()


    def _toggle_mode(self):
        """Toggles between application modes."""
        new_mode = "Meta Prompt Builder" if self.mode == "Code Enhancer Prompt Builder" else "Code Enhancer Prompt Builder"
        self._restart_with_mode(new_mode)

    def _open_readme(self):
        """Opens the README.md file."""
        readme_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'README.md'))
        if os.path.exists(readme_path):
            url = QUrl.fromLocalFile(readme_path)
            if not QDesktopServices.openUrl(url): QMessageBox.warning(self, "오류", "README.md 파일을 여는 데 실패했습니다.")
        else: QMessageBox.warning(self, "오류", "README.md 파일을 찾을 수 없습니다.")

    def open_settings_dialog(self):
        """Opens the settings dialog."""
        dialog = SettingsDialog(self, self)
        dialog.exec()
        self.load_ssh_connections_to_combo()
        logger.info("Settings dialog closed.")

    # --- reset_state, update_window_title, get_current_state, set_current_state 등 생략 ---
    def reset_state(self):
        """Resets internal state variables."""
        logger.info("Resetting application state...")
        was_initialized = self._initialized; self._initialized = False; self.auto_save_timer.stop()
        # Schedule async close if needed
        if self.ssh_client:
            try:
                 loop = asyncio.get_running_loop()
                 loop.create_task(self._close_ssh_connection_async())
            except RuntimeError:
                 logger.warning("No running event loop to schedule SSH close during reset. Closing synchronously.")
                 self._close_ssh_connection_sync()

        self.current_project_folder = None; self.last_generated_prompt = ""; self.selected_files_data = []; self.tree_generated = False; self.attached_items = []; self.api_call_start_time = None; self.api_timer.stop()
        if hasattr(self, 'checkable_proxy'): logger.debug("Clearing checked_files_dict in reset_state."); self.checkable_proxy.checked_files_dict.clear()
        if hasattr(self, 'attachment_list_widget'): self.attachment_list_widget.clear()
        self.update_window_title()
        if hasattr(self, 'file_tree_controller'): self.file_tree_controller.reset_file_tree()
        if hasattr(self, 'main_controller'): self.main_controller.on_llm_selected(); self.main_controller._stop_token_calculation_thread(); self.main_controller.reset_token_label()
        if hasattr(self, 'system_tab'): self.system_tab.clear()
        if hasattr(self, 'user_tab'): self.user_tab.clear()
        if hasattr(self, 'dir_structure_tab'): self.dir_structure_tab.clear()
        if hasattr(self, 'xml_input_tab'): self.xml_input_tab.clear()
        if hasattr(self, 'prompt_output_tab'): self.prompt_output_tab.clear()
        if hasattr(self, 'summary_tab'): self.summary_tab.clear()
        if hasattr(self, 'meta_prompt_tab'): self.meta_prompt_tab.clear()
        if hasattr(self, 'user_prompt_tab'): user_prompt_tab_widget = getattr(self, 'user_prompt_tab', None); user_prompt_tab_widget.clear() if user_prompt_tab_widget else None
        if hasattr(self, 'final_prompt_tab'): final_prompt_tab_widget = getattr(self, 'final_prompt_tab', None); final_prompt_tab_widget.clear() if final_prompt_tab_widget else None
        if hasattr(self, 'project_folder_label'): self.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)")
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API 시간: -")
        self._apply_initial_settings()
        self._initialized = was_initialized; self.restart_auto_save_timer(); logger.info("Application state reset complete.")

    def update_window_title(self, folder_name: Optional[str] = None):
        """Updates the window title."""
        title = f"{folder_name} - {self.base_title}" if folder_name else self.base_title; self.setWindowTitle(title)

    def get_current_state(self) -> AppState:
        """Gathers the current UI state for saving."""
        checked_paths = []
        if not self.ssh_client and hasattr(self, 'checkable_proxy'): checked_paths = self.checkable_proxy.get_all_checked_paths()
        selected_llm = self.llm_combo.currentText() if hasattr(self, 'llm_combo') else "Gemini"; selected_model_name = self.model_name_combo.currentText().strip() if hasattr(self, 'model_name_combo') else ""
        serializable_attachments = [];
        for item in self.attached_items: s_item = item.copy(); s_item.pop('data', None); serializable_attachments.append(s_item)
        state_data = {"mode": self.mode, "project_folder": self.current_project_folder if not self.ssh_client else None, "system_prompt": self.system_tab.toPlainText(), "user_prompt": self.user_tab.toPlainText(), "checked_files": checked_paths, "selected_llm": selected_llm, "selected_model_name": selected_model_name, "attached_items": serializable_attachments}
        try: app_state = AppState(**state_data); return app_state
        except Exception as e: logger.error(f"Error creating AppState model: {e}"); return AppState(mode=self.mode, project_folder=self.current_project_folder if not self.ssh_client else None, user_prompt=self.user_tab.toPlainText(), checked_files=checked_paths, attached_items=serializable_attachments, selected_llm=selected_llm, selected_model_name=selected_model_name)

    def set_current_state(self, state: AppState, partial_load: bool = False):
        """Sets the UI state based on the provided AppState model."""
        logger.info(f"Setting current state. Partial load: {partial_load}"); was_initialized = self._initialized; self._initialized = False; self.auto_save_timer.stop(); is_ssh_connected = bool(self.ssh_client)
        if partial_load:
            folder_name = None
            if not is_ssh_connected and state.project_folder and os.path.isdir(state.project_folder):
                if self.current_project_folder != state.project_folder:
                    self.current_project_folder = state.project_folder; folder_name = os.path.basename(state.project_folder); self.project_folder_label.setText(f"현재 프로젝트 폴더: {state.project_folder}")
                    if hasattr(self, 'dir_model') and hasattr(self, 'checkable_proxy'):
                        if self.tree_view.model() != self.checkable_proxy: self.tree_view.setModel(self.checkable_proxy)
                        self.checkable_proxy.checked_files_dict.clear(); logger.debug("Cleared checked_files_dict due to project folder change (partial load)."); idx = self.dir_model.setRootPathFiltered(state.project_folder); root_proxy_index = self.checkable_proxy.mapFromSource(idx); self.tree_view.setRootIndex(root_proxy_index)
                    self.status_bar.showMessage(f"Project Folder: {state.project_folder}"); self.file_tree_controller.load_gitignore_settings(); self.update_window_title(folder_name)
                else: folder_name = os.path.basename(self.current_project_folder)
            elif not is_ssh_connected and not state.project_folder and self.current_project_folder: folder_name = os.path.basename(self.current_project_folder)
            elif not is_ssh_connected: self.current_project_folder = None; self.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)"); self.file_tree_controller.reset_file_tree(); self.update_window_title()
            elif is_ssh_connected: logger.info("Skipping project folder load during partial load because SSH is connected.")
            self.user_tab.setText(state.user_prompt); self.attached_items = state.attached_items or []; self._update_attachment_list_ui()
            if not is_ssh_connected and self.current_project_folder and hasattr(self, 'checkable_proxy'):
                if self.current_project_folder == state.project_folder: self.checkable_proxy.checked_files_dict.clear(); logger.debug("Cleared checked_files_dict before restoring checks (partial load, same folder).")
                items_to_check = []; logger.info(f"Restoring checked files from state: {len(state.checked_files)} items")
                for fpath in state.checked_files:
                    try:
                        abs_fpath = os.path.abspath(fpath); abs_proj_folder = os.path.abspath(self.current_project_folder)
                        if abs_fpath.startswith(abs_proj_folder):
                            if os.path.exists(abs_fpath):
                                src_index = self.dir_model.index(abs_fpath)
                                if src_index.isValid(): proxy_index = self.checkable_proxy.mapFromSource(src_index); items_to_check.append(proxy_index) if proxy_index.isValid() else logger.warning(f"  Could not map source index to proxy for: {abs_fpath}")
                                else: logger.warning(f"  Could not get source index for: {abs_fpath}")
                            else: logger.warning(f"  Checked file path from state does not exist: {abs_fpath}")
                        else: logger.warning(f"  Checked file path from state is outside current project folder: {abs_fpath}")
                    except Exception as e: logger.error(f"  Error processing checked file path '{fpath}': {e}")
                logger.info(f"Applying check state for {len(items_to_check)} restored items using setData.")
                for proxy_index in items_to_check: self.checkable_proxy.setData(proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole); logger.debug(f"  Called setData(Checked) for: {self.checkable_proxy.get_file_path_from_index(proxy_index)}")
            elif is_ssh_connected: logger.info("Skipping checked files restore during partial load because SSH is connected.")
            self.status_bar.showMessage("마지막 작업 상태 로드 완료.")
        else: # Full load
            if self.mode != state.mode: logger.info(f"Mode mismatch. Restarting..."); self._restart_with_mode(state.mode); return
            folder_name = None
            if not is_ssh_connected and state.project_folder and os.path.isdir(state.project_folder):
                if self.current_project_folder != state.project_folder:
                    self.current_project_folder = state.project_folder; folder_name = os.path.basename(state.project_folder); self.project_folder_label.setText(f"현재 프로젝트 폴더: {state.project_folder}")
                    if hasattr(self, 'dir_model') and hasattr(self, 'checkable_proxy'):
                        if self.tree_view.model() != self.checkable_proxy: self.tree_view.setModel(self.checkable_proxy)
                        self.checkable_proxy.checked_files_dict.clear(); logger.debug("Cleared checked_files_dict due to project folder change (full load)."); idx = self.dir_model.setRootPathFiltered(state.project_folder); root_proxy_index = self.checkable_proxy.mapFromSource(idx); self.tree_view.setRootIndex(root_proxy_index)
                    self.status_bar.showMessage(f"Project Folder: {state.project_folder}"); self.file_tree_controller.load_gitignore_settings()
                else: folder_name = os.path.basename(self.current_project_folder)
            elif not is_ssh_connected: self.current_project_folder = None; self.project_folder_label.setText("현재 프로젝트 폴더: (선택 안 됨)"); self.file_tree_controller.reset_file_tree()
            elif is_ssh_connected: logger.info("Skipping project folder load during full load because SSH is connected.")
            self.system_tab.setText(state.system_prompt); self.user_tab.setText(state.user_prompt)
            llm_index = self.llm_combo.findText(state.selected_llm)
            if llm_index != -1:
                self.llm_combo.setCurrentIndex(llm_index); available_models = self.config_service.get_available_models(state.selected_llm); self.model_name_combo.blockSignals(True); self.model_name_combo.clear(); self.model_name_combo.addItems(available_models); self.model_name_combo.blockSignals(False)
                model_index = self.model_name_combo.findText(state.selected_model_name)
                if model_index != -1: self.model_name_combo.setCurrentIndex(model_index)
                elif available_models: self.model_name_combo.setCurrentIndex(0); logger.warning(f"Warning: Saved model '{state.selected_model_name}' not found for {state.selected_llm}. Selecting first available.")
                else: logger.warning(f"No available models found for {state.selected_llm}.")
            else: self.llm_combo.setCurrentIndex(self.llm_combo.findText("Gemini")); self.main_controller.on_llm_selected()
            self.attached_items = state.attached_items or []; self._update_attachment_list_ui()
            if not is_ssh_connected and self.current_project_folder and hasattr(self, 'checkable_proxy'):
                if self.current_project_folder == state.project_folder: self.checkable_proxy.checked_files_dict.clear(); logger.debug("Cleared checked_files_dict before restoring checks (full load, same folder).")
                items_to_check = []; logger.info(f"Restoring checked files from state: {len(state.checked_files)} items")
                for fpath in state.checked_files:
                    try:
                        abs_fpath = os.path.abspath(fpath); abs_proj_folder = os.path.abspath(self.current_project_folder)
                        if abs_fpath.startswith(abs_proj_folder):
                            if os.path.exists(abs_fpath):
                                src_index = self.dir_model.index(abs_fpath)
                                if src_index.isValid(): proxy_index = self.checkable_proxy.mapFromSource(src_index); items_to_check.append(proxy_index) if proxy_index.isValid() else logger.warning(f"  Could not map source index to proxy for: {abs_fpath}")
                                else: logger.warning(f"  Could not get source index for: {abs_fpath}")
                            else: logger.warning(f"  Checked file path from state does not exist: {abs_fpath}")
                        else: logger.warning(f"  Checked file path from state is outside current project folder: {abs_fpath}")
                    except Exception as e: logger.error(f"  Error processing checked file path '{fpath}': {e}")
                logger.info(f"Applying check state for {len(items_to_check)} restored items using setData.")
                for proxy_index in items_to_check: self.checkable_proxy.setData(proxy_index, Qt.CheckState.Checked, Qt.ItemDataRole.CheckStateRole); logger.debug(f"  Called setData(Checked) for: {self.checkable_proxy.get_file_path_from_index(proxy_index)}")
            elif is_ssh_connected: logger.info("Skipping checked files restore during full load because SSH is connected.")
            if not is_ssh_connected and self.current_project_folder: self.file_tree_controller.load_gitignore_settings()
            self.update_window_title(folder_name); self.resource_controller.update_buttons_label(); self.load_gemini_settings_to_ui()
            self.status_bar.showMessage("State loaded successfully!")
        self._initialized = was_initialized; self.main_controller.update_char_count_for_active_tab(); self.token_count_label.setText("토큰 계산: -");
        if hasattr(self, 'api_time_label'): self.api_time_label.setText("API 시간: -")
        self.restart_auto_save_timer()

    # --- uncheck_all_files, create_tree_item, add_new_custom_tab, _update_attachment_list_ui 등 생략 ---
    def uncheck_all_files(self):
        """Unchecks all items in the file tree view (Local only)."""
        if self.ssh_client: return
        if not hasattr(self, 'checkable_proxy'): return
        paths_to_uncheck = list(self.checkable_proxy.checked_files_dict.keys()); self.checkable_proxy.checked_files_dict.clear()
        for fpath in paths_to_uncheck:
            src_index = self.dir_model.index(fpath)
            if src_index.isValid(): proxy_index = self.checkable_proxy.mapFromSource(src_index); self.checkable_proxy.dataChanged.emit(proxy_index, proxy_index, [Qt.ItemDataRole.CheckStateRole]) if proxy_index.isValid() else None
        self.state_changed_signal.emit()

    def create_tree_item(self, text, parent=None) -> QTreeWidgetItem:
        """Helper method to create items in the template/state tree."""
        item = QTreeWidgetItem([text]); self.template_tree.addTopLevelItem(item) if parent is None else parent.addChild(item); return item

    def add_new_custom_tab(self):
        """Adds a new custom tab."""
        new_tab_name, ok = QInputDialog.getText(self, "새 탭 추가", "새 탭의 이름을 입력하세요:")
        if ok and new_tab_name and new_tab_name.strip():
            new_name = new_tab_name.strip()
            from ui.widgets.tab_manager import is_tab_deletable
            if not is_tab_deletable(new_name): QMessageBox.warning(self, "경고", f"'{new_name}'은(는) 사용할 수 없는 탭 이름입니다."); return
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == new_name: QMessageBox.warning(self, "경고", f"'{new_name}' 탭이 이미 존재합니다."); return
            new_tab = CustomTextEdit(); new_tab.setPlaceholderText(f"{new_name} 내용 입력...")
            plus_tab_index = -1
            for i in range(self.build_tabs.count()):
                if self.build_tabs.tabText(i) == "+": plus_tab_index = i; break
            if plus_tab_index != -1: self.build_tabs.insertTab(plus_tab_index, new_tab, new_name); self.build_tabs.setCurrentIndex(plus_tab_index)
            else: self.build_tabs.addTab(new_tab, new_name); self.build_tabs.setCurrentIndex(self.build_tabs.count() - 1)
            new_tab.textChanged.connect(self.main_controller.handle_text_changed); self.state_changed_signal.emit()
        elif ok: QMessageBox.warning(self, "경고", "탭 이름은 비워둘 수 없습니다.")

    def _update_attachment_list_ui(self):
        """Updates the attachment list widget based on self.attached_items."""
        if not hasattr(self, 'attachment_list_widget'): return
        self.attachment_list_widget.clear()
        for item in self.attached_items:
            item_name = item.get('name', 'Unknown'); item_type = item.get('type', 'unknown'); display_text = f"[{item_type.upper()}] {item_name}"; list_item = QListWidgetItem(display_text); icon = QIcon()
            if item_type == 'image':
                img_data = item.get('data')
                if not img_data and item.get('path') and os.path.exists(item['path']):
                    try:
                        with open(item['path'], 'rb') as f: img_data = f.read()
                    except Exception: pass
                if img_data:
                    try: pixmap = QPixmap(); pixmap.loadFromData(img_data); icon = QIcon(pixmap.scaled(QSize(32, 32), Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)) if not pixmap.isNull() else self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
                    except Exception as e: logger.error(f"Error creating thumbnail for {item_name}: {e}"); icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
                else: icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
            elif item_type == 'file': icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
            else: icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
            list_item.setIcon(icon); self.attachment_list_widget.addItem(list_item)

    # --- LangGraph 관련 메서드 (변경 없음) ---
    def send_prompt_to_gemini(self):
        """ Sends the prompt and attachments to Gemini via LangGraph worker thread. """
        if self.mode == "Meta Prompt Builder": QMessageBox.information(self, "정보", "Meta Prompt Builder 모드에서는 Gemini 전송 기능을 사용할 수 없습니다."); return
        if not hasattr(self, 'prompt_output_tab'): QMessageBox.warning(self, "오류", "프롬프트 출력 탭을 찾을 수 없습니다."); return
        prompt_text = self.prompt_output_tab.toPlainText(); loaded_attachments = []
        for item in self.attached_items:
            if not item.get('data') and item.get('path') and os.path.exists(item['path']):
                try:
                    with open(item['path'], 'rb') as f: item['data'] = f.read()
                    logger.info(f"Loaded data for attachment: {item['name']}")
                except Exception as e: QMessageBox.warning(self, "첨부 파일 오류", f"첨부 파일 '{item['name']}' 로드 실패: {e}")
            loaded_attachments.append(item)
        if not prompt_text.strip() and not loaded_attachments: QMessageBox.warning(self, "경고", "Gemini에 전송할 프롬프트 내용이나 첨부 파일이 없습니다."); return
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(False)
        self.status_bar.showMessage("Gemini API 호출 중..."); self.api_call_start_time = datetime.datetime.now(); start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
        if hasattr(self, 'api_time_label'): self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: 0:00:00"); self.api_timer.start(1000); QApplication.processEvents()
        if self.gemini_thread and self.gemini_thread.isRunning(): logger.warning("Terminating previous Gemini thread..."); self.gemini_thread.quit(); self.gemini_thread.wait()
        selected_model_name = self.model_name_combo.currentText().strip()
        initial_state: GeminiGraphState = {"input_prompt": prompt_text, "input_attachments": loaded_attachments, "selected_model_name": selected_model_name, "gemini_response": "", "xml_output": "", "summary_output": "", "error_message": None, "log_id": None }
        self.gemini_thread = QThread(); self.gemini_worker = GeminiWorker(self.gemini_graph, initial_state); self.gemini_worker.moveToThread(self.gemini_thread)
        self.gemini_thread.started.connect(self.gemini_worker.run); self.gemini_worker.finished.connect(self.handle_gemini_response); self.gemini_worker.error.connect(self.handle_gemini_error)
        self.gemini_worker.finished.connect(self.gemini_thread.quit); self.gemini_worker.finished.connect(self.gemini_worker.deleteLater); self.gemini_thread.finished.connect(self.gemini_thread.deleteLater)
        self.gemini_worker.error.connect(self.gemini_thread.quit); self.gemini_worker.error.connect(self.gemini_worker.deleteLater); self.gemini_thread.finished.connect(self.cleanup_gemini_thread)
        self.gemini_thread.start()

    def _update_api_elapsed_time(self):
        """ Updates the API elapsed time label. """
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            elapsed_time = datetime.datetime.now() - self.api_call_start_time; elapsed_str = str(elapsed_time).split('.')[0]; start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str}")
        else: self.api_timer.stop()

    def handle_gemini_response(self, xml_result: str, summary_result: str):
        """ Handles Gemini response. """
        logger.info("--- Handling Gemini Response ---"); self.api_timer.stop()
        if hasattr(self, 'xml_input_tab'): self.xml_input_tab.setPlainText(xml_result); logger.info(f"XML Output Length: {len(xml_result)}")
        if hasattr(self, 'summary_tab'): self.summary_tab.setPlainText(summary_result); logger.info(f"Summary Output Length: {len(summary_result)}"); self.build_tabs.setCurrentWidget(self.summary_tab)
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now(); elapsed_time = end_time - self.api_call_start_time; elapsed_str = str(elapsed_time).split('.')[0]; start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str} (완료)")
        self.status_bar.showMessage("Gemini 응답 처리 완료.");
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)
        show_notification("Gemini 응답 완료", "Gemini API 응답 처리가 완료되었습니다.")

    def handle_gemini_error(self, error_msg: str):
        """ Handles Gemini error. """
        logger.error(f"--- Handling Gemini Error: {error_msg} ---"); self.api_timer.stop()
        if self.api_call_start_time and hasattr(self, 'api_time_label'):
            end_time = datetime.datetime.now(); elapsed_time = end_time - self.api_call_start_time; elapsed_str = str(elapsed_time).split('.')[0]; start_time_str = self.api_call_start_time.strftime('%H:%M:%S')
            self.api_time_label.setText(f"API 시작: {start_time_str}, 경과: {elapsed_str} (오류)")
        user_display_error = error_msg
        if "Gemini API 응답 처리 오류" in error_msg or "Gemini API 응답 문제 발생" in error_msg: user_display_error = "Gemini API 응답 문제입니다. 자세한 내용은 Summary 탭을 확인하세요.";
        if hasattr(self, 'summary_tab'): self.summary_tab.setPlainText(f"Gemini 오류 상세:\n{error_msg}")
        QMessageBox.critical(self, "Gemini API 오류", user_display_error); self.status_bar.showMessage("Gemini API 호출 오류.")
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)
        notification_msg = f"Gemini API 호출 중 오류 발생: {error_msg[:100]}"; notification_msg += "..." if len(error_msg) > 100 else ""; show_notification("Gemini 오류", notification_msg)

    def cleanup_gemini_thread(self):
        """ Cleans up Gemini thread and worker objects. """
        logger.info("--- Cleaning up Gemini thread and worker ---"); self.api_timer.stop()
        self.gemini_thread = None; self.gemini_worker = None
        if hasattr(self, 'send_to_gemini_btn'): self.send_to_gemini_btn.setEnabled(True)

    # --- Gemini 파라미터 관리 메서드 (변경 없음) ---
    def load_gemini_settings_to_ui(self):
        """Loads Gemini parameters from DB to UI."""
        try:
            settings = self.config_service.get_settings()
            if not settings: logger.warning("Cannot load Gemini settings to UI: Config settings not available."); return
            logger.info("Loading Gemini settings to UI...")
            self.gemini_temp_edit.blockSignals(True); self.gemini_thinking_checkbox.blockSignals(True); self.gemini_budget_edit.blockSignals(True); self.gemini_search_checkbox.blockSignals(True)
            self.gemini_temp_edit.setText(str(settings.gemini_temperature)); self.gemini_thinking_checkbox.setChecked(settings.gemini_enable_thinking); self.gemini_budget_edit.setText(str(settings.gemini_thinking_budget)); self.gemini_search_checkbox.setChecked(settings.gemini_enable_search)
            logger.info(f"  Temp: {settings.gemini_temperature}, Thinking: {settings.gemini_enable_thinking}, Budget: {settings.gemini_thinking_budget}, Search: {settings.gemini_enable_search}")
            self.gemini_temp_edit.blockSignals(False); self.gemini_thinking_checkbox.blockSignals(False); self.gemini_budget_edit.blockSignals(False); self.gemini_search_checkbox.blockSignals(False)
            is_gemini_selected = (self.llm_combo.currentText() == "Gemini")
            if hasattr(self, 'gemini_param_widget'): self.gemini_param_widget.setVisible(is_gemini_selected)
            logger.info("Gemini settings loaded to UI successfully.")
        except Exception as e: logger.error(f"Error loading Gemini settings to UI: {e}", exc_info=True); QMessageBox.warning(self, "오류", f"Gemini 설정을 UI에 로드하는 중 오류 발생: {e}")

    def save_gemini_settings(self):
        """Saves Gemini parameters (currently disabled)."""
        if not self._initialized or self._is_saving_gemini_settings: return
        self._is_saving_gemini_settings = True
        try: temp_str = self.gemini_temp_edit.text().strip(); temperature = float(temp_str) if temp_str else 0.0; enable_thinking = self.gemini_thinking_checkbox.isChecked(); budget_str = self.gemini_budget_edit.text().strip(); thinking_budget = int(budget_str) if budget_str else 0; enable_search = self.gemini_search_checkbox.isChecked()
        except ValueError: pass
        finally: self._is_saving_gemini_settings = False

    # --- SSH Connection Handling (AsyncSSH 적용) ---
    def load_ssh_connections_to_combo(self):
        """Loads SSH connection aliases into the ComboBox."""
        self.ssh_connection_combo.clear()
        self.ssh_connection_combo.addItem("SSH 연결 선택...")
        try:
            connections = self.ssh_config_service.list_connections()
            for conn in connections:
                self.ssh_connection_combo.addItem(conn.alias, conn.id)
            logger.info(f"Loaded {len(connections)} SSH connections into combobox.")
        except Exception as e:
            logger.error(f"Error loading SSH connections into combobox: {e}")
            QMessageBox.warning(self, "오류", f"SSH 연결 목록 로드 실패: {e}")

    def _trigger_toggle_ssh_async(self):
         """ Schedules the async SSH connection task. """
         # This function runs in the Qt thread and schedules the async task
         # Requires qasync or similar setup where asyncio.create_task works with the Qt loop
         try:
             logger.info("Scheduling async toggle_ssh_connection task...")
             asyncio.create_task(self.toggle_ssh_connection())
         except RuntimeError as e:
              logger.error(f"Failed to schedule async SSH task (is event loop running?): {e}")
              QMessageBox.critical(self, "오류", f"비동기 작업 스케줄링 실패: {e}")
              # Reset button state if scheduling fails
              self.ssh_connect_btn.setEnabled(True)
              self.ssh_connect_btn.setText("🔌 연결")

    async def toggle_ssh_connection(self): # Add async
        """Handles the SSH Connect/Disconnect button click asynchronously."""
        logger.debug("async toggle_ssh_connection called.")
        if self.ssh_client:
            logger.info("SSH client exists, attempting to disconnect...")
            await self._close_ssh_connection_async() # Make closing async too
        else:
            logger.info("SSH client does not exist, attempting to connect...")
            selected_index = self.ssh_connection_combo.currentIndex()
            if selected_index <= 0:
                logger.warning("No valid SSH connection selected.")
                QMessageBox.warning(self, "선택 오류", "연결할 SSH 설정을 선택하세요.")
                return

            selected_alias = self.ssh_connection_combo.currentText()
            selected_id = self.ssh_connection_combo.itemData(selected_index)
            logger.info(f"Attempting to connect to SSH alias: {selected_alias} (ID: {selected_id})")

            logger.debug(f"Fetching SSH config for ID {selected_id} from DB...")
            config_to_connect = self.db_service.get_ssh_connection_by_id(selected_id)
            if not config_to_connect:
                 logger.error(f"SSH config for ID {selected_id} not found in DB.")
                 QMessageBox.critical(self, "오류", f"ID {selected_id}에 해당하는 SSH 설정을 찾을 수 없습니다.")
                 # --- DB 조회 실패 시 UI 상태 리셋 및 핸들러 호출 ---
                 self.handle_ssh_connection_failure(f"ID {selected_id} 설정을 찾을 수 없음")
                 # ----------------------------------------------
                 return
            logger.debug(f"SSH config found for ID {selected_id}.")

            logger.debug("Disabling UI elements during async connection attempt.")
            self.ssh_connect_btn.setEnabled(False); self.ssh_connect_btn.setText("연결 중...")
            self.ssh_status_label.setText("SSH: 연결 중..."); self.ssh_connection_combo.setEnabled(False)
            QApplication.processEvents()

            # --- Run connection logic directly using asyncssh ---
            conn = None; sftp = None; error_message = "Unknown error"
            connect_duration = -1.0; sftp_duration = -1.0
            try:
                if not _ASYNCSSH_AVAILABLE: raise ImportError("AsyncSSH library not available.")

                connect_options = { # Prepare options as before
                    "host": config_to_connect.host, "port": config_to_connect.port,
                    "username": config_to_connect.username, "known_hosts": None # Ignore host keys for now
                }
                if config_to_connect.auth_type == 'password':
                    if not config_to_connect.password: raise ValueError("Password required but not provided.")
                    connect_options["password"] = config_to_connect.password
                    connect_options["client_keys"] = None # Ensure client keys are not used
                elif config_to_connect.auth_type == 'key':
                    if not config_to_connect.key_path: raise ValueError("Key path required but not provided.")
                    key_filepath = os.path.expanduser(config_to_connect.key_path)
                    if not os.path.exists(key_filepath): raise FileNotFoundError(f"Private key file not found: {key_filepath}")
                    connect_options["client_keys"] = [key_filepath]
                    # connect_options["passphrase"] = ... # Add passphrase if needed
                    connect_options["password"] = None # Ensure password is not used
                else: raise ValueError(f"Invalid authentication type: {config_to_connect.auth_type}")

                logger.info(f"Attempting asyncssh.connect() to {config_to_connect.host}:{config_to_connect.port}...")
                start_connect_time = time.monotonic()
                # Set a connection timeout directly if needed
                # conn = await asyncio.wait_for(asyncssh.connect(**connect_options), timeout=30.0)
                conn = await asyncssh.connect(**connect_options) # Use default timeout for now
                connect_duration = time.monotonic() - start_connect_time
                logger.info(f"asyncssh.connect() successful after {connect_duration:.2f} seconds.")

                logger.info("Attempting to start SFTP client...")
                start_sftp_time = time.monotonic()
                sftp = await conn.start_sftp_client()
                sftp_duration = time.monotonic() - start_sftp_time
                logger.info(f"SFTP client started successfully in {sftp_duration:.2f} seconds.")

                # Call success handler directly
                self.handle_ssh_connection_success(conn, sftp, config_to_connect.alias)

            except (asyncssh.PermissionDenied, # Removed AuthenticationFailed
                      asyncssh.ConnectionLost, asyncssh.KeyExchangeFailed,
                      FileNotFoundError, ValueError, ImportError, socket.timeout,
                      ConnectionRefusedError, OSError, asyncio.TimeoutError) as e: # Add asyncio.TimeoutError
                error_message = f"{type(e).__name__}: {e}"
                log_exc_info = not isinstance(e, (asyncssh.PermissionDenied, FileNotFoundError, ValueError, ImportError, socket.timeout, ConnectionRefusedError))
                logger.error(f"SSH connection failed: {error_message}", exc_info=log_exc_info)
                # Call failure handler directly
                self.handle_ssh_connection_failure(error_message) # Pass error message
            except Exception as e:
                error_message = f"Unexpected error: {e}"
                logger.exception(f"Unexpected error during SSH connection: {e}") # Log full traceback
                # Call failure handler directly
                self.handle_ssh_connection_failure(error_message) # Pass error message


    # 핸들러의 타입 힌트 수정 (Worker 제거)
    def handle_ssh_connection_success(self, client_conn: asyncssh.SSHClientConnection, sftp: asyncssh.SFTPClient, alias: str):
        """Handles successful SSH connection."""
        logger.info(f"SSH connection successful for alias: {alias}")
        self.ssh_client = client_conn # asyncssh 객체 저장
        self.sftp_client = sftp       # asyncssh 객체 저장
        logger.debug("Updating UI for successful SSH connection...")
        self.ssh_connect_btn.setText("🔌 연결 해제"); self.ssh_status_label.setText(f"SSH: 연결됨 ({alias})")
        self.ssh_connect_btn.setEnabled(True); self.ssh_connection_combo.setEnabled(False)
        self.select_project_btn.setEnabled(False); self.status_bar.showMessage(f"SSH 연결됨: {alias}")
        logger.debug("UI updated for successful SSH connection.")
        logger.debug("Updating file tree for SSH connection...")
        # *** 수정: remote_root를 "/"로 명시적으로 전달 ***
        self.file_tree_controller.update_tree_for_ssh_status(is_connected=True, remote_root="/")
        logger.debug("File tree updated for SSH connection.")

    def handle_ssh_connection_failure(self, error_message: str):
        """Handles failed SSH connection."""
        logger.error(f"SSH connection failed: {error_message}")
        QMessageBox.critical(self, "SSH 연결 실패", f"SSH 연결 중 오류 발생:\n{error_message}")
        logger.debug("Resetting UI after SSH connection failure...")
        self.ssh_client = None; self.sftp_client = None
        self.ssh_connect_btn.setText("🔌 연결"); self.ssh_status_label.setText("SSH: 연결 실패") # 상태 레이블 변경
        self.ssh_connect_btn.setEnabled(True); self.ssh_connection_combo.setEnabled(True)
        self.select_project_btn.setEnabled(True); self.status_bar.showMessage("SSH 연결 실패.")
        logger.debug("UI reset after SSH connection failure.")
        logger.debug("Updating file tree after SSH failure...")
        self.file_tree_controller.update_tree_for_ssh_status(is_connected=False)
        logger.debug("File tree updated after SSH failure.")

    async def _close_ssh_connection_async(self): # Add async
        """Safely closes the AsyncSSH connection and SFTP client asynchronously."""
        logger.info("Attempting to close SSH connection asynchronously...")
        sftp_closed = False
        conn_closed = False

        # Cancel ongoing SFTP operations in the model first
        if isinstance(self.tree_view.model(), RemoteFileSystemModel):
            logger.debug("Cancelling ongoing SFTP fetch tasks in the model...")
            self.tree_view.model().cancel_all_fetches() # Add cancel method to model
            await asyncio.sleep(0.1) # Give cancellation a moment

        if self.sftp_client:
            try:
                logger.debug("Closing AsyncSSH SFTP client...")
                # SFTPClient doesn't have an explicit async close, rely on connection close
                # However, AsyncSSH SFTPClient has an exit() method
                self.sftp_client.exit()
                self.sftp_client = None
                sftp_closed = True
                logger.info("SFTP client exited and reference removed.")
            except Exception as e:
                 logger.error(f"Error closing SFTP client (reference removed anyway): {e}", exc_info=True)
                 self.sftp_client = None # Ensure reference is removed
        if self.ssh_client:
            try:
                logger.debug("Closing AsyncSSH connection...")
                self.ssh_client.close()
                await self.ssh_client.wait_closed() # Wait for close to complete
                logger.info("AsyncSSH connection closed and waited.")
                conn_closed = True
            except Exception as e:
                logger.error(f"Error closing AsyncSSH connection: {e}", exc_info=True)
            finally:
                self.ssh_client = None # Ensure reference is removed

        # Update UI only if something was actually closed or reference removed
        if sftp_closed or conn_closed:
             logger.debug("Resetting SSH UI elements...")
             self.ssh_connect_btn.setText("🔌 연결"); self.ssh_status_label.setText("SSH: 미연결")
             self.ssh_connect_btn.setEnabled(True); self.ssh_connection_combo.setEnabled(True)
             self.select_project_btn.setEnabled(True)
             logger.debug("SSH UI elements reset.")
             logger.debug("Updating file tree after closing SSH connection...")
             self.file_tree_controller.update_tree_for_ssh_status(is_connected=False)
             logger.debug("File tree updated after closing SSH connection.")
             logger.info("SSH connection closed and UI reset.")
        else:
             logger.info("No active SSH connection or SFTP client to close.")

    def _close_ssh_connection_sync(self): # Synchronous fallback
        """Synchronous (best effort) SSH cleanup for non-async contexts."""
        logger.warning("Performing synchronous SSH cleanup (best effort)...")
        if isinstance(self.tree_view.model(), RemoteFileSystemModel):
            logger.debug("Cancelling ongoing SFTP fetch tasks in the model (sync cleanup)...")
            self.tree_view.model().cancel_all_fetches() # Cancel tasks

        if self.sftp_client:
            try:
                self.sftp_client.exit() # Attempt to exit SFTP
            except Exception: pass
            self.sftp_client = None
            logger.info("SFTP client reference removed (sync).")
        if self.ssh_client:
            try:
                self.ssh_client.close() # Attempt close, no await
                logger.info("AsyncSSH connection close initiated (sync).")
            except Exception as e:
                logger.error(f"Error initiating SSH connection close (sync): {e}")
            finally:
                self.ssh_client = None
        # Update UI immediately
        self.ssh_connect_btn.setText("🔌 연결"); self.ssh_status_label.setText("SSH: 미연결")
        self.ssh_connect_btn.setEnabled(True); self.ssh_connection_combo.setEnabled(True)
        self.select_project_btn.setEnabled(True)
        self.file_tree_controller.update_tree_for_ssh_status(is_connected=False)
        logger.info("SSH UI and file tree updated (sync cleanup).")


    # --- Event Handlers 등 나머지 코드 생략 ---
    def on_copy_shortcut(self):
        """Handles Ctrl+C shortcut."""
        current_widget = self.build_tabs.currentWidget()
        if isinstance(current_widget, CustomTextEdit):
            if current_widget.textCursor().hasSelection(): current_widget.copy()
            elif current_widget == self.prompt_output_tab or (hasattr(self, 'final_prompt_tab') and current_widget == self.final_prompt_tab): self.prompt_controller.copy_to_clipboard()

    def on_tree_view_context_menu(self, position):
        """Handles context menu requests on the file tree view."""
        if self.ssh_client: QMessageBox.information(self, "정보", "원격 파일 시스템 작업은 아직 지원되지 않습니다."); return
        index = self.tree_view.indexAt(position);
        if not index.isValid(): return
        file_path = self.checkable_proxy.get_file_path_from_index(index);
        if not file_path: return
        menu = QMenu(); rename_action = QAction("이름 변경", self); delete_action = QAction("삭제", self)
        menu.addAction(rename_action); menu.addAction(delete_action)
        action = menu.exec(self.tree_view.viewport().mapToGlobal(position))
        if action == rename_action: self.file_tree_controller.rename_item(file_path)
        elif action == delete_action: self.file_tree_controller.delete_item(file_path)

    def on_tree_view_item_clicked(self, index: QModelIndex):
        """Handles item clicks in the tree view to toggle check state (Local only)."""
        if self.ssh_client: return
        if not index.isValid() or index.column() != 0: return
        if not (self.checkable_proxy.flags(index) & Qt.ItemFlag.ItemIsUserCheckable): return
        current_state_value = self.checkable_proxy.data(index, Qt.ItemDataRole.CheckStateRole)
        if isinstance(current_state_value, Qt.CheckState): current_check_state = current_state_value
        elif isinstance(current_state_value, int): current_check_state = Qt.CheckState(current_state_value)
        else: logger.warning(f"on_tree_view_item_clicked: Unexpected data type for CheckStateRole: {type(current_state_value)}"); return
        target_check_state = Qt.CheckState.Unchecked if current_check_state == Qt.CheckState.Checked else Qt.CheckState.Checked
        selection_model = self.tree_view.selectionModel(); selected_indexes = selection_model.selectedIndexes()
        logger.debug(f"Clicked item: {self.checkable_proxy.get_file_path_from_index(index)}, Target state: {target_check_state}, Selected count: {len(selected_indexes)}")
        indices_processed = set()
        try:
            for selected_index in selected_indexes:
                if selected_index.isValid() and selected_index.column() == 0 and selected_index not in indices_processed:
                    logger.debug(f"  Calling setData for selected index: {self.checkable_proxy.get_file_path_from_index(selected_index)} with state {target_check_state}")
                    self.checkable_proxy.setData(selected_index, target_check_state, Qt.ItemDataRole.CheckStateRole); indices_processed.add(selected_index)
        finally: pass
        self.state_changed_signal.emit()

    def restart_auto_save_timer(self):
        """Restarts the auto-save timer."""
        if self._initialized: self.auto_save_timer.start(30000)

    def eventFilter(self, source: QObject, event: QEvent) -> bool:
        """Filters events for Ctrl+Enter in user tab."""
        if source == self.user_tab and event.type() == QEvent.Type.KeyPress:
            key_event = event
            if isinstance(key_event, QKeyEvent):
                is_control_pressed = bool(key_event.modifiers() & Qt.KeyboardModifier.ControlModifier)
                is_enter_key = key_event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter)
                if is_control_pressed and is_enter_key:
                    logger.info("Ctrl+Enter detected in user_tab. Triggering 'Generate All' then 'Send to Gemini'.")
                    if self.mode == "Code Enhancer Prompt Builder":
                        logger.info("Running 'Generate All'...")
                        success_generate_all = self.prompt_controller.generate_all_and_copy()
                        prompt_generated = bool(self.last_generated_prompt and self.last_generated_prompt.strip())
                        if prompt_generated:
                            logger.info("Prompt generated. Proceeding to 'Send to Gemini'.")
                            if not success_generate_all: logger.warning("'Generate All' returned False, but prompt was generated. Sending to Gemini anyway."); self.status_bar.showMessage("일부 작업 실패, Gemini 전송 시도...")
                            self.send_prompt_to_gemini()
                        else: logger.error("'Generate All' failed to generate a prompt. Skipping 'Send to Gemini'."); QMessageBox.warning(self, "실패", "'한번에 실행' 작업 중 프롬프트 생성에 실패하여 Gemini로 전송하지 못했습니다.")
                    else: logger.info("Ctrl+Enter ignored in Meta Prompt Builder mode.")
                    return True
        return super().eventFilter(source, event)

    def closeEvent(self, event):
        """Ensure database connection is closed and threads are stopped."""
        logger.info("Closing MainWindow. Stopping threads and disconnecting database."); self.auto_save_timer.stop(); self.api_timer.stop()
        if hasattr(self, 'main_controller'): self.main_controller._stop_token_calculation_thread()
        if self.gemini_thread and self.gemini_thread.isRunning(): logger.warning("Terminating Gemini thread on close..."); self.gemini_thread.quit(); self.gemini_thread.wait(1000); self.cleanup_gemini_thread()
        # --- 비동기 SSH 연결 해제 시도 (루프 없을 수 있음) ---
        if self.ssh_client:
            logger.warning("SSH connection still open during closeEvent. Closing synchronously.")
            self._close_ssh_connection_sync() # Use sync close in closeEvent
        # -------------------------------------------------
        try: logger.info("Attempting to save final state before closing..."); self.resource_controller.save_state_to_default()
        except Exception as e: logger.error(f"Error saving final state: {e}")
        if hasattr(self, 'db_service'): self.db_service.disconnect()
        super().closeEvent(event)

  


======== src\ui\main_window_setup_signals.py ========
from PyQt6.QtGui import QKeySequence, QAction # PyQt5 -> PyQt6
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow 타입 힌트
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# 컨트롤러 import (함수 호출용)
def connect_signals(mw: 'MainWindow'):
    """Connects widget signals to controller slots."""
    # 상단 버튼
    mw.mode_toggle_btn.clicked.connect(mw._toggle_mode)
    mw.reset_program_btn.clicked.connect(mw.main_controller.reset_program) # MainController
    mw.load_previous_work_btn.clicked.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.save_current_work_btn.clicked.connect(mw.resource_controller.save_state_to_default) # ResourceController (save default)
    mw.select_project_btn.clicked.connect(mw.file_tree_controller.select_project_folder) # FileTreeController

    # SSH 연결 버튼 시그널 연결 (비동기 트리거 함수로 변경)
    mw.ssh_connect_btn.clicked.connect(mw._trigger_toggle_ssh_async) # MainWindow

    # 파일 트리
    mw.tree_view.customContextMenuRequested.connect(mw.on_tree_view_context_menu) # MainWindow (컨트롤러 호출)
    mw.tree_view.clicked.connect(mw.on_tree_view_item_clicked) # 아이템 클릭 시 체크 상태 토글 (연결 복원)
    mw.checkable_proxy.dataChanged.connect(mw.file_tree_controller.on_data_changed) # FileTreeController
    # 파일 체크 상태 변경 시 MainWindow의 상태 변경 시그널 발생
    mw.checkable_proxy.dataChanged.connect(lambda topLeft, bottomRight, roles: mw.state_changed_signal.emit() if Qt.ItemDataRole.CheckStateRole in roles else None) # Qt.CheckStateRole -> Qt.ItemDataRole.CheckStateRole


    # 실행 버튼
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn.clicked.connect(mw.file_tree_controller.generate_directory_tree_structure) # FileTreeController
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_prompt) # PromptController (Calculates tokens)
        mw.send_to_gemini_btn.clicked.connect(mw.send_prompt_to_gemini) # MainWindow (LangGraph 호출)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        mw.run_xml_parser_btn.clicked.connect(mw.xml_controller.run_xml_parser) # XmlController
        mw.generate_all_btn.clicked.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens via generate_prompt)
    else:
        mw.generate_btn.clicked.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
        mw.copy_btn.clicked.connect(mw.prompt_controller.copy_to_clipboard) # PromptController
        if hasattr(mw, "generate_final_prompt_btn"):
            mw.generate_final_prompt_btn.clicked.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)

    # 리소스 관리
    mw.resource_mode_combo.currentIndexChanged.connect(mw.resource_controller.load_templates_list) # ResourceController
    mw.load_selected_template_btn.clicked.connect(mw.resource_controller.load_selected_item) # ResourceController
    mw.save_as_template_btn.clicked.connect(mw.resource_controller.save_current_as_item) # ResourceController
    mw.delete_template_btn.clicked.connect(mw.resource_controller.delete_selected_item) # ResourceController
    mw.update_template_btn.clicked.connect(mw.resource_controller.update_current_item) # ResourceController
    # 백업/복원 버튼 시그널 연결 제거
    # mw.backup_button.clicked.connect(mw.resource_controller.backup_all_states_action)
    # mw.restore_button.clicked.connect(mw.resource_controller.restore_states_from_backup_action)
    mw.template_tree.itemDoubleClicked.connect(mw.resource_controller.load_selected_item) # ResourceController

    # 첨부 파일 관리 버튼 (추가)
    if hasattr(mw, 'attach_file_btn'):
        mw.attach_file_btn.clicked.connect(mw.main_controller.attach_files) # MainController
    if hasattr(mw, 'paste_clipboard_btn'):
        mw.paste_clipboard_btn.clicked.connect(mw.main_controller.paste_from_clipboard) # MainController
    if hasattr(mw, 'remove_attachment_btn'):
        mw.remove_attachment_btn.clicked.connect(mw.main_controller.remove_selected_attachment) # MainController

    # 상태바 & 모델 선택
    mw.llm_combo.currentIndexChanged.connect(mw.main_controller.on_llm_selected) # MainController (Resets token label)
    # 모델명 변경 시 상태 변경 시그널 발생
    mw.model_name_combo.currentIndexChanged.connect(lambda: mw.state_changed_signal.emit())
    mw.model_name_combo.lineEdit().editingFinished.connect(lambda: mw.state_changed_signal.emit())


    # --- Gemini 파라미터 변경 시그널 연결 제거 (DB 저장 비활성화) ---
    # mw.gemini_temp_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_thinking_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # mw.gemini_budget_edit.textChanged.connect(mw.save_gemini_settings)
    # mw.gemini_search_checkbox.stateChanged.connect(mw.save_gemini_settings)
    # -----------------------------------------------------------

    # 텍스트 변경 시 문자 수 업데이트 및 토큰 레이블 리셋 (현재 활성 탭 기준)
    mw.build_tabs.currentChanged.connect(mw.main_controller.update_char_count_for_active_tab) # Update char counts when tab changes
    # Connect textChanged for all relevant text edit widgets to the new handler
    mw.system_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.user_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    mw.prompt_output_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'dir_structure_tab'):
        mw.dir_structure_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'xml_input_tab'):
        mw.xml_input_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'summary_tab'): # Summary 탭 연결 추가
        mw.summary_tab.textChanged.connect(mw.main_controller.handle_text_changed) # ReadOnly, but connect anyway
    if hasattr(mw, 'meta_prompt_tab'):
        mw.meta_prompt_tab.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'user_prompt_tab'):
        user_prompt_tab_widget = getattr(mw, 'user_prompt_tab', None)
        if user_prompt_tab_widget:
            user_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    if hasattr(mw, 'final_prompt_tab'):
        final_prompt_tab_widget = getattr(mw, 'final_prompt_tab', None)
        if final_prompt_tab_widget:
            final_prompt_tab_widget.textChanged.connect(mw.main_controller.handle_text_changed)
    # Custom tabs added later will have their signals connected in add_new_custom_tab

    # 메뉴 액션
    mw.settings_action.triggered.connect(mw.open_settings_dialog) # 설정 메뉴 연결
    mw.save_state_action.triggered.connect(mw.resource_controller.save_state_to_default) # ResourceController
    mw.load_state_action.triggered.connect(mw.resource_controller.load_state_from_default) # ResourceController (partial load)
    mw.export_state_action.triggered.connect(mw.resource_controller.export_state_to_file) # ResourceController
    mw.import_state_action.triggered.connect(mw.resource_controller.import_state_from_file) # ResourceController

    # 단축키
    # Ctrl+Enter 단축키는 MainWindow의 eventFilter에서 처리하므로 여기서 제거
    # shortcut_generate = QAction(mw) # PyQt6: QAction(parent)
    # shortcut_generate.setShortcut(QKeySequence(Qt.Modifier.CTRL | Qt.Key.Key_Return)) # PyQt6: Use Qt.Modifier and Qt.Key
    # if mw.mode == "Meta Prompt Builder":
    #      if hasattr(mw, "generate_final_prompt_btn"):
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_final_meta_prompt) # PromptController (Calculates tokens)
    #      else:
    #          shortcut_generate.triggered.connect(mw.prompt_controller.generate_meta_prompt) # PromptController (Calculates tokens)
    # else:
    #      shortcut_generate.triggered.connect(mw.prompt_controller.generate_all_and_copy) # PromptController (Calculates tokens)
    # mw.addAction(shortcut_generate)

    shortcut_copy = QAction(mw) # PyQt6: QAction(parent)
    shortcut_copy.setShortcut(QKeySequence(QKeySequence.StandardKey.Copy)) # PyQt6: Use StandardKey enum
    shortcut_copy.triggered.connect(mw.on_copy_shortcut) # MainWindow
    mw.addAction(shortcut_copy)

    # 사용자 탭에 이벤트 필터 설치 (MainWindow 생성자에서 수행)
    # if hasattr(mw, 'user_tab'):
    #     mw.user_tab.installEventFilter(mw)



======== src\ui\main_window_setup_ui.py ========
import os
import sys
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QWidget, QVBoxLayout, QHBoxLayout, QTreeView, QTabWidget,
    QStatusBar, QPushButton, QLabel, QCheckBox, QAbstractItemView, QMenuBar,
    QSplitter, QStyleFactory, QApplication, QMenu, QTreeWidget, QComboBox,
    QFrame, QLineEdit, QGroupBox, QSpacerItem, QSizePolicy, QListWidget,
    QGridLayout
)
from PyQt6.QtGui import QFont, QFontDatabase, QAction # PyQt5 -> PyQt6, QAction 추가
from PyQt6.QtCore import Qt # PyQt5 -> PyQt6

# MainWindow 타입 힌트
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow

# 모델 및 위젯 import
from .models.file_system_models import FilteredFileSystemModel, CheckableProxyModel
from .widgets.custom_text_edit import CustomTextEdit
from .widgets.custom_tab_bar import CustomTabBar
from utils.helpers import get_resource_path
from .widgets.check_box_delegate import CheckBoxDelegate
from .widgets.file_tree_view import FileTreeView

def create_menu_bar(mw: 'MainWindow'):
    """Creates the main menu bar."""
    mw.menubar = QMenuBar(mw)
    mw.setMenuBar(mw.menubar)

    # "파일" 메뉴 제거, "환경 설정" 메뉴를 첫 번째로 추가
    settings_menu = mw.menubar.addMenu("환경 설정") # "파일" 대신 "환경 설정" 메뉴 추가
    mw.settings_action = QAction("환경 설정 열기...", mw) # PyQt6: QAction(text, parent)
    settings_menu.addAction(mw.settings_action)
    settings_menu.addSeparator() # 필요 시 구분선 추가

    # 나머지 메뉴들
    mode_menu = mw.menubar.addMenu("모드")
    switch_to_code_action = QAction("코드 강화 빌더로 전환", mw) # PyQt6: QAction(text, parent)
    switch_to_meta_action = QAction("메타 프롬프트 빌더로 전환", mw) # PyQt6: QAction(text, parent)
    switch_to_code_action.triggered.connect(lambda: mw._restart_with_mode("Code Enhancer Prompt Builder"))
    switch_to_meta_action.triggered.connect(lambda: mw._restart_with_mode("Meta Prompt Builder"))
    mode_menu.addAction(switch_to_code_action)
    mode_menu.addAction(switch_to_meta_action)

    state_menu = mw.menubar.addMenu("상태")
    mw.save_state_action = QAction("상태 저장(기본)", mw) # PyQt6: QAction(text, parent)
    mw.load_state_action = QAction("상태 불러오기(기본)", mw) # PyQt6: QAction(text, parent)
    mw.export_state_action = QAction("상태 내보내기", mw) # PyQt6: QAction(text, parent)
    mw.import_state_action = QAction("상태 가져오기", mw) # PyQt6: QAction(text, parent)
    state_menu.addAction(mw.save_state_action)
    state_menu.addAction(mw.load_state_action)
    state_menu.addAction(mw.export_state_action)
    state_menu.addAction(mw.import_state_action)

    help_menu = mw.menubar.addMenu("도움말")
    open_readme_action = QAction("README 열기", mw) # PyQt6: QAction(text, parent)
    open_readme_action.triggered.connect(mw._open_readme)
    help_menu.addAction(open_readme_action)


def create_widgets(mw: 'MainWindow'):
    """Creates the main widgets used in the window."""
    # --- OS별 기본 폰트 설정 ---
    default_font = QFont()
    font_family_name = ""
    if sys.platform == "win32":
        try:
            font_path = get_resource_path("fonts/malgun.ttf")
            font_id = QFontDatabase.addApplicationFont(font_path)
            if font_id != -1:
                family = QFontDatabase.applicationFontFamilies(font_id)[0]
                print(f"Loaded custom font: {family} from {font_path}")
                default_font = QFont(family, 10)
                font_family_name = family
            else:
                print(f"Failed to load custom font from {font_path}. Using system default.")
                default_font.setFamily("Malgun Gothic")
                default_font.setPointSize(10)
                font_family_name = "Malgun Gothic (Fallback)"
        except Exception as e:
            print(f"Error loading custom font: {e}. Using system default.")
            default_font.setFamily("Malgun Gothic")
            default_font.setPointSize(10)
            font_family_name = "Malgun Gothic (Exception Fallback)"
    elif sys.platform == "darwin":
        default_font.setFamily("Apple SD Gothic Neo")
        default_font.setPointSize(11)
        font_family_name = "Apple SD Gothic Neo"
    else:
        default_font.setStyleHint(QFont.StyleHint.SansSerif) # QFont.SansSerif -> QFont.StyleHint.SansSerif
        default_font.setPointSize(10)
        font_family_name = "System Default Sans-Serif"
    print(f"Applying default font: {font_family_name}, Size: {default_font.pointSize()}")

    # --- 상단 버튼 및 레이블 ---
    mw.mode_toggle_btn = QPushButton("🔄 모드 전환")
    mw.reset_program_btn = QPushButton("🗑️ 전체 프로그램 리셋")
    mw.load_previous_work_btn = QPushButton("⏪ 마지막 작업 불러오기") # 버튼 텍스트 변경
    mw.save_current_work_btn = QPushButton("💾 현재 작업 저장") # 작업 저장 버튼 추가
    mw.select_project_btn = QPushButton("📁 프로젝트 폴더 선택")
    for btn in [mw.mode_toggle_btn, mw.reset_program_btn, mw.load_previous_work_btn, mw.save_current_work_btn, mw.select_project_btn]: # 새 버튼 포함
        btn.setFixedHeight(30)
    mw.project_folder_label = QLabel("현재 프로젝트 폴더: (선택 안 됨)")
    font_lbl = mw.project_folder_label.font()
    font_lbl.setPointSize(10); font_lbl.setBold(True)
    mw.project_folder_label.setFont(font_lbl)

    # --- 파일 탐색기 (왼쪽) ---
    mw.dir_model = FilteredFileSystemModel()
    mw.tree_view = FileTreeView()
    project_folder_getter = lambda: mw.current_project_folder
    mw.checkable_proxy = CheckableProxyModel(mw.dir_model, project_folder_getter, mw.fs_service, mw.tree_view)
    mw.checkable_proxy.setSourceModel(mw.dir_model)
    mw.tree_view.setModel(mw.checkable_proxy)
    mw.tree_view.setColumnWidth(0, 250)
    mw.tree_view.hideColumn(1); mw.tree_view.hideColumn(2); mw.tree_view.hideColumn(3)
    mw.tree_view.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    mw.tree_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu) # Qt.CustomContextMenu -> Qt.ContextMenuPolicy.CustomContextMenu
    mw.tree_view.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers) # QAbstractItemView.NoEditTriggers -> QAbstractItemView.EditTrigger.NoEditTriggers
    mw.tree_view.setItemDelegateForColumn(0, CheckBoxDelegate(mw.tree_view))

    # --- 리소스 관리 (오른쪽 하단) ---
    mw.resource_manager_group = QGroupBox("리소스 관리")
    resource_manager_layout = QGridLayout() # QVBoxLayout 대신 QGridLayout 사용
    resource_manager_layout.setContentsMargins(5, 5, 5, 5); resource_manager_layout.setSpacing(5)

    # 위젯 생성 (기존 코드 재사용)
    mw.resource_mode_combo = QComboBox(); mw.resource_mode_combo.addItems(["프롬프트", "상태"])
    mw.template_tree = QTreeWidget(); mw.template_tree.setHeaderHidden(True)
    mw.load_selected_template_btn = QPushButton("📥 선택 불러오기")
    mw.save_as_template_btn = QPushButton("💾 현재 내용으로 저장")
    mw.template_type_label = QLabel("저장 타입:")
    mw.template_type_combo = QComboBox(); mw.template_type_combo.addItems(["시스템", "사용자"])
    mw.delete_template_btn = QPushButton("❌ 선택 삭제")
    mw.update_template_btn = QPushButton("🔄 현재 내용 업데이트")

    # --- 레이아웃 재구성 (2열 그리드) ---
    # 왼쪽 열 (Column 0)
    resource_manager_layout.addWidget(QLabel("아래에서 로드/저장할 리소스 선택:"), 0, 0, 1, 2) # 라벨은 2열에 걸쳐 표시
    resource_manager_layout.addWidget(mw.template_tree, 1, 0, 6, 1) # 트리는 1행부터 6개 행에 걸쳐 표시

    # 오른쪽 열 (Column 1) - 위젯 배치 순서 조정
    resource_manager_layout.addWidget(mw.load_selected_template_btn, 1, 1) # 행 1

    # 저장 타입 레이아웃 (HBox)
    save_type_layout = QHBoxLayout()
    save_type_layout.addWidget(mw.template_type_label)
    save_type_layout.addWidget(mw.template_type_combo)
    save_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(save_type_layout, 2, 1) # 행 2

    # 리소스 타입 선택 레이아웃 (HBox)
    resource_type_layout = QHBoxLayout()
    resource_type_layout.addWidget(QLabel("리소스 타입 선택:"))
    resource_type_layout.addWidget(mw.resource_mode_combo)
    resource_type_layout.setContentsMargins(0, 0, 0, 0)
    resource_manager_layout.addLayout(resource_type_layout, 3, 1) # 행 3

    resource_manager_layout.addWidget(mw.save_as_template_btn, 4, 1) # 행 4
    resource_manager_layout.addWidget(mw.update_template_btn, 5, 1) # 행 5
    resource_manager_layout.addWidget(mw.delete_template_btn, 6, 1) # 행 6

    # 오른쪽 열 하단에 빈 공간 추가 (선택적)
    resource_manager_layout.addItem(QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding), 7, 1) # QSizePolicy.Minimum -> QSizePolicy.Policy.Minimum, QSizePolicy.Expanding -> QSizePolicy.Policy.Expanding

    # 열 너비 비율 설정 (선택적)
    resource_manager_layout.setColumnStretch(0, 1) # 왼쪽 열(트리)이 남는 공간 차지
    resource_manager_layout.setColumnStretch(1, 0) # 오른쪽 열(버튼)은 필요한 만큼만

    mw.resource_manager_group.setLayout(resource_manager_layout) # 최종 레이아웃 설정

    # --- 첨부 파일 관리 (왼쪽 하단으로 이동) ---
    mw.attachment_group = QGroupBox("첨부 파일")
    attachment_layout = QVBoxLayout()
    attachment_layout.setContentsMargins(5, 5, 5, 5); attachment_layout.setSpacing(5)
    attachment_button_layout = QHBoxLayout()
    mw.attach_file_btn = QPushButton("📎 파일 첨부")
    mw.paste_clipboard_btn = QPushButton("📋 클립보드 붙여넣기")
    mw.remove_attachment_btn = QPushButton("➖ 선택 제거")
    attachment_button_layout.addWidget(mw.attach_file_btn)
    attachment_button_layout.addWidget(mw.paste_clipboard_btn)
    attachment_button_layout.addWidget(mw.remove_attachment_btn)
    attachment_button_layout.addStretch()
    mw.attachment_list_widget = QListWidget() # 리스트 위젯 생성
    mw.attachment_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection) # QAbstractItemView.ExtendedSelection -> QAbstractItemView.SelectionMode.ExtendedSelection
    attachment_layout.addLayout(attachment_button_layout)
    attachment_layout.addWidget(mw.attachment_list_widget, 1) # 리스트 위젯이 공간 차지
    mw.attachment_group.setLayout(attachment_layout)
    # Code Enhancer 모드에서만 보이도록 설정 (초기 상태)
    mw.attachment_group.setVisible(mw.mode == "Code Enhancer Prompt Builder")


    # --- 탭 위젯 (오른쪽 상단) ---
    mw.build_tabs = QTabWidget()
    custom_tab_bar = CustomTabBar(mw.build_tabs, mw)
    mw.build_tabs.setTabBar(custom_tab_bar)
    system_tab_label = "메타 프롬프트 템플릿" if mw.mode == "Meta Prompt Builder" else "시스템"
    user_tab_label = "메타 사용자 입력" if mw.mode == "Meta Prompt Builder" else "사용자"
    prompt_output_label = "메타 프롬프트 출력" if mw.mode == "Meta Prompt Builder" else "프롬프트 출력"
    mw.system_tab = CustomTextEdit(); mw.system_tab.setPlaceholderText(f"{system_tab_label} 내용 입력..."); mw.system_tab.setFont(default_font); mw.build_tabs.addTab(mw.system_tab, system_tab_label)
    mw.user_tab = CustomTextEdit(); mw.user_tab.setPlaceholderText(f"{user_tab_label} 내용 입력..."); mw.user_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_tab, user_tab_label)
    if mw.mode != "Meta Prompt Builder":
        mw.dir_structure_tab = CustomTextEdit(); mw.dir_structure_tab.setReadOnly(True); mw.dir_structure_tab.setFont(default_font); mw.build_tabs.addTab(mw.dir_structure_tab, "파일 트리")
    mw.prompt_output_tab = CustomTextEdit()
    output_font = QFont("Consolas", 10) if sys.platform == "win32" else QFont("Monaco", 11) if sys.platform == "darwin" else QFont("Monospace", 10); output_font.setStyleHint(QFont.StyleHint.Monospace) # QFont.Monospace -> QFont.StyleHint.Monospace
    mw.prompt_output_tab.setFont(output_font); mw.prompt_output_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.prompt_output_tab, prompt_output_label)
    if mw.mode != "Meta Prompt Builder":
        mw.xml_input_tab = CustomTextEdit(); mw.xml_input_tab.setPlaceholderText("XML 내용 입력..."); mw.xml_input_tab.setFont(default_font); mw.build_tabs.addTab(mw.xml_input_tab, "XML 입력")
        mw.summary_tab = CustomTextEdit(); mw.summary_tab.setPlaceholderText("Gemini 응답 요약..."); mw.summary_tab.setReadOnly(True); mw.summary_tab.setFont(default_font); mw.build_tabs.addTab(mw.summary_tab, "Summary")
    if mw.mode == "Meta Prompt Builder":
        mw.meta_prompt_tab = CustomTextEdit(); mw.meta_prompt_tab.setPlaceholderText("메타 프롬프트 내용..."); mw.meta_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.meta_prompt_tab, "메타 프롬프트")
        mw.user_prompt_tab = CustomTextEdit(); mw.user_prompt_tab.setPlaceholderText("사용자 프롬프트 내용 입력..."); mw.user_prompt_tab.setFont(default_font); mw.build_tabs.addTab(mw.user_prompt_tab, "사용자 프롬프트")
        mw.final_prompt_tab = CustomTextEdit(); mw.final_prompt_tab.setFont(output_font); mw.final_prompt_tab.setStyleSheet("QTextEdit { padding: 10px; }"); mw.build_tabs.addTab(mw.final_prompt_tab, "최종 프롬프트")

    # --- 실행 버튼 (오른쪽 상단) ---
    copy_btn_label = "📋 메타 프롬프트 복사" if mw.mode == "Meta Prompt Builder" else "📋 클립보드에 복사"
    if mw.mode != "Meta Prompt Builder":
        mw.generate_tree_btn = QPushButton("🌳 트리 생성")
        mw.generate_btn = QPushButton("✨ 프롬프트 생성")
        mw.send_to_gemini_btn = QPushButton("♊ Gemini로 전송")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.run_xml_parser_btn = QPushButton("▶️ XML 파서 실행")
        mw.generate_all_btn = QPushButton("⚡️ 한번에 실행")
        mw.run_buttons = [mw.generate_tree_btn, mw.generate_btn, mw.send_to_gemini_btn, mw.copy_btn, mw.run_xml_parser_btn, mw.generate_all_btn]
    else:
        mw.generate_btn = QPushButton("🚀 메타 프롬프트 생성")
        mw.copy_btn = QPushButton(copy_btn_label)
        mw.generate_final_prompt_btn = QPushButton("🚀 최종 프롬프트 생성")
        mw.run_buttons = [mw.generate_btn, mw.copy_btn, mw.generate_final_prompt_btn]

    # --- 상태 표시줄 위젯 ---
    mw.char_count_label = QLabel("Chars: 0")
    mw.token_count_label = QLabel("토큰 계산: -")
    mw.api_time_label = QLabel("API 시간: -") # API 시간 표시 라벨 추가

    # --- LLM 관련 위젯 (상단) ---
    mw.llm_combo = QComboBox(); mw.llm_combo.addItems(["Gemini", "Claude", "GPT"])
    mw.model_name_combo = QComboBox(); mw.model_name_combo.setEditable(True); mw.model_name_combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert) # QComboBox.NoInsert -> QComboBox.InsertPolicy.NoInsert
    mw.gemini_temp_label = QLabel("Temp:")
    mw.gemini_temp_edit = QLineEdit(); mw.gemini_temp_edit.setFixedWidth(40); mw.gemini_temp_edit.setPlaceholderText("0.0")
    mw.gemini_thinking_label = QLabel("Thinking:")
    mw.gemini_thinking_checkbox = QCheckBox()
    mw.gemini_budget_label = QLabel("Budget:")
    mw.gemini_budget_edit = QLineEdit(); mw.gemini_budget_edit.setFixedWidth(60); mw.gemini_budget_edit.setPlaceholderText("24576")
    mw.gemini_search_label = QLabel("Search:")
    mw.gemini_search_checkbox = QCheckBox()
    # Gemini 파라미터 위젯 그룹화 (상단 이동용)
    mw.gemini_param_widget = QWidget()
    gemini_param_layout = QHBoxLayout(mw.gemini_param_widget)
    gemini_param_layout.setContentsMargins(0, 0, 0, 0); gemini_param_layout.setSpacing(5)
    # 위젯 추가 순서 변경: Temp -> Search -> Thinking -> Budget
    gemini_param_layout.addWidget(mw.gemini_temp_label); gemini_param_layout.addWidget(mw.gemini_temp_edit)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_search_label); gemini_param_layout.addWidget(mw.gemini_search_checkbox) # Search 이동
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_thinking_label); gemini_param_layout.addWidget(mw.gemini_thinking_checkbox)
    gemini_param_layout.addSpacerItem(QSpacerItem(10, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    gemini_param_layout.addWidget(mw.gemini_budget_label); gemini_param_layout.addWidget(mw.gemini_budget_edit)
    mw.gemini_param_widget.setVisible(mw.llm_combo.currentText() == "Gemini") # 초기 가시성 설정

    # --- SSH 연결 위젯 (상단) ---
    mw.ssh_connection_combo = QComboBox(); mw.ssh_connection_combo.setMinimumWidth(150)
    mw.ssh_connection_combo.setToolTip("사용할 SSH 연결 설정을 선택하세요.")
    mw.ssh_connect_btn = QPushButton("🔌 연결"); mw.ssh_connect_btn.setFixedWidth(100)
    mw.ssh_status_label = QLabel("SSH: 미연결"); mw.ssh_status_label.setMinimumWidth(120)


def create_layout(mw: 'MainWindow'):
    """Creates the layout and arranges widgets."""
    central_widget = QWidget()
    mw.setCentralWidget(central_widget)
    main_layout = QVBoxLayout(central_widget)
    main_layout.setContentsMargins(5, 2, 5, 5); main_layout.setSpacing(2)

    # --- 상단 레이아웃 (버튼 + 프로젝트 경로 + LLM 컨트롤 + SSH 컨트롤) ---
    top_layout_wrapper = QVBoxLayout(); top_layout_wrapper.setSpacing(2); top_layout_wrapper.setContentsMargins(0, 0, 0, 0)

    # 상단 버튼 행
    top_button_container = QWidget()
    top_button_layout = QHBoxLayout(top_button_container)
    top_button_layout.setSpacing(10); top_button_layout.setContentsMargins(0, 0, 0, 0)
    top_button_layout.addWidget(mw.mode_toggle_btn)
    top_button_layout.addWidget(mw.reset_program_btn)
    top_button_layout.addWidget(mw.load_previous_work_btn)
    top_button_layout.addWidget(mw.save_current_work_btn) # 작업 저장 버튼 추가
    top_button_layout.addWidget(mw.select_project_btn)
    top_button_layout.addStretch(1)
    top_layout_wrapper.addWidget(top_button_container)

    # 프로젝트 경로 행
    top_layout_wrapper.addWidget(mw.project_folder_label)

    # LLM 컨트롤 행 (새로 추가)
    llm_controls_container = QWidget()
    llm_controls_layout = QHBoxLayout(llm_controls_container)
    llm_controls_layout.setContentsMargins(0, 5, 0, 5); llm_controls_layout.setSpacing(10) # 상하 여백 추가
    llm_controls_layout.addWidget(QLabel("Model:"))
    llm_controls_layout.addWidget(mw.llm_combo); mw.llm_combo.setFixedWidth(80)
    llm_controls_layout.addWidget(mw.model_name_combo); mw.model_name_combo.setMinimumWidth(180)
    llm_controls_layout.addWidget(mw.gemini_param_widget) # Gemini 파라미터 그룹 위젯 추가

    # SSH 컨트롤 추가
    llm_controls_layout.addStretch(1) # 여백 추가 후 SSH 위젯 배치
    llm_controls_layout.addWidget(mw.ssh_connection_combo)
    llm_controls_layout.addWidget(mw.ssh_connect_btn)
    llm_controls_layout.addWidget(mw.ssh_status_label)

    top_layout_wrapper.addWidget(llm_controls_container)

    main_layout.addLayout(top_layout_wrapper, 0) # 상단 전체 레이아웃 추가

    # --- 중앙 스플리터 ---
    mw.center_splitter = QSplitter(Qt.Orientation.Horizontal) # Qt.Horizontal -> Qt.Orientation.Horizontal

    # --- 왼쪽 영역 (파일 트리 + 첨부 파일) ---
    left_side_widget = QWidget() # 컨테이너 위젯
    left_side_layout = QVBoxLayout(left_side_widget) # 메인 레이아웃
    left_side_layout.setContentsMargins(2, 2, 2, 2); left_side_layout.setSpacing(5)

    # 세로 스플리터 생성
    left_splitter = QSplitter(Qt.Orientation.Vertical) # Qt.Vertical -> Qt.Orientation.Vertical
    left_splitter.addWidget(mw.tree_view) # 파일 트리 추가
    left_splitter.addWidget(mw.attachment_group) # 첨부 파일 그룹 추가
    left_splitter.setSizes([400, 200]) # 초기 크기 설정 (조정 가능)

    left_side_layout.addWidget(left_splitter) # 스플리터를 레이아웃에 추가

    mw.center_splitter.addWidget(left_side_widget)

    # --- 오른쪽 영역 (실행 버튼 + 상하 분할 영역) ---
    right_side_widget = QWidget()
    right_side_layout = QVBoxLayout(right_side_widget)
    right_side_layout.setContentsMargins(0, 0, 0, 0); right_side_layout.setSpacing(0)

    # 실행 버튼 컨테이너
    run_buttons_container = QWidget()
    run_layout = QHBoxLayout(run_buttons_container)
    run_layout.setContentsMargins(5, 5, 5, 5); run_layout.setSpacing(10); run_layout.setAlignment(Qt.AlignmentFlag.AlignLeft) # Qt.AlignLeft -> Qt.AlignmentFlag.AlignLeft
    for btn in mw.run_buttons: run_layout.addWidget(btn)
    run_layout.addStretch(1)
    right_side_layout.addWidget(run_buttons_container)

    # 구분선
    line_frame = QFrame(); line_frame.setFrameShape(QFrame.Shape.HLine); line_frame.setFrameShadow(QFrame.Shadow.Sunken) # QFrame.HLine -> QFrame.Shape.HLine, QFrame.Sunken -> QFrame.Shadow.Sunken
    right_side_layout.addWidget(line_frame)

    # 오른쪽 상하 분할 스플리터
    right_content_splitter = QSplitter(Qt.Orientation.Vertical) # Qt.Vertical -> Qt.Orientation.Vertical

    # 오른쪽 상단: 탭 위젯
    right_content_splitter.addWidget(mw.build_tabs)

    # 오른쪽 하단: 리소스 관리만
    bottom_right_widget = QWidget()
    bottom_right_layout = QVBoxLayout(bottom_right_widget)
    bottom_right_layout.setContentsMargins(0, 5, 0, 0) # 상단 여백 추가
    bottom_right_layout.setSpacing(5)
    bottom_right_layout.addWidget(mw.resource_manager_group) # 리소스 관리 그룹만 추가
    right_content_splitter.addWidget(bottom_right_widget)

    # 오른쪽 상하 스플리터 크기 비율 설정 (예: 2:1)
    right_content_splitter.setSizes([400, 200]) # 초기 높이 설정 (조정 가능)

    # 오른쪽 레이아웃에 상하 스플리터 추가
    right_side_layout.addWidget(right_content_splitter)

    # 중앙 스플리터에 오른쪽 영역 추가
    mw.center_splitter.addWidget(right_side_widget)

    # 중앙 스플리터 크기 비율 설정 (예: 1:3)
    # setStretchFactor is deprecated in PyQt6, use setSizes or handle resize events
    # mw.center_splitter.setStretchFactor(0, 1) # 왼쪽 영역 비율
    # mw.center_splitter.setStretchFactor(1, 3) # 오른쪽 영역 비율
    # Instead, set initial sizes (already done above)

    # 메인 레이아웃에 중앙 스플리터 추가
    main_layout.addWidget(mw.center_splitter, 1)


def create_status_bar(mw: 'MainWindow'):
    """Creates the status bar."""
    mw.status_bar = QStatusBar()
    mw.setStatusBar(mw.status_bar)
    status_widget = QWidget()
    status_layout = QHBoxLayout(status_widget)
    status_layout.setContentsMargins(5, 2, 5, 2); status_layout.setSpacing(10)

    # 문자 수와 토큰 계산 라벨을 붙여서 추가
    status_layout.addWidget(mw.char_count_label)
    status_layout.addWidget(mw.token_count_label) # 토큰 계산 라벨 위치 변경

    # API 시간 표시 라벨 추가
    status_layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)) # QSizePolicy.Fixed -> QSizePolicy.Policy.Fixed
    status_layout.addWidget(mw.api_time_label)

    # LLM 관련 위젯들은 상단으로 이동했으므로 여기서 제거
    # status_layout.addWidget(QLabel("Model:"))
    # status_layout.addWidget(mw.llm_combo); mw.llm_combo.setFixedWidth(80)
    # status_layout.addWidget(mw.model_name_combo); mw.model_name_combo.setMinimumWidth(180)
    # status_layout.addWidget(mw.gemini_param_widget) # Gemini 파라미터 그룹 위젯 추가

    status_layout.addStretch(1)
    mw.status_bar.addPermanentWidget(status_widget)



  


======== src\ui\settings_dialog.py ========
import os
import datetime
import asyncio # asyncio 추가
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QPlainTextEdit, QFileDialog, QMessageBox, QGroupBox, QHBoxLayout, QComboBox,
    QCheckBox, QApplication, QListWidget, QListWidgetItem, QAbstractItemView, QInputDialog, QWidget,
    QSplitter, QSizePolicy, QTableWidget, QTableWidgetItem, QHeaderView, QAbstractScrollArea,
    QTabWidget
)
from PyQt6.QtCore import Qt, QThreadPool, QObject, pyqtSignal, QThread
from PyQt6.QtGui import QColor, QIcon, QIntValidator, QBrush, QFont, QFontDatabase
from typing import Optional, Set, List, Dict, Any, Tuple
from pydantic import ValidationError
import logging
from concurrent.futures import ThreadPoolExecutor

# 서비스 및 컨트롤러 함수 import
from core.services.config_service import ConfigService
from core.services.ssh_config_service import SshConfigService
from core.pydantic_models.config_settings import ConfigSettings
from core.pydantic_models.ssh_connection_config import SshConnectionConfig
from ui.controllers.system_prompt_controller import select_default_system_prompt
from ui.widgets.ssh_config_dialog import SshConfigDialog

# MainWindow 타입 힌트 (순환 참조 방지)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow
    from core.services.db_service import DbService

logger = logging.getLogger(__name__)

PASTEL_GREEN = QColor(152, 251, 152)
PASTEL_BLUE = QColor(173, 216, 230)
PASTEL_PURPLE = QColor(221, 160, 221)

# --- 모델 추가 다이얼로그 ---
class AddModelDialog(QDialog):
    """모델 이름, RPM, Daily Limit을 입력받는 다이얼로그."""
    def __init__(self, model_type: str, existing_models: List[str], parent=None):
        super().__init__(parent)
        self.model_type = model_type
        self.existing_models = existing_models
        self.setWindowTitle(f"{model_type} 모델 추가")

        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.model_name_edit = QLineEdit()
        self.rpm_limit_edit = QLineEdit()
        self.daily_limit_edit = QLineEdit()

        self.rpm_limit_edit.setValidator(QIntValidator(0, 999999))
        self.daily_limit_edit.setValidator(QIntValidator(0, 9999999))

        form_layout.addRow("모델 이름:", self.model_name_edit)
        form_layout.addRow("RPM Limit (분당 요청 수):", self.rpm_limit_edit)
        form_layout.addRow("Daily Limit (하루 요청 수):", self.daily_limit_edit)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)

    def validate_and_accept(self):
        """입력값 유효성 검사 후 accept."""
        model_name = self.model_name_edit.text().strip()
        rpm_limit_str = self.rpm_limit_edit.text().strip()
        daily_limit_str = self.daily_limit_edit.text().strip()

        if not model_name:
            QMessageBox.warning(self, "입력 오류", "모델 이름을 입력해야 합니다.")
            return
        if model_name in self.existing_models:
            QMessageBox.warning(self, "입력 오류", f"'{model_name}' 모델이 이미 목록에 존재합니다.")
            return
        if not rpm_limit_str:
            QMessageBox.warning(self, "입력 오류", "RPM Limit을 입력해야 합니다.")
            return
        if not daily_limit_str:
            QMessageBox.warning(self, "입력 오류", "Daily Limit을 입력해야 합니다.")
            return

        try:
            int(rpm_limit_str)
            int(daily_limit_str)
        except ValueError:
            QMessageBox.warning(self, "입력 오류", "RPM 및 Daily Limit은 숫자로 입력해야 합니다.")
            return

        self.accept()

    def get_model_data(self) -> Optional[Tuple[str, int, int]]:
        """입력된 모델 데이터 반환."""
        if self.result() == QDialog.DialogCode.Accepted:
            model_name = self.model_name_edit.text().strip()
            rpm_limit = int(self.rpm_limit_edit.text().strip())
            daily_limit = int(self.daily_limit_edit.text().strip())
            return model_name, rpm_limit, daily_limit
        return None

# --- SSH Connection Test Worker ---
class SshTestWorker(QObject):
    finished = pyqtSignal(bool, str)

    def __init__(self, ssh_config_service: SshConfigService, alias: str):
        super().__init__()
        self.ssh_config_service = ssh_config_service
        self.alias = alias

    def run(self):
        """백그라운드에서 SSH 연결 테스트 수행 (asyncio 사용)"""
        success = False
        message = "Test execution failed"
        try:
            # asyncio.run()을 사용하여 비동기 함수 실행
            success, message = asyncio.run(self.ssh_config_service.test_connection(self.alias))
            logger.info(f"SSH test result for {self.alias}: Success={success}, Message='{message}'")
        except RuntimeError as e:
            # asyncio.run()은 같은 스레드에서 재실행 불가 등의 RuntimeError 발생 가능
            logger.error(f"RuntimeError running SSH test worker for {self.alias}: {e}")
            message = f"Test runtime error: {e}"
        except Exception as e:
            logger.exception(f"Unexpected error running SSH test worker for {self.alias}: {e}")
            message = f"Unexpected error: {e}"
        finally:
            # 결과 시그널 발생
            self.finished.emit(success, message)

# --- SettingsDialog ---
class SettingsDialog(QDialog):
    """
    환경 설정을 표시하고 수정하는 다이얼로그 창.
    (Docstring 유지)
    """
    PASTEL_GREEN = PASTEL_GREEN
    PASTEL_BLUE = PASTEL_BLUE
    PASTEL_PURPLE = PASTEL_PURPLE

    def __init__(self, main_window: 'MainWindow', parent=None):
        super().__init__(parent)
        self.mw = main_window
        self.config_service = main_window.config_service
        self.db_service: 'DbService' = main_window.db_service
        self.ssh_config_service = SshConfigService(self.db_service)
        self.settings: Optional[ConfigSettings] = None
        self.ssh_connections: List[SshConnectionConfig] = []
        self.thread_pool = QThreadPool.globalInstance() # QRunnable 사용 시
        self._ssh_test_thread: Optional[QThread] = None # QObject + moveToThread 사용 시
        self._ssh_test_worker: Optional[SshTestWorker] = None # QObject + moveToThread 사용 시

        self.setWindowTitle("환경 설정")
        self.setMinimumWidth(900)
        self.setMinimumHeight(800)

        self.tab_widget = QTabWidget()
        general_settings_widget = self.create_general_settings_widget()
        self.tab_widget.addTab(general_settings_widget, "일반 설정")
        ssh_settings_widget = self.create_ssh_settings_widget()
        self.tab_widget.addTab(ssh_settings_widget, "SSH 연결 설정")

        main_layout = QVBoxLayout(self)
        main_layout.addWidget(self.tab_widget)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Close)
        self.button_box.button(QDialogButtonBox.StandardButton.Save).setText("설정 저장")
        self.button_box.button(QDialogButtonBox.StandardButton.Close).setText("닫기")
        main_layout.addWidget(self.button_box)

        self.button_box.accepted.connect(self.save_settings)
        self.button_box.rejected.connect(self.reject)

        self.load_config_settings()
        self.load_api_keys_list()
        self.load_ssh_connections_list()
        if self.mw.current_project_folder:
            self.load_gitignore()

    # --- create_general_settings_widget, create_ssh_settings_widget 등 다른 메서드 생략 (변경 없음) ---
    def create_general_settings_widget(self) -> QWidget:
        """일반 설정 탭의 위젯들을 생성하고 배치합니다."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)

        # 기본 시스템 프롬프트
        self.default_prompt_group = QGroupBox("기본 시스템 프롬프트")
        prompt_layout = QHBoxLayout()
        self.default_prompt_path_edit = QLineEdit()
        self.default_prompt_path_edit.setPlaceholderText("프로젝트 루트 기준 상대 경로 또는 절대 경로")
        self.browse_prompt_button = QPushButton("찾아보기...")
        prompt_layout.addWidget(self.default_prompt_path_edit)
        prompt_layout.addWidget(self.browse_prompt_button)
        self.default_prompt_group.setLayout(prompt_layout)
        layout.addWidget(self.default_prompt_group)

        # 메인 수평 스플리터 생성
        main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal)

        # 왼쪽 컬럼 위젯 및 레이아웃 생성
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(10)

        # API 키 관리
        self.api_key_management_group = QGroupBox("API 키 관리")
        api_key_management_layout = QVBoxLayout()
        api_list_layout = QHBoxLayout()
        self.api_keys_list = QListWidget()
        self.api_keys_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.api_keys_list.setMinimumHeight(100)
        self.api_keys_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.refresh_api_usage_btn = QPushButton("🔄")
        self.refresh_api_usage_btn.setToolTip("API 키 사용량 새로고침")
        self.refresh_api_usage_btn.setFixedWidth(30)
        api_list_layout.addWidget(self.api_keys_list)
        api_list_layout.addWidget(self.refresh_api_usage_btn)
        self.api_key_label = QLabel("등록된 API 키 (🔵: 사용자 선택됨, 🟢: 마지막 사용, ✨: 자동 선택 예정, 🟡: 활성, 🔴: 비활성 / 잔여량은 기본 Gemini 모델 기준):")
        api_key_management_layout.addWidget(self.api_key_label)
        api_key_management_layout.addLayout(api_list_layout)
        api_key_buttons_layout = QHBoxLayout()
        self.add_api_key_btn = QPushButton("➕ 새 API 키 추가")
        self.remove_api_key_btn = QPushButton("➖ 선택한 키 제거")
        self.set_selected_key_btn = QPushButton("✅ 선택한 키 사용")
        api_key_buttons_layout.addWidget(self.add_api_key_btn)
        api_key_buttons_layout.addWidget(self.remove_api_key_btn)
        api_key_buttons_layout.addWidget(self.set_selected_key_btn)
        api_key_buttons_layout.addStretch()
        api_key_management_layout.addLayout(api_key_buttons_layout)
        self.api_key_management_group.setLayout(api_key_management_layout)
        left_layout.addWidget(self.api_key_management_group)

        # 사용 가능 LLM 모델 목록
        self.available_models_group = QGroupBox("사용 가능 LLM 모델 목록 관리 (클릭하여 기본 모델 지정)")
        available_models_main_layout = QHBoxLayout()
        # Gemini 모델
        gemini_model_widget = QWidget()
        gemini_model_layout = QVBoxLayout(gemini_model_widget)
        gemini_model_layout.addWidget(QLabel("Gemini 모델:"))
        self.gemini_models_list = QListWidget(); self.gemini_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.gemini_models_list.setMinimumHeight(100); self.gemini_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gemini_model_buttons = QHBoxLayout()
        self.add_gemini_model_btn = QPushButton("추가"); self.remove_gemini_model_btn = QPushButton("제거")
        gemini_model_buttons.addWidget(self.add_gemini_model_btn); gemini_model_buttons.addWidget(self.remove_gemini_model_btn)
        gemini_model_layout.addWidget(self.gemini_models_list); gemini_model_layout.addLayout(gemini_model_buttons)
        available_models_main_layout.addWidget(gemini_model_widget)
        # Claude 모델
        claude_model_widget = QWidget()
        claude_model_layout = QVBoxLayout(claude_model_widget)
        claude_model_layout.addWidget(QLabel("Claude 모델:"))
        self.claude_models_list = QListWidget(); self.claude_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.claude_models_list.setMinimumHeight(100); self.claude_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        claude_model_buttons = QHBoxLayout()
        self.add_claude_model_btn = QPushButton("추가"); self.remove_claude_model_btn = QPushButton("제거")
        claude_model_buttons.addWidget(self.add_claude_model_btn); claude_model_buttons.addWidget(self.remove_claude_model_btn)
        claude_model_layout.addWidget(self.claude_models_list); claude_model_layout.addLayout(claude_model_buttons)
        available_models_main_layout.addWidget(claude_model_widget)
        # GPT 모델
        gpt_model_widget = QWidget()
        gpt_model_layout = QVBoxLayout(gpt_model_widget)
        gpt_model_layout.addWidget(QLabel("GPT 모델:"))
        self.gpt_models_list = QListWidget(); self.gpt_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.gpt_models_list.setMinimumHeight(100); self.gpt_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gpt_model_buttons = QHBoxLayout()
        self.add_gpt_model_btn = QPushButton("추가"); self.remove_gpt_model_btn = QPushButton("제거")
        gpt_model_buttons.addWidget(self.add_gpt_model_btn); gpt_model_buttons.addWidget(self.remove_gpt_model_btn)
        gpt_model_layout.addWidget(self.gpt_models_list); gpt_model_layout.addLayout(gpt_model_buttons)
        available_models_main_layout.addWidget(gpt_model_widget)
        self.available_models_group.setLayout(available_models_main_layout)
        left_layout.addWidget(self.available_models_group)

        # Gemini 파라미터
        self.gemini_group = QGroupBox("Gemini 파라미터")
        gemini_layout = QFormLayout()
        self.gemini_temp_edit = QLineEdit(); self.gemini_thinking_checkbox = QCheckBox(); self.gemini_budget_edit = QLineEdit(); self.gemini_search_checkbox = QCheckBox()
        gemini_layout.addRow("Temperature (0.0 ~ 2.0):", self.gemini_temp_edit)
        gemini_layout.addRow("Enable Search:", self.gemini_search_checkbox)
        gemini_layout.addRow("Enable Thinking:", self.gemini_thinking_checkbox)
        gemini_layout.addRow("Thinking Budget:", self.gemini_budget_edit)
        self.gemini_group.setLayout(gemini_layout)
        left_layout.addWidget(self.gemini_group)
        left_layout.addStretch(1)

        # 오른쪽 컬럼 위젯 및 레이아웃 생성
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # 파일 필터링
        self.filtering_group = QGroupBox("파일 필터링")
        filtering_layout = QFormLayout()
        self.allowed_extensions_edit = QLineEdit(); self.allowed_extensions_edit.setPlaceholderText("쉼표(,) 또는 공백으로 구분 (예: .py, .js .html)")
        self.excluded_dirs_edit = QPlainTextEdit(); self.excluded_dirs_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: node_modules/, *.log)"); self.excluded_dirs_edit.setMinimumHeight(80); self.excluded_dirs_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.default_ignore_list_edit = QPlainTextEdit(); self.default_ignore_list_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: .git/, __pycache__/)"); self.default_ignore_list_edit.setMinimumHeight(80); self.default_ignore_list_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        filtering_layout.addRow("허용 확장자:", self.allowed_extensions_edit)
        filtering_layout.addRow("제외 폴더/파일:", self.excluded_dirs_edit)
        filtering_layout.addRow("기본 무시 목록:", self.default_ignore_list_edit)
        self.filtering_group.setLayout(filtering_layout)
        right_layout.addWidget(self.filtering_group)

        # .gitignore 편집
        self.gitignore_group = QGroupBox(".gitignore 편집 (현재 프로젝트)")
        gitignore_layout = QVBoxLayout()
        gitignore_button_layout = QHBoxLayout()
        self.load_gitignore_button = QPushButton("불러오기")
        self.save_gitignore_button = QPushButton("저장하기")
        gitignore_button_layout.addWidget(self.load_gitignore_button); gitignore_button_layout.addWidget(self.save_gitignore_button); gitignore_button_layout.addStretch()
        self.gitignore_edit = QPlainTextEdit(); self.gitignore_edit.setPlaceholderText("프로젝트 폴더 선택 후 '.gitignore' 내용을 불러오거나 편집/저장하세요."); self.gitignore_edit.setMinimumHeight(120); self.gitignore_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gitignore_layout.addLayout(gitignore_button_layout); gitignore_layout.addWidget(self.gitignore_edit)
        self.gitignore_group.setLayout(gitignore_layout)
        self.gitignore_group.setEnabled(bool(self.mw.current_project_folder))
        right_layout.addWidget(self.gitignore_group)
        right_layout.addStretch(1)

        main_horizontal_splitter.addWidget(left_widget)
        main_horizontal_splitter.addWidget(right_widget)
        main_horizontal_splitter.setSizes([self.width() // 2, self.width() // 2])
        layout.addWidget(main_horizontal_splitter)

        # --- 시그널 연결 ---
        self.browse_prompt_button.clicked.connect(self.browse_default_prompt)
        self.load_gitignore_button.clicked.connect(self.load_gitignore)
        self.save_gitignore_button.clicked.connect(self.save_gitignore)
        self.add_api_key_btn.clicked.connect(self.add_api_key)
        self.remove_api_key_btn.clicked.connect(self.remove_api_key)
        self.refresh_api_usage_btn.clicked.connect(self.load_api_keys_list)
        self.api_keys_list.itemDoubleClicked.connect(self.show_api_key_value)
        self.set_selected_key_btn.clicked.connect(self.set_selected_api_key)
        self.add_gemini_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gemini_models_list, "google"))
        self.remove_gemini_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gemini_models_list))
        self.add_claude_model_btn.clicked.connect(lambda: self.add_model_to_list(self.claude_models_list, "anthropic"))
        self.remove_claude_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.claude_models_list))
        self.add_gpt_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gpt_models_list, "openai"))
        self.remove_gpt_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gpt_models_list))
        self.gemini_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gemini_models_list, 'gemini'))
        self.claude_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.claude_models_list, 'claude'))
        self.gpt_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gpt_models_list, 'gpt'))

        return widget

    def create_ssh_settings_widget(self) -> QWidget:
        """SSH 설정 탭의 위젯들을 생성하고 배치합니다."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)

        self.ssh_table = QTableWidget()
        self.ssh_table.setColumnCount(5)
        self.ssh_table.setHorizontalHeaderLabels(["Alias", "Host", "Port", "Username", "Auth Type"])
        self.ssh_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.ssh_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.ssh_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.ssh_table.verticalHeader().setVisible(False)
        self.ssh_table.horizontalHeader().setStretchLastSection(True)
        self.ssh_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        self.ssh_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.ssh_table.setAlternatingRowColors(True)
        self.ssh_table.setSizeAdjustPolicy(QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents)
        layout.addWidget(self.ssh_table, 1)

        ssh_button_layout = QHBoxLayout()
        self.add_ssh_btn = QPushButton("➕ 추가")
        self.edit_ssh_btn = QPushButton("✏️ 수정")
        self.delete_ssh_btn = QPushButton("❌ 삭제")
        self.test_ssh_btn = QPushButton("⚡ 연결 테스트")
        ssh_button_layout.addWidget(self.add_ssh_btn)
        ssh_button_layout.addWidget(self.edit_ssh_btn)
        ssh_button_layout.addWidget(self.delete_ssh_btn)
        ssh_button_layout.addStretch()
        ssh_button_layout.addWidget(self.test_ssh_btn)
        layout.addLayout(ssh_button_layout)

        self.add_ssh_btn.clicked.connect(self.add_ssh_connection)
        self.edit_ssh_btn.clicked.connect(self.edit_ssh_connection)
        self.delete_ssh_btn.clicked.connect(self.delete_ssh_connection)
        self.test_ssh_btn.clicked.connect(self.test_ssh_connection)
        self.ssh_table.itemDoubleClicked.connect(self.edit_ssh_connection)

        return widget

    # --- load_ssh_connections_list 등 다른 메서드 생략 ---
    def load_ssh_connections_list(self):
        """DB에서 SSH 연결 목록을 로드하여 테이블에 표시합니다."""
        try:
            self.ssh_connections = self.ssh_config_service.list_connections()
            self.ssh_table.setRowCount(0) # 테이블 초기화
            self.ssh_table.setRowCount(len(self.ssh_connections))

            default_font = QFontDatabase.systemFont(QFontDatabase.SystemFont.GeneralFont)
            if default_font:
                default_font.setPointSize(10)
                self.ssh_table.setFont(default_font)

            for row, conn in enumerate(self.ssh_connections):
                id_item = QTableWidgetItem()
                id_item.setData(Qt.ItemDataRole.UserRole, conn.id)
                alias_item = QTableWidgetItem(conn.alias)
                host_item = QTableWidgetItem(conn.host)
                port_item = QTableWidgetItem(str(conn.port))
                username_item = QTableWidgetItem(conn.username)
                auth_type_item = QTableWidgetItem(conn.auth_type)

                self.ssh_table.setItem(row, 0, alias_item)
                self.ssh_table.setItem(row, 1, host_item)
                self.ssh_table.setItem(row, 2, port_item)
                self.ssh_table.setItem(row, 3, username_item)
                self.ssh_table.setItem(row, 4, auth_type_item)
                alias_item.setData(Qt.ItemDataRole.UserRole, conn.id)

            self.ssh_table.resizeColumnsToContents()
            self.ssh_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
            logger.info(f"Loaded {len(self.ssh_connections)} SSH connections into table.")

        except Exception as e:
            QMessageBox.critical(self, "SSH 목록 로드 오류", f"SSH 연결 목록을 불러오는 중 오류 발생:\n{e}")
            logger.exception("Error loading SSH connections list")

    def get_selected_ssh_connection_id(self) -> Optional[int]:
        """테이블에서 선택된 행의 SSH 연결 ID를 반환합니다."""
        selected_rows = self.ssh_table.selectionModel().selectedRows()
        if not selected_rows:
            return None
        selected_row_index = selected_rows[0]
        id_item = self.ssh_table.item(selected_row_index.row(), 0)
        if id_item:
            return id_item.data(Qt.ItemDataRole.UserRole)
        return None

    def add_ssh_connection(self):
        """SSH 연결 추가 다이얼로그를 열고 결과를 처리합니다."""
        dialog = SshConfigDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            config_data = dialog.get_data()
            if config_data:
                # Pydantic SecretStr -> str 변환 (DB 저장용)
                if 'password' in config_data and config_data['password']:
                    config_data['password'] = config_data['password'].get_secret_value()
                else:
                    config_data.pop('password', None) # None 이면 제거

                result = self.ssh_config_service.add_connection(config_data)
                if result:
                    QMessageBox.information(self, "성공", f"SSH 연결 '{result.alias}'이(가) 추가되었습니다.")
                    self.load_ssh_connections_list()
                    self.mw.load_ssh_connections_to_combo() # 메인 윈도우 콤보박스 업데이트
                else:
                    QMessageBox.warning(self, "실패", "SSH 연결 추가 중 오류가 발생했습니다.\n(별칭 중복 또는 DB 오류)")
            else:
                 logger.warning("Add SSH connection dialog accepted but returned no data.")

    def edit_ssh_connection(self):
        """선택된 SSH 연결 정보를 수정하는 다이얼로그를 엽니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "수정할 SSH 연결을 목록에서 선택하세요.")
            return

        config_to_edit = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        if not config_to_edit:
             QMessageBox.critical(self, "오류", "선택한 SSH 연결 정보를 찾을 수 없습니다.")
             return

        dialog = SshConfigDialog(self, config=config_to_edit)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            updated_data = dialog.get_data()
            if updated_data:
                # Pydantic SecretStr -> str 변환 (DB 저장용)
                if 'password' in updated_data and updated_data['password']:
                    updated_data['password'] = updated_data['password'].get_secret_value()
                else:
                    updated_data.pop('password', None) # None이면 제거

                result = self.ssh_config_service.update_connection(selected_id, updated_data)
                if result:
                    QMessageBox.information(self, "성공", f"SSH 연결 '{result.alias}'이(가) 수정되었습니다.")
                    self.load_ssh_connections_list()
                    self.mw.load_ssh_connections_to_combo() # 메인 윈도우 콤보박스 업데이트
                else:
                    QMessageBox.warning(self, "실패", "SSH 연결 수정 중 오류가 발생했습니다.\n(별칭 중복 또는 DB 오류)")
            else:
                 logger.warning("Edit SSH connection dialog accepted but returned no data.")

    def delete_ssh_connection(self):
        """선택된 SSH 연결 정보를 삭제합니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "삭제할 SSH 연결을 목록에서 선택하세요.")
            return

        config_to_delete = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        alias_to_delete = config_to_delete.alias if config_to_delete else f"ID {selected_id}"

        reply = QMessageBox.question(self, "삭제 확인", f"정말로 SSH 연결 '{alias_to_delete}'을(를) 삭제하시겠습니까?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: return

        success = self.ssh_config_service.delete_connection(selected_id)
        if success:
            QMessageBox.information(self, "성공", f"SSH 연결 '{alias_to_delete}'이(가) 삭제되었습니다.")
            self.load_ssh_connections_list()
            self.mw.load_ssh_connections_to_combo() # 메인 윈도우 콤보박스 업데이트
        else:
            QMessageBox.warning(self, "실패", "SSH 연결 삭제 중 오류가 발생했습니다.")

    def test_ssh_connection(self):
        """선택된 SSH 연결을 백그라운드에서 테스트합니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "테스트할 SSH 연결을 목록에서 선택하세요.")
            return

        config_to_test = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        if not config_to_test:
            QMessageBox.critical(self, "오류", "선택한 SSH 연결 정보를 찾을 수 없습니다.")
            return

        alias_to_test = config_to_test.alias

        self.test_ssh_btn.setEnabled(False)
        self.test_ssh_btn.setText("테스트 중...")
        QApplication.processEvents()

        # 이전 스레드 정리
        if self._ssh_test_thread and self._ssh_test_thread.isRunning():
            logger.warning("Previous SSH test thread still running. Attempting to quit.")
            self._ssh_test_thread.quit()
            if not self._ssh_test_thread.wait(1000):
                logger.warning("Previous SSH test thread did not quit gracefully.")
            else:
                logger.info("Previous SSH test thread stopped.")
        self._ssh_test_thread = None
        self._ssh_test_worker = None

        # 새 스레드 및 워커 생성
        thread = QThread()
        worker = SshTestWorker(self.ssh_config_service, alias_to_test)
        worker.moveToThread(thread)

        # 시그널 연결
        worker.finished.connect(self.handle_ssh_test_result)
        thread.started.connect(worker.run)
        worker.finished.connect(thread.quit)
        worker.finished.connect(worker.deleteLater)
        thread.finished.connect(thread.deleteLater)
        thread.finished.connect(self._clear_ssh_test_thread_ref) # 스레드 종료 시 참조 제거

        # 스레드 시작 및 참조 저장
        thread.start()
        self._ssh_test_thread = thread
        self._ssh_test_worker = worker

    def handle_ssh_test_result(self, success: bool, message: str):
        """SSH 연결 테스트 결과를 처리하고 UI를 업데이트합니다."""
        self.test_ssh_btn.setEnabled(True)
        self.test_ssh_btn.setText("⚡ 연결 테스트")
        if success:
            QMessageBox.information(self, "연결 테스트 결과", message)
        else:
            QMessageBox.warning(self, "연결 테스트 결과", message)
        # 스레드 참조 정리는 _clear_ssh_test_thread_ref 에서 수행

    def _clear_ssh_test_thread_ref(self):
        """Clears the reference to the finished SSH test thread."""
        logger.debug("Clearing SSH test thread reference.")
        self._ssh_test_thread = None
        self._ssh_test_worker = None

    # --- load_config_settings, _populate_and_highlight_model_list 등 다른 메서드 생략 ---
    def load_config_settings(self):
        """UI 위젯에 현재 DB 설정값을 로드하고 기본 모델을 하이라이트합니다."""
        try:
            self.settings = self.config_service.get_settings()
            if not self.settings:
                 QMessageBox.critical(self, "오류", "DB에서 설정을 로드하지 못했습니다.")
                 return
            logger.info("Loading config settings into SettingsDialog UI...")
            self.default_prompt_path_edit.setText(self.settings.default_system_prompt or "")
            self._populate_and_highlight_model_list(self.gemini_models_list, self.settings.gemini_available_models, self.settings.gemini_default_model)
            self._populate_and_highlight_model_list(self.claude_models_list, self.settings.claude_available_models, self.settings.claude_default_model)
            self._populate_and_highlight_model_list(self.gpt_models_list, self.settings.gpt_available_models, self.settings.gpt_default_model)
            self.allowed_extensions_edit.setText(", ".join(sorted(list(self.settings.allowed_extensions or set()))))
            self.excluded_dirs_edit.setPlainText("\n".join(sorted(self.settings.excluded_dirs or [])))
            self.default_ignore_list_edit.setPlainText("\n".join(sorted(self.settings.default_ignore_list or [])))
            self.gemini_temp_edit.setText(str(self.settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(self.settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(self.settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(self.settings.gemini_enable_search)
            logger.info("SettingsDialog UI updated with loaded config.")
        except Exception as e:
            QMessageBox.critical(self, "로드 오류", f"설정을 로드하는 중 오류 발생:\n{e}")
            logger.exception("Error loading config settings into SettingsDialog UI")

    def _populate_and_highlight_model_list(self, list_widget: QListWidget, models: List[str], default_model: str):
        """Helper function to populate a model list and highlight the default."""
        list_widget.clear()
        list_widget.addItems(models or [])
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() == default_model:
                item.setBackground(self.PASTEL_GREEN)
            else:
                item.setBackground(QBrush(Qt.GlobalColor.transparent))

    def handle_model_click(self, clicked_item: QListWidgetItem, list_widget: QListWidget, model_type: str):
        """Handles clicks on model list items to set the default model."""
        if not self.settings: return
        new_default_model = clicked_item.text()
        old_default_model = ""
        if model_type == 'gemini': old_default_model = self.settings.gemini_default_model; self.settings.gemini_default_model = new_default_model
        elif model_type == 'claude': old_default_model = self.settings.claude_default_model; self.settings.claude_default_model = new_default_model
        elif model_type == 'gpt': old_default_model = self.settings.gpt_default_model; self.settings.gpt_default_model = new_default_model
        else: return
        logger.info(f"Set default {model_type} model to: {new_default_model}")
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() == old_default_model: item.setBackground(QBrush(Qt.GlobalColor.transparent))
            if item.text() == new_default_model: item.setBackground(self.PASTEL_GREEN)

    # --- load_api_keys_list, add_api_key, remove_api_key 등 다른 메서드 생략 ---
    def load_api_keys_list(self):
        """DB에서 API 키 목록 로드 및 상태 강조."""
        self.api_keys_list.clear()
        try:
            all_keys = self.db_service.list_api_keys()
            if not all_keys:
                self.api_keys_list.addItem("등록된 API 키가 없습니다.")
                self.api_keys_list.setEnabled(False)
                return
            self.api_keys_list.setEnabled(True)
            user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
            last_used_key_id = self.config_service.get_last_used_gemini_key_id()
            logger.info(f"Current User Selected Key ID: {user_selected_key_id}, Last Used Key ID: {last_used_key_id}")
            default_gemini_model = self.config_service.get_default_model_name('Gemini')
            auto_select_candidate_id: Optional[int] = None
            if user_selected_key_id is None:
                logger.info("Identifying auto-select candidate key...")
                candidate_keys = []
                active_google_keys_info = [k for k in all_keys if k.get('provider') == 'google' and k.get('is_active')]
                for key_info in active_google_keys_info:
                    key_id = key_info['id']
                    is_limited, reason = self.db_service.is_key_rate_limited(key_id, default_gemini_model)
                    if not is_limited:
                        now = datetime.datetime.now(datetime.timezone.utc)
                        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
                        raw_calls_day = key_info.get('calls_this_day', 0)
                        day_start = key_info.get('day_start_timestamp')
                        if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                        effective_daily_calls = raw_calls_day if day_start and day_start >= current_day_start else 0
                        candidate_keys.append({'id': key_id, 'effective_calls': effective_daily_calls})
                        logger.debug(f"  Candidate Key ID: {key_id} (Not Rate Limited, Effective Daily Calls: {effective_daily_calls})")
                    else: logger.debug(f"  Skipping Key ID: {key_id} (Rate Limited: {reason})")
                candidate_keys.sort(key=lambda x: x['effective_calls'])
                if candidate_keys:
                    auto_select_candidate_id = candidate_keys[0]['id']
                    logger.info(f"Auto-select candidate key ID identified: {auto_select_candidate_id} (Effective Daily Calls: {candidate_keys[0]['effective_calls']})")
                else: logger.warning("No suitable auto-select candidate key found.")

            rate_limit_info = self.db_service.get_model_rate_limit(default_gemini_model)
            rpm_limit = rate_limit_info.get('rpm_limit') if rate_limit_info else None
            daily_limit = rate_limit_info.get('daily_limit') if rate_limit_info else None
            now = datetime.datetime.now(datetime.timezone.utc)

            for key_info in all_keys:
                key_id = key_info['id']; provider = key_info.get('provider', 'N/A'); description = key_info.get('description', ''); api_key_value = key_info.get('api_key', ''); api_key_display = api_key_value[:4] + "..." + api_key_value[-4:] if len(api_key_value) > 8 else api_key_value[:4] + "..."; is_active = key_info.get('is_active', False)
                status_icon = ""; item_color = QBrush(Qt.GlobalColor.transparent); display_text = f"[{provider.upper()}] {description or api_key_display}"; extra_info = ""; tooltip_status = ""
                if provider == 'google' and key_id == user_selected_key_id: status_icon = "🔵"; item_color = QBrush(self.PASTEL_BLUE); extra_info = " (사용자 선택)"; tooltip_status = "User Selected"
                elif provider == 'google' and key_id == auto_select_candidate_id: status_icon = "✨"; item_color = QBrush(self.PASTEL_PURPLE); extra_info = " (자동 선택 예정)"; tooltip_status = "Auto-Select Candidate"
                elif provider == 'google' and key_id == last_used_key_id: status_icon = "🟢"; item_color = QBrush(self.PASTEL_GREEN); extra_info = " (마지막 사용)"; tooltip_status = "Last Used"
                elif is_active: status_icon = "🟡"; item_color = QBrush(QColor("lightyellow")); tooltip_status = "Active"
                else: status_icon = "🔴"; item_color = QBrush(QColor("lightcoral")); tooltip_status = "Inactive"
                display_text = f"{status_icon}{display_text}{extra_info}"
                remaining_rpm_str, remaining_daily_str = "N/A", "N/A"; tooltip_rpm, tooltip_daily = "N/A", "N/A"
                if provider == 'google' and rpm_limit is not None and daily_limit is not None:
                    calls_this_minute = key_info.get('calls_this_minute', 0); minute_start = key_info.get('minute_start_timestamp'); calls_this_day = key_info.get('calls_this_day', 0); day_start = key_info.get('day_start_timestamp')
                    if minute_start and minute_start.tzinfo is None: minute_start = minute_start.replace(tzinfo=datetime.timezone.utc)
                    if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                    current_minute_calls = calls_this_minute
                    if minute_start and now >= minute_start + datetime.timedelta(minutes=1): current_minute_calls = 0
                    remaining_rpm = max(0, rpm_limit - current_minute_calls); remaining_rpm_str = f"{remaining_rpm}/{rpm_limit}"; tooltip_rpm = f"{remaining_rpm} / {rpm_limit} (Used: {current_minute_calls})"
                    current_day_calls = calls_this_day
                    if day_start and now >= day_start + datetime.timedelta(days=1): current_day_calls = 0
                    remaining_daily = max(0, daily_limit - current_day_calls); remaining_daily_str = f"{remaining_daily}/{daily_limit}"; tooltip_daily = f"{remaining_daily} / {daily_limit} (Used: {current_day_calls})"
                    display_text += f" (RPM: {remaining_rpm_str}, Daily: {remaining_daily_str})"
                elif provider == 'google': logger.warning(f"Rate limit info not found for model '{default_gemini_model}'. Cannot calculate remaining usage for key ID {key_id}.")
                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, key_id); item.setData(Qt.ItemDataRole.UserRole + 1, api_key_value); item.setData(Qt.ItemDataRole.UserRole + 2, provider); item.setBackground(item_color)
                tooltip_text = f"ID: {key_id}\nProvider: {provider}\nKey: {api_key_display}\nStatus: {tooltip_status}";
                if provider == 'google': tooltip_text += f"\nRemaining RPM (vs {default_gemini_model}): {tooltip_rpm}\nRemaining Daily (vs {default_gemini_model}): {tooltip_daily}"
                item.setToolTip(tooltip_text)
                self.api_keys_list.addItem(item)
        except Exception as e:
            QMessageBox.critical(self, "API 키 로드 오류", f"API 키 목록을 불러오는 중 오류 발생:\n{e}"); logger.exception("Error loading API keys list"); self.api_keys_list.addItem("API 키 로드 오류"); self.api_keys_list.setEnabled(False)

    def add_api_key(self):
        """새 API 키 추가."""
        provider, ok1 = QInputDialog.getItem(self, "API 키 추가", "Provider 선택:", ["google", "anthropic", "openai"], 0, False)
        if not ok1: return
        api_key, ok2 = QInputDialog.getText(self, "API 키 추가", f"{provider} API 키 입력:", QLineEdit.EchoMode.Normal)
        if not ok2 or not api_key.strip(): return
        description, ok3 = QInputDialog.getText(self, "API 키 추가", "설명 (선택 사항):", QLineEdit.EchoMode.Normal)
        if not ok3: description = ""
        try:
            key_id = self.db_service.add_api_key(provider, api_key.strip(), description.strip())
            if key_id is not None: QMessageBox.information(self, "성공", "API 키가 성공적으로 추가되었습니다."); self.load_api_keys_list()
            else: QMessageBox.warning(self, "실패", "API 키 추가 중 오류가 발생했습니다.")
        except Exception as e: QMessageBox.critical(self, "오류", f"API 키 추가 중 예외 발생:\n{e}")

    def remove_api_key(self):
        """선택된 API 키 제거."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items: QMessageBox.warning(self, "선택 오류", "제거할 API 키를 목록에서 선택하세요."); return
        item = selected_items[0]; key_id = item.data(Qt.ItemDataRole.UserRole); display_text = item.text()
        user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
        if key_id == user_selected_key_id: QMessageBox.warning(self, "제거 불가", "현재 사용하도록 선택된 API 키는 제거할 수 없습니다.\n다른 키를 선택하거나 선택을 해제한 후 시도하세요."); return
        reply = QMessageBox.question(self, "삭제 확인", f"정말로 API 키를 삭제하시겠습니까?\n({display_text})", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: return
        try:
            success = self.db_service.delete_api_key(key_id)
            if success: QMessageBox.information(self, "성공", "API 키가 성공적으로 제거되었습니다."); self.load_api_keys_list()
            else: QMessageBox.warning(self, "실패", "API 키 제거 중 오류가 발생했습니다.")
        except Exception as e: QMessageBox.critical(self, "오류", f"API 키 제거 중 예외 발생:\n{e}")

    def show_api_key_value(self, item: QListWidgetItem):
        """더블클릭된 API 키 값 표시."""
        api_key_value = item.data(Qt.ItemDataRole.UserRole + 1)
        if api_key_value: QMessageBox.information(self, "API 키 값 확인", f"선택한 API 키 값:\n\n{api_key_value}\n\n주의: 이 키는 민감한 정보이므로 안전하게 관리하세요.", QMessageBox.StandardButton.Ok)
        else: QMessageBox.warning(self, "오류", "API 키 값을 가져올 수 없습니다.")

    def set_selected_api_key(self):
        """선택된 API 키를 사용자로 설정 (Gemini만)."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items: QMessageBox.warning(self, "선택 오류", "사용할 API 키를 목록에서 선택하세요."); return
        item = selected_items[0]; key_id = item.data(Qt.ItemDataRole.UserRole); provider = item.data(Qt.ItemDataRole.UserRole + 2)
        if provider != 'google': QMessageBox.information(self, "정보", "Google (Gemini) API 키만 사용하도록 선택할 수 있습니다."); return
        if "🔴" in item.text(): QMessageBox.warning(self, "선택 불가", "비활성화된 API 키는 사용할 수 없습니다."); return
        current_selected_id = self.config_service.get_user_selected_gemini_key_id()
        if key_id == current_selected_id: self.config_service.set_user_selected_gemini_key(None); QMessageBox.information(self, "선택 해제", "API 키 선택이 해제되었습니다.\n이제 사용량이 가장 적은 키부터 자동으로 사용됩니다.")
        else: self.config_service.set_user_selected_gemini_key(key_id); QMessageBox.information(self, "키 선택 완료", f"API 키 ID {key_id}가 사용되도록 선택되었습니다.")
        self.load_api_keys_list()

    def browse_default_prompt(self):
        """기본 시스템 프롬프트 파일 선택."""
        selected_path = select_default_system_prompt(self.config_service, self)
        if selected_path is not None: self.default_prompt_path_edit.setText(selected_path)

    def add_model_to_list(self, list_widget: QListWidget, provider: str):
        """모델 목록에 새 모델 추가."""
        existing_models = [list_widget.item(i).text() for i in range(list_widget.count())]
        dialog = AddModelDialog(provider.capitalize(), existing_models, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            model_data = dialog.get_model_data()
            if model_data:
                model_name, rpm_limit, daily_limit = model_data
                try:
                    self.db_service.insert_or_update_rate_limit(model_name=model_name, provider=provider, rpm_limit=rpm_limit, daily_limit=daily_limit)
                    list_widget.addItem(model_name)
                    QMessageBox.information(self, "성공", f"모델 '{model_name}' 및 Rate Limit 정보가 추가되었습니다.")
                except Exception as e: QMessageBox.critical(self, "DB 오류", f"모델 Rate Limit 정보 저장 중 오류 발생:\n{e}"); logger.exception(f"Error saving rate limit for model {model_name}")

    def remove_model_from_list(self, list_widget: QListWidget):
        """모델 목록에서 모델 제거."""
        selected_items = list_widget.selectedItems()
        if not selected_items: QMessageBox.warning(self, "선택 오류", "제거할 모델을 목록에서 선택하세요."); return
        model_to_remove = selected_items[0].text(); is_default = False
        if list_widget == self.gemini_models_list and self.settings and model_to_remove == self.settings.gemini_default_model: is_default = True
        elif list_widget == self.claude_models_list and self.settings and model_to_remove == self.settings.claude_default_model: is_default = True
        elif list_widget == self.gpt_models_list and self.settings and model_to_remove == self.settings.gpt_default_model: is_default = True
        if is_default: QMessageBox.warning(self, "제거 불가", f"'{model_to_remove}' 모델은 현재 기본 모델로 지정되어 있어 제거할 수 없습니다.\n다른 모델을 기본으로 지정한 후 다시 시도하세요."); return
        reply = QMessageBox.question(self, "모델 제거 확인", f"정말로 '{model_to_remove}' 모델을 목록과 DB에서 제거하시겠습니까?\n(Rate Limit 정보도 함께 제거됩니다)", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: return
        try:
            success_db = self.db_service.delete_rate_limit(model_name=model_to_remove)
            if success_db:
                logger.info(f"Successfully removed rate limit info for model '{model_to_remove}' from DB.")
                for item in selected_items: list_widget.takeItem(list_widget.row(item))
                QMessageBox.information(self, "성공", f"모델 '{model_to_remove}'이(가) 목록과 DB에서 제거되었습니다.")
            else: logger.warning(f"Failed to remove rate limit info for model '{model_to_remove}' from DB (or not found)."); QMessageBox.warning(self, "DB 오류", f"DB에서 '{model_to_remove}' 모델의 Rate Limit 정보를 제거하는 데 실패했습니다.")
        except Exception as e: QMessageBox.critical(self, "오류", f"모델 제거 중 예외 발생:\n{e}"); logger.exception(f"Error removing model {model_to_remove}")

    def save_settings(self):
        """변경된 모든 설정을 저장합니다."""
        self.save_config_settings()
        self.save_gitignore() # .gitignore 저장 추가

    def save_config_settings(self):
        """UI 설정값을 읽어 DB에 저장합니다."""
        if not self.settings: QMessageBox.critical(self, "오류", "설정 객체가 로드되지 않아 저장할 수 없습니다."); return
        try:
            default_prompt = self.default_prompt_path_edit.text().strip(); gemini_model = self.settings.gemini_default_model; claude_model = self.settings.claude_default_model; gpt_model = self.settings.gpt_default_model
            gemini_available = [self.gemini_models_list.item(i).text() for i in range(self.gemini_models_list.count())]; claude_available = [self.claude_models_list.item(i).text() for i in range(self.claude_models_list.count())]; gpt_available = [self.gpt_models_list.item(i).text() for i in range(self.gpt_models_list.count())]
            if gemini_model not in gemini_available and gemini_available: QMessageBox.warning(self, "설정 오류", f"Gemini 기본 모델 '{gemini_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요."); return
            if claude_model not in claude_available and claude_available: QMessageBox.warning(self, "설정 오류", f"Claude 기본 모델 '{claude_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요."); return
            if gpt_model not in gpt_available and gpt_available: QMessageBox.warning(self, "설정 오류", f"GPT 기본 모델 '{gpt_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요."); return
            allowed_ext_str = self.allowed_extensions_edit.text().strip(); allowed_extensions = {ext.strip() for ext in allowed_ext_str.replace(',', ' ').split() if ext.strip()}
            excluded_dirs = [line.strip() for line in self.excluded_dirs_edit.toPlainText().splitlines() if line.strip()]; default_ignore = [line.strip() for line in self.default_ignore_list_edit.toPlainText().splitlines() if line.strip()]
            temp_str = self.gemini_temp_edit.text().strip(); gemini_temp = float(temp_str) if temp_str else 0.0; gemini_thinking = self.gemini_thinking_checkbox.isChecked(); budget_str = self.gemini_budget_edit.text().strip(); gemini_budget = int(budget_str) if budget_str else 0; gemini_search = self.gemini_search_checkbox.isChecked()
            update_data = self.settings.model_copy(deep=True); update_data.default_system_prompt = default_prompt if default_prompt else None; update_data.allowed_extensions = allowed_extensions; update_data.excluded_dirs = set(excluded_dirs); update_data.default_ignore_list = default_ignore; update_data.gemini_available_models = gemini_available; update_data.claude_available_models = claude_available; update_data.gpt_available_models = gpt_available; update_data.gemini_temperature = gemini_temp; update_data.gemini_enable_thinking = gemini_thinking; update_data.gemini_thinking_budget = gemini_budget; update_data.gemini_enable_search = gemini_search
            validated_settings = ConfigSettings(**update_data.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'}))
            logger.info("Validated settings data before saving to DB:"); logger.info(f"{validated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})}")
            if self.config_service.update_settings(validated_settings): logger.info("Application settings saved successfully."); self.mw.main_controller.on_llm_selected(); self.mw.load_gemini_settings_to_ui(); self.mw.file_tree_controller.load_gitignore_settings(); # self.accept() # 저장 버튼 눌렀을 때 바로 닫지 않음
            else: QMessageBox.critical(self, "저장 실패", "설정을 데이터베이스에 저장하는 중 오류가 발생했습니다.")
        except ValidationError as e: QMessageBox.warning(self, "입력 오류", f"설정 값 유효성 검사 실패:\n{e}")
        except ValueError as e: QMessageBox.warning(self, "입력 오류", f"숫자 필드(온도, 예산)에 유효한 숫자를 입력하세요.\n{e}")
        except Exception as e: QMessageBox.critical(self, "오류", f"설정 저장 중 예기치 않은 오류 발생:\n{e}")

    def load_gitignore(self):
        """현재 프로젝트의 .gitignore 로드."""
        if not self.mw.current_project_folder: self.gitignore_edit.setPlainText(""); self.gitignore_edit.setEnabled(False); return
        self.gitignore_edit.setEnabled(True); gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore"); content = ""
        try:
            if os.path.isfile(gitignore_path):
                with open(gitignore_path, 'r', encoding='utf-8') as f: content = f.read()
                self.gitignore_edit.setPlainText(content)
            else: self.gitignore_edit.setPlainText("# .gitignore 파일 없음")
        except Exception as e: QMessageBox.critical(self, "오류", f".gitignore 파일을 불러오는 중 오류 발생:\n{e}"); self.gitignore_edit.setPlainText(f"# 오류: {e}")

    def save_gitignore(self):
        """.gitignore 저장."""
        if not self.mw.current_project_folder: QMessageBox.warning(self, "오류", "프로젝트 폴더가 선택되지 않았습니다."); return
        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore"); content = self.gitignore_edit.toPlainText()
        try:
            with open(gitignore_path, 'w', encoding='utf-8') as f: f.write(content)
            # QMessageBox.information(self, "성공", f".gitignore 파일이 저장되었습니다:\n{gitignore_path}") # 저장 완료 메시지 제거
            logger.info(f".gitignore saved to: {gitignore_path}")
            if hasattr(self.mw, 'file_tree_controller'): self.mw.file_tree_controller.load_gitignore_settings() # 메인 윈도우 필터 업데이트
        except Exception as e: QMessageBox.critical(self, "오류", f".gitignore 파일을 저장하는 중 오류 발생:\n{e}")

    def closeEvent(self, event):
        """다이얼로그 닫기 전 스레드 정리."""
        logger.info("Closing SettingsDialog.")
        if self._ssh_test_thread and self._ssh_test_thread.isRunning():
             logger.warning("SSH test thread still running on dialog close. Attempting to quit.")
             self._ssh_test_thread.quit()
             if not self._ssh_test_thread.wait(500):
                 logger.warning("SSH test thread did not quit gracefully.")
        super().closeEvent(event)



======== src\utils\__init__.py ========

# This file makes Python treat the directory utils as a package.

from .helpers import get_project_root, get_resource_path, calculate_char_count
from .notifications import show_notification

__all__ = [
    "get_project_root",
    "get_resource_path",
    "calculate_char_count",
    "show_notification",
]



======== src\utils\db_migration_script.py ========
import psycopg2
import logging
from typing import Dict, Any, Optional, List

# --- Database Connection Details (from db_service.py or environment) ---
# WARNING: Hardcoded credentials are not recommended for production.
# Consider using environment variables or a secrets management tool.
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389"

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def run_migration():
    """Performs the database migration: adds usage columns to api_keys, migrates data, drops api_key_usage."""
    conn = None
    try:
        # 1. Connect to the database
        logger.info(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD
        )
        conn.autocommit = False # Start transaction
        logger.info("Database connection successful.")
        cur = conn.cursor()

        # 2. Add new columns to api_keys table if they don't exist
        logger.info("Adding usage tracking columns to api_keys table (if they don't exist)...")
        columns_to_add = [
            ("last_api_call_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_minute", "INTEGER", "NOT NULL DEFAULT 0"),
            ("minute_start_timestamp", "TIMESTAMPTZ", "NULL"),
            ("calls_this_day", "INTEGER", "NOT NULL DEFAULT 0"),
            ("day_start_timestamp", "TIMESTAMPTZ", "NULL")
        ]
        for col_name, col_type, col_constraint in columns_to_add:
            try:
                alter_sql = f"ALTER TABLE api_keys ADD COLUMN IF NOT EXISTS {col_name} {col_type} {col_constraint};"
                logger.debug(f"Executing: {alter_sql}")
                cur.execute(alter_sql)
                logger.info(f"Column '{col_name}' added or already exists in api_keys.")
            except psycopg2.Error as e:
                logger.error(f"Error adding column '{col_name}' to api_keys: {e}")
                raise # Stop migration if altering fails

        # 3. Check if api_key_usage table exists before attempting migration
        cur.execute("SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'api_key_usage');")
        usage_table_exists = cur.fetchone()[0]

        if usage_table_exists:
            logger.info("api_key_usage table exists. Migrating data...")

            # 4. Fetch data from api_key_usage
            logger.info("Fetching data from api_key_usage table...")
            try:
                cur.execute("""
                    SELECT api_key_id, last_api_call_timestamp, calls_this_minute,
                           minute_start_timestamp, calls_this_day, day_start_timestamp
                    FROM api_key_usage;
                """)
                usage_data = cur.fetchall()
                logger.info(f"Fetched {len(usage_data)} rows from api_key_usage.")
            except psycopg2.Error as e:
                logger.error(f"Error fetching data from api_key_usage: {e}")
                raise

            # 5. Update api_keys table with migrated data
            logger.info("Updating api_keys table with migrated usage data...")
            update_count = 0
            for row in usage_data:
                key_id, last_call, calls_min, min_start, calls_day, day_start = row
                try:
                    update_sql = """
                        UPDATE api_keys
                        SET last_api_call_timestamp = %s,
                            calls_this_minute = %s,
                            minute_start_timestamp = %s,
                            calls_this_day = %s,
                            day_start_timestamp = %s,
                            updated_at = NOW()
                        WHERE id = %s;
                    """
                    cur.execute(update_sql, (last_call, calls_min, min_start, calls_day, day_start, key_id))
                    if cur.rowcount == 1:
                        update_count += 1
                    else:
                        logger.warning(f"API key ID {key_id} not found in api_keys table during migration update.")
                except psycopg2.Error as e:
                    logger.error(f"Error updating api_keys for key_id {key_id}: {e}")
                    # Decide whether to continue or stop on error
                    # raise # Uncomment to stop on first error
            logger.info(f"Successfully updated {update_count} rows in api_keys with usage data.")

            # 6. Drop the api_key_usage table
            logger.info("Dropping api_key_usage table...")
            try:
                cur.execute("DROP TABLE IF EXISTS api_key_usage;")
                logger.info("api_key_usage table dropped successfully.")
            except psycopg2.Error as e:
                logger.error(f"Error dropping api_key_usage table: {e}")
                raise
        else:
            logger.info("api_key_usage table does not exist. Skipping data migration and table drop.")

        # 7. Commit transaction
        conn.commit()
        logger.info("Database migration completed successfully.")

    except (Exception, psycopg2.Error) as error:
        logger.error(f"Database migration failed: {error}", exc_info=True)
        if conn:
            conn.rollback()
            logger.info("Transaction rolled back.")
    finally:
        if conn:
            if not conn.closed:
                cur.close()
                conn.close()
                logger.info("Database connection closed.")
            else:
                logger.info("Database connection was already closed.")

if __name__ == "__main__":
    run_migration()



======== src\utils\helpers.py ========
import os
import sys
# import tiktoken # No longer directly used here, moved to TokenCalculationService
from typing import Union, Optional
# import threading # No longer needed for preloading here
from pathlib import Path # pathlib 사용

# --- 경로 관련 ---
def get_project_root() -> Path:
    """Gets the project root directory reliably."""
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # PyInstaller 번들 환경
        return Path(sys._MEIPASS)
    else:
        # 개발 환경 (main.py 또는 src/app.py에서 실행 가정)

        src_dir = Path(__file__).parent.parent.resolve()
        # 프로젝트 루트는 src 폴더의 부모
        return src_dir.parent

def get_resource_path(relative_path: str) -> str:
    """
    Gets the absolute path to a resource file/directory.
    Assumes the 'resources' directory is at the project root.
    """
    project_root = get_project_root()
    resource_path = project_root / "resources" / relative_path
    return str(resource_path)

# --- 텍스트 계산 관련 ---
def calculate_char_count(text: str) -> int:
    """Calculates the number of characters in the text."""
    return len(text)

# calculate_token_count is now handled by TokenCalculationService
# def calculate_token_count(text: str) -> Optional[int]:
#     """
#     Calculates the number of tokens using the preloaded tiktoken encoding.
#     Returns None if encoding is not available or an error occurs.
#     """
#     # ... (old implementation removed) ...

# init_utils and preload_encoding are removed as tiktoken loading is now
# handled within TokenCalculationService when needed.
# def preload_encoding():
#     """Preloads the tiktoken encoding in a separate thread."""
#     # ... (old implementation removed) ...

# def init_utils():
#     """Initializes utility functions, including preloading encoding."""
#     # ... (old implementation removed) ...

# def get_encoding() -> Optional[tiktoken.Encoding]:
#     """Returns the preloaded tiktoken encoding, loading if necessary."""
#     # ... (old implementation removed) ...



======== src\utils\notifications.py ========
import logging
import os
from typing import Optional

# 애플리케이션 이름 전역 변수
_APP_NAME = "DuckPrompt"

# winotify import 시도
try:
    from winotify import Notification
    # winotify는 기본적으로 Windows에서만 작동합니다.
    _WINOTIFY_AVAILABLE = os.name == 'nt'
except ImportError:
    _WINOTIFY_AVAILABLE = False
    logging.warning("winotify library not found or OS is not Windows. Desktop notifications will be disabled.")

# helpers에서 아이콘 경로 함수 가져오기
from .helpers import get_resource_path

logger = logging.getLogger(__name__)

def show_notification(title: str, message: str, app_name: str = None, timeout: Optional[int] = None):
    """
    Displays a desktop notification using winotify (Windows only).

    Args:
        title: The title of the notification.
        message: The main message content of the notification.
        app_name: The name of the application sending the notification.
        timeout: Duration in seconds (winotify doesn't directly support timeout, Windows setting applies).
    """
    if not _WINOTIFY_AVAILABLE:
        logger.warning(f"Notification not shown (winotify unavailable or not Windows): Title='{title}', Message='{message[:50]}...'")
        return

    try:
        logger.info(f"Showing notification via winotify: Title='{title}', Message='{message[:50]}...'")

        # 아이콘 경로 가져오기
        icon_path = ""
        try:
            icon_path = get_resource_path("icons/rubber_duck.ico")
            if not os.path.exists(icon_path):
                logger.warning(f"Notification icon not found at: {icon_path}")
                icon_path = "" # 아이콘 경로 없으면 빈 문자열로 설정
        except Exception as e:
            logger.error(f"Error getting notification icon path: {e}")
            icon_path = ""

        # 애플리케이션 이름 설정
        notification_app_name = app_name if app_name else _APP_NAME

        # winotify Notification 객체 생성
        toast = Notification(
            app_id=notification_app_name,
            title=title,
            msg=message,
            icon=icon_path if icon_path else None  # 아이콘 경로 설정 (없으면 None)
        )

        # 알림 표시
        toast.show()
        logger.info("winotify notification shown successfully.")

    except Exception as e:
        logger.error(f"Failed to show winotify notification: {e}", exc_info=True)

# Example usage (for testing):
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    print("Testing winotify notification...")
    if _WINOTIFY_AVAILABLE:
        show_notification("Test Notification", "This is a test message from notifications.py using winotify.")
        print("Notification test finished.")
    else:
        print("winotify is not available on this system (requires Windows and winotify library).")




======== src\utils\postgres_db_initializer.py ========
import psycopg2
import os
import yaml
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, List
import logging # 로깅 추가

# --- Database Connection Details ---
# WARNING: Hardcoded credentials are not recommended for production.
# Consider using environment variables or a secrets management tool.
DB_HOST = "postgresdb.lab.miraker.me"
DB_PORT = 5333
DB_NAME = "duck_agent"
DB_USER = "shacea"
DB_PASSWORD = "alfkzj9389"

# --- Project Root and Config File Path ---
try:
    PROJECT_ROOT = Path(__file__).parent.parent.parent.resolve()
except NameError:
    PROJECT_ROOT = Path('.').resolve()

CONFIG_FILE_PATH = PROJECT_ROOT / "src" / "config.yml"

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- SQL Schema Definition ---
SCHEMA_SQL = """
-- 타임스탬프 자동 업데이트를 위한 함수 생성 (존재하지 않을 경우)
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ==== API 키 테이블 ====
CREATE TABLE IF NOT EXISTS api_keys (
    id SERIAL PRIMARY KEY,
    api_key TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    description TEXT,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    last_api_call_timestamp TIMESTAMPTZ,
    calls_this_minute INTEGER NOT NULL DEFAULT 0,
    minute_start_timestamp TIMESTAMPTZ,
    calls_this_day INTEGER NOT NULL DEFAULT 0,
    day_start_timestamp TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_api_keys_timestamp') THEN
        CREATE TRIGGER set_api_keys_timestamp BEFORE UPDATE ON api_keys FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;
COMMENT ON TABLE api_keys IS 'Stores individual API keys, their metadata, and usage tracking.';
-- Column comments... (생략 가능)

-- ==== 모델별 기본 Rate Limit 테이블 ====
CREATE TABLE IF NOT EXISTS model_rate_limits (
    id SERIAL PRIMARY KEY,
    model_name TEXT NOT NULL UNIQUE,
    provider TEXT NOT NULL DEFAULT 'google',
    rpm_limit INTEGER NOT NULL,
    daily_limit INTEGER NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_model_rate_limits_timestamp') THEN
        CREATE TRIGGER set_model_rate_limits_timestamp BEFORE UPDATE ON model_rate_limits FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;
COMMENT ON TABLE model_rate_limits IS 'Stores default rate limit information per model.';
-- Column comments...

-- ==== 애플리케이션 설정 테이블 ====
CREATE TABLE IF NOT EXISTS application_config (
    id SERIAL PRIMARY KEY,
    profile_name TEXT NOT NULL UNIQUE DEFAULT 'default',
    default_system_prompt TEXT,
    allowed_extensions TEXT[],
    excluded_dirs TEXT[],
    default_ignore_list TEXT[],
    gemini_default_model TEXT,
    claude_default_model TEXT,
    gpt_default_model TEXT,
    gemini_available_models TEXT[],
    claude_available_models TEXT[],
    gpt_available_models TEXT[],
    gemini_temperature NUMERIC(3, 2) DEFAULT 0.0,
    gemini_enable_thinking BOOLEAN DEFAULT TRUE,
    gemini_thinking_budget INTEGER DEFAULT 24576,
    gemini_enable_search BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_application_config_timestamp') THEN
        CREATE TRIGGER set_application_config_timestamp BEFORE UPDATE ON application_config FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;
COMMENT ON TABLE application_config IS 'Stores application-wide configuration settings, replacing config.yml.';
-- Column comments...

-- ==== Gemini API 로그 테이블 ====
CREATE TABLE IF NOT EXISTS gemini_api_logs (
    id SERIAL PRIMARY KEY,
    request_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    response_timestamp TIMESTAMPTZ,
    model_name TEXT,
    request_prompt TEXT,
    request_attachments JSONB,
    response_text TEXT,
    response_xml TEXT,
    response_summary TEXT,
    error_message TEXT,
    elapsed_time_ms INTEGER,
    token_count INTEGER,
    api_key_id INTEGER REFERENCES api_keys(id) ON DELETE SET NULL
);
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_request_timestamp' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_request_timestamp ON gemini_api_logs(request_timestamp);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_gemini_api_logs_api_key_id' AND n.nspname = 'public') THEN
        CREATE INDEX idx_gemini_api_logs_api_key_id ON gemini_api_logs(api_key_id);
    END IF;
END $$;
COMMENT ON TABLE gemini_api_logs IS 'Stores logs of requests and responses to the Gemini API.';
-- Column comments...

-- ==== SSH 연결 설정 테이블 ====
CREATE TABLE IF NOT EXISTS ssh_connections (
    id SERIAL PRIMARY KEY,
    alias TEXT NOT NULL UNIQUE,
    host TEXT NOT NULL,
    port INTEGER NOT NULL DEFAULT 22,
    username TEXT NOT NULL,
    auth_type TEXT NOT NULL CHECK (auth_type IN ('password', 'key')),
    password TEXT,
    key_path TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_ssh_connections_timestamp') THEN
        CREATE TRIGGER set_ssh_connections_timestamp BEFORE UPDATE ON ssh_connections FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();
    END IF;
END $$;
COMMENT ON TABLE ssh_connections IS 'Stores SSH connection configurations.';
-- Column comments...
"""

def create_tables(conn):
    """Creates database tables based on the SCHEMA_SQL."""
    logger.info("Attempting to create/update database tables...")
    try:
        with conn.cursor() as cur:
            cur.execute(SCHEMA_SQL)
        conn.commit()
        logger.info("Tables created/updated (or already exist) successfully.")
    except psycopg2.Error as e:
        logger.error(f"Error creating/updating tables: {e}", exc_info=True) # Log traceback
        conn.rollback() # Roll back changes on error
        raise # Re-raise the exception to stop the script

def load_yaml_config(file_path: Path) -> Optional[Dict[str, Any]]:
    """Loads configuration from a YAML file."""
    if not file_path.exists():
        logger.error(f"Configuration file not found at {file_path}")
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        logger.info(f"Configuration loaded successfully from {file_path}")
        return config
    except yaml.YAMLError as e:
        logger.error(f"Error parsing YAML file {file_path}: {e}", exc_info=True)
        return None
    except Exception as e:
        logger.error(f"Error reading configuration file {file_path}: {e}", exc_info=True)
        return None

def insert_or_update_config(conn, config_data: Dict[str, Any]):
    """Inserts or updates the 'default' profile in the application_config table."""
    logger.info("Attempting to insert/update application configuration...")
    profile_name = 'default'

    allowed_extensions = list(config_data.get('allowed_extensions', set()))
    excluded_dirs = list(config_data.get('excluded_dirs', set()))
    default_ignore_list = list(config_data.get('default_ignore_list', []))
    gemini_available_models = list(config_data.get('gemini_available_models', []))
    claude_available_models = list(config_data.get('claude_available_models', []))
    gpt_available_models = list(config_data.get('gpt_available_models', []))

    gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
    gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

    try: gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
    except (ValueError, TypeError): gemini_temperature = 0.0
    try: gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
    except (ValueError, TypeError): gemini_thinking_budget = 24576

    sql = """
        INSERT INTO application_config (
            profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
            default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
            gemini_available_models, claude_available_models, gpt_available_models,
            gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
        ) VALUES ( %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s )
        ON CONFLICT (profile_name) DO UPDATE SET
            default_system_prompt = EXCLUDED.default_system_prompt,
            allowed_extensions = EXCLUDED.allowed_extensions, excluded_dirs = EXCLUDED.excluded_dirs,
            default_ignore_list = EXCLUDED.default_ignore_list, gemini_default_model = EXCLUDED.gemini_default_model,
            claude_default_model = EXCLUDED.claude_default_model, gpt_default_model = EXCLUDED.gpt_default_model,
            gemini_available_models = EXCLUDED.gemini_available_models, claude_available_models = EXCLUDED.claude_available_models,
            gpt_available_models = EXCLUDED.gpt_available_models, gemini_temperature = EXCLUDED.gemini_temperature,
            gemini_enable_thinking = EXCLUDED.gemini_enable_thinking, gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
            gemini_enable_search = EXCLUDED.gemini_enable_search, updated_at = NOW();
    """
    params = (profile_name, config_data.get('default_system_prompt'), allowed_extensions, excluded_dirs, default_ignore_list,
              config_data.get('gemini_default_model'), config_data.get('claude_default_model'), config_data.get('gpt_default_model'),
              gemini_available_models, claude_available_models, gpt_available_models, gemini_temperature,
              gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search)

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        logger.info(f"Application configuration for profile '{profile_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        logger.error(f"Error inserting/updating application configuration: {e}", exc_info=True)
        conn.rollback()
    except Exception as e:
        logger.error(f"An unexpected error occurred during config update: {e}", exc_info=True)
        conn.rollback()

def insert_or_update_api_key(conn, api_key: str, provider: str):
    """Inserts or updates an API key in the api_keys table."""
    if not api_key:
        logger.warning(f"Skipping API key insertion/update for {provider}: Key is empty.")
        return

    logger.info(f"Attempting to insert/update API key for provider: {provider}...")
    sql = """
        INSERT INTO api_keys (api_key, provider, is_active, last_api_call_timestamp, calls_this_minute,
                              minute_start_timestamp, calls_this_day, day_start_timestamp)
        VALUES (%s, %s, %s, NULL, 0, NULL, 0, NULL)
        ON CONFLICT (api_key) DO UPDATE SET provider = EXCLUDED.provider, is_active = EXCLUDED.is_active, updated_at = NOW();
    """
    params = (api_key, provider, True)

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        logger.info(f"API key for provider '{provider}' inserted/updated successfully.")
    except psycopg2.Error as e:
        logger.error(f"Error inserting/updating API key for {provider}: {e}", exc_info=True)
        conn.rollback()
    except Exception as e:
        logger.error(f"An unexpected error occurred during API key update for {provider}: {e}", exc_info=True)
        conn.rollback()

def insert_or_update_rate_limit(conn, model_name: str, provider: str, rpm_limit: int, daily_limit: int, notes: Optional[str] = None):
    """Inserts or updates a model's rate limit in the model_rate_limits table."""
    logger.info(f"Attempting to insert/update rate limit for model: {model_name}...")
    sql = """
        INSERT INTO model_rate_limits (model_name, provider, rpm_limit, daily_limit, notes)
        VALUES (%s, %s, %s, %s, %s)
        ON CONFLICT (model_name) DO UPDATE SET provider = EXCLUDED.provider, rpm_limit = EXCLUDED.rpm_limit,
            daily_limit = EXCLUDED.daily_limit, notes = EXCLUDED.notes, updated_at = NOW();
    """
    params = (model_name, provider, rpm_limit, daily_limit, notes)

    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()
        logger.info(f"Rate limit for model '{model_name}' inserted/updated successfully.")
    except psycopg2.Error as e:
        logger.error(f"Error inserting/updating rate limit for {model_name}: {e}", exc_info=True)
        conn.rollback()
    except Exception as e:
        logger.error(f"An unexpected error occurred during rate limit update for {model_name}: {e}", exc_info=True)
        conn.rollback()

def main():
    """Main function to connect, setup/update DB schema, and load config."""
    conn = None
    try:
        logger.info(f"Connecting to database {DB_NAME} at {DB_HOST}:{DB_PORT}...")
        conn = psycopg2.connect(host=DB_HOST, port=DB_PORT, dbname=DB_NAME, user=DB_USER, password=DB_PASSWORD)
        logger.info("Database connection successful.")

        create_tables(conn)
        logger.info("Database schema setup/update complete.")

        logger.info(f"Loading configuration from: {CONFIG_FILE_PATH}")
        config = load_yaml_config(CONFIG_FILE_PATH)

        if config:
            insert_or_update_config(conn, config)
            gemini_key = config.get('gemini_api_key'); anthropic_key = config.get('anthropic_api_key')
            if gemini_key: insert_or_update_api_key(conn, gemini_key, 'google')
            if anthropic_key: insert_or_update_api_key(conn, anthropic_key, 'anthropic')
            logger.info("Configuration data loaded into database.")

            logger.info("Inserting/Updating specific model rate limits...")
            insert_or_update_rate_limit(conn, 'gemini-1.5-pro-latest', 'google', 5, 25, 'Gemini 1.5 Pro Rate Limit') # Updated model name
            insert_or_update_rate_limit(conn, 'gemini-1.5-flash-latest', 'google', 15, 1500, 'Gemini 1.5 Flash Rate Limit') # Updated model name and limits
            logger.info("Model rate limits updated.")
        else:
            logger.warning("Skipping database update due to configuration loading failure.")

    except psycopg2.OperationalError as e:
        logger.critical(f"Database connection failed: {e}", exc_info=True)
    except Exception as e:
        logger.critical(f"An unexpected error occurred during database initialization: {e}", exc_info=True)
    finally:
        if conn:
            if not conn.closed:
                conn.close()
                logger.info("Database connection closed.")
            else:
                 logger.info("Database connection was already closed.")

if __name__ == "__main__":
    main()



======== src\__init__.py ========
# This file makes Python treat the directory src as a package.



======== src\app.py ========
import sys
import os
import ctypes
import logging
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtGui import QIcon
from PyQt6.QtCore import Qt
from ui.main_window import MainWindow
from utils.helpers import get_resource_path
from core.services.db_service import DbService # DbService 임포트

def setup_logging():
    """Sets up basic logging configuration."""
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    # Set level to DEBUG for more verbose output during development/testing
    # Set level to INFO or WARNING for production
    logging.basicConfig(level=logging.INFO, format=log_format)
    # logging.basicConfig(level=logging.DEBUG, format=log_format)

    # Optionally add file handler later if needed
    # try:
    #     log_file_path = get_resource_path("logs/app.log")
    #     os.makedirs(os.path.dirname(log_file_path), exist_ok=True)
    #     handler = logging.FileHandler(log_file_path, encoding='utf-8')
    #     handler.setFormatter(logging.Formatter(log_format))
    #     logging.getLogger().addHandler(handler)
    # except Exception as e:
    #     logging.error(f"Failed to set up file logging: {e}")

    logging.info("Logging setup complete.")

def cleanup_logs(db_service: DbService):
    """Calls the log cleanup function."""
    try:
        logging.info("Attempting to clean up old Gemini logs...")
        db_service.cleanup_old_gemini_logs(days_to_keep=7) # 7일 이상된 로그 삭제
        logging.info("Log cleanup process finished.")
    except Exception as e:
        logging.error(f"Error during log cleanup: {e}", exc_info=True)

def main():
    setup_logging() # 로깅 설정 호출

    if sys.platform.startswith("win"):
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(1)
            logging.info("Set DPI awareness for Windows.")
        except AttributeError:
            logging.warning("ctypes.windll.shcore not available, DPI awareness not set (might be older Windows).")
        except Exception as e:
            logging.warning(f"Error setting DPI awareness: {e}", exc_info=True)

    logging.info("PyQt6 High DPI scaling is enabled by default.")

    app = QApplication(sys.argv)

    try:
        icon_path = get_resource_path("icons/rubber_duck.ico")
        logging.info(f"Attempting to load icon from: {icon_path}")
        if os.path.exists(icon_path):
            app_icon = QIcon(icon_path)
            app.setWindowIcon(app_icon)
            logging.info(f"Application icon set successfully from: {icon_path}")
        else:
            logging.warning(f"Icon file not found at resolved path: {icon_path}. Check if the file exists at 'project_root/resources/icons/rubber_duck.ico'.")
    except Exception as e:
        logging.error(f"Error loading application icon: {e}", exc_info=True)

    db_service_instance = None
    try:
        try:
            db_service_instance = DbService()
            cleanup_logs(db_service_instance)
        except (ConnectionError, ValueError) as db_init_err:
             logging.error(f"Initial DB connection/cleanup failed: {db_init_err}. MainWindow will attempt connection.", exc_info=True)
        except Exception as cleanup_err:
             logging.error(f"Error during initial log cleanup: {cleanup_err}", exc_info=True)
        finally:
            if db_service_instance:
                try:
                    db_service_instance.disconnect()
                    logging.info("Initial DB connection for cleanup closed.")
                except Exception as db_close_err:
                     logging.error(f"Error disconnecting initial DB service: {db_close_err}", exc_info=True)

        window = MainWindow(mode="Code Enhancer Prompt Builder")
        window.show()
        sys.exit(app.exec())

    except (ConnectionError, ValueError) as e:
         logging.critical(f"Application initialization failed: {e}", exc_info=True)
         QMessageBox.critical(None, "치명적 오류", f"애플리케이션 시작 실패:\n{e}")
         sys.exit(1)
    except SystemExit as e:
         logging.info(f"Application exited with code {e.code}")
         sys.exit(e.code)
    except Exception as e:
         logging.critical(f"An unexpected error occurred during application startup: {e}", exc_info=True)
         # Show a simple message box even if the main window failed to initialize fully
         try:
             QMessageBox.critical(None, "예상치 못한 오류", f"애플리케이션 시작 중 오류 발생:\n{e}")
         except Exception as mb_err:
             logging.error(f"Failed to show critical error message box: {mb_err}")
         sys.exit(1)

if __name__ == "__main__":
    main()



======== src\config.yml ========
default_system_prompt: resources/prompts/system/xml_prompt_guide_python_en.md
allowed_extensions: !!set {}
excluded_dirs: !!set
  __pycache__/: null
  .gitignore: null
  dist/: null
  node_modules/: null
  .vscode/: null
  .DS_Store: null
  .idea/: null
  .git/: null
  '*.log': null
  build/: null
  .venv/: null
default_ignore_list:
- '*.egg-info/'
- '*.pyc'
- .cursorrules
- .git/
- .gitignore
- .idea/
- .vscode/
- .windsurfrules
- __pycache__/
- build/
- dist/
gemini_default_model: gemini-1.5-pro-latest # 기본 모델 변경
claude_default_model: claude-3-sonnet-20240229
gpt_default_model: gpt-4o
gemini_available_models:
- gemini-1.5-pro-latest # 사용 가능 모델 업데이트
- gemini-1.5-flash-latest
claude_available_models:
- claude-3-opus-20240229
- claude-3-sonnet-20240229
- claude-3-haiku-20240307
gpt_available_models:
- gpt-4o
- gpt-4-turbo
- gpt-3.5-turbo
# Test API Keys - Replace with your actual keys or manage securely
anthropic_api_key: sk-ant-api03-xxxx # 실제 키 일부 가림
gemini_api_key: AIzaSyAxxxx # 실제 키 일부 가림
gemini_temperature: 0.5 # 온도 기본값 변경
gemini_enable_thinking: true # Thinking 기본값 변경
gemini_thinking_budget: 24576 # 예산 유지
gemini_enable_search: true # 검색 기본값 변경



======== .env ========
SSH_ID=2
SSH_ALIAS=Lab_79
SSH_HOST=lab.miraker.me
SSH_PORT=7922
SSH_USERNAME=shacea
SSH_AUTH_TYPE=password
SSH_PASSWORD=alfkzj9389#


======== tests\ui\test_2_main_window_remote_fs.py ========
import pytest
import os
import asyncio
import logging
from PyQt6.QtCore import QModelIndex, Qt
from pytestqt.qt_compat import qt_api
from pytestqt.qt_compat import qt_api
from pytestqt.exceptions import TimeoutError # TimeoutError import

# 테스트 대상 모듈 import
from src.ui.main_window import MainWindow
from src.ui.models.remote_file_system_model import RemoteFileSystemModel
from src.core.pydantic_models.ssh_connection_config import SshConnectionConfig
from src.core.services.ssh_config_service import SshConfigService

logger = logging.getLogger(__name__)

# --- Fixtures ---

@pytest.fixture(scope="function")
async def main_window(qtbot) -> MainWindow: # async 추가
    """MainWindow 인스턴스를 생성하고 테스트 종료 시 정리합니다."""
    logger.info("Creating MainWindow instance for testing...")
    window = MainWindow()
    qtbot.addWidget(window) # qtbot에 위젯 등록
    window.show() # 테스트 중 UI 확인을 위해 표시 (선택 사항)
    yield window
    logger.info("Tearing down MainWindow instance...")
    # MainWindow의 closeEvent에서 비동기 리소스 정리 시도 -> fixture에서 직접 호출
    await window._close_ssh_connection_async() # await 추가
    window.close() # 창 닫기
    # 명시적으로 이벤트 루프 처리 보장 (qasync 사용 시 불필요할 수 있음)
    qt_api.qapp.processEvents()


@pytest.fixture(scope="function")
def setup_test_ssh_connection(main_window: MainWindow): # async 제거 (DB 작업은 동기)
    """
    .env 파일에서 SSH 정보를 읽어 테스트용 SSH 연결 설정을 DB에 추가합니다.
    테스트 종료 시 해당 설정을 삭제합니다.
    """
    ssh_alias = os.getenv("SSH_ALIAS")
    ssh_host = os.getenv("SSH_HOST")
    ssh_port_str = os.getenv("SSH_PORT")
    ssh_username = os.getenv("SSH_USERNAME")
    ssh_auth_type = os.getenv("SSH_AUTH_TYPE")
    ssh_password = os.getenv("SSH_PASSWORD")
    ssh_key_path = os.getenv("SSH_KEY_PATH") # 키 경로 추가

    if not all([ssh_alias, ssh_host, ssh_port_str, ssh_username, ssh_auth_type]):
        pytest.skip("Required SSH environment variables not set in .env file.")

    try:
        ssh_port = int(ssh_port_str)
    except ValueError:
        pytest.fail(f"Invalid SSH_PORT value: {ssh_port_str}")

    config_data = {
        "alias": ssh_alias,
        "host": ssh_host,
        "port": ssh_port,
        "username": ssh_username,
        "auth_type": ssh_auth_type,
        "password": ssh_password if ssh_auth_type == 'password' else None,
        "key_path": ssh_key_path if ssh_auth_type == 'key' else None,
    }

    ssh_config_service: SshConfigService = main_window.ssh_config_service
    existing_config = ssh_config_service.get_connection(ssh_alias)
    original_id = None
    if existing_config:
        logger.warning(f"SSH connection with alias '{ssh_alias}' already exists. It will be used for the test.")
        original_id = existing_config.id
        # Ensure the existing config matches the .env data (optional, could update instead)
        # ssh_config_service.update_connection(existing_config.id, config_data)
    else:
        logger.info(f"Adding test SSH connection '{ssh_alias}' to the database.")
        added_config = ssh_config_service.add_connection(config_data)
        if not added_config:
            pytest.fail(f"Failed to add test SSH connection '{ssh_alias}' to the database.")
        original_id = added_config.id

    # 메인 윈도우 콤보박스 새로고침
    main_window.load_ssh_connections_to_combo()

    yield ssh_alias # 테스트 함수에서 사용할 alias 반환

    # --- Cleanup ---
    if original_id is not None:
        logger.info(f"Cleaning up test SSH connection '{ssh_alias}' (ID: {original_id}).")
        # Check if the config still exists before deleting
        if ssh_config_service.get_connection(ssh_alias):
            deleted = ssh_config_service.delete_connection_by_alias(ssh_alias)
            if not deleted:
                logger.error(f"Failed to delete test SSH connection '{ssh_alias}' during cleanup.")
        else:
            logger.info(f"Test SSH connection '{ssh_alias}' was already removed.")
    else:
        logger.info(f"No SSH connection ID found for alias '{ssh_alias}' during cleanup.")

    # 메인 윈도우 콤보박스 새로고침
    main_window.load_ssh_connections_to_combo()


# --- Tests ---

@pytest.mark.asyncio
@pytest.mark.integration
@pytest.mark.network
async def test_ssh_connection_and_remote_fs(qtbot, main_window: MainWindow, setup_test_ssh_connection):
    """
    Tests connecting to an SSH server and verifying the remote file system view.
    Requires a running SSH server configured in the .env file.
    """
    test_alias = setup_test_ssh_connection # Fixture provides the alias
    logger.info(f"Starting SSH connection test for alias: {test_alias}")

    # 1. Select the connection alias in the combobox
    combo = main_window.ssh_connection_combo
    index_to_select = combo.findText(test_alias)
    assert index_to_select > 0, f"Test SSH alias '{test_alias}' not found in combobox."
    logger.info(f"Selecting alias '{test_alias}' in combobox (index: {index_to_select}).")
    # qtbot.mouseClick(combo, Qt.MouseButton.LeftButton) # 클릭 대신 직접 설정
    combo.setCurrentIndex(index_to_select)
    qtbot.wait(100) # Short wait for signal processing

    # 2. Click the connect button - 비동기 함수 호출
    connect_button = main_window.ssh_connect_btn
    assert connect_button.text() == "🔌 연결", "Connect button should initially show '연결'"
    logger.info("Triggering async toggle_ssh_connection...")
    # qtbot.mouseClick(connect_button, Qt.MouseButton.LeftButton) # 클릭 대신 직접 호출
    await main_window.toggle_ssh_connection() # await 추가

    # 3. Wait for the connection to establish (UI update) - toggle_ssh_connection이 완료될 때까지 기다림
    # UI 상태 확인은 여전히 유효
    logger.info("Waiting for SSH connection UI update (max 30s)...")
    try:
        qtbot.waitUntil(lambda: main_window.ssh_status_label.text().startswith("SSH: 연결됨"), timeout=30000)
        qtbot.waitUntil(lambda: connect_button.text() == "🔌 연결 해제", timeout=5000)
    except TimeoutError:
        pytest.fail("Timed out waiting for SSH connection UI update. Check connection details and server status.")

    logger.info("SSH connection established based on UI.")
    assert main_window.ssh_client is not None, "SSH client object should be created."
    assert main_window.sftp_client is not None, "SFTP client object should be created."

    # 4. Verify the tree view model switched to RemoteFileSystemModel
    current_model = main_window.tree_view.model()
    assert isinstance(current_model, RemoteFileSystemModel), \
        f"Tree view model should be RemoteFileSystemModel, but got {type(current_model)}"
    logger.info("Tree view model successfully switched to RemoteFileSystemModel.")

    # 5. Wait for the remote root directory contents to load using waitSignal
    remote_model: RemoteFileSystemModel = current_model
    logger.info("Waiting for remote root directory ('/') contents to load via fetchCompleted signal (max 30s)...")
    try:
        # fetchCompleted 시그널을 기다림 (path가 root_path와 일치하는 경우)
        # raising=True는 타임아웃 시 예외 발생
        # check_params_cb를 사용하여 시그널의 인자(path, success) 검증
        qtbot.waitSignal(
            remote_model.fetchCompleted,
            timeout=30000,
            raising=True,
            check_params_cb=lambda path, success: path == remote_model.root_path and success
        )
        logger.info(f"fetchCompleted signal received for root path '{remote_model.root_path}' with success=True.")
    except TimeoutError:
        pytest.fail("Timed out waiting for remote root directory fetchCompleted signal.")
    except Exception as e:
        pytest.fail(f"Error waiting for fetchCompleted signal: {e}")


    # 6. Verify that some items are loaded in the root
    root_index = QModelIndex() # Root index for the model
    root_item_count = remote_model.rowCount(root_index)
    logger.info(f"Remote root directory loaded with {root_item_count} items.")
    assert root_item_count > 0, "Remote root directory view should contain items after connection."

    # Optional: Check for specific common root directories (adjust as needed for your test server)
    # root_items = [remote_model.data(remote_model.index(r, 0, root_index), Qt.ItemDataRole.DisplayRole) for r in range(root_item_count)]
    # logger.info(f"Root items: {root_items}")
    # assert any(item.startswith("etc") for item in root_items), "Expected '/etc' directory not found in remote root."
    # assert any(item.startswith("home") for item in root_items), "Expected '/home' directory not found in remote root."

    # 7. Cleanup: Disconnect
    logger.info("Test successful. Disconnecting...")
    # qtbot.mouseClick(connect_button, Qt.MouseButton.LeftButton) # 클릭 대신 직접 호출
    await main_window.toggle_ssh_connection() # await 추가

    # Wait for disconnect UI update
    try:
        qtbot.waitUntil(lambda: main_window.ssh_status_label.text() == "SSH: 미연결", timeout=10000)
        qtbot.waitUntil(lambda: connect_button.text() == "🔌 연결", timeout=5000)
    except TimeoutError:
        logger.warning("Timed out waiting for UI update after disconnect.")

    assert main_window.ssh_client is None, "SSH client should be None after disconnect."
    assert main_window.sftp_client is None, "SFTP client should be None after disconnect."
    assert not isinstance(main_window.tree_view.model(), RemoteFileSystemModel), \
        "Tree view model should revert from RemoteFileSystemModel after disconnect."
    logger.info("SSH disconnection verified.")





======== pytest_results.txt ========
Traceback (most recent call last):
  File "<frozen runpy>", line 198, in _run_module_as_main
  File "<frozen runpy>", line 88, in _run_code
  File "E:\Projects\duck-prompt\.venv\Scripts\pytest.exe\__main__.py", line 10, in <module>
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 201, in console_main
    code = main()
           ^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 156, in main
    config = _prepareconfig(args, plugins)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 341, in _prepareconfig
    config = pluginmanager.hook.pytest_cmdline_parse(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_callers.py", line 122, in _multicall
    teardown.throw(exception)  # type: ignore[union-attr]
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\helpconfig.py", line 105, in pytest_cmdline_parse
    config = yield
             ^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 1140, in pytest_cmdline_parse
    self.parse(args)
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 1494, in parse
    self._preparse(args, addopts=addopts)
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\config\__init__.py", line 1381, in _preparse
    self.pluginmanager.load_setuptools_entrypoints("pytest11")
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pluggy\_manager.py", line 421, in load_setuptools_entrypoints
    plugin = ep.load()
             ^^^^^^^^^
  File "C:\Users\shace\AppData\Roaming\uv\python\cpython-3.12.9-windows-x86_64-none\Lib\importlib\metadata\__init__.py", line 205, in load
    module = import_module(match.group('module'))
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\shace\AppData\Roaming\uv\python\cpython-3.12.9-windows-x86_64-none\Lib\importlib\__init__.py", line 90, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1387, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1360, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1331, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 935, in _load_unlocked
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\_pytest\assertion\rewrite.py", line 185, in exec_module
    exec(co, module.__dict__)
  File "E:\Projects\duck-prompt\.venv\Lib\site-packages\pytest_qasync\plugin.py", line 27, in <module>
    raise NotImplementedError(qasync.QtModuleName)
NotImplementedError: PyQt6



File Tree:
 📁 duck-prompt/
   📁 ./
   📁 docs/
     📄 Database Schema Definitions.md (11,229 bytes)
     📄 ssh_docs.md (9,999 bytes)
   📁 src/
     📁 core/
       📁 pydantic_models/
         📄 __init__.py (314 bytes)
         📄 app_state.py (1,412 bytes)
         📄 config_settings.py (3,605 bytes)
         📄 ssh_connection_config.py (3,169 bytes)
       📁 services/
         📄 __init__.py (973 bytes)
         📄 config_service.py (11,819 bytes)
         📄 db_service.py (42,643 bytes)
         📄 filesystem_service.py (6,005 bytes)
         📄 gemini_service.py (23,158 bytes)
         📄 prompt_service.py (3,956 bytes)
         📄 ssh_config_service.py (8,791 bytes)
         📄 state_service.py (7,995 bytes)
         📄 template_service.py (3,485 bytes)
         📄 token_service.py (12,637 bytes)
         📄 xml_service.py (12,145 bytes)
       📁 utils/
         📄 __init__.py (282 bytes)
       📄 __init__.py (65 bytes)
       📄 langgraph_state.py (860 bytes)
     📁 ui/
       📁 controllers/
         📄 __init__.py (72 bytes)
         📄 file_tree_controller.py (22,373 bytes)
         📄 main_controller.py (19,701 bytes)
         📄 prompt_controller.py (9,902 bytes)
         📄 resource_controller.py (14,442 bytes)
         📄 system_prompt_controller.py (7,322 bytes)
         📄 xml_controller.py (3,759 bytes)
       📁 models/
         📄 __init__.py (318 bytes)
         📄 file_system_models.py (13,375 bytes)
         📄 remote_file_system_model.py (31,807 bytes)
       📁 widgets/
         📄 __init__.py (68 bytes)
         📄 check_box_delegate.py (3,040 bytes)
         📄 custom_tab_bar.py (4,364 bytes)
         📄 custom_text_edit.py (501 bytes)
         📄 file_tree_view.py (3,538 bytes)
         📄 ssh_config_dialog.py (9,318 bytes)
         📄 tab_manager.py (613 bytes)
       📄 __init__.py (63 bytes)
       📄 main_window.py (61,460 bytes)
       📄 main_window_setup_signals.py (8,883 bytes)
       📄 main_window_setup_ui.py (24,738 bytes)
       📄 settings_dialog.py (57,924 bytes)
     📁 utils/
       📄 __init__.py (320 bytes)
       📄 db_migration_script.py (5,986 bytes)
       📄 helpers.py (2,152 bytes)
       📄 notifications.py (2,983 bytes)
       📄 postgres_db_initializer.py (15,840 bytes)
     📄 __init__.py (64 bytes)
     📄 app.py (4,795 bytes)
     📄 config.yml (1,320 bytes)
   📁 tests/
     📁 ui/
       📄 test_2_main_window_remote_fs.py (10,099 bytes)
   📄 .env (137 bytes)
   📄 conftest.py (2,151 bytes)
   📄 main.py (422 bytes)
   📄 pyproject.toml (2,328 bytes)
   📄 pytest.ini (390 bytes)
   📄 pytest_results.txt (3,758 bytes)
   📄 qt.conf (47 bytes)