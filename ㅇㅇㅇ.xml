
<code_changes>
<changed_files>
<file>
  <file_summary>암호화 라이브러리 cryptography 의존성 추가</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>pyproject.toml</file_path>
  <file_code><![CDATA[

[project]
name = "duck-prompt"
version = "0.2.0"
description = "DuckPrompt: Code Enhancer & Meta Prompt Builder"
requires-python = ">=3.12"
dependencies = [
    "PyQt6>=6.7.0",
    "PyQt6-Qt6>=6.7.0",
    "google-generativeai>=0.5.4", # Gemini API
    "langgraph>=0.0.69", # LangGraph for workflow
    "tiktoken>=0.7.0", # Token calculation (GPT/fallback)
    "anthropic>=0.28.0", # Anthropic API (Claude)
    "psycopg2-binary>=2.9.9", # PostgreSQL driver
    "PyYAML>=6.0.1", # YAML parsing (config)
    "pydantic>=2.7.1", # Data validation and settings
    "pillow>=10.3.0", # Image handling
    "winotify>=1.1.0", # Windows notifications
    "pyinstaller>=6.13.0",
    "cryptography>=42.0.8", # For SSH password encryption
]

[tool.black]
line-length = 88

[tool.isort]
profile = "black"

[tool.uv.sources]
# Optional: Specify custom package sources if needed

# Optional: Define project scripts or entry points
# [project.scripts]
# duckprompt = "src.app:main"

# Optional: Project URLs
# [project.urls]
# homepage = "https://example.com"
# documentation = "https://readthedocs.org"
# repository = "https://github.com/user/duck-prompt.git"
# changelog = "https://github.com/user/duck-prompt/blob/main/CHANGELOG.md"

# Optional: Author and maintainer information
# authors = [
#   { name="Your Name", email="your.email@example.com" },
# ]
# maintainers = [
#   { name="Your Name", email="your.email@example.com" },
# ]

# Optional: License information
# license = { text = "MIT License" }

# Optional: Keywords for PyPI
# keywords = ["llm", "prompt", "gui", "pyqt"]

# Optional: Classifiers for PyPI
# classifiers = [
#     "Development Status :: 3 - Alpha",
#     "Intended Audience :: Developers",
#     "License :: OSI Approved :: MIT License",
#     "Programming Language :: Python :: 3",
#     "Programming Language :: Python :: 3.12",
#     "Operating System :: OS Independent",
#     "Topic :: Software Development :: User Interfaces",
# ]

]]></file_code>
</file>
<file>
  <file_summary>새 Pydantic 모델(SshConnectionConfig) 임포트</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>src/core/pydantic_models/__init__.py</file_path>
  <file_code><![CDATA[
# This file makes Python treat the directory pydantic_models as a package.

from .app_state import AppState
from .config_settings import ConfigSettings
from .ssh_connection_config import SshConnectionConfig # Added

__all__ = [
    "AppState",
    "ConfigSettings",
    "SshConnectionConfig", # Added
]
]]></file_code>
</file>
<file>
  <file_summary>SSH 연결 설정을 위한 Pydantic 모델 정의</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>src/core/pydantic_models/ssh_connection_config.py</file_path>
  <file_code><![CDATA[
from pydantic import BaseModel, Field, field_validator, SecretStr
from typing import Literal, Optional

class SshConnectionConfig(BaseModel):
    """
    Represents the configuration for an SSH connection.
    Password will be stored encrypted in the DB.
    """
    id: Optional[int] = None  # DB에서 자동 생성되는 ID
    alias: str = Field(..., min_length=1, max_length=100) # Unique alias for the connection
    host: str = Field(..., min_length=1) # Hostname or IP address
    port: int = Field(22, ge=1, le=65535) # Port number
    username: str = Field(..., min_length=1) # Username for SSH authentication
    auth_type: Literal['password', 'key'] = Field(...) # Authentication method
    password: Optional[SecretStr] = Field(None) # Plain password (only used temporarily before encryption)
    password_enc: Optional[str] = Field(None) # Encrypted password (Base64 encoded AES-GCM)
    key_path: Optional[str] = Field(None) # Path to the private key file

    @field_validator('auth_type')
    @classmethod
    def validate_auth_details(cls, v, values):
        """Validate that required fields are present based on auth_type."""
        auth_type = v
        password = values.data.get('password') # .data to access raw input
        key_path = values.data.get('key_path')

        if auth_type == 'password' and not password:
            raise ValueError("Password is required for password authentication.")
        if auth_type == 'key' and not key_path:
            raise ValueError("Key path is required for key authentication.")
        # Ensure only one auth method detail is provided if necessary (optional, depends on UI logic)
        # if auth_type == 'password' and key_path:
        #     raise ValueError("Cannot provide both password and key path.")
        # if auth_type == 'key' and password:
        #     raise ValueError("Cannot provide both password and key path.")
        return v

    @field_validator('key_path')
    @classmethod
    def validate_key_path_if_needed(cls, v, values):
        """Optional: Validate key path existence if auth_type is 'key'."""
        auth_type = values.data.get('auth_type')
        if auth_type == 'key' and v:
            # Basic validation, actual existence check might be better elsewhere
            if not isinstance(v, str) or not v.strip():
                raise ValueError("Key path must be a non-empty string.")
            # import os # Consider moving os import to top
            # if not os.path.exists(v): # Maybe too strict for config validation
            #     raise ValueError(f"Key file not found at path: {v}")
        return v

    class Config:
        validate_assignment = True
        extra = 'ignore' # Ignore extra fields like created_at, updated_at from DB
        # Allow SecretStr to be handled correctly
        arbitrary_types_allowed = True
]]></file_code>
</file>
<file>
  <file_summary>새 서비스(SshConfigService) 임포트</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>src/core/services/__init__.py</file_path>
  <file_code><![CDATA[

# This file makes Python treat the directory services as a package.
# It can also be used to expose specific classes or functions.

from .config_service import ConfigService
from .db_service import DbService # Added
from .filesystem_service import FilesystemService
from .prompt_service import PromptService
from .state_service import StateService
from .template_service import TemplateService
from .token_service import TokenCalculationService
from .xml_service import XmlService
from .ssh_config_service import SshConfigService # Added
# from .gemini_service import build_gemini_graph # 함수 직접 임포트 대신 모듈 사용

__all__ = [
    "ConfigService",
    "DbService", # Added
    "FilesystemService",
    "PromptService",
    "StateService",
    "TemplateService",
    "TokenCalculationService",
    "XmlService",
    "SshConfigService", # Added
    # "build_gemini_graph", # 함수 직접 노출 대신 서비스 모듈 사용
]
]]></file_code>
</file>
<file>
  <file_summary>SSH 연결 설정 CRUD 관련 데이터베이스 메서드 추가</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>src/core/services/db_service.py</file_path>
  <file_code><![CDATA[

import psycopg2
import logging
from typing import Optional, Dict, Any, List, Tuple
import json
import datetime
from decimal import Decimal

# Added SshConnectionConfig for type hinting
from core.pydantic_models.ssh_connection_config import SshConnectionConfig

logger = logging.getLogger(__name__)

# 데이터베이스 접속 정보 (요청에 따라 하드코딩)
DB_CONFIG = {
    "host": "postgresdb.lab.miraker.me",
    "user": "shacea",
    "password": "alfkzj9389",
    "port": 5333,
    "database": "duck_agent"
}

class DbService:
    """Handles database connection and queries for application configuration and logging."""

    def __init__(self, db_config: Dict[str, Any] = DB_CONFIG):
        self.db_config = db_config
        self.connection = None
        self.connect()

    def connect(self):
        """Establishes a connection to the PostgreSQL database."""
        if self.connection and not self.connection.closed:
            return # Already connected

        try:
            logger.info(f"Connecting to database '{self.db_config['database']}' on {self.db_config['host']}...")
            self.connection = psycopg2.connect(**self.db_config)
            logger.info("Database connection successful.")
        except psycopg2.Error as e:
            logger.critical(f"Database connection failed: {e}", exc_info=True)
            self.connection = None
            raise ConnectionError(f"Failed to connect to the database: {e}")

    def disconnect(self):
        """Closes the database connection."""
        if self.connection and not self.connection.closed:
            self.connection.close()
            logger.info("Database connection closed.")
        self.connection = None

    def _execute_query(self, query: str, params: Optional[tuple] = None, fetch_one: bool = False, fetch_all: bool = False, return_id: bool = False) -> Optional[Any]:
        """Executes a SQL query and returns the result."""
        if not self.connection or self.connection.closed:
            logger.error("Cannot execute query: Database connection is not active.")
            logger.info("Attempting to reconnect to the database...")
            self.connect()
            if not self.connection or self.connection.closed:
                 raise ConnectionError("Database connection lost and could not be re-established.")

        cursor = None
        try:
            cursor = self.connection.cursor()
            logger.debug(f"Executing query: {query} with params: {params}")
            cursor.execute(query, params)

            if return_id:
                result = cursor.fetchone()
                self.connection.commit()
                logger.debug(f"Query returned ID: {result[0] if result else None}")
                return result[0] if result else None
            elif fetch_one:
                result = cursor.fetchone()
                if result and cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    row_dict = dict(zip(colnames, result))
                    logger.debug(f"Query fetched one row: {row_dict}")
                    return row_dict
                elif result:
                    # Handling case where query returns a single value, not a row dict
                    logger.debug(f"Query fetched one value: {result[0]}")
                    return result[0] # Return the single value directly
                else:
                    logger.debug("Query fetched no results (fetch_one).")
                    return None
            elif fetch_all:
                if cursor.description:
                    colnames = [desc[0] for desc in cursor.description]
                    rows = cursor.fetchall()
                    results_list = [dict(zip(colnames, row)) for row in rows]
                    logger.debug(f"Query fetched {len(results_list)} rows.")
                    return results_list
                else: # Handle queries that might not have a description (e.g., COUNT(*))
                    rows = cursor.fetchall()
                    if rows and len(rows) > 0 and len(rows[0]) == 1:
                         # Return list of single values if it looks like a single column result
                         results_list = [row[0] for row in rows]
                         logger.debug(f"Query fetched {len(results_list)} single values.")
                         return results_list
                    elif rows:
                         logger.debug(f"Query fetched {len(rows)} rows (no column description).")
                         return rows # Return raw rows if no description
                    else:
                         logger.debug("Query fetched no results (fetch_all).")
                         return []
            else:
                affected_rows = cursor.rowcount
                self.connection.commit()
                logger.debug(f"Query executed successfully. Rows affected: {affected_rows}")
                return affected_rows
        except psycopg2.Error as e:
            logger.error(f"Database query failed: {e}\nQuery: {query}\nParams: {params}", exc_info=True)
            if self.connection:
                self.connection.rollback()
            raise e
        finally:
            if cursor:
                cursor.close()

    def get_application_config(self, profile_name: str = 'default') -> Optional[Dict[str, Any]]:
        """Fetches application configuration for a given profile."""
        query = """
            SELECT * FROM application_config WHERE profile_name = %s;
        """
        try:
            result = self._execute_query(query, (profile_name,), fetch_one=True)
            if result and isinstance(result, dict):
                logger.info(f"Application config loaded for profile '{profile_name}'.")
                config_data = result
                if 'gemini_temperature' in config_data and isinstance(config_data['gemini_temperature'], Decimal):
                    config_data['gemini_temperature'] = float(config_data['gemini_temperature'])
                return config_data
            else:
                logger.error(f"Application config not found for profile '{profile_name}'.")
                return None
        except psycopg2.Error as e:
             logger.error(f"Failed to get application config for profile '{profile_name}': {e}")
             return None

    def save_application_config(self, profile_name: str, config_data: Dict[str, Any]) -> bool:
        """
        Inserts or updates the application configuration for a given profile.
        Handles data type conversions for DB compatibility. Excludes API keys.
        """
        logger.info(f"Attempting to save application configuration for profile '{profile_name}'...")

        allowed_extensions = list(config_data.get('allowed_extensions', []))
        excluded_dirs = list(config_data.get('excluded_dirs', []))
        default_ignore_list = list(config_data.get('default_ignore_list', []))
        gemini_available_models = list(config_data.get('gemini_available_models', []))
        claude_available_models = list(config_data.get('claude_available_models', []))
        gpt_available_models = list(config_data.get('gpt_available_models', []))

        gemini_enable_thinking = bool(config_data.get('gemini_enable_thinking', True))
        gemini_enable_search = bool(config_data.get('gemini_enable_search', True))

        try: gemini_temperature = float(config_data.get('gemini_temperature', 0.0))
        except (ValueError, TypeError): gemini_temperature = 0.0
        try: gemini_thinking_budget = int(config_data.get('gemini_thinking_budget', 24576))
        except (ValueError, TypeError): gemini_thinking_budget = 24576

        sql = """
            INSERT INTO application_config (
                profile_name, default_system_prompt, allowed_extensions, excluded_dirs,
                default_ignore_list, gemini_default_model, claude_default_model, gpt_default_model,
                gemini_available_models, claude_available_models, gpt_available_models,
                gemini_temperature, gemini_enable_thinking, gemini_thinking_budget, gemini_enable_search
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (profile_name) DO UPDATE SET
                default_system_prompt = EXCLUDED.default_system_prompt,
                allowed_extensions = EXCLUDED.allowed_extensions,
                excluded_dirs = EXCLUDED.excluded_dirs,
                default_ignore_list = EXCLUDED.default_ignore_list,
                gemini_default_model = EXCLUDED.gemini_default_model,
                claude_default_model = EXCLUDED.claude_default_model,
                gpt_default_model = EXCLUDED.gpt_default_model,
                gemini_available_models = EXCLUDED.gemini_available_models,
                claude_available_models = EXCLUDED.claude_available_models,
                gpt_available_models = EXCLUDED.gpt_available_models,
                gemini_temperature = EXCLUDED.gemini_temperature,
                gemini_enable_thinking = EXCLUDED.gemini_enable_thinking,
                gemini_thinking_budget = EXCLUDED.gemini_thinking_budget,
                gemini_enable_search = EXCLUDED.gemini_enable_search,
                updated_at = NOW();
        """
        params = (
            profile_name, config_data.get('default_system_prompt'), allowed_extensions, excluded_dirs,
            default_ignore_list, config_data.get('gemini_default_model'), config_data.get('claude_default_model'),
            config_data.get('gpt_default_model'), gemini_available_models, claude_available_models,
            gpt_available_models, gemini_temperature, gemini_enable_thinking, gemini_thinking_budget,
            gemini_enable_search
        )

        try:
            affected_rows = self._execute_query(sql, params)
            logger.info(f"Application configuration for profile '{profile_name}' saved successfully. Rows affected: {affected_rows}")
            return True
        except psycopg2.Error as e:
            logger.error(f"Error saving application configuration for profile '{profile_name}': {e}")
            return False
        except Exception as e:
            logger.error(f"An unexpected error occurred during config save for profile '{profile_name}': {e}")
            return False

    # --- API Key Management ---

    def get_active_api_key(self, provider: str) -> Optional[str]:
        """Fetches the first active API key string for a given provider."""
        keys = self.get_active_api_keys(provider)
        return keys[0]['api_key'] if keys else None

    def get_active_api_keys(self, provider: str) -> List[Dict[str, Any]]:
        """Fetches all active API keys for a given provider, ordered by ID."""
        # Removed usage columns from this query as they are fetched in get_active_api_keys_with_usage
        query = """
            SELECT id, api_key, description, is_active FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            result = self._execute_query(query, (provider,), fetch_all=True)
            if result:
                logger.info(f"Found {len(result)} active API key(s) for provider '{provider}'.")
                return result
            else:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []
        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys for provider '{provider}': {e}")
             return []

    def get_active_api_keys_with_usage(self, provider: str) -> List[Dict[str, Any]]:
        """
        Fetches all active API keys for a given provider along with their current daily usage,
        ordered by ID. Calculates effective daily usage considering the reset window.
        (Queries only api_keys table now)
        """
        query = """
            SELECT
                id, api_key, description, is_active,
                COALESCE(calls_this_day, 0) AS raw_calls_this_day,
                day_start_timestamp
            FROM api_keys
            WHERE provider = %s AND is_active = TRUE
            ORDER BY id;
        """
        try:
            results = self._execute_query(query, (provider,), fetch_all=True)
            if not results:
                logger.warning(f"No active API keys found for provider '{provider}'.")
                return []

            logger.info(f"Found {len(results)} active API key(s) with usage info for provider '{provider}'.")
            now = datetime.datetime.now(datetime.timezone.utc)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

            # Calculate effective daily usage
            for key_info in results:
                raw_calls = key_info.get('raw_calls_this_day', 0)
                day_start = key_info.get('day_start_timestamp')

                if day_start and day_start.tzinfo is None:
                    day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                    key_info['day_start_timestamp'] = day_start

                if day_start and day_start < current_day_start:
                    key_info['calls_this_day'] = 0
                    logger.debug(f"Key ID {key_info['id']}: Day window reset. Effective calls_this_day = 0")
                else:
                    key_info['calls_this_day'] = raw_calls
                    logger.debug(f"Key ID {key_info['id']}: Within current day window. Effective calls_this_day = {raw_calls}")

            return results

        except psycopg2.Error as e:
             logger.error(f"Failed to get active API keys with usage for provider '{provider}': {e}")
             return []
        except Exception as e:
            logger.error(f"Unexpected error getting active API keys with usage for '{provider}': {e}", exc_info=True)
            return []


    def list_api_keys(self, provider: Optional[str] = None) -> List[Dict[str, Any]]:
        """Lists all API keys, optionally filtered by provider."""
        # Added usage columns to the SELECT statement
        select_columns = "id, api_key, provider, description, is_active, last_api_call_timestamp, calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp"
        if provider:
            query = f"SELECT {select_columns} FROM api_keys WHERE provider = %s ORDER BY provider, id;"
            params = (provider,)
        else:
            query = f"SELECT {select_columns} FROM api_keys ORDER BY provider, id;"
            params = None
        try:
            result = self._execute_query(query, params, fetch_all=True)
            logger.info(f"Listed {len(result)} API keys" + (f" for provider '{provider}'." if provider else "."))
            return result if result else []
        except psycopg2.Error as e:
            logger.error(f"Failed to list API keys: {e}")
            return []

    def add_api_key(self, provider: str, api_key: str, description: Optional[str] = None) -> Optional[int]:
        """Adds a new API key to the database."""
        if not provider or not api_key:
            logger.error("Cannot add API key: Provider and API key string are required.")
            return None
        # Added default values for usage columns on insert
        query = """
            INSERT INTO api_keys (provider, api_key, description, is_active,
                                  last_api_call_timestamp, calls_this_minute, minute_start_timestamp,
                                  calls_this_day, day_start_timestamp)
            VALUES (%s, %s, %s, %s, NULL, 0, NULL, 0, NULL)
            RETURNING id;
        """
        params = (provider, api_key, description, True)
        try:
            key_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new API key with ID: {key_id} for provider '{provider}'.")
            return key_id
        except psycopg2.IntegrityError as e:
             logger.error(f"Failed to add API key for '{provider}': Key likely already exists. {e}")
             return None
        except psycopg2.Error as e:
            logger.error(f"Failed to add API key for '{provider}': {e}")
            return None

    def update_api_key(self, key_id: int, description: Optional[str] = None, is_active: Optional[bool] = None) -> bool:
        """Updates the description or active status of an API key."""
        if description is None and is_active is None:
            logger.warning(f"No update provided for API key ID {key_id}.")
            return False

        set_clauses = []
        params = []
        if description is not None:
            set_clauses.append("description = %s")
            params.append(description)
        if is_active is not None:
            set_clauses.append("is_active = %s")
            params.append(is_active)

        query = f"""
            UPDATE api_keys
            SET {', '.join(set_clauses)}, updated_at = NOW()
            WHERE id = %s;
        """
        params.append(key_id)

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} updated successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found or no changes made.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to update API key ID {key_id}: {e}")
            return False

    def delete_api_key(self, key_id: int) -> bool:
        """Deletes an API key from the database."""
        # ON DELETE CASCADE in gemini_api_logs handles foreign key constraint
        query = "DELETE FROM api_keys WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (key_id,))
            if affected_rows == 1:
                logger.info(f"API key ID {key_id} deleted successfully.")
                return True
            else:
                logger.warning(f"API key ID {key_id} not found for deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to delete API key ID {key_id}: {e}")
            return False

    def get_api_key_id(self, api_key_string: str) -> Optional[int]:
        """Fetches the ID of a given API key string."""
        if not api_key_string: return None
        query = "SELECT id FROM api_keys WHERE api_key = %s;"
        try:
            result_dict = self._execute_query(query, (api_key_string,), fetch_one=True)
            return result_dict['id'] if result_dict and 'id' in result_dict else None
        except psycopg2.Error as e:
            logger.error(f"Failed to get API key ID: {e}")
            return None

    # --- Gemini Log Management ---

    def log_gemini_request(self, model_name: str, request_prompt: str, request_attachments: Optional[List[Dict[str, Any]]], api_key_id: Optional[int]) -> Optional[int]:
        """Logs the initial Gemini API request details and returns the log ID."""
        query = """
            INSERT INTO gemini_api_logs (model_name, request_prompt, request_attachments, api_key_id, request_timestamp)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """
        attachments_json = None
        if request_attachments:
            metadata_attachments = [{k: v for k, v in att.items() if k != 'data'} for att in request_attachments]
            try: attachments_json = json.dumps(metadata_attachments)
            except TypeError as e:
                logger.error(f"Failed to serialize attachments to JSON: {e}")
                attachments_json = json.dumps([{"error": "Serialization failed"}])

        request_timestamp = datetime.datetime.now(datetime.timezone.utc)
        params = (model_name, request_prompt, attachments_json, api_key_id, request_timestamp)
        try:
            log_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Logged Gemini request with ID: {log_id}")
            return log_id
        except psycopg2.Error as e:
            logger.error(f"Failed to log Gemini request: {e}")
            return None

    def update_gemini_log(self, log_id: int, response_text: Optional[str] = None, response_xml: Optional[str] = None, response_summary: Optional[str] = None, error_message: Optional[str] = None, elapsed_time_ms: Optional[int] = None, token_count: Optional[int] = None):
        """Updates the Gemini API log record with response details. Only updates non-None fields."""
        if log_id is None:
            logger.error("Cannot update Gemini log: Invalid log_id provided.")
            return

        update_fields = []
        params = []

        if response_text is not None: update_fields.append("response_text = %s"); params.append(response_text)
        if response_xml is not None: update_fields.append("response_xml = %s"); params.append(response_xml)
        if response_summary is not None: update_fields.append("response_summary = %s"); params.append(response_summary)
        if error_message is not None: update_fields.append("error_message = %s"); params.append(error_message)
        if elapsed_time_ms is not None: update_fields.append("elapsed_time_ms = %s"); params.append(elapsed_time_ms)
        if token_count is not None: update_fields.append("token_count = %s"); params.append(token_count)

        if not update_fields:
            # Nothing specific to update, but update response_timestamp anyway
            pass
            # logger.info(f"No fields to update for Gemini log ID: {log_id}")
            # return # Still update timestamp

        update_fields.append("response_timestamp = %s")
        params.append(datetime.datetime.now(datetime.timezone.utc))
        params.append(log_id)

        query = f"""
            UPDATE gemini_api_logs
            SET {', '.join(update_fields)}
            WHERE id = %s;
        """

        try:
            affected_rows = self._execute_query(query, tuple(params))
            if affected_rows == 1: logger.info(f"Updated Gemini log record ID: {log_id}")
            else: logger.warning(f"Attempted to update Gemini log ID: {log_id}, but no rows were affected (or more than 1).")
        except psycopg2.Error as e:
            logger.error(f"Failed to update Gemini log ID {log_id}: {e}")

    def cleanup_old_gemini_logs(self, days_to_keep: int = 7):
        """Deletes Gemini API log records older than the specified number of days."""
        if days_to_keep <= 0:
            logger.warning("Log cleanup skipped: days_to_keep must be positive.")
            return

        cutoff_date = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=days_to_keep)
        query = "DELETE FROM gemini_api_logs WHERE request_timestamp < %s;"
        try:
            affected_rows = self._execute_query(query, (cutoff_date,))
            if affected_rows is not None and affected_rows > 0:
                logger.info(f"Cleaned up {affected_rows} old Gemini log records older than {cutoff_date.strftime('%Y-%m-%d')}.")
            else: logger.info("No old Gemini log records found to clean up.")
        except psycopg2.Error as e:
            logger.error(f"Failed to clean up old Gemini logs: {e}")

    # --- Rate Limit and Usage Tracking (Modified for api_keys table) ---

    def update_api_key_usage(self, api_key_id: int):
        """Updates the usage statistics for a given API key ID directly in the api_keys table."""
        if api_key_id is None:
            logger.warning("Cannot update API key usage: api_key_id is None.")
            return

        logger.info(f"Updating API key usage for key ID: {api_key_id}")
        now = datetime.datetime.now(datetime.timezone.utc)
        current_minute_start = now.replace(second=0, microsecond=0)
        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

        # --- SQL Query using UPDATE with CASE statements ---
        # This query updates the existing row in api_keys based on the api_key_id.
        # It correctly handles the logic for incrementing counts or resetting them
        # based on whether the current minute/day window has passed.
        query = """
            UPDATE api_keys SET
                last_api_call_timestamp = %(now)s,

                -- Update minute count and timestamp
                calls_this_minute = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN 1
                    ELSE calls_this_minute + 1
                END,
                minute_start_timestamp = CASE
                    WHEN minute_start_timestamp IS NULL OR minute_start_timestamp < %(minute_start)s THEN %(minute_start)s
                    ELSE minute_start_timestamp
                END,

                -- Update day count and timestamp
                calls_this_day = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN 1
                    ELSE calls_this_day + 1
                END,
                day_start_timestamp = CASE
                    WHEN day_start_timestamp IS NULL OR day_start_timestamp < %(day_start)s THEN %(day_start)s
                    ELSE day_start_timestamp
                END,

                -- Always update the updated_at timestamp
                updated_at = NOW()
            WHERE id = %(key_id)s;
        """
        params = {
            'key_id': api_key_id,
            'now': now,
            'minute_start': current_minute_start,
            'day_start': current_day_start
        }

        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1:
                logger.info(f"API key usage updated successfully for key ID: {api_key_id}.")
            elif affected_rows == 0:
                 logger.warning(f"API key usage update failed for key ID {api_key_id}: Key not found.")
            else:
                 # Should not happen with WHERE id = ...
                 logger.error(f"Unexpected number of rows affected ({affected_rows}) during API key usage update for key ID {api_key_id}.")

        except psycopg2.Error as e:
            logger.error(f"Failed to update API key usage for key ID {api_key_id}: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"An unexpected error occurred during API key usage update for key ID {api_key_id}: {e}", exc_info=True)


    def get_model_rate_limit(self, model_name: str) -> Optional[Dict[str, Any]]:
        """Fetches the default rate limit information for a specific model."""
        query = "SELECT rpm_limit, daily_limit FROM model_rate_limits WHERE model_name = %s;"
        try:
            result = self._execute_query(query, (model_name,), fetch_one=True)
            if result:
                logger.info(f"Rate limit found for model '{model_name}': RPM={result.get('rpm_limit')}, Daily={result.get('daily_limit')}")
                return result
            else:
                logger.warning(f"No rate limit information found for model '{model_name}'.")
                return None
        except psycopg2.Error as e:
            logger.error(f"Failed to get rate limit for model '{model_name}': {e}")
            return None

    def get_api_key_usage(self, api_key_id: int) -> Optional[Dict[str, Any]]:
        """Fetches the current usage statistics for a specific API key ID from the api_keys table."""
        if api_key_id is None: return None
        query = """
            SELECT calls_this_minute, minute_start_timestamp, calls_this_day, day_start_timestamp
            FROM api_keys
            WHERE id = %s;
        """
        try:
            result = self._execute_query(query, (api_key_id,), fetch_one=True)
            if result:
                logger.info(f"Usage found for API key ID {api_key_id}.")
                # Ensure timestamps are timezone-aware if they aren't already
                if result.get('minute_start_timestamp') and result['minute_start_timestamp'].tzinfo is None:
                    result['minute_start_timestamp'] = result['minute_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                if result.get('day_start_timestamp') and result['day_start_timestamp'].tzinfo is None:
                    result['day_start_timestamp'] = result['day_start_timestamp'].replace(tzinfo=datetime.timezone.utc)
                return result
            else:
                logger.info(f"No usage record found for API key ID {api_key_id}. Assuming 0 usage.")
                # Return default zero usage if no record exists (or key doesn't exist)
                return {
                    'calls_this_minute': 0, 'minute_start_timestamp': None,
                    'calls_this_day': 0, 'day_start_timestamp': None
                }
        except psycopg2.Error as e:
            logger.error(f"Failed to get usage for API key ID {api_key_id}: {e}")
            return None

    def is_key_rate_limited(self, api_key_id: int, model_name: str) -> Tuple[bool, str]:
        """
        Checks if the API key is currently rate-limited for the given model.
        (Uses the modified get_api_key_usage)
        """
        if api_key_id is None:
            return True, "API Key ID is missing."

        try:
            # 1. Get model's default rate limits
            rate_limit_info = self.get_model_rate_limit(model_name)
            if not rate_limit_info:
                logger.warning(f"No rate limit info found for model '{model_name}'. Assuming not limited.")
                return False, "Rate limit info not found."
            rpm_limit = rate_limit_info.get('rpm_limit')
            daily_limit = rate_limit_info.get('daily_limit')

            # 2. Get current usage for the API key (from api_keys table now)
            usage_info = self.get_api_key_usage(api_key_id)
            # get_api_key_usage now returns default 0 if key not found or no usage
            # No need to check if usage_info is None here

            calls_this_minute = usage_info.get('calls_this_minute', 0)
            minute_start = usage_info.get('minute_start_timestamp')
            calls_this_day = usage_info.get('calls_this_day', 0)
            day_start = usage_info.get('day_start_timestamp')
            now = datetime.datetime.now(datetime.timezone.utc)
            current_minute_start = now.replace(second=0, microsecond=0)
            current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)


            # 3. Check RPM limit
            if rpm_limit is not None and rpm_limit > 0:
                current_minute_call_count = calls_this_minute
                if minute_start and now >= minute_start + datetime.timedelta(minutes=1):
                     current_minute_call_count = 0
                     logger.debug(f"RPM Check: Minute window reset for key {api_key_id}. Current count considered 0.")

                if current_minute_call_count >= rpm_limit:
                    reason = f"RPM limit ({rpm_limit}) reached or exceeded (current minute calls: {current_minute_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            # 4. Check Daily limit
            if daily_limit is not None and daily_limit > 0:
                current_day_call_count = calls_this_day
                if day_start and now >= day_start + datetime.timedelta(days=1):
                    current_day_call_count = 0
                    logger.debug(f"Daily Check: Day window reset for key {api_key_id}. Current count considered 0.")

                if current_day_call_count >= daily_limit:
                    reason = f"Daily limit ({daily_limit}) reached or exceeded (current day calls: {current_day_call_count})."
                    logger.warning(f"Rate limit check failed for key ID {api_key_id}: {reason}")
                    return True, reason

            logger.debug(f"Rate limit check passed for key ID {api_key_id} and model '{model_name}'.")
            return False, "Rate limit OK."

        except Exception as e:
            logger.error(f"Error checking rate limit for key ID {api_key_id}: {e}", exc_info=True)
            return True, f"Error during rate limit check: {e}"

    def insert_or_update_rate_limit(self, model_name: str, provider: str, rpm_limit: int, daily_limit: int, notes: Optional[str] = None) -> bool:
        """Inserts or updates a model's rate limit information."""
        sql = """
            INSERT INTO model_rate_limits (model_name, provider, rpm_limit, daily_limit, notes)
            VALUES (%s, %s, %s, %s, %s)
            ON CONFLICT (model_name) DO UPDATE SET
                provider = EXCLUDED.provider,
                rpm_limit = EXCLUDED.rpm_limit,
                daily_limit = EXCLUDED.daily_limit,
                notes = EXCLUDED.notes,
                updated_at = NOW();
        """
        params = (model_name, provider, rpm_limit, daily_limit, notes)
        try:
            self._execute_query(sql, params)
            logger.info(f"Rate limit for model '{model_name}' saved successfully.")
            return True
        except psycopg2.Error as e:
            logger.error(f"Error saving rate limit for model '{model_name}': {e}")
            return False

    def delete_rate_limit(self, model_name: str) -> bool:
        """Deletes rate limit information for a specific model."""
        sql = "DELETE FROM model_rate_limits WHERE model_name = %s;"
        try:
            affected_rows = self._execute_query(sql, (model_name,))
            if affected_rows == 1:
                logger.info(f"Rate limit for model '{model_name}' deleted successfully.")
                return True
            else:
                logger.warning(f"Model '{model_name}' not found for rate limit deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Error deleting rate limit for model '{model_name}': {e}")
            return False

    # --- SSH Connection Management ---

    def add_ssh_connection(self, config: SshConnectionConfig) -> Optional[int]:
        """Adds a new SSH connection configuration to the database."""
        query = """
            INSERT INTO ssh_connections (alias, host, port, username, auth_type, password_enc, key_path)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
            RETURNING id;
        """
        # password_enc should already be encrypted and base64 encoded
        params = (
            config.alias, config.host, config.port, config.username,
            config.auth_type, config.password_enc, config.key_path
        )
        try:
            connection_id = self._execute_query(query, params, return_id=True)
            logger.info(f"Added new SSH connection with ID: {connection_id} (Alias: {config.alias})")
            return connection_id
        except psycopg2.IntegrityError as e:
             logger.error(f"Failed to add SSH connection '{config.alias}': Alias likely already exists. {e}")
             return None
        except psycopg2.Error as e:
            logger.error(f"Failed to add SSH connection '{config.alias}': {e}")
            return None

    def get_ssh_connection(self, alias: str) -> Optional[SshConnectionConfig]:
        """Fetches an SSH connection configuration by its alias."""
        query = "SELECT * FROM ssh_connections WHERE alias = %s;"
        try:
            result_dict = self._execute_query(query, (alias,), fetch_one=True)
            if result_dict:
                # Pydantic 모델로 변환 (password는 포함하지 않음)
                # Pydantic 2.x: SecretStr 사용 불필요, password_enc만 로드
                return SshConnectionConfig(**result_dict)
            else:
                logger.info(f"No SSH connection found with alias '{alias}'.")
                return None
        except psycopg2.Error as e:
            logger.error(f"Failed to get SSH connection '{alias}': {e}")
            return None

    def get_ssh_connection_by_id(self, connection_id: int) -> Optional[SshConnectionConfig]:
        """Fetches an SSH connection configuration by its ID."""
        query = "SELECT * FROM ssh_connections WHERE id = %s;"
        try:
            result_dict = self._execute_query(query, (connection_id,), fetch_one=True)
            if result_dict:
                return SshConnectionConfig(**result_dict)
            else:
                logger.info(f"No SSH connection found with ID {connection_id}.")
                return None
        except psycopg2.Error as e:
            logger.error(f"Failed to get SSH connection by ID {connection_id}: {e}")
            return None

    def list_ssh_connections(self) -> List[SshConnectionConfig]:
        """Lists all saved SSH connection configurations."""
        query = "SELECT * FROM ssh_connections ORDER BY alias;"
        try:
            results_list = self._execute_query(query, fetch_all=True)
            connections = [SshConnectionConfig(**row) for row in results_list] if results_list else []
            logger.info(f"Listed {len(connections)} SSH connections.")
            return connections
        except psycopg2.Error as e:
            logger.error(f"Failed to list SSH connections: {e}")
            return []

    def update_ssh_connection(self, connection_id: int, config: SshConnectionConfig) -> bool:
        """Updates an existing SSH connection configuration."""
        query = """
            UPDATE ssh_connections
            SET alias = %s, host = %s, port = %s, username = %s, auth_type = %s,
                password_enc = %s, key_path = %s, updated_at = NOW()
            WHERE id = %s;
        """
        params = (
            config.alias, config.host, config.port, config.username, config.auth_type,
            config.password_enc, config.key_path, connection_id
        )
        try:
            affected_rows = self._execute_query(query, params)
            if affected_rows == 1:
                logger.info(f"SSH connection ID {connection_id} (Alias: {config.alias}) updated successfully.")
                return True
            else:
                logger.warning(f"SSH connection ID {connection_id} not found for update.")
                return False
        except psycopg2.IntegrityError as e:
             logger.error(f"Failed to update SSH connection ID {connection_id}: Alias '{config.alias}' likely already exists for another entry. {e}")
             return False
        except psycopg2.Error as e:
            logger.error(f"Failed to update SSH connection ID {connection_id}: {e}")
            return False

    def delete_ssh_connection(self, connection_id: int) -> bool:
        """Deletes an SSH connection configuration by its ID."""
        query = "DELETE FROM ssh_connections WHERE id = %s;"
        try:
            affected_rows = self._execute_query(query, (connection_id,))
            if affected_rows == 1:
                logger.info(f"SSH connection ID {connection_id} deleted successfully.")
                return True
            else:
                logger.warning(f"SSH connection ID {connection_id} not found for deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to delete SSH connection ID {connection_id}: {e}")
            return False

    def delete_ssh_connection_by_alias(self, alias: str) -> bool:
        """Deletes an SSH connection configuration by its alias."""
        query = "DELETE FROM ssh_connections WHERE alias = %s;"
        try:
            affected_rows = self._execute_query(query, (alias,))
            if affected_rows == 1:
                logger.info(f"SSH connection with alias '{alias}' deleted successfully.")
                return True
            else:
                logger.warning(f"SSH connection with alias '{alias}' not found for deletion.")
                return False
        except psycopg2.Error as e:
            logger.error(f"Failed to delete SSH connection with alias '{alias}': {e}")
            return False


    def __del__(self):
        """Ensure disconnection when the service object is destroyed."""
        self.disconnect()
]]></file_code>
</file>
<file>
  <file_summary>SSH 연결 설정 관리 서비스 로직 구현 (암호화 포함)</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>src/core/services/ssh_config_service.py</file_path>
  <file_code><![CDATA[
import logging
from typing import List, Optional
from pydantic import ValidationError

from .db_service import DbService
from core.pydantic_models.ssh_connection_config import SshConnectionConfig
from core.utils.crypto import encrypt_password, decrypt_password

logger = logging.getLogger(__name__)

class SshConfigService:
    """
    Manages SSH connection configurations, including CRUD operations
    and password encryption/decryption.
    """

    def __init__(self, db_service: DbService):
        self.db_service = db_service

    def add_connection(self, config_data: dict) -> Optional[SshConnectionConfig]:
        """
        Adds a new SSH connection configuration after validation and encryption.

        Args:
            config_data: A dictionary containing the SSH connection details.
                         Password should be plain text here.

        Returns:
            The created SshConnectionConfig object with ID, or None if failed.
        """
        try:
            # Validate input data using Pydantic model
            config = SshConnectionConfig(**config_data)

            # Encrypt password if provided
            if config.auth_type == 'password' and config.password:
                plain_password = config.password.get_secret_value()
                config.password_enc = encrypt_password(plain_password)
                if not config.password_enc:
                    logger.error(f"Failed to encrypt password for alias '{config.alias}'.")
                    return None
                # Clear the plain password after encryption
                config.password = None
            else:
                config.password_enc = None # Ensure password_enc is None for key auth

            # Add to database
            connection_id = self.db_service.add_ssh_connection(config)
            if connection_id:
                config.id = connection_id
                logger.info(f"Successfully added SSH connection: {config.alias} (ID: {connection_id})")
                # Return the config with the new ID, excluding the plain password
                return config.model_copy(exclude={'password'})
            else:
                logger.error(f"Failed to add SSH connection '{config.alias}' to the database.")
                return None

        except ValidationError as e:
            logger.error(f"SSH connection configuration validation failed: {e}")
            return None
        except Exception as e:
            logger.exception(f"Unexpected error adding SSH connection: {e}")
            return None

    def get_connection(self, alias: str) -> Optional[SshConnectionConfig]:
        """Retrieves an SSH connection configuration by alias."""
        config = self.db_service.get_ssh_connection(alias)
        if config:
            # Decryption is usually handled just before connection, not on retrieval.
            # The Pydantic model should not expose the decrypted password by default.
            return config
        return None

    def get_connection_with_decrypted_password(self, alias: str) -> Optional[SshConnectionConfig]:
        """
        Retrieves an SSH connection by alias and decrypts the password if present.
        Use with caution, only when the password is required for connection.
        """
        config = self.db_service.get_ssh_connection(alias)
        if config and config.auth_type == 'password' and config.password_enc:
            try:
                decrypted_pw = decrypt_password(config.password_enc)
                if decrypted_pw is None:
                    logger.error(f"Failed to decrypt password for SSH connection: {alias}")
                    # Return config without password if decryption fails? Or return None?
                    # Let's return None to indicate failure.
                    return None
                # Set the decrypted password (as SecretStr) temporarily in the model
                config.password = decrypted_pw
            except Exception as e:
                logger.exception(f"Error decrypting password for SSH connection {alias}: {e}")
                return None # Return None on decryption error
        elif config and config.auth_type == 'password' and not config.password_enc:
             logger.warning(f"Password authentication selected for SSH connection '{alias}', but no encrypted password found.")
        return config

    def list_connections(self) -> List[SshConnectionConfig]:
        """Lists all saved SSH connection configurations."""
        return self.db_service.list_ssh_connections()

    def update_connection(self, connection_id: int, config_data: dict) -> Optional[SshConnectionConfig]:
        """
        Updates an existing SSH connection configuration.

        Args:
            connection_id: The ID of the connection to update.
            config_data: Dictionary with updated connection details.
                         Password can be plain text if it needs updating.

        Returns:
            The updated SshConnectionConfig object, or None if failed.
        """
        try:
            # Fetch existing config to compare or validate against if needed (optional)
            existing_config = self.db_service.get_ssh_connection_by_id(connection_id)
            if not existing_config:
                logger.error(f"Cannot update SSH connection: ID {connection_id} not found.")
                return None

            # Merge existing data with updates and validate
            # Ensure ID is preserved for update
            config_data['id'] = connection_id
            # Keep original password_enc if password is not being updated
            if 'password' not in config_data and existing_config.password_enc:
                 config_data['password_enc'] = existing_config.password_enc
            config = SshConnectionConfig(**config_data)

            # Encrypt password if a new plain password is provided
            if config.auth_type == 'password' and config.password:
                plain_password = config.password.get_secret_value()
                config.password_enc = encrypt_password(plain_password)
                if not config.password_enc:
                    logger.error(f"Failed to encrypt new password for SSH connection ID {connection_id}.")
                    return None
                config.password = None # Clear plain password
            elif config.auth_type == 'key':
                 config.password_enc = None # Ensure password_enc is None for key auth if type changed
            # If auth_type remains 'password' but no new password provided, keep existing password_enc

            # Update in database
            success = self.db_service.update_ssh_connection(connection_id, config)
            if success:
                logger.info(f"Successfully updated SSH connection: {config.alias} (ID: {connection_id})")
                return config.model_copy(exclude={'password'})
            else:
                logger.error(f"Failed to update SSH connection ID {connection_id} in the database.")
                return None

        except ValidationError as e:
            logger.error(f"SSH connection configuration validation failed during update: {e}")
            return None
        except Exception as e:
            logger.exception(f"Unexpected error updating SSH connection ID {connection_id}: {e}")
            return None

    def delete_connection(self, connection_id: int) -> bool:
        """Deletes an SSH connection configuration by its ID."""
        logger.info(f"Attempting to delete SSH connection with ID: {connection_id}")
        success = self.db_service.delete_ssh_connection(connection_id)
        if success:
            logger.info(f"Successfully deleted SSH connection ID {connection_id}.")
        else:
            logger.error(f"Failed to delete SSH connection ID {connection_id}.")
        return success

    def delete_connection_by_alias(self, alias: str) -> bool:
        """Deletes an SSH connection configuration by its alias."""
        logger.info(f"Attempting to delete SSH connection with alias: {alias}")
        success = self.db_service.delete_ssh_connection_by_alias(alias)
        if success:
            logger.info(f"Successfully deleted SSH connection with alias '{alias}'.")
        else:
            logger.error(f"Failed to delete SSH connection with alias '{alias}'.")
        return success

    def test_connection(self, alias: str) -> Tuple[bool, str]:
        """
        Tests the SSH connection for the given alias.
        (Placeholder - Actual connection logic requires paramiko or similar)
        """
        logger.info(f"Attempting to test SSH connection for alias: {alias}")
        config = self.get_connection_with_decrypted_password(alias)
        if not config:
            return False, f"Configuration for alias '{alias}' not found or password decryption failed."

        # --- Placeholder for actual SSH connection test using paramiko ---
        # try:
        #     import paramiko
        #     client = paramiko.SSHClient()
        #     client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # Or WarningPolicy
        #
        #     if config.auth_type == 'password' and config.password:
        #         client.connect(hostname=config.host, port=config.port, username=config.username,
        #                        password=config.password.get_secret_value(), timeout=5)
        #     elif config.auth_type == 'key' and config.key_path:
        #         key_filepath = os.path.expanduser(config.key_path)
        #         if not os.path.exists(key_filepath):
        #             return False, f"Private key file not found: {key_filepath}"
        #         # Consider adding key password handling if needed
        #         private_key = paramiko.RSAKey.from_private_key_file(key_filepath) # Or other key types
        #         client.connect(hostname=config.host, port=config.port, username=config.username,
        #                        pkey=private_key, timeout=5)
        #     else:
        #         return False, "Invalid authentication configuration."
        #
        #     client.close()
        #     logger.info(f"SSH connection test successful for alias: {alias}")
        #     return True, "Connection successful!"
        #
        # except paramiko.AuthenticationException:
        #     logger.warning(f"SSH Authentication failed for alias: {alias}")
        #     return False, "Authentication failed (check username/password/key)."
        # except paramiko.SSHException as e:
        #     logger.error(f"SSH connection error for alias {alias}: {e}")
        #     return False, f"SSH connection error: {e}"
        # except socket.timeout:
        #     logger.error(f"SSH connection timed out for alias: {alias}")
        #     return False, "Connection timed out."
        # except Exception as e:
        #     logger.exception(f"Unexpected error testing SSH connection {alias}: {e}")
        #     return False, f"Unexpected error: {e}"
        # --- End of Placeholder ---

        # Return placeholder success for now
        logger.warning("SSH connection test logic is not implemented. Returning placeholder success.")
        return True, "Connection test successful (Placeholder)"
]]></file_code>
</file>
<file>
  <file_summary>crypto 유틸리티 임포트 경로 추가</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>src/core/utils/__init__.py</file_path>
  <file_code><![CDATA[
# This file makes Python treat the directory utils as a package.

from .helpers import get_project_root, get_resource_path, calculate_char_count
from .notifications import show_notification
from .crypto import encrypt_password, decrypt_password, generate_key # Added

__all__ = [
    "get_project_root",
    "get_resource_path",
    "calculate_char_count",
    "show_notification",
    "encrypt_password", # Added
    "decrypt_password", # Added
    "generate_key",     # Added
]
]]></file_code>
</file>
<file>
  <file_summary>AES-GCM 암호화/복호화 유틸리티 함수 추가</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>src/core/utils/crypto.py</file_path>
  <file_code><![CDATA[
import os
import base64
import logging
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# --- Configuration ---
# For production, use environment variables or a secure key management system.
# WARNING: Hardcoding the key or storing it insecurely is a major security risk.
# ENV_VAR_NAME = "DUCKPROMPT_CRYPTO_KEY" # Example environment variable name
KEY_FILE_PATH = "resources/encryption.key" # Example key file path (relative to project root)

logger = logging.getLogger(__name__)

# --- Key Management ---
_encryption_key: Optional[bytes] = None

def generate_key() -> bytes:
    """Generates a new AES-GCM key (256-bit)."""
    return AESGCM.generate_key(bit_length=256)

def save_key_to_file(key: bytes, file_path: str):
    """Saves the key to a file (Base64 encoded). Ensure file permissions are strict."""
    try:
        from .helpers import get_resource_path # Local import to avoid circular dependency if needed
        full_path = get_resource_path(file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        # Set strict permissions if possible (Linux/macOS)
        try:
            # Open with mode 0o600 creates the file with restricted permissions
            fd = os.open(full_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
            with os.fdopen(fd, 'wb') as f:
                f.write(base64.urlsafe_b64encode(key))
            logger.info(f"Encryption key saved to: {full_path} with restricted permissions.")
        except OSError: # Handle systems not supporting os.O_WRONLY etc. like Windows
             with open(full_path, 'wb') as f:
                f.write(base64.urlsafe_b64encode(key))
             logger.warning(f"Encryption key saved to: {full_path}. Could not set strict file permissions on this OS.")
        except AttributeError: # Handle systems where os.O_WRONLY might be missing
             with open(full_path, 'wb') as f:
                f.write(base64.urlsafe_b64encode(key))
             logger.warning(f"Encryption key saved to: {full_path}. Could not set strict file permissions on this OS.")

    except Exception as e:
        logger.exception(f"Failed to save encryption key to {file_path}: {e}")

def load_key_from_file(file_path: str) -> Optional[bytes]:
    """Loads the key from a file (Base64 encoded)."""
    try:
        from .helpers import get_resource_path # Local import
        full_path = get_resource_path(file_path)
        if not os.path.exists(full_path):
            logger.warning(f"Encryption key file not found at {full_path}. Generating a new key.")
            new_key = generate_key()
            save_key_to_file(new_key, file_path)
            return new_key
        with open(full_path, 'rb') as f:
            key = base64.urlsafe_b64decode(f.read())
        logger.info(f"Encryption key loaded successfully from {full_path}.")
        return key
    except Exception as e:
        logger.exception(f"Failed to load encryption key from {file_path}: {e}")
        return None

def get_encryption_key() -> Optional[bytes]:
    """Retrieves the encryption key (loads if not already loaded)."""
    global _encryption_key
    if _encryption_key is None:
        # --- Key Loading Priority ---
        # 1. Environment Variable (Most Secure - Recommended for Production)
        # key_b64 = os.environ.get(ENV_VAR_NAME)
        # if key_b64:
        #     try:
        #         _encryption_key = base64.urlsafe_b64decode(key_b64)
        #         logger.info(f"Encryption key loaded from environment variable '{ENV_VAR_NAME}'.")
        #     except Exception as e:
        #         logger.error(f"Failed to decode key from environment variable '{ENV_VAR_NAME}': {e}")
        #         _encryption_key = None # Fallback

        # 2. Key File (Less Secure than Env Var, use with strict permissions)
        # if _encryption_key is None:
        _encryption_key = load_key_from_file(KEY_FILE_PATH)

        # 3. Fallback/Error Handling (if key loading failed)
        if _encryption_key is None:
            logger.critical("FATAL: Could not load or generate encryption key. Encryption/Decryption will fail.")
            # Depending on requirements, you might want to raise an exception here
            # raise RuntimeError("Encryption key is missing or invalid.")

    return _encryption_key

# --- Encryption/Decryption ---

def encrypt_password(password: str) -> Optional[str]:
    """
    Encrypts a password using AES-GCM.

    Args:
        password: The plain text password string.

    Returns:
        A Base64 encoded string containing nonce + ciphertext + tag,
        or None if encryption fails.
    """
    key = get_encryption_key()
    if key is None or not password:
        logger.error("Encryption failed: Key is missing or password is empty.")
        return None
    try:
        aesgcm = AESGCM(key)
        nonce = os.urandom(12)  # AES-GCM recommended nonce size is 12 bytes
        password_bytes = password.encode('utf-8')
        # associated_data = b"optional-associated-data" # Example: Can add user ID, etc.
        ciphertext = aesgcm.encrypt(nonce, password_bytes, None) # No associated data here

        # Combine nonce and ciphertext for storage (nonce first)
        encrypted_data = nonce + ciphertext
        encoded_data = base64.urlsafe_b64encode(encrypted_data).decode('utf-8')
        # logger.debug("Password encrypted successfully.") # Avoid logging success for sensitive ops
        return encoded_data
    except Exception as e:
        logger.exception(f"Encryption failed: {e}")
        return None

def decrypt_password(encoded_data: str) -> Optional[str]:
    """
    Decrypts a password encrypted with AES-GCM.

    Args:
        encoded_data: The Base64 encoded string (nonce + ciphertext + tag).

    Returns:
        The decrypted plain text password string, or None if decryption fails.
    """
    key = get_encryption_key()
    if key is None or not encoded_data:
        logger.error("Decryption failed: Key is missing or encoded data is empty.")
        return None
    try:
        aesgcm = AESGCM(key)
        encrypted_data = base64.urlsafe_b64decode(encoded_data.encode('utf-8'))

        # Extract nonce and ciphertext
        nonce = encrypted_data[:12] # Assuming 12-byte nonce
        ciphertext = encrypted_data[12:]

        if len(nonce) != 12:
            logger.error("Decryption failed: Invalid nonce length.")
            return None

        # associated_data = b"optional-associated-data" # Must match encryption if used
        decrypted_bytes = aesgcm.decrypt(nonce, ciphertext, None) # No associated data
        password = decrypted_bytes.decode('utf-8')
        # logger.debug("Password decrypted successfully.") # Avoid logging success
        return password
    except InvalidToken:
        logger.error("Decryption failed: Invalid token (likely wrong key or corrupted data).")
        return None
    except Exception as e:
        logger.exception(f"Decryption failed: {e}")
        return None

# Initialize the key on module load (optional, get_encryption_key handles lazy loading)
# get_encryption_key()
]]></file_code>
</file>
<file>
  <file_summary>환경 설정 창에 SSH 설정 탭 추가 및 기능 연동</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>src/ui/settings_dialog.py</file_path>
  <file_code><![CDATA[
import os
import datetime # datetime 추가
from PyQt6.QtWidgets import ( # PyQt5 -> PyQt6
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QPlainTextEdit, QFileDialog, QMessageBox, QGroupBox, QHBoxLayout, QComboBox,
    QCheckBox, QApplication, QListWidget, QListWidgetItem, QAbstractItemView, QInputDialog, QWidget,
    QSplitter, QSizePolicy, QTableWidget, QTableWidgetItem, QHeaderView, QAbstractScrollArea # Table related added
)
from PyQt6.QtCore import Qt, QThreadPool # PyQt5 -> PyQt6, QThreadPool added for background task
from PyQt6.QtGui import QColor, QIcon, QIntValidator, QBrush, QFont # PyQt5 -> PyQt6, QIntValidator, QBrush, QFont added
from typing import Optional, Set, List, Dict, Any, Tuple # Dict, Any, Tuple 추가
from pydantic import ValidationError
import logging # 로깅 추가
from concurrent.futures import ThreadPoolExecutor # For background tasks

# 서비스 및 컨트롤러 함수 import
from core.services.config_service import ConfigService
from core.services.ssh_config_service import SshConfigService # Added
from core.pydantic_models.config_settings import ConfigSettings
from core.pydantic_models.ssh_connection_config import SshConnectionConfig # Added
from ui.controllers.system_prompt_controller import select_default_system_prompt
from ui.widgets.ssh_config_dialog import SshConfigDialog # Added

# MainWindow 타입 힌트 (순환 참조 방지)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .main_window import MainWindow
    from core.services.db_service import DbService # DbService 타입 힌트

logger = logging.getLogger(__name__) # 로거 설정

# 파스텔 그린 색상 정의
PASTEL_GREEN = QColor(152, 251, 152) # 연한 녹색 (RGB)
# 파스텔 블루 색상 정의 (사용자 선택 강조용)
PASTEL_BLUE = QColor(173, 216, 230) # 연한 파란색 (Light Blue)
# 파스텔 퍼플 색상 정의 (자동 선택 예정 강조용)
PASTEL_PURPLE = QColor(221, 160, 221) # 연보라색 (Plum)

# --- 모델 추가 다이얼로그 ---
class AddModelDialog(QDialog):
    """모델 이름, RPM, Daily Limit을 입력받는 다이얼로그."""
    def __init__(self, model_type: str, existing_models: List[str], parent=None):
        super().__init__(parent)
        self.model_type = model_type
        self.existing_models = existing_models
        self.setWindowTitle(f"{model_type} 모델 추가")

        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.model_name_edit = QLineEdit()
        self.rpm_limit_edit = QLineEdit()
        self.daily_limit_edit = QLineEdit()

        # 숫자만 입력 가능하도록 Validator 설정
        self.rpm_limit_edit.setValidator(QIntValidator(0, 999999)) # 0 이상 정수
        self.daily_limit_edit.setValidator(QIntValidator(0, 9999999)) # 0 이상 정수

        form_layout.addRow("모델 이름:", self.model_name_edit)
        form_layout.addRow("RPM Limit (분당 요청 수):", self.rpm_limit_edit)
        form_layout.addRow("Daily Limit (하루 요청 수):", self.daily_limit_edit)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)

    def validate_and_accept(self):
        """입력값 유효성 검사 후 accept."""
        model_name = self.model_name_edit.text().strip()
        rpm_limit_str = self.rpm_limit_edit.text().strip()
        daily_limit_str = self.daily_limit_edit.text().strip()

        if not model_name:
            QMessageBox.warning(self, "입력 오류", "모델 이름을 입력해야 합니다.")
            return
        if model_name in self.existing_models:
            QMessageBox.warning(self, "입력 오류", f"'{model_name}' 모델이 이미 목록에 존재합니다.")
            return
        if not rpm_limit_str:
            QMessageBox.warning(self, "입력 오류", "RPM Limit을 입력해야 합니다.")
            return
        if not daily_limit_str:
            QMessageBox.warning(self, "입력 오류", "Daily Limit을 입력해야 합니다.")
            return

        try:
            int(rpm_limit_str)
            int(daily_limit_str)
        except ValueError:
            QMessageBox.warning(self, "입력 오류", "RPM 및 Daily Limit은 숫자로 입력해야 합니다.")
            return

        self.accept() # 유효성 검사 통과 시 accept

    def get_model_data(self) -> Optional[Tuple[str, int, int]]:
        """입력된 모델 데이터 반환."""
        if self.result() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_name = self.model_name_edit.text().strip()
            rpm_limit = int(self.rpm_limit_edit.text().strip())
            daily_limit = int(self.daily_limit_edit.text().strip())
            return model_name, rpm_limit, daily_limit
        return None

# --- SSH Connection Test Worker ---
class SshTestWorker(QObject): # QObject 상속 필요
    # PyQt6에서는 QRunnable보다 QObject + moveToThread 방식이 더 권장됨
    # finished = pyqtSignal(bool, str) # 결과 (성공 여부, 메시지) 전달
    # PyQt6에서 signal 정의 방식 변경
    from PyQt6.QtCore import pyqtSignal
    finished = pyqtSignal(bool, str)

    def __init__(self, ssh_config_service: SshConfigService, alias: str):
        super().__init__() # QObject 초기화
        self.ssh_config_service = ssh_config_service
        self.alias = alias

    # PyQt6: run 메서드는 QThread와 함께 사용될 때 필요
    def run(self):
        """백그라운드에서 SSH 연결 테스트 수행"""
        success, message = self.ssh_config_service.test_connection(self.alias)
        self.finished.emit(success, message)

# --- SettingsDialog ---
class SettingsDialog(QDialog):
    """
    환경 설정을 표시하고 수정하는 다이얼로그 창.
    DB에서 로드된 설정을 보여주고, 수정 후 DB에 저장합니다.
    .gitignore 파일 편집/저장 기능도 유지합니다.
    API 키 필드는 일반 텍스트로 표시됩니다. (저장 로직은 별도 관리)
    사용 가능 LLM 모델 목록 및 API 키를 관리하는 기능이 추가되었습니다.
    API 키 목록에 잔여 사용량 정보를 표시하고, 사용자가 사용할 키를 선택할 수 있습니다.
    사용 가능 LLM 모델 목록에서 클릭하여 기본 모델을 지정할 수 있습니다.
    사용자가 키를 선택하지 않았을 때 자동으로 선택될 키를 표시합니다.
    SSH 연결 설정 관리 기능 추가.
    """
    PASTEL_GREEN = PASTEL_GREEN # 클래스 변수로도 정의
    PASTEL_BLUE = PASTEL_BLUE # 클래스 변수로도 정의
    PASTEL_PURPLE = PASTEL_PURPLE # 클래스 변수로도 정의

    def __init__(self, main_window: 'MainWindow', parent=None):
        super().__init__(parent)
        self.mw = main_window # MainWindow 참조
        self.config_service = main_window.config_service
        self.db_service: 'DbService' = main_window.db_service # DbService 참조 추가
        self.ssh_config_service = SshConfigService(self.db_service) # SSH Config Service 추가
        self.settings: Optional[ConfigSettings] = None # Load in load_config_settings
        self.ssh_connections: List[SshConnectionConfig] = [] # SSH 연결 목록 저장
        self.thread_pool = QThreadPool.globalInstance() # 백그라운드 작업용 스레드 풀

        self.setWindowTitle("환경 설정") # Title updated
        self.setMinimumWidth(900) # 너비 증가 (SSH 탭 고려)
        self.setMinimumHeight(800) # 높이 증가 (SSH 탭 고려)

        # --- 메인 탭 위젯 생성 ---
        self.tab_widget = QTabWidget()

        # --- 일반 설정 탭 생성 ---
        general_settings_widget = self.create_general_settings_widget()
        self.tab_widget.addTab(general_settings_widget, "일반 설정")

        # --- SSH 설정 탭 생성 ---
        ssh_settings_widget = self.create_ssh_settings_widget()
        self.tab_widget.addTab(ssh_settings_widget, "SSH 연결 설정")

        # --- 전체 레이아웃 설정 ---
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(self.tab_widget)

        # 버튼 박스 (Save and Close)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Close) # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Save).setText("설정 저장") # QDialogButtonBox.Save -> QDialogButtonBox.StandardButton.Save
        self.button_box.button(QDialogButtonBox.StandardButton.Close).setText("닫기") # QDialogButtonBox.Close -> QDialogButtonBox.StandardButton.Close
        main_layout.addWidget(self.button_box)

        # --- 시그널 연결 (버튼 박스만 여기서 연결, 나머지는 각 탭 생성 함수에서) ---
        self.button_box.accepted.connect(self.save_settings) # 모든 탭 설정 저장
        self.button_box.rejected.connect(self.reject)

        # --- 초기 설정값 로드 ---
        self.load_config_settings()
        self.load_api_keys_list() # API 키 목록 로드
        self.load_ssh_connections_list() # SSH 연결 목록 로드
        if self.mw.current_project_folder:
            self.load_gitignore()

    def create_general_settings_widget(self) -> QWidget:
        """일반 설정 탭의 위젯들을 생성하고 배치합니다."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)

        # --- 위젯 생성 (기존 코드 재사용 및 일부 수정) ---
        # 기본 시스템 프롬프트
        self.default_prompt_group = QGroupBox("기본 시스템 프롬프트")
        prompt_layout = QHBoxLayout()
        self.default_prompt_path_edit = QLineEdit()
        self.default_prompt_path_edit.setPlaceholderText("프로젝트 루트 기준 상대 경로 또는 절대 경로")
        self.browse_prompt_button = QPushButton("찾아보기...")
        prompt_layout.addWidget(self.default_prompt_path_edit)
        prompt_layout.addWidget(self.browse_prompt_button)
        self.default_prompt_group.setLayout(prompt_layout)
        layout.addWidget(self.default_prompt_group)

        # 메인 수평 스플리터 생성
        main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal)

        # 왼쪽 컬럼 위젯 및 레이아웃 생성
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(10)

        # 왼쪽 컬럼에 그룹 추가 (API 키, 모델 목록, Gemini 파라미터)
        self.api_key_management_group = QGroupBox("API 키 관리")
        api_key_management_layout = QVBoxLayout()
        api_list_layout = QHBoxLayout()
        self.api_keys_list = QListWidget()
        self.api_keys_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.api_keys_list.setMinimumHeight(100)
        self.api_keys_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.refresh_api_usage_btn = QPushButton("🔄")
        self.refresh_api_usage_btn.setToolTip("API 키 사용량 새로고침")
        self.refresh_api_usage_btn.setFixedWidth(30)
        api_list_layout.addWidget(self.api_keys_list)
        api_list_layout.addWidget(self.refresh_api_usage_btn)
        self.api_key_label = QLabel("등록된 API 키 (🔵: 사용자 선택됨, 🟢: 마지막 사용, ✨: 자동 선택 예정, 🟡: 활성, 🔴: 비활성 / 잔여량은 기본 Gemini 모델 기준):")
        api_key_management_layout.addWidget(self.api_key_label)
        api_key_management_layout.addLayout(api_list_layout)
        api_key_buttons_layout = QHBoxLayout()
        self.add_api_key_btn = QPushButton("➕ 새 API 키 추가")
        self.remove_api_key_btn = QPushButton("➖ 선택한 키 제거")
        self.set_selected_key_btn = QPushButton("✅ 선택한 키 사용")
        api_key_buttons_layout.addWidget(self.add_api_key_btn)
        api_key_buttons_layout.addWidget(self.remove_api_key_btn)
        api_key_buttons_layout.addWidget(self.set_selected_key_btn)
        api_key_buttons_layout.addStretch()
        api_key_management_layout.addLayout(api_key_buttons_layout)
        self.api_key_management_group.setLayout(api_key_management_layout)
        left_layout.addWidget(self.api_key_management_group)

        self.available_models_group = QGroupBox("사용 가능 LLM 모델 목록 관리 (클릭하여 기본 모델 지정)")
        available_models_main_layout = QHBoxLayout()
        # Gemini 모델
        gemini_model_widget = QWidget()
        gemini_model_layout = QVBoxLayout(gemini_model_widget)
        gemini_model_layout.addWidget(QLabel("Gemini 모델:"))
        self.gemini_models_list = QListWidget(); self.gemini_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.gemini_models_list.setMinimumHeight(100); self.gemini_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gemini_model_buttons = QHBoxLayout()
        self.add_gemini_model_btn = QPushButton("추가"); self.remove_gemini_model_btn = QPushButton("제거")
        gemini_model_buttons.addWidget(self.add_gemini_model_btn); gemini_model_buttons.addWidget(self.remove_gemini_model_btn)
        gemini_model_layout.addWidget(self.gemini_models_list); gemini_model_layout.addLayout(gemini_model_buttons)
        available_models_main_layout.addWidget(gemini_model_widget)
        # Claude 모델
        claude_model_widget = QWidget()
        claude_model_layout = QVBoxLayout(claude_model_widget)
        claude_model_layout.addWidget(QLabel("Claude 모델:"))
        self.claude_models_list = QListWidget(); self.claude_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.claude_models_list.setMinimumHeight(100); self.claude_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        claude_model_buttons = QHBoxLayout()
        self.add_claude_model_btn = QPushButton("추가"); self.remove_claude_model_btn = QPushButton("제거")
        claude_model_buttons.addWidget(self.add_claude_model_btn); claude_model_buttons.addWidget(self.remove_claude_model_btn)
        claude_model_layout.addWidget(self.claude_models_list); claude_model_layout.addLayout(claude_model_buttons)
        available_models_main_layout.addWidget(claude_model_widget)
        # GPT 모델
        gpt_model_widget = QWidget()
        gpt_model_layout = QVBoxLayout(gpt_model_widget)
        gpt_model_layout.addWidget(QLabel("GPT 모델:"))
        self.gpt_models_list = QListWidget(); self.gpt_models_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection); self.gpt_models_list.setMinimumHeight(100); self.gpt_models_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gpt_model_buttons = QHBoxLayout()
        self.add_gpt_model_btn = QPushButton("추가"); self.remove_gpt_model_btn = QPushButton("제거")
        gpt_model_buttons.addWidget(self.add_gpt_model_btn); gpt_model_buttons.addWidget(self.remove_gpt_model_btn)
        gpt_model_layout.addWidget(self.gpt_models_list); gpt_model_layout.addLayout(gpt_model_buttons)
        available_models_main_layout.addWidget(gpt_model_widget)
        self.available_models_group.setLayout(available_models_main_layout)
        left_layout.addWidget(self.available_models_group)

        self.gemini_group = QGroupBox("Gemini 파라미터")
        gemini_layout = QFormLayout()
        self.gemini_temp_edit = QLineEdit(); self.gemini_thinking_checkbox = QCheckBox(); self.gemini_budget_edit = QLineEdit(); self.gemini_search_checkbox = QCheckBox()
        gemini_layout.addRow("Temperature (0.0 ~ 2.0):", self.gemini_temp_edit)
        gemini_layout.addRow("Enable Search:", self.gemini_search_checkbox)
        gemini_layout.addRow("Enable Thinking:", self.gemini_thinking_checkbox)
        gemini_layout.addRow("Thinking Budget:", self.gemini_budget_edit)
        self.gemini_group.setLayout(gemini_layout)
        left_layout.addWidget(self.gemini_group)
        left_layout.addStretch(1)

        # 오른쪽 컬럼 위젯 및 레이아웃 생성
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # 오른쪽 컬럼에 그룹 추가 (필터링, gitignore)
        self.filtering_group = QGroupBox("파일 필터링")
        filtering_layout = QFormLayout()
        self.allowed_extensions_edit = QLineEdit(); self.allowed_extensions_edit.setPlaceholderText("쉼표(,) 또는 공백으로 구분 (예: .py, .js .html)")
        self.excluded_dirs_edit = QPlainTextEdit(); self.excluded_dirs_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: node_modules/, *.log)"); self.excluded_dirs_edit.setMinimumHeight(80); self.excluded_dirs_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.default_ignore_list_edit = QPlainTextEdit(); self.default_ignore_list_edit.setPlaceholderText("한 줄에 하나씩 입력 (예: .git/, __pycache__/)"); self.default_ignore_list_edit.setMinimumHeight(80); self.default_ignore_list_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        filtering_layout.addRow("허용 확장자:", self.allowed_extensions_edit)
        filtering_layout.addRow("제외 폴더/파일:", self.excluded_dirs_edit)
        filtering_layout.addRow("기본 무시 목록:", self.default_ignore_list_edit)
        self.filtering_group.setLayout(filtering_layout)
        right_layout.addWidget(self.filtering_group)

        self.gitignore_group = QGroupBox(".gitignore 편집 (현재 프로젝트)")
        gitignore_layout = QVBoxLayout()
        gitignore_button_layout = QHBoxLayout()
        self.load_gitignore_button = QPushButton("불러오기")
        self.save_gitignore_button = QPushButton("저장하기")
        gitignore_button_layout.addWidget(self.load_gitignore_button); gitignore_button_layout.addWidget(self.save_gitignore_button); gitignore_button_layout.addStretch()
        self.gitignore_edit = QPlainTextEdit(); self.gitignore_edit.setPlaceholderText("프로젝트 폴더 선택 후 '.gitignore' 내용을 불러오거나 편집/저장하세요."); self.gitignore_edit.setMinimumHeight(120); self.gitignore_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        gitignore_layout.addLayout(gitignore_button_layout); gitignore_layout.addWidget(self.gitignore_edit)
        self.gitignore_group.setLayout(gitignore_layout)
        self.gitignore_group.setEnabled(bool(self.mw.current_project_folder))
        right_layout.addWidget(self.gitignore_group)
        right_layout.addStretch(1)

        # 스플리터에 위젯 추가 및 초기 크기 설정
        main_horizontal_splitter.addWidget(left_widget)
        main_horizontal_splitter.addWidget(right_widget)
        main_horizontal_splitter.setSizes([self.width() // 2, self.width() // 2]) # 대략 1:1 비율

        layout.addWidget(main_horizontal_splitter)

        # --- 시그널 연결 ---
        self.browse_prompt_button.clicked.connect(self.browse_default_prompt)
        self.load_gitignore_button.clicked.connect(self.load_gitignore)
        self.save_gitignore_button.clicked.connect(self.save_gitignore)
        self.add_api_key_btn.clicked.connect(self.add_api_key)
        self.remove_api_key_btn.clicked.connect(self.remove_api_key)
        self.refresh_api_usage_btn.clicked.connect(self.load_api_keys_list)
        self.api_keys_list.itemDoubleClicked.connect(self.show_api_key_value)
        self.set_selected_key_btn.clicked.connect(self.set_selected_api_key)
        self.add_gemini_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gemini_models_list, "google"))
        self.remove_gemini_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gemini_models_list))
        self.add_claude_model_btn.clicked.connect(lambda: self.add_model_to_list(self.claude_models_list, "anthropic"))
        self.remove_claude_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.claude_models_list))
        self.add_gpt_model_btn.clicked.connect(lambda: self.add_model_to_list(self.gpt_models_list, "openai"))
        self.remove_gpt_model_btn.clicked.connect(lambda: self.remove_model_from_list(self.gpt_models_list))
        self.gemini_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gemini_models_list, 'gemini'))
        self.claude_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.claude_models_list, 'claude'))
        self.gpt_models_list.itemClicked.connect(lambda item: self.handle_model_click(item, self.gpt_models_list, 'gpt'))

        return widget

    def create_ssh_settings_widget(self) -> QWidget:
        """SSH 설정 탭의 위젯들을 생성하고 배치합니다."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)

        # SSH 연결 목록 테이블
        self.ssh_table = QTableWidget()
        self.ssh_table.setColumnCount(5) # ID, Alias, Host, Port, Username
        self.ssh_table.setHorizontalHeaderLabels(["Alias", "Host", "Port", "Username", "Auth Type"])
        self.ssh_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows) # QAbstractItemView.SelectRows -> QAbstractItemView.SelectionBehavior.SelectRows
        self.ssh_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection) # QAbstractItemView.SingleSelection -> QAbstractItemView.SelectionMode.SingleSelection
        self.ssh_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers) # QAbstractItemView.NoEditTriggers -> QAbstractItemView.EditTrigger.NoEditTriggers
        self.ssh_table.verticalHeader().setVisible(False)
        self.ssh_table.horizontalHeader().setStretchLastSection(True)
        self.ssh_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents) # QHeaderView.ResizeToContents -> QHeaderView.ResizeMode.ResizeToContents
        self.ssh_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch) # Host 열 확장
        self.ssh_table.setAlternatingRowColors(True)
        self.ssh_table.setSizeAdjustPolicy(QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents) # QAbstractScrollArea.AdjustToContents -> QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents
        layout.addWidget(self.ssh_table, 1) # 테이블이 남는 공간 차지

        # SSH 관리 버튼
        ssh_button_layout = QHBoxLayout()
        self.add_ssh_btn = QPushButton("➕ 추가")
        self.edit_ssh_btn = QPushButton("✏️ 수정")
        self.delete_ssh_btn = QPushButton("❌ 삭제")
        self.test_ssh_btn = QPushButton("⚡ 연결 테스트")
        ssh_button_layout.addWidget(self.add_ssh_btn)
        ssh_button_layout.addWidget(self.edit_ssh_btn)
        ssh_button_layout.addWidget(self.delete_ssh_btn)
        ssh_button_layout.addStretch()
        ssh_button_layout.addWidget(self.test_ssh_btn)
        layout.addLayout(ssh_button_layout)

        # --- 시그널 연결 ---
        self.add_ssh_btn.clicked.connect(self.add_ssh_connection)
        self.edit_ssh_btn.clicked.connect(self.edit_ssh_connection)
        self.delete_ssh_btn.clicked.connect(self.delete_ssh_connection)
        self.test_ssh_btn.clicked.connect(self.test_ssh_connection)
        self.ssh_table.itemDoubleClicked.connect(self.edit_ssh_connection) # 더블클릭으로 수정

        return widget

    def load_ssh_connections_list(self):
        """DB에서 SSH 연결 목록을 로드하여 테이블에 표시합니다."""
        try:
            self.ssh_connections = self.ssh_config_service.list_connections()
            self.ssh_table.setRowCount(0) # 테이블 초기화
            self.ssh_table.setRowCount(len(self.ssh_connections))

            # 테이블 글꼴 설정 (선택적)
            default_font = QFontDatabase.systemFont(QFontDatabase.SystemFont.GeneralFont) # QFontDatabase.GeneralFont -> QFontDatabase.SystemFont.GeneralFont
            if default_font:
                default_font.setPointSize(10)
                self.ssh_table.setFont(default_font)

            for row, conn in enumerate(self.ssh_connections):
                # ID는 테이블 데이터로 저장
                id_item = QTableWidgetItem()
                id_item.setData(Qt.ItemDataRole.UserRole, conn.id) # Qt.UserRole -> Qt.ItemDataRole.UserRole

                # 테이블에 표시할 항목들
                alias_item = QTableWidgetItem(conn.alias)
                host_item = QTableWidgetItem(conn.host)
                port_item = QTableWidgetItem(str(conn.port))
                username_item = QTableWidgetItem(conn.username)
                auth_type_item = QTableWidgetItem(conn.auth_type)

                # 테이블에 아이템 설정
                self.ssh_table.setItem(row, 0, alias_item)
                self.ssh_table.setItem(row, 1, host_item)
                self.ssh_table.setItem(row, 2, port_item)
                self.ssh_table.setItem(row, 3, username_item)
                self.ssh_table.setItem(row, 4, auth_type_item)

                # ID 아이템도 첫 번째 컬럼에 연결 (선택 시 ID 접근용)
                alias_item.setData(Qt.ItemDataRole.UserRole, conn.id) # Qt.UserRole -> Qt.ItemDataRole.UserRole

            self.ssh_table.resizeColumnsToContents()
            self.ssh_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch) # Host 열 재조정
            logger.info(f"Loaded {len(self.ssh_connections)} SSH connections into table.")

        except Exception as e:
            QMessageBox.critical(self, "SSH 목록 로드 오류", f"SSH 연결 목록을 불러오는 중 오류 발생:\n{e}")
            logger.exception("Error loading SSH connections list")

    def get_selected_ssh_connection_id(self) -> Optional[int]:
        """테이블에서 선택된 행의 SSH 연결 ID를 반환합니다."""
        selected_rows = self.ssh_table.selectionModel().selectedRows()
        if not selected_rows:
            return None
        # 첫 번째 컬럼의 UserRole 데이터에서 ID 가져오기
        selected_row_index = selected_rows[0]
        id_item = self.ssh_table.item(selected_row_index.row(), 0) # Alias 컬럼
        if id_item:
            return id_item.data(Qt.ItemDataRole.UserRole) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        return None

    def add_ssh_connection(self):
        """SSH 연결 추가 다이얼로그를 열고 결과를 처리합니다."""
        dialog = SshConfigDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            config_data = dialog.get_data()
            if config_data:
                result = self.ssh_config_service.add_connection(config_data)
                if result:
                    QMessageBox.information(self, "성공", f"SSH 연결 '{result.alias}'이(가) 추가되었습니다.")
                    self.load_ssh_connections_list() # 목록 새로고침
                else:
                    QMessageBox.warning(self, "실패", "SSH 연결 추가 중 오류가 발생했습니다.\n(별칭 중복 또는 DB 오류)")
            else:
                 logger.warning("Add SSH connection dialog accepted but returned no data.")

    def edit_ssh_connection(self):
        """선택된 SSH 연결 정보를 수정하는 다이얼로그를 엽니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "수정할 SSH 연결을 목록에서 선택하세요.")
            return

        # 선택된 ID에 해당하는 설정 정보 가져오기 (암호화된 상태)
        config_to_edit = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        if not config_to_edit:
             QMessageBox.critical(self, "오류", "선택한 SSH 연결 정보를 찾을 수 없습니다.")
             return

        dialog = SshConfigDialog(self, config=config_to_edit)
        if dialog.exec() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            updated_data = dialog.get_data()
            if updated_data:
                result = self.ssh_config_service.update_connection(selected_id, updated_data)
                if result:
                    QMessageBox.information(self, "성공", f"SSH 연결 '{result.alias}'이(가) 수정되었습니다.")
                    self.load_ssh_connections_list() # 목록 새로고침
                else:
                    QMessageBox.warning(self, "실패", "SSH 연결 수정 중 오류가 발생했습니다.\n(별칭 중복 또는 DB 오류)")
            else:
                 logger.warning("Edit SSH connection dialog accepted but returned no data.")

    def delete_ssh_connection(self):
        """선택된 SSH 연결 정보를 삭제합니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "삭제할 SSH 연결을 목록에서 선택하세요.")
            return

        config_to_delete = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        alias_to_delete = config_to_delete.alias if config_to_delete else f"ID {selected_id}"

        reply = QMessageBox.question(self, "삭제 확인", f"정말로 SSH 연결 '{alias_to_delete}'을(를) 삭제하시겠습니까?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: return

        success = self.ssh_config_service.delete_connection(selected_id)
        if success:
            QMessageBox.information(self, "성공", f"SSH 연결 '{alias_to_delete}'이(가) 삭제되었습니다.")
            self.load_ssh_connections_list() # 목록 새로고침
        else:
            QMessageBox.warning(self, "실패", "SSH 연결 삭제 중 오류가 발생했습니다.")

    def test_ssh_connection(self):
        """선택된 SSH 연결을 백그라운드에서 테스트합니다."""
        selected_id = self.get_selected_ssh_connection_id()
        if selected_id is None:
            QMessageBox.warning(self, "선택 오류", "테스트할 SSH 연결을 목록에서 선택하세요.")
            return

        config_to_test = next((conn for conn in self.ssh_connections if conn.id == selected_id), None)
        if not config_to_test:
            QMessageBox.critical(self, "오류", "선택한 SSH 연결 정보를 찾을 수 없습니다.")
            return

        alias_to_test = config_to_test.alias

        # 버튼 비활성화 및 메시지 표시
        self.test_ssh_btn.setEnabled(False)
        self.test_ssh_btn.setText("테스트 중...")
        QApplication.processEvents() # UI 업데이트

        # --- 백그라운드 실행 (QThreadPool 사용) ---
        # PyQt6: QThreadPool을 사용하여 백그라운드 작업 실행
        worker = SshTestWorker(self.ssh_config_service, alias_to_test)
        worker.finished.connect(self.handle_ssh_test_result) # 결과 처리 슬롯 연결
        # QThreadPool.globalInstance().start(worker) # QThreadPool에서 직접 실행
        # QObject + moveToThread 방식
        thread = QThread()
        worker.moveToThread(thread)
        thread.started.connect(worker.run)
        worker.finished.connect(thread.quit) # 작업 완료 시 스레드 종료
        worker.finished.connect(worker.deleteLater) # 작업 완료 시 워커 삭제
        thread.finished.connect(thread.deleteLater) # 스레드 종료 시 스레드 삭제
        thread.start()
        self._current_ssh_test_thread = thread # 스레드 참조 저장 (선택적)

    def handle_ssh_test_result(self, success: bool, message: str):
        """SSH 연결 테스트 결과를 처리하고 UI를 업데이트합니다."""
        self.test_ssh_btn.setEnabled(True)
        self.test_ssh_btn.setText("⚡ 연결 테스트")
        if success:
            QMessageBox.information(self, "연결 테스트 결과", message)
        else:
            QMessageBox.warning(self, "연결 테스트 결과", message)
        self._current_ssh_test_thread = None # 스레드 참조 제거

    def load_config_settings(self):
        """UI 위젯에 현재 DB 설정값을 로드하고 기본 모델을 하이라이트합니다."""
        try:
            # ConfigService를 통해 최신 설정 로드
            self.settings = self.config_service.get_settings()
            if not self.settings:
                 QMessageBox.critical(self, "오류", "DB에서 설정을 로드하지 못했습니다.")
                 return

            logger.info("Loading config settings into SettingsDialog UI...")

            # UI 위젯 업데이트 (시그널 차단 불필요, 로드 시점에는 사용자 입력 없음)
            self.default_prompt_path_edit.setText(self.settings.default_system_prompt or "")

            # 사용 가능 모델 목록 로드 및 기본 모델 하이라이트
            self._populate_and_highlight_model_list(self.gemini_models_list, self.settings.gemini_available_models, self.settings.gemini_default_model)
            self._populate_and_highlight_model_list(self.claude_models_list, self.settings.claude_available_models, self.settings.claude_default_model)
            self._populate_and_highlight_model_list(self.gpt_models_list, self.settings.gpt_available_models, self.settings.gpt_default_model)

            self.allowed_extensions_edit.setText(", ".join(sorted(list(self.settings.allowed_extensions or set()))))
            self.excluded_dirs_edit.setPlainText("\n".join(sorted(self.settings.excluded_dirs or [])))
            self.default_ignore_list_edit.setPlainText("\n".join(sorted(self.settings.default_ignore_list or [])))

            self.gemini_temp_edit.setText(str(self.settings.gemini_temperature))
            self.gemini_thinking_checkbox.setChecked(self.settings.gemini_enable_thinking)
            self.gemini_budget_edit.setText(str(self.settings.gemini_thinking_budget))
            self.gemini_search_checkbox.setChecked(self.settings.gemini_enable_search)

            logger.info("SettingsDialog UI updated with loaded config.")

        except Exception as e:
            QMessageBox.critical(self, "로드 오류", f"설정을 로드하는 중 오류 발생:\n{e}")
            logger.exception("Error loading config settings into SettingsDialog UI")

    def _populate_and_highlight_model_list(self, list_widget: QListWidget, models: List[str], default_model: str):
        """Helper function to populate a model list and highlight the default."""
        list_widget.clear()
        list_widget.addItems(models or [])
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.text() == default_model:
                item.setBackground(self.PASTEL_GREEN) # 기본 모델 하이라이트
            else:
                # 명시적으로 기본 배경색 설정 (이전 하이라이트 제거)
                # 기본 배경색을 투명하게 설정하여 시스템 테마 따르도록 수정
                item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent

    def handle_model_click(self, clicked_item: QListWidgetItem, list_widget: QListWidget, model_type: str):
        """Handles clicks on model list items to set the default model."""
        if not self.settings: return
        new_default_model = clicked_item.text()
        old_default_model = ""

        # Update the settings object and get the old default model
        if model_type == 'gemini':
            old_default_model = self.settings.gemini_default_model
            self.settings.gemini_default_model = new_default_model
        elif model_type == 'claude':
            old_default_model = self.settings.claude_default_model
            self.settings.claude_default_model = new_default_model
        elif model_type == 'gpt':
            old_default_model = self.settings.gpt_default_model
            self.settings.gpt_default_model = new_default_model
        else:
            return

        logger.info(f"Set default {model_type} model to: {new_default_model}")

        # Update highlighting in the list widget
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            # 이전 기본 모델 하이라이트 제거
            if item.text() == old_default_model:
                 item.setBackground(QBrush(Qt.GlobalColor.transparent)) # Qt.white -> Qt.transparent
            # 새 기본 모델 하이라이트 적용
            if item.text() == new_default_model:
                item.setBackground(self.PASTEL_GREEN)

    def load_api_keys_list(self):
        """DB에서 API 키 목록을 로드하여 리스트 위젯에 표시하고 상태(사용자 선택, 마지막 사용, 자동 선택 예정 등)를 강조합니다."""
        self.api_keys_list.clear()
        try:
            all_keys = self.db_service.list_api_keys() # 모든 키 정보 가져오기 (사용량 포함)
            if not all_keys:
                self.api_keys_list.addItem("등록된 API 키가 없습니다.")
                self.api_keys_list.setEnabled(False)
                return

            self.api_keys_list.setEnabled(True)

            user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
            last_used_key_id = self.config_service.get_last_used_gemini_key_id()
            logger.info(f"Current User Selected Key ID: {user_selected_key_id}, Last Used Key ID: {last_used_key_id}")

            default_gemini_model = self.config_service.get_default_model_name('Gemini')
            # Rate limit info is fetched inside the loop now if needed

            # --- 자동 선택 예정 키 식별 (개선) ---
            auto_select_candidate_id: Optional[int] = None
            if user_selected_key_id is None:
                logger.info("Identifying auto-select candidate key...")
                candidate_keys = []
                # 활성 Google 키 필터링
                active_google_keys_info = [k for k in all_keys if k.get('provider') == 'google' and k.get('is_active')]

                for key_info in active_google_keys_info:
                    key_id = key_info['id']
                    # Rate Limit 체크
                    is_limited, reason = self.db_service.is_key_rate_limited(key_id, default_gemini_model)
                    if not is_limited:
                        # Rate Limit 안 걸린 키만 후보로 추가
                        # 유효 일일 사용량 계산 (기존 로직 유지)
                        now = datetime.datetime.now(datetime.timezone.utc)
                        current_day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
                        raw_calls_day = key_info.get('calls_this_day', 0)
                        day_start = key_info.get('day_start_timestamp')
                        if day_start and day_start.tzinfo is None: # 타임존 정보 없으면 UTC로 간주
                             day_start = day_start.replace(tzinfo=datetime.timezone.utc)
                        effective_daily_calls = raw_calls_day if day_start and day_start >= current_day_start else 0
                        candidate_keys.append({'id': key_id, 'effective_calls': effective_daily_calls})
                        logger.debug(f"  Candidate Key ID: {key_id} (Not Rate Limited, Effective Daily Calls: {effective_daily_calls})")
                    else:
                        logger.debug(f"  Skipping Key ID: {key_id} (Rate Limited: {reason})")

                # 유효 일일 사용량 기준 정렬
                candidate_keys.sort(key=lambda x: x['effective_calls'])

                # 가장 사용량 적은 키가 자동 선택 후보
                if candidate_keys:
                    auto_select_candidate_id = candidate_keys[0]['id']
                    logger.info(f"Auto-select candidate key ID identified: {auto_select_candidate_id} (Effective Daily Calls: {candidate_keys[0]['effective_calls']})")
                else:
                    logger.warning("No suitable auto-select candidate key found (all active keys might be rate-limited).")
            # -----------------------------

            # --- 키 목록 UI 업데이트 ---
            rate_limit_info = self.db_service.get_model_rate_limit(default_gemini_model) # Get rate limit info once
            rpm_limit = rate_limit_info.get('rpm_limit') if rate_limit_info else None
            daily_limit = rate_limit_info.get('daily_limit') if rate_limit_info else None
            now = datetime.datetime.now(datetime.timezone.utc) # Get current time once

            for key_info in all_keys:
                key_id = key_info['id']
                provider = key_info.get('provider', 'N/A')
                description = key_info.get('description', '')
                api_key_value = key_info.get('api_key', '')
                api_key_display = api_key_value[:4] + "..." + api_key_value[-4:] if len(api_key_value) > 8 else api_key_value[:4] + "..."
                is_active = key_info.get('is_active', False)

                status_icon = ""
                item_color = QBrush(Qt.GlobalColor.transparent) # 기본 배경 투명
                display_text = f"[{provider.upper()}] {description or api_key_display}"
                extra_info = "" # 상태 표시용 추가 텍스트
                tooltip_status = "" # 툴팁용 상태 문자열

                # 상태 결정 (우선순위: 사용자 선택 > 자동 선택 예정 > 마지막 사용 > 활성 > 비활성)
                if provider == 'google' and key_id == user_selected_key_id:
                    status_icon = "🔵" # 사용자 선택
                    item_color = QBrush(self.PASTEL_BLUE) # 연한 파란색 배경
                    extra_info = " (사용자 선택)"
                    tooltip_status = "User Selected"
                elif provider == 'google' and key_id == auto_select_candidate_id:
                    status_icon = "✨" # 자동 선택 예정
                    item_color = QBrush(self.PASTEL_PURPLE) # 연보라색 배경
                    extra_info = " (자동 선택 예정)"
                    tooltip_status = "Auto-Select Candidate"
                elif provider == 'google' and key_id == last_used_key_id:
                    status_icon = "🟢" # 마지막 사용
                    item_color = QBrush(self.PASTEL_GREEN) # 연한 녹색 배경
                    extra_info = " (마지막 사용)"
                    tooltip_status = "Last Used"
                elif is_active:
                    status_icon = "🟡" # 활성
                    item_color = QBrush(QColor("lightyellow")) # 연한 노란색 배경
                    tooltip_status = "Active"
                else:
                    status_icon = "🔴" # 비활성
                    item_color = QBrush(QColor("lightcoral")) # 연한 산호색 배경
                    tooltip_status = "Inactive"

                display_text = f"{status_icon}{display_text}{extra_info}"

                # 잔여 사용량 계산 (Gemini 키)
                remaining_rpm_str, remaining_daily_str = "N/A", "N/A"
                tooltip_rpm, tooltip_daily = "N/A", "N/A"
                if provider == 'google' and rpm_limit is not None and daily_limit is not None:
                    calls_this_minute = key_info.get('calls_this_minute', 0)
                    minute_start = key_info.get('minute_start_timestamp')
                    calls_this_day = key_info.get('calls_this_day', 0)
                    day_start = key_info.get('day_start_timestamp')
                    if minute_start and minute_start.tzinfo is None: minute_start = minute_start.replace(tzinfo=datetime.timezone.utc)
                    if day_start and day_start.tzinfo is None: day_start = day_start.replace(tzinfo=datetime.timezone.utc)

                    current_minute_calls = calls_this_minute
                    # 분 시작 시간이 있고, 현재 시간이 분 시작 시간 + 1분보다 크거나 같으면 0으로 리셋
                    if minute_start and now >= minute_start + datetime.timedelta(minutes=1):
                        current_minute_calls = 0
                    remaining_rpm = max(0, rpm_limit - current_minute_calls)
                    remaining_rpm_str = f"{remaining_rpm}/{rpm_limit}"
                    tooltip_rpm = f"{remaining_rpm} / {rpm_limit} (Used: {current_minute_calls})"

                    current_day_calls = calls_this_day
                    # 일 시작 시간이 있고, 현재 시간이 일 시작 시간 + 1일보다 크거나 같으면 0으로 리셋
                    if day_start and now >= day_start + datetime.timedelta(days=1):
                        current_day_calls = 0
                    remaining_daily = max(0, daily_limit - current_day_calls)
                    remaining_daily_str = f"{remaining_daily}/{daily_limit}"
                    tooltip_daily = f"{remaining_daily} / {daily_limit} (Used: {current_day_calls})"

                    display_text += f" (RPM: {remaining_rpm_str}, Daily: {remaining_daily_str})"
                elif provider == 'google':
                    logger.warning(f"Rate limit info not found for model '{default_gemini_model}'. Cannot calculate remaining usage for key ID {key_id}.")

                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, key_id) # 키 ID 저장
                item.setData(Qt.ItemDataRole.UserRole + 1, api_key_value) # 실제 키 값 저장
                item.setData(Qt.ItemDataRole.UserRole + 2, provider) # 프로바이더 저장
                item.setBackground(item_color) # 배경색 설정 (QBrush 사용)

                # 툴팁 업데이트
                tooltip_text = (
                    f"ID: {key_id}\nProvider: {provider}\nKey: {api_key_display}\nStatus: {tooltip_status}"
                )
                if provider == 'google':
                     tooltip_text += f"\nRemaining RPM (vs {default_gemini_model}): {tooltip_rpm}\nRemaining Daily (vs {default_gemini_model}): {tooltip_daily}"
                item.setToolTip(tooltip_text)

                self.api_keys_list.addItem(item)

        except Exception as e:
            QMessageBox.critical(self, "API 키 로드 오류", f"API 키 목록을 불러오는 중 오류 발생:\n{e}")
            logger.exception("Error loading API keys list")
            self.api_keys_list.addItem("API 키 로드 오류")
            self.api_keys_list.setEnabled(False)


    def add_api_key(self):
        """새 API 키를 추가하는 다이얼로그를 띄우고 DB에 저장합니다."""
        provider, ok1 = QInputDialog.getItem(self, "API 키 추가", "Provider 선택:", ["google", "anthropic", "openai"], 0, False)
        if not ok1: return
        # QLineEdit.Password 대신 QLineEdit.Normal 사용
        api_key, ok2 = QInputDialog.getText(self, "API 키 추가", f"{provider} API 키 입력:", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok2 or not api_key.strip(): return
        description, ok3 = QInputDialog.getText(self, "API 키 추가", "설명 (선택 사항):", QLineEdit.EchoMode.Normal) # QLineEdit.Normal -> QLineEdit.EchoMode.Normal
        if not ok3: description = ""

        try:
            key_id = self.db_service.add_api_key(provider, api_key.strip(), description.strip())
            if key_id is not None:
                QMessageBox.information(self, "성공", "API 키가 성공적으로 추가되었습니다.")
                self.load_api_keys_list() # 목록 새로고침
            else:
                QMessageBox.warning(self, "실패", "API 키 추가 중 오류가 발생했습니다.")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"API 키 추가 중 예외 발생:\n{e}")

    def remove_api_key(self):
        """선택된 API 키를 DB에서 제거합니다."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "제거할 API 키를 목록에서 선택하세요.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        display_text = item.text()

        # 사용자 선택 키는 제거 불가
        user_selected_key_id = self.config_service.get_user_selected_gemini_key_id()
        if key_id == user_selected_key_id:
            QMessageBox.warning(self, "제거 불가", "현재 사용하도록 선택된 API 키는 제거할 수 없습니다.\n다른 키를 선택하거나 선택을 해제한 후 시도하세요.")
            return

        reply = QMessageBox.question(self, "삭제 확인", f"정말로 API 키를 삭제하시겠습니까?\n({display_text})",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No) # QMessageBox.Yes/No -> QMessageBox.StandardButton.Yes/No
        if reply != QMessageBox.StandardButton.Yes: return # QMessageBox.Yes -> QMessageBox.StandardButton.Yes

        try:
            success = self.db_service.delete_api_key(key_id)
            if success:
                QMessageBox.information(self, "성공", "API 키가 성공적으로 제거되었습니다.")
                self.load_api_keys_list() # 목록 새로고침
            else:
                QMessageBox.warning(self, "실패", "API 키 제거 중 오류가 발생했습니다.")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"API 키 제거 중 예외 발생:\n{e}")

    def show_api_key_value(self, item: QListWidgetItem):
        """더블클릭된 API 키의 실제 값을 메시지 박스로 보여줍니다."""
        api_key_value = item.data(Qt.ItemDataRole.UserRole + 1) # Qt.UserRole -> Qt.ItemDataRole.UserRole
        if api_key_value:
            QMessageBox.information(self, "API 키 값 확인",
                                    f"선택한 API 키 값:\n\n{api_key_value}\n\n"
                                    "주의: 이 키는 민감한 정보이므로 안전하게 관리하세요.",
                                    QMessageBox.StandardButton.Ok) # QMessageBox.Ok -> QMessageBox.StandardButton.Ok
        else:
            QMessageBox.warning(self, "오류", "API 키 값을 가져올 수 없습니다.")

    def set_selected_api_key(self):
        """선택된 API 키를 사용자가 사용할 키로 설정합니다 (Gemini 키만 해당)."""
        selected_items = self.api_keys_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "사용할 API 키를 목록에서 선택하세요.")
            return

        item = selected_items[0]
        key_id = item.data(Qt.ItemDataRole.UserRole)
        provider = item.data(Qt.ItemDataRole.UserRole + 2)

        if provider != 'google':
            QMessageBox.information(self, "정보", "Google (Gemini) API 키만 사용하도록 선택할 수 있습니다.")
            return

        # 비활성 키는 선택 불가
        if "🔴" in item.text():
             QMessageBox.warning(self, "선택 불가", "비활성화된 API 키는 사용할 수 없습니다.")
             return

        current_selected_id = self.config_service.get_user_selected_gemini_key_id()

        if key_id == current_selected_id:
            # 이미 선택된 키를 다시 선택하면 선택 해제
            self.config_service.set_user_selected_gemini_key(None)
            QMessageBox.information(self, "선택 해제", "API 키 선택이 해제되었습니다.\n이제 사용량이 가장 적은 키부터 자동으로 사용됩니다.")
        else:
            # 새 키 선택
            self.config_service.set_user_selected_gemini_key(key_id)
            QMessageBox.information(self, "키 선택 완료", f"API 키 ID {key_id}가 사용되도록 선택되었습니다.")

        # UI 업데이트를 위해 목록 다시 로드
        self.load_api_keys_list()


    def browse_default_prompt(self):
        """Opens a file dialog to select the default system prompt and updates the line edit."""
        selected_path = select_default_system_prompt(self.config_service, self)
        if selected_path is not None:
            self.default_prompt_path_edit.setText(selected_path)

    def add_model_to_list(self, list_widget: QListWidget, provider: str):
        """리스트 위젯에 새 모델 이름과 Rate Limit을 추가하고 DB에 저장합니다."""
        existing_models = [list_widget.item(i).text() for i in range(list_widget.count())]
        dialog = AddModelDialog(provider.capitalize(), existing_models, self)
        if dialog.exec() == QDialog.DialogCode.Accepted: # QDialog.Accepted -> QDialog.DialogCode.Accepted
            model_data = dialog.get_model_data()
            if model_data:
                model_name, rpm_limit, daily_limit = model_data
                try:
                    # DB에 Rate Limit 정보 저장
                    self.db_service.insert_or_update_rate_limit(
                        model_name=model_name,
                        provider=provider,
                        rpm_limit=rpm_limit,
                        daily_limit=daily_limit
                    )
                    # UI 리스트 위젯에 모델 이름 추가
                    list_widget.addItem(model_name)
                    QMessageBox.information(self, "성공", f"모델 '{model_name}' 및 Rate Limit 정보가 추가되었습니다.")
                except Exception as e:
                    QMessageBox.critical(self, "DB 오류", f"모델 Rate Limit 정보 저장 중 오류 발생:\n{e}")
                    logger.exception(f"Error saving rate limit for model {model_name}")

    def remove_model_from_list(self, list_widget: QListWidget):
        """리스트 위젯에서 선택된 모델 이름을 제거하고 DB에서도 Rate Limit 정보를 제거합니다."""
        selected_items = list_widget.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "선택 오류", "제거할 모델을 목록에서 선택하세요.")
            return

        model_to_remove = selected_items[0].text()
        is_default = False
        if list_widget == self.gemini_models_list and self.settings and model_to_remove == self.settings.gemini_default_model: is_default = True
        elif list_widget == self.claude_models_list and self.settings and model_to_remove == self.settings.claude_default_model: is_default = True
        elif list_widget == self.gpt_models_list and self.settings and model_to_remove == self.settings.gpt_default_model: is_default = True


        if is_default:
            QMessageBox.warning(self, "제거 불가", f"'{model_to_remove}' 모델은 현재 기본 모델로 지정되어 있어 제거할 수 없습니다.\n다른 모델을 기본으로 지정한 후 다시 시도하세요.")
            return

        # 기본 모델이 아니면 제거 진행
        reply = QMessageBox.question(self, "모델 제거 확인",
                                     f"정말로 '{model_to_remove}' 모델을 목록과 DB에서 제거하시겠습니까?\n(Rate Limit 정보도 함께 제거됩니다)",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            # DB에서 Rate Limit 정보 제거 시도
            success_db = self.db_service.delete_rate_limit(model_name=model_to_remove)
            if success_db:
                logger.info(f"Successfully removed rate limit info for model '{model_to_remove}' from DB.")
                # DB 제거 성공 시 UI 목록에서도 제거
                for item in selected_items:
                    list_widget.takeItem(list_widget.row(item))
                QMessageBox.information(self, "성공", f"모델 '{model_to_remove}'이(가) 목록과 DB에서 제거되었습니다.")
            else:
                # DB 제거 실패 또는 해당 모델 정보 없음
                logger.warning(f"Failed to remove rate limit info for model '{model_to_remove}' from DB (or not found).")
                # UI 목록에서만 제거할지 여부 결정 (여기서는 DB 실패 시 UI도 유지)
                QMessageBox.warning(self, "DB 오류", f"DB에서 '{model_to_remove}' 모델의 Rate Limit 정보를 제거하는 데 실패했습니다.")

        except Exception as e:
            QMessageBox.critical(self, "오류", f"모델 제거 중 예외 발생:\n{e}")
            logger.exception(f"Error removing model {model_to_remove}")

    def save_settings(self):
        """변경된 모든 설정을 저장합니다."""
        # 현재는 일반 설정만 저장
        self.save_config_settings()

    def save_config_settings(self):
        """UI에서 설정값을 읽어 ConfigSettings 모델을 업데이트하고 DB에 저장합니다."""
        if not self.settings:
            QMessageBox.critical(self, "오류", "설정 객체가 로드되지 않아 저장할 수 없습니다.")
            return

        try:
            # --- UI에서 값 읽기 (기본 모델은 self.settings에서 직접 읽음) ---
            default_prompt = self.default_prompt_path_edit.text().strip()
            gemini_model = self.settings.gemini_default_model # 클릭 핸들러가 업데이트한 값 사용
            claude_model = self.settings.claude_default_model # 클릭 핸들러가 업데이트한 값 사용
            gpt_model = self.settings.gpt_default_model     # 클릭 핸들러가 업데이트한 값 사용

            gemini_available = [self.gemini_models_list.item(i).text() for i in range(self.gemini_models_list.count())]
            claude_available = [self.claude_models_list.item(i).text() for i in range(self.claude_models_list.count())]
            gpt_available = [self.gpt_models_list.item(i).text() for i in range(self.gpt_models_list.count())]

            # 기본 모델이 사용 가능 목록에 있는지 확인
            if gemini_model not in gemini_available and gemini_available:
                 QMessageBox.warning(self, "설정 오류", f"Gemini 기본 모델 '{gemini_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return
            if claude_model not in claude_available and claude_available:
                 QMessageBox.warning(self, "설정 오류", f"Claude 기본 모델 '{claude_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return
            if gpt_model not in gpt_available and gpt_available:
                 QMessageBox.warning(self, "설정 오류", f"GPT 기본 모델 '{gpt_model}'이(가) 사용 가능 목록에 없습니다. 목록에 추가하거나 다른 모델을 기본으로 선택하세요.")
                 return

            allowed_ext_str = self.allowed_extensions_edit.text().strip()
            allowed_extensions = {ext.strip() for ext in allowed_ext_str.replace(',', ' ').split() if ext.strip()}

            excluded_dirs = [line.strip() for line in self.excluded_dirs_edit.toPlainText().splitlines() if line.strip()]
            default_ignore = [line.strip() for line in self.default_ignore_list_edit.toPlainText().splitlines() if line.strip()]

            temp_str = self.gemini_temp_edit.text().strip()
            gemini_temp = float(temp_str) if temp_str else 0.0
            gemini_thinking = self.gemini_thinking_checkbox.isChecked()
            budget_str = self.gemini_budget_edit.text().strip()
            gemini_budget = int(budget_str) if budget_str else 0
            gemini_search = self.gemini_search_checkbox.isChecked()

            # --- 업데이트할 데이터 준비 ---
            # self.settings 객체는 이미 클릭 핸들러에 의해 기본 모델이 업데이트되었으므로,
            # 나머지 필드만 업데이트합니다.
            update_data = self.settings.model_copy(deep=True)
            update_data.default_system_prompt = default_prompt if default_prompt else None
            # 기본 모델은 이미 self.settings에 반영됨
            update_data.allowed_extensions = allowed_extensions
            update_data.excluded_dirs = set(excluded_dirs)
            update_data.default_ignore_list = default_ignore
            update_data.gemini_available_models = gemini_available
            update_data.claude_available_models = claude_available
            update_data.gpt_available_models = gpt_available
            update_data.gemini_temperature = gemini_temp
            update_data.gemini_enable_thinking = gemini_thinking
            update_data.gemini_thinking_budget = gemini_budget
            update_data.gemini_enable_search = gemini_search

            # --- Pydantic 유효성 검사 ---
            validated_settings = ConfigSettings(**update_data.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})) # API 키는 검증/저장 제외

            # --- 로깅 추가: 저장될 최종 설정 데이터 확인 ---
            logger.info("Validated settings data before saving to DB:")
            logger.info(f"{validated_settings.model_dump(exclude={'gemini_api_key', 'anthropic_api_key'})}")
            # ---------------------------------------------

            # --- DB 저장 ---
            if self.config_service.update_settings(validated_settings):
                # QMessageBox.information(self, "성공", "애플리케이션 설정이 성공적으로 저장되었습니다.") # 확인 메시지 제거
                logger.info("Application settings saved successfully.")
                # MainWindow의 관련 UI 업데이트 트리거
                self.mw.main_controller.on_llm_selected() # LLM/모델 콤보박스 업데이트
                self.mw.load_gemini_settings_to_ui() # 메인 윈도우의 Gemini 파라미터 UI 업데이트
                self.mw.file_tree_controller.load_gitignore_settings() # 필터링 규칙 업데이트
                self.accept() # 다이얼로그 닫기
            else:
                QMessageBox.critical(self, "저장 실패", "설정을 데이터베이스에 저장하는 중 오류가 발생했습니다.")

        except ValidationError as e:
            QMessageBox.warning(self, "입력 오류", f"설정 값 유효성 검사 실패:\n{e}")
        except ValueError as e:
             QMessageBox.warning(self, "입력 오류", f"숫자 필드(온도, 예산)에 유효한 숫자를 입력하세요.\n{e}")
        except Exception as e:
            QMessageBox.critical(self, "오류", f"설정 저장 중 예기치 않은 오류 발생:\n{e}")


    def load_gitignore(self):
        """현재 프로젝트 폴더의 .gitignore 파일을 로드하여 편집기에 표시합니다."""
        if not self.mw.current_project_folder:
            self.gitignore_edit.setPlainText("")
            self.gitignore_edit.setEnabled(False)
            return

        self.gitignore_edit.setEnabled(True)
        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = ""
        try:
            if os.path.isfile(gitignore_path):
                with open(gitignore_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.gitignore_edit.setPlainText(content)
            else:
                self.gitignore_edit.setPlainText("# .gitignore 파일 없음")
        except Exception as e:
            QMessageBox.critical(self, "오류", f".gitignore 파일을 불러오는 중 오류 발생:\n{e}")
            self.gitignore_edit.setPlainText(f"# 오류: {e}")

    def save_gitignore(self):
        """편집기 내용을 현재 프로젝트 폴더의 .gitignore 파일에 저장합니다."""
        if not self.mw.current_project_folder:
            QMessageBox.warning(self, "오류", "프로젝트 폴더가 선택되지 않았습니다.")
            return

        gitignore_path = os.path.join(self.mw.current_project_folder, ".gitignore")
        content = self.gitignore_edit.toPlainText()

        try:
            with open(gitignore_path, 'w', encoding='utf-8') as f:
                f.write(content)
            QMessageBox.information(self, "성공", f".gitignore 파일이 저장되었습니다:\n{gitignore_path}")
            if hasattr(self.mw, 'file_tree_controller'):
                self.mw.file_tree_controller.load_gitignore_settings()
        except Exception as e:
            QMessageBox.critical(self, "오류", f".gitignore 파일을 저장하는 중 오류 발생:\n{e}")

    def closeEvent(self, event):
        """다이얼로그 닫을 때 스레드 풀 종료 (필요 시)"""
        # QThreadPool.globalInstance()는 일반적으로 애플리케이션 종료 시 정리됨
        logger.info("Closing SettingsDialog.")
        super().closeEvent(event)

]]></file_code>
</file>
<file>
  <file_summary>SSH 연결 정보 추가/수정 다이얼로그 UI 위젯 추가</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>src/ui/widgets/ssh_config_dialog.py</file_path>
  <file_code><![CDATA[
import os
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QLabel, QComboBox, QFileDialog, QMessageBox, QWidget, QHBoxLayout
)
from PyQt6.QtCore import Qt
from typing import Optional, Dict, Any
from pydantic import SecretStr, ValidationError # SecretStr 추가

from core.pydantic_models.ssh_connection_config import SshConnectionConfig

class SshConfigDialog(QDialog):
    """
    Dialog for adding or editing SSH connection configurations.
    """
    def __init__(self, parent: QWidget = None, config: Optional[SshConnectionConfig] = None):
        super().__init__(parent)
        self.config = config
        self.is_edit_mode = config is not None

        self.setWindowTitle("SSH 연결 설정 편집" if self.is_edit_mode else "새 SSH 연결 설정 추가")
        self.setMinimumWidth(450)

        # --- UI Elements ---
        self.alias_edit = QLineEdit()
        self.host_edit = QLineEdit()
        self.port_edit = QLineEdit()
        self.port_edit.setPlaceholderText("22")
        # Port validation can be added if needed (e.g., QIntValidator)
        self.username_edit = QLineEdit()
        self.auth_type_combo = QComboBox()
        self.auth_type_combo.addItems(['password', 'key'])

        self.password_label = QLabel("비밀번호:")
        self.password_edit = QLineEdit()
        self.password_edit.setEchoMode(QLineEdit.EchoMode.Password)

        self.key_path_label = QLabel("개인 키 경로:")
        self.key_path_edit = QLineEdit()
        self.browse_key_button = QPushButton("찾아보기...")

        # --- Layouts ---
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.addRow("별칭 (Alias):*", self.alias_edit)
        form_layout.addRow("호스트 주소:*", self.host_edit)
        form_layout.addRow("포트:", self.port_edit)
        form_layout.addRow("사용자 이름:*", self.username_edit)
        form_layout.addRow("인증 방식:*", self.auth_type_combo)

        # Password Row
        password_widget = QWidget() # Dummy widget for layout
        password_layout = QHBoxLayout(password_widget)
        password_layout.setContentsMargins(0, 0, 0, 0)
        password_layout.addWidget(self.password_edit)
        form_layout.addRow(self.password_label, password_widget)

        # Key Path Row
        key_path_widget = QWidget() # Dummy widget for layout
        key_path_layout = QHBoxLayout(key_path_widget)
        key_path_layout.setContentsMargins(0, 0, 0, 0)
        key_path_layout.addWidget(self.key_path_edit)
        key_path_layout.addWidget(self.browse_key_button)
        form_layout.addRow(self.key_path_label, key_path_widget)

        main_layout.addLayout(form_layout)

        # Button Box
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        main_layout.addWidget(self.button_box)

        # --- Signals ---
        self.auth_type_combo.currentIndexChanged.connect(self.update_auth_fields_visibility)
        self.browse_key_button.clicked.connect(self.browse_for_key_file)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        # --- Initial State ---
        if self.is_edit_mode and self.config:
            self.load_config_data()
        else:
            # Set default port if not editing
             self.port_edit.setText("22")

        self.update_auth_fields_visibility() # Initial visibility setup

    def load_config_data(self):
        """Loads existing config data into the dialog fields."""
        if not self.config: return
        self.alias_edit.setText(self.config.alias)
        self.host_edit.setText(self.config.host)
        self.port_edit.setText(str(self.config.port))
        self.username_edit.setText(self.config.username)
        self.auth_type_combo.setCurrentText(self.config.auth_type)
        # Password is not loaded for editing (security)
        self.password_edit.setPlaceholderText("변경하려면 새 비밀번호 입력")
        self.key_path_edit.setText(self.config.key_path or "")

    def update_auth_fields_visibility(self):
        """Shows/hides password or key path fields based on selected auth type."""
        auth_type = self.auth_type_combo.currentText()
        is_password_auth = (auth_type == 'password')
        self.password_label.setVisible(is_password_auth)
        self.password_edit.setVisible(is_password_auth)
        self.key_path_label.setVisible(not is_password_auth)
        self.key_path_edit.setVisible(not is_password_auth)
        self.browse_key_button.setVisible(not is_password_auth)
        # Adjust layout spacing if needed, though QFormLayout handles it mostly
        self.adjustSize() # Adjust dialog size based on visible widgets

    def browse_for_key_file(self):
        """Opens a file dialog to select a private key file."""
        start_dir = os.path.expanduser("~/.ssh") if os.path.exists(os.path.expanduser("~/.ssh")) else os.path.expanduser("~")
        key_path, _ = QFileDialog.getOpenFileName(self, "개인 키 파일 선택", start_dir, "모든 파일 (*)")
        if key_path:
            self.key_path_edit.setText(key_path)

    def validate_and_accept(self):
        """Validates the input fields before accepting the dialog."""
        data = self.get_data()
        if data:
            try:
                # Use Pydantic model for validation
                # If editing, we might need the existing ID for context, but validation itself doesn't need it.
                # Password validation requires special handling as it might be empty during edit if not changed.
                validation_data = data.copy()
                if self.is_edit_mode and 'password' not in validation_data:
                     # If editing and password field is empty, don't require it for validation
                     # The service layer will handle keeping the old encrypted password
                     pass
                elif validation_data.get('auth_type') == 'password' and not validation_data.get('password'):
                     # If adding and password auth is chosen, password is required
                     if not self.is_edit_mode:
                         raise ValueError("Password cannot be empty for password authentication.")
                     # If editing and password field is empty, it means "don't change password"
                elif validation_data.get('auth_type') == 'key' and not validation_data.get('key_path'):
                     raise ValueError("Key path cannot be empty for key authentication.")

                # Perform Pydantic validation (excluding temporary plain password for now)
                temp_config = SshConnectionConfig(**validation_data)
                # Validation passed
                self.accept()
            except (ValidationError, ValueError) as e:
                QMessageBox.warning(self, "입력 오류", f"입력값을 확인해주세요:\n{e}")
            except Exception as e:
                 QMessageBox.critical(self, "오류", f"검증 중 예기치 않은 오류 발생:\n{e}")
        # If get_data returned None, it means basic required fields were missing.

    def get_data(self) -> Optional[Dict[str, Any]]:
        """Retrieves the data entered in the dialog fields."""
        alias = self.alias_edit.text().strip()
        host = self.host_edit.text().strip()
        port_str = self.port_edit.text().strip()
        username = self.username_edit.text().strip()
        auth_type = self.auth_type_combo.currentText()
        password = self.password_edit.text() # Get plain text, might be empty
        key_path = self.key_path_edit.text().strip()

        # Basic validation for required fields
        if not alias or not host or not username:
            QMessageBox.warning(self, "입력 오류", "별칭, 호스트 주소, 사용자 이름은 필수입니다.")
            return None

        try:
            port = int(port_str) if port_str else 22 # Default to 22 if empty
            if not 1 <= port <= 65535:
                 raise ValueError("포트 번호는 1과 65535 사이여야 합니다.")
        except ValueError as e:
            QMessageBox.warning(self, "입력 오류", f"유효하지 않은 포트 번호입니다: {e}")
            return None

        data = {
            "alias": alias,
            "host": host,
            "port": port,
            "username": username,
            "auth_type": auth_type,
            "key_path": key_path if auth_type == 'key' else None,
            # Include password only if auth_type is password AND it's not empty
            # For edit mode, an empty password means "keep existing"
            "password": SecretStr(password) if auth_type == 'password' and password else None,
        }

        # Clean up None values that are not explicitly needed
        if data['key_path'] is None: del data['key_path']
        if data['password'] is None: del data['password']

        return data
]]></file_code>
</file>
<file>
  <file_summary>SSH 설정 관련 DB 메서드 테스트 케이스 추가</file_summary>
  <file_operation>UPDATE</file_operation>
  <file_path>tests/core/services/test_db_service.py</file_path>
  <file_code><![CDATA[
import pytest
import os
from unittest.mock import MagicMock, patch
import datetime
from decimal import Decimal

# Import necessary classes and exceptions
from core.services.db_service import DbService, DB_CONFIG
from core.pydantic_models.config_settings import ConfigSettings
from core.pydantic_models.ssh_connection_config import SshConnectionConfig # Added
from core.utils.crypto import encrypt_password # Added for SSH tests
import psycopg2

# --- Test Fixtures ---

# Fixture to create a DbService instance with a mocked connection
@pytest.fixture
def mock_db_service(monkeypatch):
    """Fixture to create a DbService with a mocked connection and cursor."""
    mock_conn = MagicMock(spec=psycopg2.extensions.connection)
    mock_cursor = MagicMock(spec=psycopg2.extensions.cursor)
    mock_conn.cursor.return_value = mock_cursor
    mock_conn.closed = False # Simulate open connection initially
    mock_conn.commit = MagicMock()
    mock_conn.rollback = MagicMock()
    mock_conn.close = MagicMock()

    # Mock psycopg2.connect to return our mock connection
    monkeypatch.setattr(psycopg2, 'connect', lambda **kwargs: mock_conn)

    service = DbService(db_config=DB_CONFIG) # Use actual config for init, but connection is mocked
    service.connection = mock_conn # Assign the mock connection
    return service, mock_cursor

# Sample data for tests
SAMPLE_PROFILE_NAME = 'test_profile'
SAMPLE_CONFIG_DATA = {
    'profile_name': SAMPLE_PROFILE_NAME,
    'default_system_prompt': 'Test System Prompt',
    'allowed_extensions': {'.py', '.txt'},
    'excluded_dirs': {'__pycache__', '.git'},
    'default_ignore_list': ['.DS_Store'],
    'gemini_default_model': 'gemini-test-pro',
    'claude_default_model': 'claude-test-sonnet',
    'gpt_default_model': 'gpt-test-o',
    'gemini_available_models': ['gemini-test-pro', 'gemini-test-flash'],
    'claude_available_models': ['claude-test-sonnet', 'claude-test-opus'],
    'gpt_available_models': ['gpt-test-o', 'gpt-test-turbo'],
    'gemini_temperature': 0.5,
    'gemini_enable_thinking': False,
    'gemini_thinking_budget': 1000,
    'gemini_enable_search': False,
}

SAMPLE_GEMINI_KEY = "fake_gemini_key_123"
SAMPLE_ANTHROPIC_KEY = "fake_anthropic_key_456"
SAMPLE_KEY_PROVIDER_GOOGLE = 'google'
SAMPLE_KEY_PROVIDER_ANTHROPIC = 'anthropic'
SAMPLE_DESCRIPTION = "Test Key"

SAMPLE_GEMINI_LOG = {
    "model_name": "gemini-test-pro",
    "request_prompt": "Test prompt",
    "request_attachments": [{"name": "file.txt", "type": "file"}],
    "api_key_id": 1
}

SAMPLE_UPDATE_LOG = {
    "response_text": "Test response",
    "response_xml": "<test></test>",
    "response_summary": "Summary",
    "elapsed_time_ms": 1234,
    "token_count": 50
}

# --- Test Cases ---

def test_db_service_connect_success(mock_db_service):
    """Test successful database connection."""
    service, _ = mock_db_service
    assert service.connection is not None
    assert not service.connection.closed
    psycopg2.connect.assert_called_once()

def test_db_service_connect_failure(monkeypatch):
    """Test database connection failure."""
    # Mock psycopg2.connect to raise an error
    monkeypatch.setattr(psycopg2, 'connect', MagicMock(side_effect=psycopg2.OperationalError("Connection failed")))
    with pytest.raises(ConnectionError):
        DbService(db_config=DB_CONFIG)

def test_db_service_disconnect(mock_db_service):
    """Test database disconnection."""
    service, _ = mock_db_service
    service.disconnect()
    assert service.connection is None
    service.connection.close.assert_called_once()

# --- Test Application Config ---

def test_get_application_config_success(mock_db_service):
    """Test successfully fetching application config."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = tuple(SAMPLE_CONFIG_DATA.values()) # Return as tuple
    mock_cursor.description = [(key,) for key in SAMPLE_CONFIG_DATA.keys()] # Mock description

    config = service.get_application_config(SAMPLE_PROFILE_NAME)

    assert config is not None
    assert config['profile_name'] == SAMPLE_PROFILE_NAME
    assert config['gemini_temperature'] == 0.5 # Check type conversion
    mock_cursor.execute.assert_called_once()
    assert SAMPLE_PROFILE_NAME in mock_cursor.execute.call_args[0][1] # Check query parameter

def test_get_application_config_not_found(mock_db_service):
    """Test fetching non-existent application config."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = None # Simulate not found

    config = service.get_application_config('non_existent_profile')

    assert config is None
    mock_cursor.execute.assert_called_once()

def test_get_application_config_db_error(mock_db_service):
    """Test database error during application config fetch."""
    service, mock_cursor = mock_db_service
    mock_cursor.execute.side_effect = psycopg2.Error("DB fetch error")

    config = service.get_application_config(SAMPLE_PROFILE_NAME)
    assert config is None

def test_save_application_config_insert(mock_db_service):
    """Test saving (inserting) new application config."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1 # Simulate 1 row affected

    # Use Pydantic model to easily get dict, then convert sets/lists
    settings_model = ConfigSettings(**SAMPLE_CONFIG_DATA)
    config_dict = settings_model.model_dump()

    success = service.save_application_config(SAMPLE_PROFILE_NAME, config_dict)

    assert success is True
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()
    # Check if list conversions happened correctly in parameters
    args, _ = mock_cursor.execute.call_args
    params = args[1]
    assert isinstance(params[2], list) # allowed_extensions
    assert isinstance(params[3], list) # excluded_dirs
    assert isinstance(params[4], list) # default_ignore_list
    assert isinstance(params[8], list) # gemini_available_models

def test_save_application_config_update(mock_db_service):
    """Test saving (updating) existing application config."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1 # Simulate 1 row affected

    settings_model = ConfigSettings(**SAMPLE_CONFIG_DATA)
    config_dict = settings_model.model_dump()
    config_dict['gemini_temperature'] = 0.8 # Modify a value

    success = service.save_application_config(SAMPLE_PROFILE_NAME, config_dict)

    assert success is True
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()
    # Check updated value in params
    args, _ = mock_cursor.execute.call_args
    params = args[1]
    assert params[11] == 0.8 # gemini_temperature

def test_save_application_config_db_error(mock_db_service):
    """Test database error during application config save."""
    service, mock_cursor = mock_db_service
    mock_cursor.execute.side_effect = psycopg2.Error("DB save error")

    settings_model = ConfigSettings(**SAMPLE_CONFIG_DATA)
    config_dict = settings_model.model_dump()

    success = service.save_application_config(SAMPLE_PROFILE_NAME, config_dict)

    assert success is False
    service.connection.rollback.assert_called_once()

# --- Test API Key Management ---

def test_get_active_api_keys_found(mock_db_service):
    """Test fetching active API keys when keys exist."""
    service, mock_cursor = mock_db_service
    mock_data = [{'id': 1, 'api_key': SAMPLE_GEMINI_KEY, 'description': SAMPLE_DESCRIPTION, 'is_active': True}]
    mock_cursor.fetchall.return_value = [(row['id'], row['api_key'], row['description'], row['is_active']) for row in mock_data]
    mock_cursor.description = [('id',), ('api_key',), ('description',), ('is_active',)]

    keys = service.get_active_api_keys(SAMPLE_KEY_PROVIDER_GOOGLE)

    assert len(keys) == 1
    assert keys[0]['id'] == 1
    assert keys[0]['api_key'] == SAMPLE_GEMINI_KEY
    mock_cursor.execute.assert_called_once()

def test_get_active_api_keys_not_found(mock_db_service):
    """Test fetching active API keys when none exist."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchall.return_value = []
    mock_cursor.description = [('id',), ('api_key',), ('description',), ('is_active',)] # Still need description

    keys = service.get_active_api_keys(SAMPLE_KEY_PROVIDER_GOOGLE)

    assert len(keys) == 0
    mock_cursor.execute.assert_called_once()

def test_list_api_keys_all(mock_db_service):
    """Test listing all API keys."""
    service, mock_cursor = mock_db_service
    mock_data = [
        {'id': 1, 'api_key': SAMPLE_GEMINI_KEY, 'provider': 'google', 'description': 'Key 1', 'is_active': True, 'last_api_call_timestamp': None, 'calls_this_minute': 0, 'minute_start_timestamp': None, 'calls_this_day': 0, 'day_start_timestamp': None},
        {'id': 2, 'api_key': SAMPLE_ANTHROPIC_KEY, 'provider': 'anthropic', 'description': 'Key 2', 'is_active': False, 'last_api_call_timestamp': None, 'calls_this_minute': 0, 'minute_start_timestamp': None, 'calls_this_day': 0, 'day_start_timestamp': None}
    ]
    # Adjust tuple conversion based on the actual order of columns in the SELECT query
    mock_cursor.fetchall.return_value = [
        (row['id'], row['api_key'], row['provider'], row['description'], row['is_active'], row['last_api_call_timestamp'], row['calls_this_minute'], row['minute_start_timestamp'], row['calls_this_day'], row['day_start_timestamp'])
        for row in mock_data
    ]
    mock_cursor.description = [(col,) for col in mock_data[0].keys()] # Use keys from dict for description

    keys = service.list_api_keys()

    assert len(keys) == 2
    assert keys[0]['provider'] == 'google'
    assert keys[1]['provider'] == 'anthropic'
    mock_cursor.execute.assert_called_once()
    assert "ORDER BY provider, id" in mock_cursor.execute.call_args[0][0] # Check query structure

def test_list_api_keys_filtered(mock_db_service):
    """Test listing API keys filtered by provider."""
    service, mock_cursor = mock_db_service
    mock_data = [{'id': 1, 'api_key': SAMPLE_GEMINI_KEY, 'provider': 'google', 'description': 'Key 1', 'is_active': True, 'last_api_call_timestamp': None, 'calls_this_minute': 0, 'minute_start_timestamp': None, 'calls_this_day': 0, 'day_start_timestamp': None}]
    mock_cursor.fetchall.return_value = [
        (row['id'], row['api_key'], row['provider'], row['description'], row['is_active'], row['last_api_call_timestamp'], row['calls_this_minute'], row['minute_start_timestamp'], row['calls_this_day'], row['day_start_timestamp'])
        for row in mock_data
    ]
    mock_cursor.description = [(col,) for col in mock_data[0].keys()]

    keys = service.list_api_keys(provider=SAMPLE_KEY_PROVIDER_GOOGLE)

    assert len(keys) == 1
    assert keys[0]['provider'] == SAMPLE_KEY_PROVIDER_GOOGLE
    mock_cursor.execute.assert_called_once()
    assert SAMPLE_KEY_PROVIDER_GOOGLE in mock_cursor.execute.call_args[0][1] # Check filter param

def test_add_api_key_success(mock_db_service):
    """Test successfully adding a new API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = (1,) # Simulate returning new ID

    key_id = service.add_api_key(SAMPLE_KEY_PROVIDER_GOOGLE, SAMPLE_GEMINI_KEY, SAMPLE_DESCRIPTION)

    assert key_id == 1
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()

def test_add_api_key_duplicate(mock_db_service):
    """Test adding a duplicate API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.execute.side_effect = psycopg2.IntegrityError("Duplicate key")

    key_id = service.add_api_key(SAMPLE_KEY_PROVIDER_GOOGLE, SAMPLE_GEMINI_KEY)

    assert key_id is None
    service.connection.rollback.assert_called_once()

def test_update_api_key_success(mock_db_service):
    """Test successfully updating an API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    success = service.update_api_key(key_id=1, description="Updated Desc", is_active=False)

    assert success is True
    mock_cursor.execute.assert_called_once()
    assert "description = %s" in mock_cursor.execute.call_args[0][0]
    assert "is_active = %s" in mock_cursor.execute.call_args[0][0]
    service.connection.commit.assert_called_once()

def test_update_api_key_not_found(mock_db_service):
    """Test updating a non-existent API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 0 # Simulate no rows affected

    success = service.update_api_key(key_id=999, description="Non-existent")

    assert success is False
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once() # Commit still happens even if 0 rows updated

def test_delete_api_key_success(mock_db_service):
    """Test successfully deleting an API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    success = service.delete_api_key(key_id=1)

    assert success is True
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()

def test_delete_api_key_not_found(mock_db_service):
    """Test deleting a non-existent API key."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 0

    success = service.delete_api_key(key_id=999)

    assert success is False
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()

# --- Test Gemini Log Management ---

def test_log_gemini_request_success(mock_db_service):
    """Test successfully logging a Gemini request."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = (101,) # Simulate returning new log ID

    log_id = service.log_gemini_request(**SAMPLE_GEMINI_LOG)

    assert log_id == 101
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()
    # Check if attachments are JSONified
    args, _ = mock_cursor.execute.call_args
    params = args[1]
    assert isinstance(params[2], str) # request_attachments should be JSON string
    assert "file.txt" in params[2]

def test_log_gemini_request_db_error(mock_db_service):
    """Test database error during Gemini request logging."""
    service, mock_cursor = mock_db_service
    mock_cursor.execute.side_effect = psycopg2.Error("DB log error")

    log_id = service.log_gemini_request(**SAMPLE_GEMINI_LOG)

    assert log_id is None
    service.connection.rollback.assert_called_once()

def test_update_gemini_log_success(mock_db_service):
    """Test successfully updating a Gemini log entry."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    service.update_gemini_log(log_id=101, **SAMPLE_UPDATE_LOG)

    mock_cursor.execute.assert_called_once()
    assert "response_text = %s" in mock_cursor.execute.call_args[0][0]
    assert "response_timestamp = %s" in mock_cursor.execute.call_args[0][0]
    service.connection.commit.assert_called_once()

def test_update_gemini_log_no_fields(mock_db_service):
    """Test updating a Gemini log entry with no specific fields to update (only timestamp)."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    service.update_gemini_log(log_id=101) # Call with only log_id

    mock_cursor.execute.assert_called_once()
    # Ensure the query only contains the timestamp update
    query_str = mock_cursor.execute.call_args[0][0]
    assert "response_timestamp = %s" in query_str
    assert "response_text" not in query_str # Check another field is absent
    assert "error_message" not in query_str
    service.connection.commit.assert_called_once()


def test_cleanup_old_gemini_logs(mock_db_service):
    """Test cleaning up old Gemini logs."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 5 # Simulate 5 logs deleted

    service.cleanup_old_gemini_logs(days_to_keep=7)

    mock_cursor.execute.assert_called_once()
    assert "DELETE FROM gemini_api_logs" in mock_cursor.execute.call_args[0][0]
    service.connection.commit.assert_called_once()

# --- Test SSH Connection Management (New) ---

SAMPLE_SSH_CONFIG_DATA = {
    "alias": "test_server",
    "host": "192.168.1.100",
    "port": 2222,
    "username": "testuser",
    "auth_type": "password",
    "password": "plain_password" # Plain password for adding
}
SAMPLE_SSH_CONFIG_MODEL_PW = SshConnectionConfig(**SAMPLE_SSH_CONFIG_DATA)
# Simulate encrypted password
SAMPLE_SSH_CONFIG_MODEL_PW.password_enc = encrypt_password(SAMPLE_SSH_CONFIG_DATA["password"])
SAMPLE_SSH_CONFIG_MODEL_PW.password = None # Clear plain after simulated encryption

SAMPLE_SSH_CONFIG_DATA_KEY = {
    "alias": "key_server",
    "host": "example.com",
    "port": 22,
    "username": "keyuser",
    "auth_type": "key",
    "key_path": "/path/to/id_rsa"
}
SAMPLE_SSH_CONFIG_MODEL_KEY = SshConnectionConfig(**SAMPLE_SSH_CONFIG_DATA_KEY)

def test_add_ssh_connection_success(mock_db_service):
    """Test successfully adding a new SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = (1,) # Simulate returning new ID

    # Create a config model instance to pass
    config_to_add = SAMPLE_SSH_CONFIG_MODEL_PW.model_copy(deep=True) # Use the one with password_enc

    new_id = service.add_ssh_connection(config_to_add)

    assert new_id == 1
    mock_cursor.execute.assert_called_once()
    assert "INSERT INTO ssh_connections" in mock_cursor.execute.call_args[0][0]
    # Check that password_enc is passed, not plain password
    params = mock_cursor.execute.call_args[0][1]
    assert params[5] == config_to_add.password_enc # password_enc at index 5
    service.connection.commit.assert_called_once()

def test_add_ssh_connection_duplicate_alias(mock_db_service):
    """Test adding an SSH connection with a duplicate alias."""
    service, mock_cursor = mock_db_service
    mock_cursor.execute.side_effect = psycopg2.IntegrityError("Duplicate alias")

    config_to_add = SAMPLE_SSH_CONFIG_MODEL_PW.model_copy(deep=True)
    new_id = service.add_ssh_connection(config_to_add)

    assert new_id is None
    service.connection.rollback.assert_called_once()

def test_get_ssh_connection_found(mock_db_service):
    """Test fetching an existing SSH connection by alias."""
    service, mock_cursor = mock_db_service
    # Simulate DB returning data matching the model (with encrypted password)
    db_row_dict = SAMPLE_SSH_CONFIG_MODEL_PW.model_dump()
    db_row_dict['id'] = 1 # Add ID as it comes from DB
    db_row_dict.pop('password', None) # Remove plain password field
    mock_cursor.fetchone.return_value = tuple(db_row_dict.values())
    mock_cursor.description = [(key,) for key in db_row_dict.keys()]

    config = service.get_ssh_connection("test_server")

    assert config is not None
    assert isinstance(config, SshConnectionConfig)
    assert config.alias == "test_server"
    assert config.password is None # Should not have plain password
    assert config.password_enc == SAMPLE_SSH_CONFIG_MODEL_PW.password_enc
    mock_cursor.execute.assert_called_once()

def test_get_ssh_connection_not_found(mock_db_service):
    """Test fetching a non-existent SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.fetchone.return_value = None

    config = service.get_ssh_connection("non_existent_alias")

    assert config is None
    mock_cursor.execute.assert_called_once()

def test_list_ssh_connections(mock_db_service):
    """Test listing all SSH connections."""
    service, mock_cursor = mock_db_service
    db_row_dict_pw = SAMPLE_SSH_CONFIG_MODEL_PW.model_dump(); db_row_dict_pw['id'] = 1; db_row_dict_pw.pop('password', None)
    db_row_dict_key = SAMPLE_SSH_CONFIG_MODEL_KEY.model_dump(); db_row_dict_key['id'] = 2; db_row_dict_key.pop('password', None)
    mock_data = [db_row_dict_pw, db_row_dict_key]
    mock_cursor.fetchall.return_value = [tuple(row.values()) for row in mock_data]
    mock_cursor.description = [(key,) for key in mock_data[0].keys()]

    connections = service.list_ssh_connections()

    assert len(connections) == 2
    assert isinstance(connections[0], SshConnectionConfig)
    assert connections[0].alias == "test_server"
    assert connections[1].alias == "key_server"
    mock_cursor.execute.assert_called_once()

def test_update_ssh_connection_success(mock_db_service):
    """Test successfully updating an SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    # Simulate updating host and changing auth to key
    config_to_update = SAMPLE_SSH_CONFIG_MODEL_KEY.model_copy(deep=True)
    config_to_update.host = "new.example.com"
    config_to_update.password_enc = None # Ensure password_enc is None for key type

    success = service.update_ssh_connection(connection_id=1, config=config_to_update)

    assert success is True
    mock_cursor.execute.assert_called_once()
    assert "UPDATE ssh_connections" in mock_cursor.execute.call_args[0][0]
    params = mock_cursor.execute.call_args[0][1]
    assert params[1] == "new.example.com" # Check updated host
    assert params[4] == "key" # Check updated auth_type
    assert params[5] is None # Check password_enc is None
    assert params[7] == 1 # Check ID in WHERE clause
    service.connection.commit.assert_called_once()

def test_update_ssh_connection_not_found(mock_db_service):
    """Test updating a non-existent SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 0

    config_to_update = SAMPLE_SSH_CONFIG_MODEL_PW.model_copy(deep=True)
    success = service.update_ssh_connection(connection_id=999, config=config_to_update)

    assert success is False
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once() # Commit still called

def test_delete_ssh_connection_success(mock_db_service):
    """Test successfully deleting an SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 1

    success = service.delete_ssh_connection(connection_id=1)

    assert success is True
    mock_cursor.execute.assert_called_once()
    assert "DELETE FROM ssh_connections" in mock_cursor.execute.call_args[0][0]
    service.connection.commit.assert_called_once()

def test_delete_ssh_connection_not_found(mock_db_service):
    """Test deleting a non-existent SSH connection."""
    service, mock_cursor = mock_db_service
    mock_cursor.rowcount = 0

    success = service.delete_ssh_connection(connection_id=999)

    assert success is False
    mock_cursor.execute.assert_called_once()
    service.connection.commit.assert_called_once()
]]></file_code>
</file>
<file>
  <file_summary>SSH 설정 서비스 로직 테스트 케이스 추가</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>tests/core/services/test_ssh_config_service.py</file_path>
  <file_code><![CDATA[
import pytest
from unittest.mock import MagicMock, patch
from pydantic import SecretStr, ValidationError

from core.services.ssh_config_service import SshConfigService
from core.services.db_service import DbService
from core.pydantic_models.ssh_connection_config import SshConnectionConfig
from core.utils.crypto import encrypt_password, decrypt_password # Import crypto utils

# --- Test Fixtures ---

@pytest.fixture
def mock_db_service_ssh():
    """Fixture to create a mock DbService instance for SSH tests."""
    mock_db = MagicMock(spec=DbService)
    return mock_db

@pytest.fixture
def ssh_config_service(mock_db_service_ssh):
    """Fixture to create an SshConfigService instance with a mocked DbService."""
    return SshConfigService(db_service=mock_db_service_ssh)

# Sample data for SSH tests
SAMPLE_SSH_DATA_PW = {
    "alias": "server_pw", "host": "host1", "port": 22, "username": "user1",
    "auth_type": "password", "password": SecretStr("secret123") # Use SecretStr here for consistency
}
SAMPLE_SSH_DATA_KEY = {
    "alias": "server_key", "host": "host2", "port": 22, "username": "user2",
    "auth_type": "key", "key_path": "/path/to/key"
}

# Simulate encrypted password for retrieval tests
ENCRYPTED_PW = encrypt_password("secret123")
SAMPLE_SSH_CONFIG_PW_DB = SshConnectionConfig(
    id=1, alias="server_pw", host="host1", port=22, username="user1",
    auth_type="password", password_enc=ENCRYPTED_PW, key_path=None
)
SAMPLE_SSH_CONFIG_KEY_DB = SshConnectionConfig(
    id=2, alias="server_key", host="host2", port=22, username="user2",
    auth_type="key", password_enc=None, key_path="/path/to/key"
)

# --- Test Cases ---

def test_add_connection_password_success(ssh_config_service, mock_db_service_ssh):
    """Test adding a password-authenticated SSH connection successfully."""
    mock_db_service_ssh.add_ssh_connection.return_value = 1 # Simulate successful DB insert returning ID 1

    # Use a copy to avoid modifying the fixture data
    data_to_add = SAMPLE_SSH_DATA_PW.copy()
    # Pydantic expects plain string for initial validation, service handles encryption
    data_to_add['password'] = "secret123"

    # Patch encrypt_password to return a predictable value
    with patch('core.services.ssh_config_service.encrypt_password', return_value="encrypted_mock_pw") as mock_encrypt:
        result_config = ssh_config_service.add_connection(data_to_add)

        mock_encrypt.assert_called_once_with("secret123")
        mock_db_service_ssh.add_ssh_connection.assert_called_once()
        # Check the argument passed to db_service (should be a SshConnectionConfig instance)
        args, _ = mock_db_service_ssh.add_ssh_connection.call_args
        passed_config = args[0]
        assert isinstance(passed_config, SshConnectionConfig)
        assert passed_config.alias == "server_pw"
        assert passed_config.auth_type == "password"
        assert passed_config.password is None # Plain password should be cleared
        assert passed_config.password_enc == "encrypted_mock_pw" # Encrypted password set
        assert passed_config.key_path is None

        assert result_config is not None
        assert result_config.id == 1
        assert result_config.alias == "server_pw"
        assert result_config.password is None # Result should not contain plain password
        assert result_config.password_enc == "encrypted_mock_pw"

def test_add_connection_key_success(ssh_config_service, mock_db_service_ssh):
    """Test adding a key-authenticated SSH connection successfully."""
    mock_db_service_ssh.add_ssh_connection.return_value = 2

    # Use a copy
    data_to_add = SAMPLE_SSH_DATA_KEY.copy()

    # Patch encrypt_password (should not be called for key auth)
    with patch('core.services.ssh_config_service.encrypt_password') as mock_encrypt:
        result_config = ssh_config_service.add_connection(data_to_add)

        mock_encrypt.assert_not_called() # Encrypt should not be called
        mock_db_service_ssh.add_ssh_connection.assert_called_once()
        args, _ = mock_db_service_ssh.add_ssh_connection.call_args
        passed_config = args[0]
        assert isinstance(passed_config, SshConnectionConfig)
        assert passed_config.alias == "server_key"
        assert passed_config.auth_type == "key"
        assert passed_config.key_path == "/path/to/key"
        assert passed_config.password is None
        assert passed_config.password_enc is None

        assert result_config is not None
        assert result_config.id == 2
        assert result_config.alias == "server_key"
        assert result_config.key_path == "/path/to/key"

def test_add_connection_validation_error(ssh_config_service):
    """Test adding a connection with invalid data causing validation error."""
    invalid_data = SAMPLE_SSH_DATA_PW.copy()
    invalid_data['host'] = "" # Invalid host

    result_config = ssh_config_service.add_connection(invalid_data)
    assert result_config is None

def test_add_connection_db_error(ssh_config_service, mock_db_service_ssh):
    """Test database error during connection adding."""
    mock_db_service_ssh.add_ssh_connection.return_value = None # Simulate DB failure

    data_to_add = SAMPLE_SSH_DATA_PW.copy()
    data_to_add['password'] = "secret123"
    with patch('core.services.ssh_config_service.encrypt_password', return_value="encrypted_mock_pw"):
         result_config = ssh_config_service.add_connection(data_to_add)
    assert result_config is None

def test_get_connection_success(ssh_config_service, mock_db_service_ssh):
    """Test retrieving an SSH connection successfully."""
    mock_db_service_ssh.get_ssh_connection.return_value = SAMPLE_SSH_CONFIG_PW_DB

    result_config = ssh_config_service.get_connection("server_pw")

    assert result_config is not None
    assert result_config.id == 1
    assert result_config.alias == "server_pw"
    assert result_config.password_enc == ENCRYPTED_PW
    mock_db_service_ssh.get_ssh_connection.assert_called_once_with("server_pw")

def test_get_connection_not_found(ssh_config_service, mock_db_service_ssh):
    """Test retrieving a non-existent SSH connection."""
    mock_db_service_ssh.get_ssh_connection.return_value = None

    result_config = ssh_config_service.get_connection("not_found")
    assert result_config is None
    mock_db_service_ssh.get_ssh_connection.assert_called_once_with("not_found")

def test_get_connection_with_decrypted_password_success(ssh_config_service, mock_db_service_ssh):
    """Test retrieving and decrypting password successfully."""
    mock_db_service_ssh.get_ssh_connection.return_value = SAMPLE_SSH_CONFIG_PW_DB

    # Patch decrypt_password
    with patch('core.services.ssh_config_service.decrypt_password', return_value="secret123") as mock_decrypt:
        result_config = ssh_config_service.get_connection_with_decrypted_password("server_pw")

        mock_decrypt.assert_called_once_with(ENCRYPTED_PW)
        assert result_config is not None
        assert result_config.password == "secret123" # Check if plain password is set
        assert result_config.password_enc == ENCRYPTED_PW # Encrypted value should still be there

def test_get_connection_with_decrypted_password_key_auth(ssh_config_service, mock_db_service_ssh):
    """Test retrieving key auth connection (no decryption needed)."""
    mock_db_service_ssh.get_ssh_connection.return_value = SAMPLE_SSH_CONFIG_KEY_DB

    with patch('core.services.ssh_config_service.decrypt_password') as mock_decrypt:
        result_config = ssh_config_service.get_connection_with_decrypted_password("server_key")
        mock_decrypt.assert_not_called() # Decrypt should not be called
        assert result_config is not None
        assert result_config.alias == "server_key"
        assert result_config.auth_type == "key"
        assert result_config.password is None
        assert result_config.password_enc is None

def test_get_connection_with_decryption_failure(ssh_config_service, mock_db_service_ssh):
    """Test decryption failure during retrieval."""
    mock_db_service_ssh.get_ssh_connection.return_value = SAMPLE_SSH_CONFIG_PW_DB

    with patch('core.services.ssh_config_service.decrypt_password', return_value=None) as mock_decrypt:
        result_config = ssh_config_service.get_connection_with_decrypted_password("server_pw")
        mock_decrypt.assert_called_once_with(ENCRYPTED_PW)
        assert result_config is None # Should return None on decryption failure

def test_list_connections(ssh_config_service, mock_db_service_ssh):
    """Test listing all connections."""
    mock_db_service_ssh.list_ssh_connections.return_value = [SAMPLE_SSH_CONFIG_PW_DB, SAMPLE_SSH_CONFIG_KEY_DB]

    result_list = ssh_config_service.list_connections()

    assert len(result_list) == 2
    assert result_list[0].alias == "server_pw"
    assert result_list[1].alias == "server_key"
    mock_db_service_ssh.list_ssh_connections.assert_called_once()

def test_update_connection_success_change_pw(ssh_config_service, mock_db_service_ssh):
    """Test updating connection with a new password."""
    mock_db_service_ssh.update_ssh_connection.return_value = True
    mock_db_service_ssh.get_ssh_connection_by_id.return_value = SAMPLE_SSH_CONFIG_PW_DB # For pre-fetch

    update_data = {"alias": "server_pw_updated", "password": "new_password123"}
    # Merge with existing data for validation
    config_data_for_update = SAMPLE_SSH_CONFIG_PW_DB.model_dump()
    config_data_for_update.update(update_data)
    # Remove password_enc so Pydantic doesn't complain during validation if plain password exists
    config_data_for_update.pop('password_enc', None)

    with patch('core.services.ssh_config_service.encrypt_password', return_value="encrypted_new_pw") as mock_encrypt:
        result_config = ssh_config_service.update_connection(1, config_data_for_update)

        mock_encrypt.assert_called_once_with("new_password123")
        mock_db_service_ssh.update_ssh_connection.assert_called_once()
        args, _ = mock_db_service_ssh.update_ssh_connection.call_args
        updated_config_arg = args[1]
        assert updated_config_arg.id == 1
        assert updated_config_arg.alias == "server_pw_updated"
        assert updated_config_arg.password is None # Plain should be cleared
        assert updated_config_arg.password_enc == "encrypted_new_pw" # New encrypted pw

        assert result_config is not None
        assert result_config.alias == "server_pw_updated"
        assert result_config.password_enc == "encrypted_new_pw"

def test_update_connection_success_no_pw_change(ssh_config_service, mock_db_service_ssh):
    """Test updating connection without changing the password."""
    mock_db_service_ssh.update_ssh_connection.return_value = True
    mock_db_service_ssh.get_ssh_connection_by_id.return_value = SAMPLE_SSH_CONFIG_PW_DB

    update_data = {"host": "new_host1"} # Only change host
    # Merge with existing data
    config_data_for_update = SAMPLE_SSH_CONFIG_PW_DB.model_dump()
    config_data_for_update.update(update_data)
    config_data_for_update.pop('password', None) # Remove plain password if it existed

    with patch('core.services.ssh_config_service.encrypt_password') as mock_encrypt:
        result_config = ssh_config_service.update_connection(1, config_data_for_update)

        mock_encrypt.assert_not_called() # Encrypt should not be called
        mock_db_service_ssh.update_ssh_connection.assert_called_once()
        args, _ = mock_db_service_ssh.update_ssh_connection.call_args
        updated_config_arg = args[1]
        assert updated_config_arg.id == 1
        assert updated_config_arg.host == "new_host1"
        assert updated_config_arg.password_enc == ENCRYPTED_PW # Original encrypted pw kept

        assert result_config is not None
        assert result_config.host == "new_host1"
        assert result_config.password_enc == ENCRYPTED_PW

def test_update_connection_change_to_key_auth(ssh_config_service, mock_db_service_ssh):
    """Test updating connection changing auth type from password to key."""
    mock_db_service_ssh.update_ssh_connection.return_value = True
    mock_db_service_ssh.get_ssh_connection_by_id.return_value = SAMPLE_SSH_CONFIG_PW_DB

    update_data = {"auth_type": "key", "key_path": "/new/key/path"}
    config_data_for_update = SAMPLE_SSH_CONFIG_PW_DB.model_dump()
    config_data_for_update.update(update_data)
    config_data_for_update.pop('password', None)
    config_data_for_update.pop('password_enc', None) # Clear existing password_enc

    with patch('core.services.ssh_config_service.encrypt_password') as mock_encrypt:
        result_config = ssh_config_service.update_connection(1, config_data_for_update)

        mock_encrypt.assert_not_called()
        mock_db_service_ssh.update_ssh_connection.assert_called_once()
        args, _ = mock_db_service_ssh.update_ssh_connection.call_args
        updated_config_arg = args[1]
        assert updated_config_arg.auth_type == "key"
        assert updated_config_arg.key_path == "/new/key/path"
        assert updated_config_arg.password is None
        assert updated_config_arg.password_enc is None # Should be None for key auth

        assert result_config is not None
        assert result_config.auth_type == "key"
        assert result_config.key_path == "/new/key/path"

def test_update_connection_not_found(ssh_config_service, mock_db_service_ssh):
    """Test updating a non-existent connection ID."""
    mock_db_service_ssh.get_ssh_connection_by_id.return_value = None # Simulate not found

    result_config = ssh_config_service.update_connection(999, {"host": "any"})
    assert result_config is None
    mock_db_service_ssh.update_ssh_connection.assert_not_called()

def test_delete_connection_success(ssh_config_service, mock_db_service_ssh):
    """Test deleting a connection successfully."""
    mock_db_service_ssh.delete_ssh_connection.return_value = True

    success = ssh_config_service.delete_connection(1)
    assert success is True
    mock_db_service_ssh.delete_ssh_connection.assert_called_once_with(1)

def test_delete_connection_failure(ssh_config_service, mock_db_service_ssh):
    """Test failure during connection deletion."""
    mock_db_service_ssh.delete_ssh_connection.return_value = False

    success = ssh_config_service.delete_connection(1)
    assert success is False
    mock_db_service_ssh.delete_ssh_connection.assert_called_once_with(1)

# Test for test_connection placeholder
def test_test_connection_placeholder(ssh_config_service, mock_db_service_ssh):
    """Test the placeholder implementation of test_connection."""
    # Simulate successful retrieval of config (with mocked decryption)
    mock_db_service_ssh.get_ssh_connection.return_value = SAMPLE_SSH_CONFIG_PW_DB
    with patch('core.services.ssh_config_service.decrypt_password', return_value="secret123"):
        success, message = ssh_config_service.test_connection("server_pw")

        # Since the actual connection logic is commented out, it should return the placeholder success
        assert success is True
        assert "Placeholder" in message

def test_test_connection_config_not_found(ssh_config_service, mock_db_service_ssh):
    """Test test_connection when config is not found."""
    mock_db_service_ssh.get_ssh_connection.return_value = None

    success, message = ssh_config_service.test_connection("not_found")
    assert success is False
    assert "not found" in message.lower()
]]></file_code>
</file>
<file>
  <file_summary>암호화/복호화 유틸리티 테스트 케이스 추가</file_summary>
  <file_operation>CREATE</file_operation>
  <file_path>tests/core/utils/test_crypto.py</file_path>
  <file_code><![CDATA[
import pytest
import os
import base64
from unittest.mock import patch, mock_open

from core.utils.crypto import (
    generate_key,
    save_key_to_file,
    load_key_from_file,
    get_encryption_key,
    encrypt_password,
    decrypt_password,
    _encryption_key, # Access private variable for testing reset
    KEY_FILE_PATH
)
# Import get_resource_path from helpers for mocking
from core.utils.helpers import get_resource_path

# --- Fixtures ---

@pytest.fixture(autouse=True)
def reset_global_key():
    """Fixture to reset the global _encryption_key before and after each test."""
    global _encryption_key
    _encryption_key = None
    yield
    _encryption_key = None

@pytest.fixture
def mock_key_file(tmp_path):
    """Fixture to create a temporary key file path."""
    return tmp_path / "test_encryption.key"

# Mock get_resource_path to return the temp path for KEY_FILE_PATH
@pytest.fixture(autouse=True)
def mock_resource_path(monkeypatch, tmp_path):
    """Mock get_resource_path to use temporary directory."""
    temp_resources_dir = tmp_path / "resources"
    temp_resources_dir.mkdir()
    key_file_full_path = str(temp_resources_dir / KEY_FILE_PATH)

    def mock_get_resource(relative_path):
        # Only mock the key file path, potentially others if needed
        if relative_path == KEY_FILE_PATH:
            return key_file_full_path
        # Fallback to original logic or just return a joined path for other cases
        return str(tmp_path / "resources" / relative_path)

    monkeypatch.setattr('core.utils.crypto.get_resource_path', mock_get_resource)
    # Also patch it in the global scope if helpers is imported there
    monkeypatch.setattr('core.utils.helpers.get_resource_path', mock_get_resource, raising=False)

    return key_file_full_path # Return the mocked full path


# --- Test Cases ---

def test_generate_key():
    """Test key generation."""
    key1 = generate_key()
    key2 = generate_key()
    assert isinstance(key1, bytes)
    assert len(key1) == 32 # AES-256 key size
    assert key1 != key2

def test_save_and_load_key_file(mock_key_file):
    """Test saving a key to a file and loading it back."""
    key = generate_key()
    # Use the mocked full path returned by mock_resource_path fixture
    save_key_to_file(key, KEY_FILE_PATH) # Pass relative path, mock handles full path

    # Ensure the file was created in the temp directory
    full_mock_path = mock_key_file # The path is now managed by mock_resource_path fixture
    assert os.path.exists(full_mock_path)

    loaded_key = load_key_from_file(KEY_FILE_PATH) # Pass relative path
    assert loaded_key == key

def test_load_key_file_generates_new_if_not_exists(mock_key_file):
    """Test that loading generates a new key if the file doesn't exist."""
    # Ensure file doesn't exist
    full_mock_path = mock_key_file
    if os.path.exists(full_mock_path):
        os.remove(full_mock_path)

    loaded_key = load_key_from_file(KEY_FILE_PATH)
    assert isinstance(loaded_key, bytes)
    assert len(loaded_key) == 32
    # Check if the file was created
    assert os.path.exists(full_mock_path)

def test_get_encryption_key_loads_once(mock_key_file):
    """Test that the key is loaded only once."""
    # Setup: Ensure key file exists
    key = generate_key()
    save_key_to_file(key, KEY_FILE_PATH)

    # Mock load_key_from_file to track calls
    with patch('core.utils.crypto.load_key_from_file', return_value=key) as mock_load:
        key1 = get_encryption_key()
        key2 = get_encryption_key()

        assert key1 == key
        assert key2 == key
        mock_load.assert_called_once() # Should only be called the first time

def test_get_encryption_key_handles_load_failure():
    """Test get_encryption_key when loading fails."""
    with patch('core.utils.crypto.load_key_from_file', return_value=None):
        key = get_encryption_key()
        # In the current implementation, it returns None and logs critical error
        assert key is None

def test_encrypt_decrypt_password_success():
    """Test successful encryption and decryption."""
    # Ensure a key is loaded/generated
    key = get_encryption_key()
    assert key is not None

    password = "mysecretpassword"
    encrypted = encrypt_password(password)

    assert encrypted is not None
    assert isinstance(encrypted, str)

    decrypted = decrypt_password(encrypted)
    assert decrypted == password

def test_encrypt_password_empty_password():
    """Test encrypting an empty password."""
    encrypted = encrypt_password("")
    assert encrypted is None

def test_encrypt_password_no_key():
    """Test encryption when key is missing."""
    with patch('core.utils.crypto.get_encryption_key', return_value=None):
        encrypted = encrypt_password("password")
        assert encrypted is None

def test_decrypt_password_empty_data():
    """Test decrypting empty data."""
    decrypted = decrypt_password("")
    assert decrypted is None

def test_decrypt_password_no_key():
    """Test decryption when key is missing."""
    # Encrypt first to get valid data
    key = get_encryption_key()
    assert key is not None
    encrypted = encrypt_password("password")
    assert encrypted is not None

    # Now mock the key retrieval to fail
    with patch('core.utils.crypto.get_encryption_key', return_value=None):
        decrypted = decrypt_password(encrypted)
        assert decrypted is None

def test_decrypt_password_invalid_token():
    """Test decryption with invalid data (corrupted or wrong key)."""
    key = get_encryption_key()
    assert key is not None
    # Generate slightly different data
    invalid_encoded = base64.urlsafe_b64encode(os.urandom(32)).decode('utf-8')

    decrypted = decrypt_password(invalid_encoded)
    assert decrypted is None

def test_decrypt_password_wrong_key():
    """Test decryption with the wrong key."""
    key1 = get_encryption_key() # Load/generate initial key
    assert key1 is not None
    password = "password"
    encrypted_with_key1 = encrypt_password(password)
    assert encrypted_with_key1 is not None

    # Generate a different key and mock get_encryption_key to return it
    key2 = generate_key()
    assert key1 != key2
    with patch('core.utils.crypto.get_encryption_key', return_value=key2):
        decrypted_with_key2 = decrypt_password(encrypted_with_key1)
        assert decrypted_with_key2 is None # Should fail

# Test file permissions (mocking os.open might be complex depending on OS)
# This test is conceptual and might need adjustments based on the test environment OS
@patch('os.open')
@patch('os.fdopen', new_callable=mock_open)
@patch('os.makedirs')
def test_save_key_to_file_permissions(mock_mkdirs, mock_fdopen, mock_os_open, mock_key_file):
    """Test if save_key_to_file attempts to set permissions (conceptual)."""
    # This test focuses on the call signature, not the actual file system effect
    key = generate_key()
    full_mock_path = mock_key_file
    save_key_to_file(key, KEY_FILE_PATH)

    # Check if os.open was called with the correct flags and mode
    # This assertion might fail on Windows where os.O_WRONLY might not be defined
    # or file modes work differently. Skip or adjust assertion based on platform.
    if hasattr(os, 'O_WRONLY'):
         try:
             # Check if called with write/create/truncate flags and 0o600 mode
             mock_os_open.assert_called_once_with(full_mock_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
             # Check if os.fdopen was called
             mock_fdopen.assert_called_once()
         except AssertionError:
             # Fallback check if specific flags aren't available or assertion fails
             print("Warning: os.open permission check might be inaccurate on this OS.")
             # Check if os.open was called at all
             mock_os_open.assert_called()
             # Check if os.fdopen was called
             mock_fdopen.assert_called_once()
    else:
         # On systems without os.O_WRONLY, ensure mock_open (simulating standard open) was used
         mock_fdopen.assert_called_once() # mock_open is patched to os.fdopen's place


    # Check if the file handle was used to write
    mock_fdopen().write.assert_called_once_with(base64.urlsafe_b64encode(key))
]]></file_code>
</file>
</changed_files>
</code_changes>